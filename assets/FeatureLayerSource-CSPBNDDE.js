const __vite__fileDeps=["assets/uploadAssets-B-F66TBJ.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/External-Djr0rIk9.js","assets/infoFor3D-BTCPmnmy.js","assets/uploadAssetErrors-DaJmSTaj.js","assets/convertMeshVertexSpace-DwPR8t_n.js","assets/vertexSpaceConversion-C_GU75pR.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{G as e,h_ as t,J as s,h$ as a,cu as r,i0 as i,n,b as o,v as l,gM as u,c7 as d,e as c,y as p,i1 as v,h5 as w,g as S,m as q,i2 as E,bZ as _,cD as F,i3 as O,i4 as A,i5 as x,i6 as T,i7 as M,az as N,gs as D,gG as J,bF as C,_ as U,g5 as L,bg as k,i8 as Q,gC as P,er as $,i9 as G,fc as V,e_ as z,I as H,a2 as Z,a as B}from"./index-DSIPxOWi.js";import{v as X}from"./External-Djr0rIk9.js";import{N as Y}from"./MeshTransform-Y0ppddED.js";import{isFeatureIdentifierArrayWithGlobalId as W,isFeatureIdentifierArrayWithObjectId as K}from"./editingSupport-BNx5CWnq.js";import{o as ee}from"./clientSideDefaults-Cn_svm8L.js";import{x as te}from"./QueryTask-D61WShEy.js";import{F as se}from"./infoFor3D-BTCPmnmy.js";import{s as ae}from"./executeQueryJSON-DDi8KdIf.js";import"./normalizeUtils-BrH-PrZy.js";import"./normalizeUtilsCommon-BU8xfl77.js";import"./QueryEngineCapabilities-CTDe3LlQ.js";import"./executeForIds-vkxYbvNq.js";import"./query-C2USZ63O.js";import"./pbfQueryUtils-DUjEbwA9.js";import"./pbf-B53Txr8m.js";import"./executeQueryPBF-71YCUWAF.js";async function m(i,n,o){const{geometry:l}=n,u={...n.attributes};if(null!=o&&"mesh"===(null==l?void 0:l.type)){const{transformFieldRoles:n}=o,{origin:d,spatialReference:c,vertexSpace:p}=l,v=l.transform??new Y,w="local"===p.type,S=i.spatialReference,q=S.isGeographic,E=e(S,c),_=t(c,S)&&s(c,S);if(!(w&&q&&_||!w&&!q&&E))return null;const F=a(d,c,S);if(null==F)return null;if(u[n.originX]=F.x,u[n.originY]=F.y,u[n.originZ]=F.z??0,null!=v){const{translation:e,scale:t,rotation:s}=v,a=w?1:r(c)/r(S);u[n.translationX]=e[0]*a,u[n.translationY]=e[2]*a,u[n.translationZ]=-e[1]*a,u[n.scaleX]=t[0],u[n.scaleY]=t[2],u[n.scaleZ]=t[1],u[n.rotationX]=s[0],u[n.rotationY]=s[2],u[n.rotationZ]=-s[1],u[n.rotationDeg]=s[3]}return{attributes:u}}return null==l?{attributes:u}:"mesh"===l.type||"extent"===l.type?null:{geometry:l.toJSON(),attributes:u}}async function g(e,t){var s;const{feature:a,attachment:r}=t,{globalId:n,name:o,contentType:l,data:u,uploadId:d}=r,c={globalId:n};if(a&&("attributes"in a?c.parentGlobalId=null==(s=a.attributes)?void 0:s[e.globalIdField]:a.globalId&&(c.parentGlobalId=a.globalId)),d)c.uploadId=d;else if(u){const e=await i(u);e&&(c.contentType=e.mediaType,c.data=e.data),u instanceof File&&(c.name=u.name)}return o&&(c.name=o),l&&(c.contentType=l),c}function R(e){const t=!0===e.success?null:e.error||{code:void 0,description:void 0};return{objectId:e.objectId,globalId:e.globalId,error:t?new o("feature-layer-source:edit-failure",t.description,{code:t.code}):null}}function h(e,t){return new l({attributes:e.attributes,geometry:u({...e.geometry,spatialReference:t})})}function I(e,t){var s,a,r;return{adds:(null==(s=null==e?void 0:e.adds)?void 0:s.map((e=>h(e,t))))||[],updates:(null==(a=null==e?void 0:e.updates)?void 0:a.map((e=>({original:h(e[0],t),current:h(e[1],t)}))))||[],deletes:(null==(r=null==e?void 0:e.deletes)?void 0:r.map((e=>h(e,t))))||[],spatialReference:t}}const re=new d({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),ie=new d({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let ne=class extends v{constructor(e){super(e),this.type="feature-layer",this.supportedSourceTypes=new Set(["Feature Layer","Oriented Imagery Layer","Table","Catalog Layer"]),this.refresh=w((async()=>{var e,t;await this.load();const s=null==(e=this.sourceJSON.editingInfo)?void 0:e.lastEditDate;if(null==s)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}const a=s!==(null==(t=this.sourceJSON.editingInfo)?void 0:t.lastEditDate);return{dataChanged:a,updates:a?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}})),this._ongoingAssetUploads=new Map}load(e){const t=this.layer.sourceJSON,s=this._fetchService(t,{...e}).then((()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e))).then((()=>this._ensureLatestMetadata(e)));return this.addResolvingPromise(s),Promise.resolve(this)}initialize(){this.addHandles([S((()=>{const e=this.layer;return e&&"lastEditsEventDate"in e?e.lastEditsEventDate:null}),(e=>this._handleLastEditsEventChange(e)))])}destroy(){this._removeEditInterceptor()}get queryTask(){var e;const{capabilities:t,parsedUrl:s,gdbVersion:a,spatialReference:r,fieldsIndex:i}=this.layer,n="infoFor3D"in this.layer?this.layer.infoFor3D:null,o="dynamicDataSource"in this.layer?this.layer.dynamicDataSource:null,l=q("featurelayer-pbf")&&(null==t?void 0:t.query.supportsFormatPBF)&&null==n,u=(null==(e=null==t?void 0:t.operations)?void 0:e.supportsQueryAttachments)??!1;return new te({url:s.path,pbfSupported:l,fieldsIndex:i,infoFor3D:n,dynamicDataSource:o,gdbVersion:a,sourceSpatialReference:r,queryAttachmentsSupported:u})}async addAttachment(e,t){await this.load();const{layer:s}=this;await E(s,"editing");const a=e.attributes[s.objectIdField],r=s.parsedUrl.path+"/"+a+"/addAttachment",i=this._getLayerRequestOptions(),n=this._getFormDataForAttachment(t,i.query);try{return R((await _(r,{body:n})).data.addAttachmentResult)}catch(o){throw this._createAttachmentErrorResult(a,o)}}async updateAttachment(e,t,s){await this.load();const{layer:a}=this;await E(a,"editing");const r=e.attributes[a.objectIdField],i=a.parsedUrl.path+"/"+r+"/updateAttachment",n=this._getLayerRequestOptions({query:{attachmentId:t}}),o=this._getFormDataForAttachment(s,n.query);try{return R((await _(i,{body:o})).data.updateAttachmentResult)}catch(l){throw this._createAttachmentErrorResult(r,l)}}async applyEdits(e,t){var s,a;await this.load();const{layer:r}=this;await E(r,"editing");const i="infoFor3D"in r?r.infoFor3D:null,n=null!=i,l=n||((null==t?void 0:t.globalIdUsed)??!1),u=n?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,d=(null==(s=e.addFeatures)?void 0:s.map((e=>m(this.layer,e,i))))??[],c=(await Promise.all(d)).filter(F),p=(null==(a=e.updateFeatures)?void 0:a.map((e=>m(this.layer,e,i))))??[],v=(await Promise.all(p)).filter(F),w=function b(e,t,s){if(!t||0===t.length)return[];if(s&&W(t))return t.map((e=>e.globalId));if(K(t))return t.map((e=>e.objectId));const a=s?e.globalIdField:e.objectIdField;return a?t.map((e=>e.getAttribute(a))):[]}(this.layer,e.deleteFeatures,l);O(c,v,r.spatialReference);const S=await async function f(e,t){const s=await Promise.all((t.addAttachments??[]).map((t=>g(e,t)))),a=await Promise.all((t.updateAttachments??[]).map((t=>g(e,t)))),r=t.deleteAttachments??[];return s.length||a.length||r.length?{adds:s,updates:a,deletes:[...r]}:null}(this.layer,e),q=r.capabilities.editing.supportsAsyncApplyEdits&&n,N=(null==t?void 0:t.gdbVersion)||r.gdbVersion,D={gdbVersion:N,rollbackOnFailure:null==t?void 0:t.rollbackOnFailureEnabled,useGlobalIds:l,returnEditMoment:null==t?void 0:t.returnEditMoment,usePreviousEditMoment:null==t?void 0:t.usePreviousEditMoment,async:q};await A(this.layer.url,N,!0);const J=x(this.layer.url,N||null);if(await T(r.url,N,r.historicMoment))throw new o("feature-layer-source:historic-version","Editing a historic version is not allowed");(null==t?void 0:t.returnServiceEditsOption)?(D.edits=JSON.stringify([{id:r.layerId,adds:c.length?c:null,updates:v.length?v:null,deletes:w.length?w:null,attachments:S,assetMaps:u}]),D.returnServiceEditsOption=re.toJSON(null==t?void 0:t.returnServiceEditsOption),D.returnServiceEditsInSourceSR=null==t?void 0:t.returnServiceEditsInSourceSR):(D.adds=c.length?JSON.stringify(c):null,D.updates=v.length?JSON.stringify(v):null,D.deletes=w.length?l?JSON.stringify(w):w.join(","):null,D.attachments=S&&JSON.stringify(S),D.assetMaps=null!=u?JSON.stringify(u):void 0);const C=this._getLayerRequestOptions({method:"post",query:D});J&&(C.authMode="immediate",C.query.returnEditMoment=!0,C.query.sessionId=M);const U=(null==t?void 0:t.returnServiceEditsOption)?r.url:r.parsedUrl.path;let L;try{L=q?await this._asyncApplyEdits(U+"/applyEdits",C):await _(U+"/applyEdits",C)}catch(k){if(!function j(e){const t=e.details.raw,s=+t.code,a=+t.extendedCode;return 500===s&&(-2147217144===a||-2147467261===a)}(k))throw k;C.authMode="immediate",L=q?await this._asyncApplyEdits(U+"/applyEdits",C):await _(U+"/applyEdits",C)}return this._createEditsResult(L)}async deleteAttachments(e,t){await this.load();const{layer:s}=this;await E(s,"editing");const a=e.attributes[s.objectIdField],r=s.parsedUrl.path+"/"+a+"/deleteAttachments";try{return(await _(r,this._getLayerRequestOptions({query:{attachmentIds:t.join(",")},method:"post"}))).data.deleteAttachmentResults.map(R)}catch(i){throw this._createAttachmentErrorResult(a,i)}}fetchRecomputedExtents(e={}){const t=e.signal;return this.load({signal:t}).then((async()=>{const t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:s,url:a}=this.layer,{data:r}=await _(`${a}/${s}`,t),{id:i,extent:n,fullExtent:o,timeExtent:l}=r,u=n||o;return{id:i,fullExtent:u&&N.fromJSON(u),timeExtent:l&&D.fromJSON({start:l[0],end:l[1]})}}))}async queryAttachments(e,t={}){await this.load();const s=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,s)}async queryFeatures(e,t){var s;await this.load();const a=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});return(null==(s=e.outStatistics)?void 0:s.length)&&a.features.length&&a.features.forEach((t=>{var s;const a=t.attributes;null==(s=e.outStatistics)||s.forEach((({outStatisticFieldName:e})=>{if(e){const t=e.toLowerCase();t&&t in a&&e!==t&&(a[e]=a[t],delete a[t])}}))})),a}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!J(this.layer.url))return"unavailable";const e=C(this.layer.url,"status"),t=await _(e,{query:{f:"json"}});return ie.fromJSON(t.data.status)}async uploadAssets(e,t){const{uploadAssets:s}=await U((()=>import("./uploadAssets-B-F66TBJ.js")),__vite__mapDeps([0,1,2,3,4,5]));return s(e,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},t)}_handleLastEditsEventChange(e){var t,s,a,r;const i=this.layer;if(null==e||!("capabilities"in i)||!("effectiveCapabilities"in i))return;if((null==(s=null==(t=i.capabilities)?void 0:t.operations)?void 0:s.supportsEditing)||!(null==(r=null==(a=i.effectiveCapabilities)?void 0:a.operations)?void 0:r.supportsEditing))return;const n=i.url;null!=n&&("layerId"in i&&C(n,i.layerId.toString()),this._getOrCreateEditInterceptor(n).before=t=>{const s=t.requestOptions.method??"auto";if("auto"===s||"head"===s){const s=t.requestOptions.query??{};s._ts=e.getTime(),t.requestOptions.query=s}})}_getOrCreateEditInterceptor(e){return null==this._editInterceptor&&(this._editInterceptor={urls:e},L.request.internalInterceptors.push(this._editInterceptor)),this._editInterceptor}_removeEditInterceptor(){null!=this._editInterceptor&&(k(L.request.internalInterceptors,this._editInterceptor),this._editInterceptor=null)}async _asyncApplyEdits(e,t){const s=(await _(e,t)).data.statusUrl;for(;;){const e=(await _(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return _(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new o("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new o("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await Q(oe)}}_createRequestQueryOptions(e){const t={...this.layer.customParameters,token:this.layer.apiKey,...null==e?void 0:e.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){const s={};q("featurelayer-advanced-symbols")&&(s.returnAdvancedSymbols=!0),(null==t?void 0:t.cacheBust)&&(s._ts=Date.now());const{data:a}=await _(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:s,signal:null==t?void 0:t.signal}));e=a}this.sourceJSON=await this._patchServiceJSON(e,null==t?void 0:t.signal);const s=e.type;if(!this.supportedSourceTypes.has(s))throw new o("feature-layer-source:unsupported-type",`Source type "${s}" is not supported`)}async _patchServiceJSON(e,t){var s;if("Table"!==e.type&&e.geometryType&&!(null==(s=null==e?void 0:e.drawingInfo)?void 0:s.renderer)&&!e.defaultSymbol){const t=ee(e.geometryType).renderer;P("drawingInfo.renderer",t,e)}if("esriGeometryMultiPatch"===e.geometryType&&e.infoFor3D&&(e.geometryType="mesh"),null==e.extent)try{const{data:s}=await _(this.layer.url,this._getLayerRequestOptions({signal:t}));s.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:s.spatialReference})}catch(a){$(a)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(e){const{addAssetFeatures:t}=e;if(!(null==t?void 0:t.length))return null;if(await this._areAllAssetsAlreadyMapped(t))return null;const s=e.addFeatures.filter((e=>e.geometry));if(t.length!==s.length+e.updateFeatures.length)throw new o("feature-layer-source:unsupported-mesh-edits","Mixing attribute only edits with mesh geometry edits is not currently supported");const a=new Array,r=new Map;for(const i of t){const{geometry:e}=i,{vertexSpace:t}=e;if(G(t))a.push(e);else{const t=e.anchor,{convertMeshVertexSpace:s}=await U((async()=>{const{convertMeshVertexSpace:e}=await import("./convertMeshVertexSpace-DwPR8t_n.js");return{convertMeshVertexSpace:e}}),__vite__mapDeps([6,1,2,7])),n=await s(e,new V({origin:[t.x,t.y,t.z??0]}));r.set(n,e),i.geometry=n,a.push(n)}}await this.uploadAssets(a);for(const[i,n]of r)n.addExternalSources(i.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(t),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){const t=new Array,s=this.layer.globalIdField,a=this.layer.parsedUrl;for(const r of e){const e=r.geometry,{metadata:i}=e,o=i.getExternalSourcesOnService(a),l=r.getAttribute(s);if(0===o.length){n.getLogger(this).error(`Skipping feature ${l}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:u}=o.find(X)??o[0];for(const s of u)1===s.parts.length?t.push({globalId:z(),parentGlobalId:l,assetName:s.assetName,assetHash:s.parts[0].partHash,flags:[]}):n.getLogger(this).error(`Skipping asset ${s.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){const t=e.data,{layerId:s}=this.layer,a=[];let r=null;if(Array.isArray(t))for(const n of t)a.push({id:n.id,editedFeatures:n.editedFeatures}),n.id===s&&(r={addResults:n.addResults??[],updateResults:n.updateResults??[],deleteResults:n.deleteResults??[],attachments:n.attachments,editMoment:n.editMoment});else r=t;const i=function y(e){var t,s,a;const r=null==e?void 0:e.assetMaps;if(r){for(const e of r.addResults)e.success||n.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e.globalId}.`);for(const e of r.updateResults)e.success||n.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e.globalId}.`)}const i=null==e?void 0:e.attachments,o={addFeatureResults:(null==(t=null==e?void 0:e.addResults)?void 0:t.map(R))??[],updateFeatureResults:(null==(s=null==e?void 0:e.updateResults)?void 0:s.map(R))??[],deleteFeatureResults:(null==(a=null==e?void 0:e.deleteResults)?void 0:a.map(R))??[],addAttachmentResults:(null==i?void 0:i.addResults)?i.addResults.map(R):[],updateAttachmentResults:(null==i?void 0:i.updateResults)?i.updateResults.map(R):[],deleteAttachmentResults:(null==i?void 0:i.deleteResults)?i.deleteResults.map(R):[]};return(null==e?void 0:e.editMoment)&&(o.editMoment=e.editMoment),o}(r);if(a.length>0){i.editedFeatureResults=[];for(const e of a){const{editedFeatures:t}=e,s=(null==t?void 0:t.spatialReference)?new H(t.spatialReference):null;i.editedFeatureResults.push({layerId:e.id,editedFeatures:I(t,s)})}}return i}_createAttachmentErrorResult(e,t){var s;const a=(null==(s=t.details.messages)?void 0:s[0])||t.message,r=t.details.httpStatus||t.details.messageCode;return{objectId:e,globalId:null,error:new o("feature-layer-source:attachment-failure",a,{code:r})}}_getFormDataForAttachment(e,t){const s=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(s)for(const a in t){const e=t[a];null!=e&&(s.set?s.set(a,e):s.append(a,e))}return s}_getLayerRequestOptions(e={}){const{layer:t,layer:{parsedUrl:s,gdbVersion:a}}=this;return{...e,query:{gdbVersion:a,layer:"dynamicDataSource"in t&&t.dynamicDataSource?JSON.stringify({source:t.dynamicDataSource}):void 0,...s.query,f:"json",...this._createRequestQueryOptions(e)},responseType:"json"}}async _areAllAssetsAlreadyMapped(e){const{layer:t}=this,{globalIdField:s,parsedUrl:a}=t,r="infoFor3D"in t?t.infoFor3D:null;if(null==r||null==s)return!1;const i=se(r);if(null==i)return!1;const n=C(a.path,`../${i.id}`),o=new Array;for(const w of e){if(!(w.geometry.metadata.getExternalSourcesOnService(a).length>0))return!1;o.push(w)}const l=o.map((e=>e.getAttribute(s))).filter(F);if(0===l.length)return!1;const{assetMapFieldRoles:{parentGlobalId:u,assetHash:d}}=r,c=new Z({where:`${u} IN (${l.map((e=>`'${e}'`))})`,outFields:[d,u],returnGeometry:!1}),p=await ae(n,c),{features:v}=p;return 0!==v.length&&!o.some((e=>{const t=e.getAttribute(s);if(!t)return!0;const{metadata:r}=e.geometry,i=v.filter((e=>e.getAttribute(u)===t));if(0===i.length)return!0;const n=i.map((e=>e.getAttribute(d)));return r.getExternalSourcesOnService(a).flatMap((({source:e})=>e.flatMap((e=>e.parts.map((e=>e.partHash)))))).some((e=>n.every((t=>e!==t))))}))}};c([p()],ne.prototype,"type",void 0),c([p({constructOnly:!0})],ne.prototype,"layer",void 0),c([p({constructOnly:!0})],ne.prototype,"supportedSourceTypes",void 0),c([p({readOnly:!0})],ne.prototype,"queryTask",null),ne=c([B("esri.layers.graphics.sources.FeatureLayerSource")],ne);const oe=1e3,le=ne;export{le as default};
