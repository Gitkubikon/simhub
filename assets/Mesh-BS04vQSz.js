const __vite__fileDeps=["assets/loadGLTFMesh-CY_ncj_j.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/vertexSpaceConversion-C_GU75pR.js","assets/gltfexport-DGYMPrZt.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{b as e,oq as n,or as r,cC as s,e0 as a,az as l,os as v,i9 as g,cw as w,cg as b,cx as A,dD as S,Q as F,bM as _,ka as $,fc as T,n as E,ot as N,gQ as C,_ as D,b3 as U,aw as V,ou as Y,ov as H,gR as W,c as Q,b9 as X,e as Z,y as K,a as ee,hU as te,V as ne,bd as re,mk as oe,mf as se,gU as ae,hB as ie,N as le,cv as ce,ow as ue,ox as pe,O as fe,bR as he,bS as me,bP as de,oy as ve,oz as xe,e8 as ge,ch as ye,oA as we,ci as be,oB as Ae,oC as Se,lq as Re,ce as Fe,cf as Me,lm as _e,cq as Ie,cr as $e,ct as Te,cn as Oe,co as Pe,cp as Le,mY as Ee,cy as Ne,bV as je,bX as Ce,oD as ze,dC as De,i1 as Ue,bb as Je,g as Be,oE as Ve,oF as Ge,j as ke,oG as qe,oH as Ye,g_ as He}from"./index-DSIPxOWi.js";import{N as We}from"./MeshTransform-Y0ppddED.js";import{M as Qe,X as Xe,N as Ze}from"./vertexSpaceConversion-C_GU75pR.js";import{u as Ke,y as et,h as tt}from"./External-Djr0rIk9.js";const nt="Expected location to be a Point instance";let rt=class i extends e{constructor(){super("invalid-input:location",nt)}};let ot=null;function m$2(e){if(0===e.length)return r;const n=s([Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY,-Number.POSITIVE_INFINITY]);return a(n,e),n}function N$1(e,n){const[r,s,a,v,g,w]=m$2(e);return new l({xmin:r,ymin:s,zmin:a,xmax:v,ymax:g,zmax:w,spatialReference:n})}function t(e,n,r,s){if(void 0!==s){v(e(),"option: geographic",{replacement:"Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.",version:"4.30",warnOnce:!0});const a="local"===n.type;if(!g(n)||s===a)return r.isGeographic||r.isWebMercator&&s;e().warnOnce(`Specifying the 'geographic' parameter (${s}) for a Mesh vertex space of type "${n.type}" is not supported. This parameter will be ignored.`)}switch(n.type){case"georeferenced":return r.isGeographic;case"local":return r.isGeographic||r.isWebMercator}}const g$2=()=>E.getLogger("esri.geometry.support.meshUtils.centerAt");function u$2(e,n,r){var s;if(!(null==(s=e.vertexAttributes)?void 0:s.position))return;const{vertexSpace:a}=e,l=(null==r?void 0:r.origin)??e.anchor,v=t(g$2,a,l.spatialReference,null==r?void 0:r.geographic);g(a)?function x$2(e,n,r){const{vertexSpace:s}=e;if(!g(s))return;const a=at,l=st;if(!w(n,l,e.spatialReference))return void b(g$2(),n.spatialReference,e.spatialReference,N);if(!w(r,a,e.spatialReference)){const n=e.origin;return a[0]=n.x,a[1]=n.y,a[2]=n.z,void b(g$2(),r.spatialReference,e.spatialReference,N)}const v=A(it,l,a);s.origin=S(F(),s.origin,v)}(e,n,l):v?function v$1(e,n,r){const s=_(r.x,r.y,r.z??0),a=Qe(e,new $({origin:s}));if(!a)return;const l=_(n.x,n.y,n.z??0),v=Qe({vertexAttributes:a,spatialReference:e.spatialReference,vertexSpace:new $({origin:l})},new T);if(!v)return;const{position:g,normal:w,tangent:b}=v;e.vertexAttributes.position=g,e.vertexAttributes.normal=w,e.vertexAttributes.tangent=b,e.vertexAttributesChanged()}(e,n,l):function R(e,n,r){const s=at,a=st;if(w(n,a,e.spatialReference)){if(!w(r,s,e.spatialReference)){const n=e.origin;return s[0]=n.x,s[1]=n.y,s[2]=n.z,void b(g$2(),r.spatialReference,e.spatialReference,N)}(function j$1(e,n,r){if(e)for(let s=0;s<e.length;s+=3)for(let a=0;a<3;a++)e[s+a]+=n[a]-r[a]})(e.vertexAttributes.position,a,s),e.vertexAttributesChanged()}else b(g$2(),n.spatialReference,e.spatialReference,N)}(e,n,l)}const st=F(),at=F(),it=F();async function c$1(n,r,s){const{source:a}=r,{loadGLTFMesh:l}=await C(D((()=>import("./loadGLTFMesh-CY_ncj_j.js")),__vite__mapDeps([0,1,2,3])),s),v=await async function f$1(n,r){if(Array.isArray(n)){if(!n.length)throw new e("mesh-load-external:missing-assets","There must be at least one file to load");return n[0]instanceof File?function h$1(e){return T$1(e.map((e=>({name:e.name,mimeType:e.type,source:p$1(e)}))))}(n):async function y$1(e,n){const r=await W(e.map((async e=>{const r=await async function m$1(e,n){const{parts:r,assetMimeType:s,assetName:a}=e;if(1===r.length)return new j(r[0].partUrl);const l=await e.toBlob(n);return U(n),j.fromBlob(l,x$1(a,s))}(e);return U(n),{name:e.assetName,mimeType:e.assetMimeType,source:r}})));if(Q(n))throw r.forEach((e=>e.source.dispose())),X();return T$1(r)}(n,r)}return p$1(n)}(a,s);U(s);const g=l(new V({x:0,y:0,z:0,spatialReference:n.spatialReference}),v.url,{resolveFile:u$1(v),signal:null==s?void 0:s.signal,expectedType:v.type});g.then((()=>v.dispose()),(()=>v.dispose()));const{vertexAttributes:w,components:b}=await g;n.vertexAttributes=w,n.components=b}function u$1(e){const n=Y(e.url);return r=>{const s=H(r,n,n),a=s?s.replace(/^ *\.\//,""):null;return(a?e.files.get(a):null)??r}}function p$1(e){return j.fromBlob(e,x$1(e.name,e.type))}const lt=/^model\/gltf\+json$/,ct=/^model\/gltf-binary$/,ut=/\.gltf$/i,pt=/\.glb$/i;function T$1(n){const r=new Map;let s,a=null;for(const{name:e,mimeType:l,source:v}of n)null===a&&(lt.test(l)||ut.test(e)?(a=v.url,s="gltf"):(ct.test(l)||pt.test(e))&&(a=v.url,s="glb")),r.set(e,v.url),v.files.forEach(((e,n)=>r.set(n,e)));if(null==a)throw new e("mesh-load-external:missing-files","Missing files to load external mesh source");return new j(a,(()=>n.forEach((({source:e})=>e.dispose()))),r,s)}class j{constructor(e,n=()=>{},r=new Map,s){this.url=e,this.dispose=n,this.files=r,this.type=s}static fromBlob(e,n){const r=URL.createObjectURL(e);return new j(r,(()=>URL.revokeObjectURL(r)),void 0,n)}}function x$1(e,n){return lt.test(n)||ut.test(e)?"gltf":ct.test(n)||ut.test(e)?"glb":void 0}let ft=class extends te{constructor(e){super(e),this.externalSources=new ne,this._explicitDisplaySource=null,this.addHandles(re((()=>this.externalSources),"after-remove",(({item:e})=>{e===this._explicitDisplaySource&&(this._explicitDisplaySource=null)}),{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(e){if(null!=e&&!Ke(e))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=e,e&&this.externalSources.every((n=>!et(n,e)))&&this.externalSources.add(e)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(e){return this.externalSources.items.filter((n=>tt(n,e)))}get _implicitDisplaySource(){return this.externalSources.find(Ke)}};Z([K()],ft.prototype,"externalSources",void 0),Z([K()],ft.prototype,"displaySource",null),Z([K()],ft.prototype,"_implicitDisplaySource",null),Z([K()],ft.prototype,"_explicitDisplaySource",void 0),ft=Z([ee("esri.geometry.support.meshUtils.Metadata")],ft);const ht={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function x(e,n,r){e.isPlane||function y(e){for(let n=0;n<e.position.length;n+=3)e.position[n+2]+=.5}(e),function M$1(e,n){if(null!=n){xt[0]=n[0],xt[4]=n[1],xt[8]=n[2];for(let n=0;n<e.position.length;n+=3){for(let r=0;r<3;r++)vt[r]=e.position[n+r];ie(vt,vt,xt);for(let r=0;r<3;r++)e.position[n+r]=vt[r]}if(n[0]!==n[1]||n[1]!==n[2]){xt[0]=1/n[0],xt[4]=1/n[1],xt[8]=1/n[2];for(let n=0;n<e.normal.length;n+=3){for(let r=0;r<3;r++)vt[r]=e.normal[n+r];ie(vt,vt,xt),le(vt,vt);for(let r=0;r<3;r++)e.normal[n+r]=vt[r]}}}}(e,function d(e,n,r){const s=Xe(n,r);if(null==e&&1===s)return null;if(null==e)return[s,s,s];if("number"==typeof e){const n=e*s;return[n,n,n]}return[null!=e.width?e.width*s:s,null!=e.depth?e.depth*s:s,null!=e.height?e.height*s:s]}(null==r?void 0:r.size,null==r?void 0:r.unit,n.spatialReference));const s=se(n,r),a=n.spatialReference.isGeographic?se(n):s,l=Qe({vertexAttributes:e,vertexSpace:a,spatialReference:n.spatialReference},s,{allowBufferReuse:!0});return{vertexAttributes:new ae({...l,uv:e.uv}),vertexSpace:s,components:[new oe({faces:e.faces,material:(null==r?void 0:r.material)||null})],spatialReference:n.spatialReference}}const mt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},dt={south:0,east:1,north:2,west:3,up:4,down:5},vt=F(),xt=ce(),O=()=>E.getLogger("esri.geometry.support.meshUtils.rotate");function B(e,n,r){var s;if(!(null==(s=e.vertexAttributes)?void 0:s.position)||0===n[3])return;const{spatialReference:a,vertexSpace:l}=e,v=(null==r?void 0:r.origin)??e.anchor,g=null==r?void 0:r.geographic,A=t(O,l,a,g);pe(e)?function G(e,n,r){e.transform??(e.transform=new We);const{vertexSpace:s,transform:a,spatialReference:l}=e,[v,g,w]=s.origin,A=new V({x:v,y:g,z:w,spatialReference:l}),S=gt;if(A.equals(r))fe(S,0,0,0);else if(!Ze(S,r,e))return void b(O(),r.spatialReference,l,N);he(Rt,de(n),me(n));const _=ve(yt,Rt,ge,xe,S),{localMatrix:$}=a,T=ye(yt,_,$);a.scale=we(F(),T),be(T,T,Ae(gt,a.scale));const E=a.rotationAxis;a.rotation=Se(T),0===a.rotationAngle&&(a.rotationAxis=E),a.translation=Re(F(),T)}(e,n,v):A?function H$1(e,n,r){const s=e.spatialReference,a=Fe(s),l=St;if(!w(r,l,a)&&(b(O(),r.spatialReference,a,"Falling back to mesh origin"),!w(e.origin,l,a)))return void b(O(),e.origin.spatialReference,a);const v=e.vertexAttributes.position,g=e.vertexAttributes.normal,A=e.vertexAttributes.tangent,S=new Float64Array(v.length),F=null!=g?new Float32Array(g.length):null,_=null!=A?new Float32Array(A.length):null;Me(a,l,bt,a),_e(At,bt);const $=wt;ie(de(wt),de(n),At),$[3]=n[3],!Ie(v,s,S)||null!=g&&null!=F&&!$e(g,v,S,s,F)||null!=A&&null!=_&&!Te(A,v,S,s,_)?b(O(),s,a):(J$1(S,$,3,l),!Oe(S,v,s)||null!=g&&null!=F&&(J$1(F,$,3),!Pe(F,v,S,s,g))||null!=A&&null!=_&&(J$1(_,$,4),!Le(_,v,S,s,A))?b(O(),a,s):e.vertexAttributesChanged())}(e,n,v):function I(e,n,r){const s=St;if(!w(r,s,e.spatialReference)){const n=e.origin;return s[0]=n.x,s[1]=n.y,s[2]=n.z,void b(O(),r.spatialReference,e.spatialReference,N)}J$1(e.vertexAttributes.position,n,3,s),J$1(e.vertexAttributes.normal,n,3),J$1(e.vertexAttributes.tangent,n,4),e.vertexAttributesChanged()}(e,n,v)}function J$1(e,n,r,s=ge){if(null!=e){Ee(bt,me(n),de(n));for(let n=0;n<e.length;n+=r){for(let r=0;r<3;r++)gt[r]=e[n+r]-s[r];Ne(gt,gt,bt);for(let r=0;r<3;r++)e[n+r]=gt[r]+s[r]}}}const gt=F(),yt=je(),wt=ue(),bt=je(),At=ce(),St=F(),Rt=Ce(),k=()=>E.getLogger("esri.geometry.support.meshUtils.scale");function q(e,n,r){var s;if(!(null==(s=e.vertexAttributes)?void 0:s.position))return;const{vertexSpace:a,spatialReference:l}=e,v=(null==r?void 0:r.origin)??e.anchor,g=null==r?void 0:r.geographic,A=t(k,a,l,g);pe(e)?function z(e,n,r){e.transform??(e.transform=new We);const{vertexSpace:s,transform:a,spatialReference:l}=e,[v,g,w]=s.origin,A=new V({x:v,y:g,z:w,spatialReference:l}),S=Ft;if(A.equals(r))fe(S,0,0,0);else if(!Ze(S,r,e))return void b(k(),r.spatialReference,l,N);const _=fe(Mt,n,n,n),$=ve(_t,ze,ge,_,S),{localMatrix:T}=a,E=ye(_t,$,T);a.scale=we(F(),E),be(E,E,Ae(Ft,a.scale));const C=a.rotationAxis;a.rotation=Se(E),0===a.rotationAngle&&(a.rotationAxis=C),a.translation=Re(F(),E)}(e,n,v):A?function L(e,n,r){const s=e.spatialReference,a=Fe(s),l=It;if(!w(r,l,a)&&(b(k(),r.spatialReference,a,"Falling back to mesh origin"),!w(e.origin,l,a)))return void b(k(),e.origin.spatialReference,a);const v=e.vertexAttributes.position,g=e.vertexAttributes.normal,A=e.vertexAttributes.tangent,S=new Float64Array(v.length),F=null!=g?new Float32Array(g.length):null,_=null!=A?new Float32Array(A.length):null;!Ie(v,s,S)||null!=g&&null!=F&&!$e(g,v,S,s,F)||null!=A&&null!=_&&!Te(A,v,S,s,_)?b(k(),s,a):(P(S,n,l),!Oe(S,v,s)||null!=g&&null!=F&&!Pe(F,v,S,s,g)||null!=A&&null!=_&&!Le(_,v,S,s,A)?b(k(),a,s):e.vertexAttributesChanged())}(e,n,v):function M(e,n,r){const s=It;if(!w(r,s,e.spatialReference)){const n=e.origin;return s[0]=n.x,s[1]=n.y,s[2]=n.z,void b(k(),r.spatialReference,e.spatialReference,N)}P(e.vertexAttributes.position,n,s),e.vertexAttributesChanged()}(e,n,v)}function P(e,n,r=ge){if(e)for(let s=0;s<e.length;s+=3){for(let n=0;n<3;n++)Ft[n]=e[s+n]-r[n];De(Ft,Ft,n);for(let n=0;n<3;n++)e[s+n]=Ft[n]+r[n]}}const Ft=F(),Mt=F(),_t=je(),It=F();var $t;const Tt="esri.geometry.Mesh";function J(){return E.getLogger(Tt)}const Ot={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:T,local:$}};let Pt=$t=class extends(Ue.LoadableMixin(Je(He))){constructor(e){super(e),this.components=null,this.vertexSpace=new T,this.transform=null,this.metadata=new ft,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new ae,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(Be((()=>{var e;return{vertexAttributes:this.vertexAttributes,components:null==(e=this.components)?void 0:e.map((e=>e.clone()))}}),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){var e;return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=(null==(e=this.metadata.displaySource)?void 0:e.extent)}get _transformedExtent(){const{components:e,spatialReference:r,vertexAttributes:s,vertexSpace:a}=this,v=s.position;if(0===v.length||e&&0===e.length)return new l({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:r});if(g(a)){const{_untransformedBounds:e,transform:s}=this;return function o([e,r,s,a,l,v],g,w,b){ot??(ot=new Float64Array(24));const A=ot;return A[0]=e,A[1]=r,A[2]=s,A[3]=e,A[4]=l,A[5]=s,A[6]=a,A[7]=l,A[8]=s,A[9]=a,A[10]=r,A[11]=s,A[12]=e,A[13]=r,A[14]=v,A[15]=e,A[16]=l,A[17]=v,A[18]=a,A[19]=l,A[20]=v,A[21]=a,A[22]=r,A[23]=v,n({positions:A,transform:g,vertexSpace:w,inSpatialReference:b,outSpatialReference:b,outPositions:A}),N$1(A,b)}(e,s,a,r)}return N$1(v,r)}get _untransformedBounds(){return m$2(this.vertexAttributes.position)}get anchor(){const e=Ve(this.vertexSpace,this.spatialReference);if(null!=e)return e;const{center:n,zmin:r}=this._transformedExtent;return new V({x:n.x,y:n.y,z:r,spatialReference:this.spatialReference})}get origin(){const e=Ve(this.vertexSpace,this.spatialReference);return null!=e?e:this._transformedExtent.center}get extent(){var e,n;return this.loaded||null==(null==(n=null==(e=this.metadata)?void 0:e.displaySource)?void 0:n.extent)?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(oe.from(e)),this.notifyChange("components"))}removeComponent(e){if(this._checkIfLoaded("removeComponent()")){if(this.components){const n=this.components.indexOf(e);if(-1!==n)return this.components.splice(n,1),void this.notifyChange("components")}J().error("removeComponent()","Provided component is not part of the list of components")}}rotate(e,n,r,s){return Ge(e,n,r,Lt),B(this,Lt,s),this}offset(e,n,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:s,vertexAttributes:a}=this,l=null==a?void 0:a.position;if(!l)return this;if(g(s)){const[a,l,v]=s.origin;s.origin=_(a+e,l+n,v+r)}else{for(let s=0;s<l.length;s+=3)l[s]+=e,l[s+1]+=n,l[s+2]+=r;this.vertexAttributesChanged()}return this}scale(e,n){return this._checkIfLoaded("scale()")?(q(this,e,n),this):this}centerAt(e,n){return this._checkIfLoaded("centerAt()")?(u$2(this,e,n),this):this}load(e){const{metadata:{displaySource:n}}=this;return n&&this.addResolvingPromise(c$1(this,n,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(),this.vertexSpace.clone())}cloneAndModifyVertexAttributes(e,n){var r;let s=null;if(this.components){const e=new Map,n=new Map;s=this.components.map((r=>r.cloneWithDeduplication(e,n)))}const a={components:s,spatialReference:this.spatialReference,vertexAttributes:e,vertexSpace:n,transform:(null==(r=this.transform)?void 0:r.clone())??null,metadata:this.metadata.clone()};return new $t(a)}cloneShallow(){return new $t({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const[{toBinaryGLTF:n}]=await Promise.all([D((()=>import("./gltfexport-DGYMPrZt.js")),__vite__mapDeps([4,1,2,3])),this.load(e)]);return U(e),await n(this,e)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,null!=this.components)for(const n of this.components)e+=n.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(e){return!!this.loaded||(J().error(e,"Mesh must be loaded before applying operations"),!1)}static createBox(e,n){if(!(e instanceof V))return J().error(".createBox()",nt),null;const r=new $t(x(function c(){const{faceDescriptions:e,faceVertexOffsets:n,uvScales:r}=mt,s=4*e.length,a=new Float64Array(3*s),l=new Float32Array(3*s),v=new Float32Array(2*s),g=new Uint32Array(2*e.length*3);let w=0,b=0,A=0,S=0;for(let F=0;F<e.length;F++){const s=e[F],_=w/3;for(const e of n)g[S++]=_+e;const $=s.corners;for(let e=0;e<4;e++){const n=$[e];let g=0;v[A++]=.25*r[e][0]+s.uvOrigin[0],v[A++]=s.uvOrigin[1]-.25*r[e][1];for(let e=0;e<3;e++)0!==s.axis[e]?(a[w++]=.5*s.axis[e],l[b++]=s.axis[e]):(a[w++]=.5*n[g++],l[b++]=0)}}return{position:a,normal:l,uv:v,faces:g}}(),e,n));return(null==n?void 0:n.imageFace)&&"all"!==n.imageFace?function f(e,n){const r=e.components[0],s=r.faces,a=dt[n],l=6*a,v=new Array(6),g=new Array(s.length-6);let w=0,b=0;for(let A=0;A<s.length;A++)A>=l&&A<l+6?v[w++]=s[A]:g[b++]=s[A];if(null!=e.vertexAttributes.uv){const n=new Float32Array(e.vertexAttributes.uv),r=4*a*2,s=[0,1,1,1,1,0,0,0];for(let e=0;e<s.length;e++)n[r+e]=s[e];e.vertexAttributes.uv=n}return e.components=[new oe({faces:v,material:r.material}),new oe({faces:g})],e}(r,n.imageFace):r}static createSphere(e,n){return e instanceof V?new $t(x(function u(e=0){const n=Math.round(8*2**e),r=2*n,s=(n-1)*(r+1)+2*r,a=new Float64Array(3*s),l=new Float32Array(3*s),v=new Float32Array(2*s),g=new Uint32Array((n-1)*r*2*3);let w=0,b=0,A=0,S=0;for(let F=0;F<=n;F++){const e=F/n*Math.PI+.5*Math.PI,s=Math.cos(e),_=Math.sin(e);vt[2]=_;const $=0===F||F===n,T=$?r-1:r;for(let E=0;E<=T;E++){const e=E/T*2*Math.PI;vt[0]=-Math.sin(e)*s,vt[1]=Math.cos(e)*s;for(let n=0;n<3;n++)a[w]=.5*vt[n],l[w]=vt[n],++w;v[b++]=(E+($?.5:0))/r,v[b++]=F/n,0!==F&&E!==r&&(F!==n&&(g[A++]=S,g[A++]=S+1,g[A++]=S-r),1!==F&&(g[A++]=S,g[A++]=S-r,g[A++]=S-r-1)),S++}}return{position:a,normal:l,uv:v,faces:g}}((null==n?void 0:n.densificationFactor)||0),e,n)):(J().error(".createSphere()",nt),null)}static createCylinder(e,n){return e instanceof V?new $t(x(function h(e=0){const n=Math.round(16*2**e),r=4*(n+1)+2*n,s=new Float64Array(3*r),a=new Float32Array(3*r),l=new Float32Array(2*r),v=new Uint32Array(4*n*3);let g=0,w=0,b=0,A=0,S=0;for(let F=0;F<=5;F++){const e=0===F||5===F,r=F<=1||F>=4,_=2===F||4===F,$=e?n-1:n;for(let T=0;T<=$;T++){const E=T/$*2*Math.PI,N=e?0:.5;vt[0]=N*Math.sin(E),vt[1]=N*-Math.cos(E),vt[2]=F<=2?.5:-.5;for(let e=0;e<3;e++)s[g++]=vt[e],a[w++]=r?2===e?F<=1?1:-1:0:2===e?0:vt[e]/N;l[b++]=(T+(e?.5:0))/n,l[b++]=F<=1?1*F/3:F<=3?1*(F-2)/3+1/3:1*(F-4)/3+2/3,_||0===F||T===n||(5!==F&&(v[A++]=S,v[A++]=S+1,v[A++]=S-n),1!==F&&(v[A++]=S,v[A++]=S-n,v[A++]=S-n-1)),S++}}return{position:s,normal:a,uv:l,faces:v}}((null==n?void 0:n.densificationFactor)||0),e,n)):(J().error(".createCylinder()",nt),null)}static createPlane(e,n){if(!(e instanceof V))return J().error(".createPlane()",nt),null;const r=(null==n?void 0:n.facing)??"up",s=function p(e,n){const r="number"==typeof n?n:null!=n?n.width:1,s="number"==typeof n?n:null!=n?n.height:1;switch(e){case"up":case"down":return{width:r,depth:s};case"north":case"south":return{width:r,height:s};case"east":case"west":return{depth:r,height:s}}}(r,null==n?void 0:n.size);return new $t(x(function m(e){const n=ht.facingAxisOrderSwap[e],r=ht.position,s=ht.normal,a=new Float64Array(r.length),l=new Float32Array(s.length);let v=0;for(let g=0;g<4;g++){const e=v;for(let g=0;g<3;g++){const w=n[g],b=Math.abs(w)-1,A=w>=0?1:-1;a[v]=r[e+b]*A,l[v]=s[e+b]*A,v++}}return{position:a,normal:l,uv:new Float32Array(ht.uv),faces:new Uint32Array(ht.faces),isPlane:!0}}(r),e,{...n,size:s}))}static createFromPolygon(e,n){if(!(e instanceof ke))return J().error(".createFromPolygon()","Expected polygon to be a Polygon instance"),null;const r=qe(e);return new $t({vertexAttributes:new ae({position:r.position}),components:[new oe({faces:r.faces,shading:"flat",material:(null==n?void 0:n.material)??null})],spatialReference:e.spatialReference,vertexSpace:new T})}static async createFromGLTF(e,n,r){if(!(e instanceof V)){const e=new rt;throw J().error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:s}=await C(D((()=>import("./loadGLTFMesh-CY_ncj_j.js")),__vite__mapDeps([0,1,2,3])),r);return new $t(await s(e,n,r))}static async createFromFiles(n,r,s){Ye(J(),"`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'",{replacement:"SceneLayer.convertMesh",version:"4.29"});if(!(n instanceof V)){const e=new rt;throw(e=>{J().error(".createFromFiles()",e.message)})(e),e}if(!(null==s?void 0:s.layer))throw new e("invalid:no-layer","SceneLayer required for file to mesh conversion.");return s.layer.convertMesh(r,{location:n,...s})}static createWithExternalSource(e,n,r){var s;const a=(null==r?void 0:r.extent)??null,{spatialReference:l}=e,v=(null==(s=null==r?void 0:r.transform)?void 0:s.clone())??new We,g=se(e,r),w={source:n,extent:a},b=new ft;return b.externalSources.push(w),new $t({metadata:b,transform:v,vertexSpace:g,spatialReference:l})}static createIncomplete(n,r){var s;const{spatialReference:a}=n,l=(null==(s=null==r?void 0:r.transform)?void 0:s.clone())??new We,v=se(n,r),g=new $t({transform:l,vertexSpace:v,spatialReference:a});return g.addResolvingPromise(Promise.reject(new e("mesh-incomplete","Mesh resources are not complete"))),g}};Z([K({type:[oe],json:{write:!0}})],Pt.prototype,"components",void 0),Z([K({nonNullable:!0,types:Ot,constructOnly:!0,json:{write:!0}})],Pt.prototype,"vertexSpace",void 0),Z([K({type:We,json:{write:!0}})],Pt.prototype,"transform",void 0),Z([K({constructOnly:!0})],Pt.prototype,"metadata",void 0),Z([K()],Pt.prototype,"hasExtent",null),Z([K()],Pt.prototype,"_transformedExtent",null),Z([K()],Pt.prototype,"_untransformedBounds",null),Z([K()],Pt.prototype,"anchor",null),Z([K()],Pt.prototype,"origin",null),Z([K({readOnly:!0,json:{read:!1}})],Pt.prototype,"extent",null),Z([K({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Pt.prototype,"hasZ",void 0),Z([K({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Pt.prototype,"hasM",void 0),Z([K({type:ae,nonNullable:!0,json:{write:!0}})],Pt.prototype,"vertexAttributes",void 0),Pt=$t=Z([ee(Tt)],Pt);const Lt=ue(),Et=Pt;export{Et as $};
