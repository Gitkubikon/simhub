import"./index-DSIPxOWi.js";import{g as e}from"./dom-CG95YN3b.js";import{d as t}from"./debounce-Z6QnFls1.js";
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
 * v2.10.1
 */const n=["top","right","bottom","left"],o=["start","end"],i=n.reduce(((e,t)=>e.concat(t,t+"-"+o[0],t+"-"+o[1])),[]),r=Math.min,l=Math.max,s=Math.round,a=Math.floor,createCoords=e=>({x:e,y:e}),c={left:"right",right:"left",bottom:"top",top:"bottom"},f={start:"end",end:"start"};function clamp(e,t,n){return l(e,r(t,n))}function evaluate(e,t){return"function"==typeof e?e(t):e}function getSide(e){return e.split("-")[0]}function getAlignment(e){return e.split("-")[1]}function getOppositeAxis(e){return"x"===e?"y":"x"}function getAxisLength(e){return"y"===e?"height":"width"}function getSideAxis(e){return["top","bottom"].includes(getSide(e))?"y":"x"}function getAlignmentAxis(e){return getOppositeAxis(getSideAxis(e))}function getAlignmentSides(e,t,n){void 0===n&&(n=!1);const o=getAlignment(e),i=getAlignmentAxis(e),r=getAxisLength(i);let l="x"===i?o===(n?"end":"start")?"right":"left":"start"===o?"bottom":"top";return t.reference[r]>t.floating[r]&&(l=getOppositePlacement(l)),[l,getOppositePlacement(l)]}function getOppositeAlignmentPlacement(e){return e.replace(/start|end/g,(e=>f[e]))}function getOppositePlacement(e){return e.replace(/left|right|bottom|top/g,(e=>c[e]))}function getPaddingObject(e){return"number"!=typeof e?function expandPaddingObject(e){return{top:0,right:0,bottom:0,left:0,...e}}(e):{top:e,right:e,bottom:e,left:e}}function rectToClientRect(e){const{x:t,y:n,width:o,height:i}=e;return{width:o,height:i,top:n,left:t,right:t+o,bottom:n+i,x:t,y:n}}function computeCoordsFromPlacement(e,t,n){let{reference:o,floating:i}=e;const r=getSideAxis(t),l=getAlignmentAxis(t),s=getAxisLength(l),a=getSide(t),c="y"===r,f=o.x+o.width/2-i.width/2,u=o.y+o.height/2-i.height/2,g=o[s]/2-i[s]/2;let d;switch(a){case"top":d={x:f,y:o.y-i.height};break;case"bottom":d={x:f,y:o.y+o.height};break;case"right":d={x:o.x+o.width,y:u};break;case"left":d={x:o.x-i.width,y:u};break;default:d={x:o.x,y:o.y}}switch(getAlignment(t)){case"start":d[l]-=g*(n&&c?-1:1);break;case"end":d[l]+=g*(n&&c?-1:1)}return d}async function detectOverflow(e,t){var n;void 0===t&&(t={});const{x:o,y:i,platform:r,rects:l,elements:s,strategy:a}=e,{boundary:c="clippingAncestors",rootBoundary:f="viewport",elementContext:u="floating",altBoundary:g=!1,padding:d=0}=evaluate(t,e),m=getPaddingObject(d),p=s[g?"floating"===u?"reference":"floating":u],h=rectToClientRect(await r.getClippingRect({element:null==(n=await(null==r.isElement?void 0:r.isElement(p)))||n?p:p.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(s.floating)),boundary:c,rootBoundary:f,strategy:a})),y="floating"===u?{x:o,y:i,width:l.floating.width,height:l.floating.height}:l.reference,w=await(null==r.getOffsetParent?void 0:r.getOffsetParent(s.floating)),v=await(null==r.isElement?void 0:r.isElement(w))&&await(null==r.getScale?void 0:r.getScale(w))||{x:1,y:1},x=rectToClientRect(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({elements:s,rect:y,offsetParent:w,strategy:a}):y);return{top:(h.top-x.top+m.top)/v.y,bottom:(x.bottom-h.bottom+m.bottom)/v.y,left:(h.left-x.left+m.left)/v.x,right:(x.right-h.right+m.right)/v.x}}function getSideOffsets(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function isAnySideFullyClipped(e){return n.some((t=>e[t]>=0))}function getNodeName(e){return isNode(e)?(e.nodeName||"").toLowerCase():"#document"}function getWindow(e){var t;return(null==e||null==(t=e.ownerDocument)?void 0:t.defaultView)||window}function getDocumentElement(e){var t;return null==(t=(isNode(e)?e.ownerDocument:e.document)||window.document)?void 0:t.documentElement}function isNode(e){return e instanceof Node||e instanceof getWindow(e).Node}function isElement(e){return e instanceof Element||e instanceof getWindow(e).Element}function isHTMLElement(e){return e instanceof HTMLElement||e instanceof getWindow(e).HTMLElement}function isShadowRoot(e){return"undefined"!=typeof ShadowRoot&&(e instanceof ShadowRoot||e instanceof getWindow(e).ShadowRoot)}function isOverflowElement(e){const{overflow:t,overflowX:n,overflowY:o,display:i}=getComputedStyle$1(e);return/auto|scroll|overlay|hidden|clip/.test(t+o+n)&&!["inline","contents"].includes(i)}function isTableElement(e){return["table","td","th"].includes(getNodeName(e))}function isContainingBlock(e){const t=isWebKit(),n=getComputedStyle$1(e);return"none"!==n.transform||"none"!==n.perspective||!!n.containerType&&"normal"!==n.containerType||!t&&!!n.backdropFilter&&"none"!==n.backdropFilter||!t&&!!n.filter&&"none"!==n.filter||["transform","perspective","filter"].some((e=>(n.willChange||"").includes(e)))||["paint","layout","strict","content"].some((e=>(n.contain||"").includes(e)))}function isWebKit(){return!("undefined"==typeof CSS||!CSS.supports)&&CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(e){return["html","body","#document"].includes(getNodeName(e))}function getComputedStyle$1(e){return getWindow(e).getComputedStyle(e)}function getNodeScroll(e){return isElement(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function getParentNode(e){if("html"===getNodeName(e))return e;const t=e.assignedSlot||e.parentNode||isShadowRoot(e)&&e.host||getDocumentElement(e);return isShadowRoot(t)?t.host:t}function getNearestOverflowAncestor(e){const t=getParentNode(e);return isLastTraversableNode(t)?e.ownerDocument?e.ownerDocument.body:e.body:isHTMLElement(t)&&isOverflowElement(t)?t:getNearestOverflowAncestor(t)}function getOverflowAncestors(e,t,n){var o;void 0===t&&(t=[]),void 0===n&&(n=!0);const i=getNearestOverflowAncestor(e),r=i===(null==(o=e.ownerDocument)?void 0:o.body),l=getWindow(i);return r?t.concat(l,l.visualViewport||[],isOverflowElement(i)?i:[],l.frameElement&&n?getOverflowAncestors(l.frameElement):[]):t.concat(i,getOverflowAncestors(i,[],n))}function getCssDimensions(e){const t=getComputedStyle$1(e);let n=parseFloat(t.width)||0,o=parseFloat(t.height)||0;const i=isHTMLElement(e),r=i?e.offsetWidth:n,l=i?e.offsetHeight:o,a=s(n)!==r||s(o)!==l;return a&&(n=r,o=l),{width:n,height:o,$:a}}function unwrapElement(e){return isElement(e)?e:e.contextElement}function getScale(e){const t=unwrapElement(e);if(!isHTMLElement(t))return createCoords(1);const n=t.getBoundingClientRect(),{width:o,height:i,$:r}=getCssDimensions(t);let l=(r?s(n.width):n.width)/o,a=(r?s(n.height):n.height)/i;return l&&Number.isFinite(l)||(l=1),a&&Number.isFinite(a)||(a=1),{x:l,y:a}}const u=createCoords(0);function getVisualOffsets(e){const t=getWindow(e);return isWebKit()&&t.visualViewport?{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}:u}function getBoundingClientRect(e,t,n,o){void 0===t&&(t=!1),void 0===n&&(n=!1);const i=e.getBoundingClientRect(),r=unwrapElement(e);let l=createCoords(1);t&&(o?isElement(o)&&(l=getScale(o)):l=getScale(e));const s=function shouldAddVisualOffsets(e,t,n){return void 0===t&&(t=!1),!(!n||t&&n!==getWindow(e))&&t}(r,n,o)?getVisualOffsets(r):createCoords(0);let a=(i.left+s.x)/l.x,c=(i.top+s.y)/l.y,f=i.width/l.x,u=i.height/l.y;if(r){const e=getWindow(r),t=o&&isElement(o)?getWindow(o):o;let n=e,i=n.frameElement;for(;i&&o&&t!==n;){const e=getScale(i),t=i.getBoundingClientRect(),o=getComputedStyle$1(i),r=t.left+(i.clientLeft+parseFloat(o.paddingLeft))*e.x,l=t.top+(i.clientTop+parseFloat(o.paddingTop))*e.y;a*=e.x,c*=e.y,f*=e.x,u*=e.y,a+=r,c+=l,n=getWindow(i),i=n.frameElement}}return rectToClientRect({width:f,height:u,x:a,y:c})}const g=[":popover-open",":modal"];function isTopLayer(e){return g.some((t=>{try{return e.matches(t)}catch(n){return!1}}))}function getWindowScrollBarX(e){return getBoundingClientRect(getDocumentElement(e)).left+getNodeScroll(e).scrollLeft}function getClientRectFromClippingAncestor(e,t,n){let o;if("viewport"===t)o=function getViewportRect(e,t){const n=getWindow(e),o=getDocumentElement(e),i=n.visualViewport;let r=o.clientWidth,l=o.clientHeight,s=0,a=0;if(i){r=i.width,l=i.height;const e=isWebKit();(!e||e&&"fixed"===t)&&(s=i.offsetLeft,a=i.offsetTop)}return{width:r,height:l,x:s,y:a}}(e,n);else if("document"===t)o=function getDocumentRect(e){const t=getDocumentElement(e),n=getNodeScroll(e),o=e.ownerDocument.body,i=l(t.scrollWidth,t.clientWidth,o.scrollWidth,o.clientWidth),r=l(t.scrollHeight,t.clientHeight,o.scrollHeight,o.clientHeight);let s=-n.scrollLeft+getWindowScrollBarX(e);const a=-n.scrollTop;return"rtl"===getComputedStyle$1(o).direction&&(s+=l(t.clientWidth,o.clientWidth)-i),{width:i,height:r,x:s,y:a}}(getDocumentElement(e));else if(isElement(t))o=function getInnerBoundingClientRect(e,t){const n=getBoundingClientRect(e,!0,"fixed"===t),o=n.top+e.clientTop,i=n.left+e.clientLeft,r=isHTMLElement(e)?getScale(e):createCoords(1);return{width:e.clientWidth*r.x,height:e.clientHeight*r.y,x:i*r.x,y:o*r.y}}(t,n);else{const n=getVisualOffsets(e);o={...t,x:t.x-n.x,y:t.y-n.y}}return rectToClientRect(o)}function hasFixedPositionAncestor(e,t){const n=getParentNode(e);return!(n===t||!isElement(n)||isLastTraversableNode(n))&&("fixed"===getComputedStyle$1(n).position||hasFixedPositionAncestor(n,t))}function getRectRelativeToOffsetParent(e,t,n){const o=isHTMLElement(t),i=getDocumentElement(t),r="fixed"===n,l=getBoundingClientRect(e,!0,r,t);let s={scrollLeft:0,scrollTop:0};const a=createCoords(0);if(o||!o&&!r)if(("body"!==getNodeName(t)||isOverflowElement(i))&&(s=getNodeScroll(t)),o){const e=getBoundingClientRect(t,!0,r,t);a.x=e.x+t.clientLeft,a.y=e.y+t.clientTop}else i&&(a.x=getWindowScrollBarX(i));return{x:l.left+s.scrollLeft-a.x,y:l.top+s.scrollTop-a.y,width:l.width,height:l.height}}function isStaticPositioned(e){return"static"===getComputedStyle$1(e).position}function getTrueOffsetParent(e,t){return isHTMLElement(e)&&"fixed"!==getComputedStyle$1(e).position?t?t(e):e.offsetParent:null}function getOffsetParent(e,t){const n=getWindow(e);if(isTopLayer(e))return n;if(!isHTMLElement(e)){let t=getParentNode(e);for(;t&&!isLastTraversableNode(t);){if(isElement(t)&&!isStaticPositioned(t))return t;t=getParentNode(t)}return n}let o=getTrueOffsetParent(e,t);for(;o&&isTableElement(o)&&isStaticPositioned(o);)o=getTrueOffsetParent(o,t);return o&&isLastTraversableNode(o)&&isStaticPositioned(o)&&!isContainingBlock(o)?n:o||function getContainingBlock(e){let t=getParentNode(e);for(;isHTMLElement(t)&&!isLastTraversableNode(t);){if(isContainingBlock(t))return t;t=getParentNode(t)}return null}(e)||n}const d={convertOffsetParentRelativeRectToViewportRelativeRect:function convertOffsetParentRelativeRectToViewportRelativeRect(e){let{elements:t,rect:n,offsetParent:o,strategy:i}=e;const r="fixed"===i,l=getDocumentElement(o),s=!!t&&isTopLayer(t.floating);if(o===l||s&&r)return n;let a={scrollLeft:0,scrollTop:0},c=createCoords(1);const f=createCoords(0),u=isHTMLElement(o);if((u||!u&&!r)&&(("body"!==getNodeName(o)||isOverflowElement(l))&&(a=getNodeScroll(o)),isHTMLElement(o))){const e=getBoundingClientRect(o);c=getScale(o),f.x=e.x+o.clientLeft,f.y=e.y+o.clientTop}return{width:n.width*c.x,height:n.height*c.y,x:n.x*c.x-a.scrollLeft*c.x+f.x,y:n.y*c.y-a.scrollTop*c.y+f.y}},getDocumentElement:getDocumentElement,getClippingRect:function getClippingRect(e){let{element:t,boundary:n,rootBoundary:o,strategy:i}=e;const s=[..."clippingAncestors"===n?isTopLayer(t)?[]:function getClippingElementAncestors(e,t){const n=t.get(e);if(n)return n;let o=getOverflowAncestors(e,[],!1).filter((e=>isElement(e)&&"body"!==getNodeName(e))),i=null;const r="fixed"===getComputedStyle$1(e).position;let l=r?getParentNode(e):e;for(;isElement(l)&&!isLastTraversableNode(l);){const t=getComputedStyle$1(l),n=isContainingBlock(l);n||"fixed"!==t.position||(i=null),(r?!n&&!i:!n&&"static"===t.position&&i&&["absolute","fixed"].includes(i.position)||isOverflowElement(l)&&!n&&hasFixedPositionAncestor(e,l))?o=o.filter((e=>e!==l)):i=t,l=getParentNode(l)}return t.set(e,o),o}(t,this._c):[].concat(n),o],a=s[0],c=s.reduce(((e,n)=>{const o=getClientRectFromClippingAncestor(t,n,i);return e.top=l(o.top,e.top),e.right=r(o.right,e.right),e.bottom=r(o.bottom,e.bottom),e.left=l(o.left,e.left),e}),getClientRectFromClippingAncestor(t,a,i));return{width:c.right-c.left,height:c.bottom-c.top,x:c.left,y:c.top}},getOffsetParent:getOffsetParent,getElementRects:async function(e){const t=this.getOffsetParent||getOffsetParent,n=this.getDimensions,o=await n(e.floating);return{reference:getRectRelativeToOffsetParent(e.reference,await t(e.floating),e.strategy),floating:{x:0,y:0,width:o.width,height:o.height}}},getClientRects:function getClientRects(e){return Array.from(e.getClientRects())},getDimensions:function getDimensions(e){const{width:t,height:n}=getCssDimensions(e);return{width:t,height:n}},getScale:getScale,isElement:isElement,isRTL:function isRTL(e){return"rtl"===getComputedStyle$1(e).direction}};function autoUpdate(e,t,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:s=!0,elementResize:c="function"==typeof ResizeObserver,layoutShift:f="function"==typeof IntersectionObserver,animationFrame:u=!1}=o,g=unwrapElement(e),d=i||s?[...g?getOverflowAncestors(g):[],...getOverflowAncestors(t)]:[];d.forEach((e=>{i&&e.addEventListener("scroll",n,{passive:!0}),s&&e.addEventListener("resize",n)}));const m=g&&f?function observeMove(e,t){let n,o=null;const i=getDocumentElement(e);function cleanup(){var e;clearTimeout(n),null==(e=o)||e.disconnect(),o=null}return function refresh(s,c){void 0===s&&(s=!1),void 0===c&&(c=1),cleanup();const{left:f,top:u,width:g,height:d}=e.getBoundingClientRect();if(s||t(),!g||!d)return;const m={rootMargin:-a(u)+"px "+-a(i.clientWidth-(f+g))+"px "+-a(i.clientHeight-(u+d))+"px "+-a(f)+"px",threshold:l(0,r(1,c))||1};let p=!0;function handleObserve(e){const t=e[0].intersectionRatio;if(t!==c){if(!p)return refresh();t?refresh(!1,t):n=setTimeout((()=>{refresh(!1,1e-7)}),1e3)}p=!1}try{o=new IntersectionObserver(handleObserve,{...m,root:i.ownerDocument})}catch(h){o=new IntersectionObserver(handleObserve,m)}o.observe(e)}(!0),cleanup}(g,n):null;let p,h=-1,y=null;c&&(y=new ResizeObserver((e=>{let[o]=e;o&&o.target===g&&y&&(y.unobserve(t),cancelAnimationFrame(h),h=requestAnimationFrame((()=>{var e;null==(e=y)||e.observe(t)}))),n()})),g&&!u&&y.observe(g),y.observe(t));let w=u?getBoundingClientRect(e):null;return u&&function frameLoop(){const t=getBoundingClientRect(e);!w||t.x===w.x&&t.y===w.y&&t.width===w.width&&t.height===w.height||n();w=t,p=requestAnimationFrame(frameLoop)}(),n(),()=>{var e;d.forEach((e=>{i&&e.removeEventListener("scroll",n),s&&e.removeEventListener("resize",n)})),null==m||m(),null==(e=y)||e.disconnect(),y=null,u&&cancelAnimationFrame(p)}}const offset=function(e){return void 0===e&&(e=0),{name:"offset",options:e,async fn(t){var n,o;const{x:i,y:r,placement:l,middlewareData:s}=t,a=await async function convertValueToCoords(e,t){const{placement:n,platform:o,elements:i}=e,r=await(null==o.isRTL?void 0:o.isRTL(i.floating)),l=getSide(n),s=getAlignment(n),a="y"===getSideAxis(n),c=["left","top"].includes(l)?-1:1,f=r&&a?-1:1,u=evaluate(t,e);let{mainAxis:g,crossAxis:d,alignmentAxis:m}="number"==typeof u?{mainAxis:u,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...u};return s&&"number"==typeof m&&(d="end"===s?-1*m:m),a?{x:d*f,y:g*c}:{x:g*c,y:d*f}}(t,e);return l===(null==(n=s.offset)?void 0:n.placement)&&null!=(o=s.arrow)&&o.alignmentOffset?{}:{x:i+a.x,y:r+a.y,data:{...a,placement:l}}}}},autoPlacement=function(e){return void 0===e&&(e={}),{name:"autoPlacement",options:e,async fn(t){var n,o,r;const{rects:l,middlewareData:s,placement:a,platform:c,elements:f}=t,{crossAxis:u=!1,alignment:g,allowedPlacements:d=i,autoAlignment:m=!0,...p}=evaluate(e,t),h=void 0!==g||d===i?function getPlacementList(e,t,n){return(e?[...n.filter((t=>getAlignment(t)===e)),...n.filter((t=>getAlignment(t)!==e))]:n.filter((e=>getSide(e)===e))).filter((n=>!e||getAlignment(n)===e||!!t&&getOppositeAlignmentPlacement(n)!==n))}(g||null,m,d):d,y=await detectOverflow(t,p),w=(null==(n=s.autoPlacement)?void 0:n.index)||0,v=h[w];if(null==v)return{};const x=getAlignmentSides(v,l,await(null==c.isRTL?void 0:c.isRTL(f.floating)));if(a!==v)return{reset:{placement:h[0]}};const b=[y[getSide(v)],y[x[0]],y[x[1]]],E=[...(null==(o=s.autoPlacement)?void 0:o.overflows)||[],{placement:v,overflows:b}],P=h[w+1];if(P)return{data:{index:w+1,overflows:E},reset:{placement:P}};const A=E.map((e=>{const t=getAlignment(e.placement);return[e.placement,t&&u?e.overflows.slice(0,2).reduce(((e,t)=>e+t),0):e.overflows[0],e.overflows]})).sort(((e,t)=>e[1]-t[1])),O=(null==(r=A.filter((e=>e[2].slice(0,getAlignment(e[0])?2:3).every((e=>e<=0))))[0])?void 0:r[0])||A[0][0];return O!==a?{data:{index:w+1,overflows:E},reset:{placement:O}}:{}}}},shift=function(e){return void 0===e&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:o,placement:i}=t,{mainAxis:r=!0,crossAxis:l=!1,limiter:s={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...a}=evaluate(e,t),c={x:n,y:o},f=await detectOverflow(t,a),u=getSideAxis(getSide(i)),g=getOppositeAxis(u);let d=c[g],m=c[u];if(r){const e="y"===g?"bottom":"right";d=clamp(d+f["y"===g?"top":"left"],d,d-f[e])}if(l){const e="y"===u?"bottom":"right";m=clamp(m+f["y"===u?"top":"left"],m,m-f[e])}const p=s.fn({...t,[g]:d,[u]:m});return{...p,data:{x:p.x-n,y:p.y-o}}}}},flip=function(e){return void 0===e&&(e={}),{name:"flip",options:e,async fn(t){var n,o;const{placement:i,middlewareData:r,rects:l,initialPlacement:s,platform:a,elements:c}=t,{mainAxis:f=!0,crossAxis:u=!0,fallbackPlacements:g,fallbackStrategy:d="bestFit",fallbackAxisSideDirection:m="none",flipAlignment:p=!0,...h}=evaluate(e,t);if(null!=(n=r.arrow)&&n.alignmentOffset)return{};const y=getSide(i),w=getSide(s)===s,v=await(null==a.isRTL?void 0:a.isRTL(c.floating)),x=g||(w||!p?[getOppositePlacement(s)]:function getExpandedPlacements(e){const t=getOppositePlacement(e);return[getOppositeAlignmentPlacement(e),t,getOppositeAlignmentPlacement(t)]}(s));g||"none"===m||x.push(...function getOppositeAxisPlacements(e,t,n,o){const i=getAlignment(e);let r=function getSideList(e,t,n){const o=["left","right"],i=["right","left"],r=["top","bottom"],l=["bottom","top"];switch(e){case"top":case"bottom":return n?t?i:o:t?o:i;case"left":case"right":return t?r:l;default:return[]}}(getSide(e),"start"===n,o);return i&&(r=r.map((e=>e+"-"+i)),t&&(r=r.concat(r.map(getOppositeAlignmentPlacement)))),r}(s,p,m,v));const b=[s,...x],E=await detectOverflow(t,h),P=[];let A=(null==(o=r.flip)?void 0:o.overflows)||[];if(f&&P.push(E[y]),u){const e=getAlignmentSides(i,l,v);P.push(E[e[0]],E[e[1]])}if(A=[...A,{placement:i,overflows:P}],!P.every((e=>e<=0))){var O,S;const e=((null==(O=r.flip)?void 0:O.index)||0)+1,t=b[e];if(t)return{data:{index:e,overflows:A},reset:{placement:t}};let n=null==(S=A.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:S.placement;if(!n)switch(d){case"bestFit":{var R;const e=null==(R=A.map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:R[0];e&&(n=e);break}case"initialPlacement":n=s}if(i!==n)return{reset:{placement:n}}}return{}}}},hide=function(e){return void 0===e&&(e={}),{name:"hide",options:e,async fn(t){const{rects:n}=t,{strategy:o="referenceHidden",...i}=evaluate(e,t);switch(o){case"referenceHidden":{const e=getSideOffsets(await detectOverflow(t,{...i,elementContext:"reference"}),n.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:isAnySideFullyClipped(e)}}}case"escaped":{const e=getSideOffsets(await detectOverflow(t,{...i,altBoundary:!0}),n.floating);return{data:{escapedOffsets:e,escaped:isAnySideFullyClipped(e)}}}default:return{}}}}},arrow=e=>({name:"arrow",options:e,async fn(t){const{x:n,y:o,placement:i,rects:l,platform:s,elements:a,middlewareData:c}=t,{element:f,padding:u=0}=evaluate(e,t)||{};if(null==f)return{};const g=getPaddingObject(u),d={x:n,y:o},m=getAlignmentAxis(i),p=getAxisLength(m),h=await s.getDimensions(f),y="y"===m,w=y?"top":"left",v=y?"bottom":"right",x=y?"clientHeight":"clientWidth",b=l.reference[p]+l.reference[m]-d[m]-l.floating[p],E=d[m]-l.reference[m],P=await(null==s.getOffsetParent?void 0:s.getOffsetParent(f));let A=P?P[x]:0;A&&await(null==s.isElement?void 0:s.isElement(P))||(A=a.floating[x]||l.floating[p]);const O=b/2-E/2,S=A/2-h[p]/2-1,R=r(g[w],S),T=r(g[v],S),C=R,L=A-h[p]-T,N=A/2-h[p]/2+O,D=clamp(C,N,L),F=!c.arrow&&null!=getAlignment(i)&&N!==D&&l.reference[p]/2-(N<C?R:T)-h[p]/2<0,W=F?N<C?N-C:N-L:0;return{[m]:d[m]+W,data:{[m]:D,centerOffset:N-D-W,...F&&{alignmentOffset:W}},reset:F}}}),computePosition=(e,t,n)=>{const o=new Map,i={platform:d,...n},r={...i.platform,_c:o};return(async(e,t,n)=>{const{placement:o="bottom",strategy:i="absolute",middleware:r=[],platform:l}=n,s=r.filter(Boolean),a=await(null==l.isRTL?void 0:l.isRTL(t));let c=await l.getElementRects({reference:e,floating:t,strategy:i}),{x:f,y:u}=computeCoordsFromPlacement(c,o,a),g=o,d={},m=0;for(let p=0;p<s.length;p++){const{name:n,fn:r}=s[p],{x:h,y:y,data:w,reset:v}=await r({x:f,y:u,initialPlacement:o,placement:g,strategy:i,middlewareData:d,rects:c,platform:l,elements:{reference:e,floating:t}});f=null!=h?h:f,u=null!=y?y:u,d={...d,[n]:{...d[n],...w}},v&&m<=50&&(m++,"object"==typeof v&&(v.placement&&(g=v.placement),v.rects&&(c=!0===v.rects?await l.getElementRects({reference:e,floating:t,strategy:i}):v.rects),({x:f,y:u}=computeCoordsFromPlacement(c,g,a))),p=-1)}return{x:f,y:u,placement:g,strategy:i,middlewareData:d}})(e,t,{...i,platform:r})};function offsetParent(e){return function offsetParentPolyfill(e){for(let t=e;t;t=flatTreeParent(t))if(t instanceof Element&&"none"===getComputedStyle(t).display)return null;for(let t=flatTreeParent(e);t;t=flatTreeParent(t)){if(!(t instanceof Element))continue;const e=getComputedStyle(t);if("contents"!==e.display){if("static"!==e.position||"none"!==e.filter)return t;if("BODY"===t.tagName)return t}}return null}(e)}function flatTreeParent(e){return e.assignedSlot?e.assignedSlot:e.parentNode instanceof ShadowRoot?e.parentNode.host:e.parentNode}function roundByDPR(e){const t=window.devicePixelRatio||1;return Math.round(e*t)/t}!function setUpFloatingUiForShadowDomPositioning(){{const e=d.getOffsetParent;d.getOffsetParent=t=>e(t,offsetParent)}}();const positionFloatingUI=async(e,{referenceEl:t,floatingEl:n,overlayPositioning:o="absolute",placement:i,flipDisabled:r,flipPlacements:l,offsetDistance:s,offsetSkidding:a,arrowEl:c,type:f})=>{var u;if(!t||!n)return null;const{x:g,y:d,placement:p,strategy:h,middlewareData:y}=await computePosition(t,n,{strategy:o,placement:"auto"===i||"auto-start"===i||"auto-end"===i?void 0:getEffectivePlacement(n,i),middleware:getMiddleware({placement:i,flipDisabled:r,flipPlacements:null==l?void 0:l.map((e=>getEffectivePlacement(n,e))),offsetDistance:s,offsetSkidding:a,arrowEl:c,type:f})});if(c&&y.arrow){const{x:t,y:n}=y.arrow,o=p.split("-")[0],i=null!=t?"left":"top",r=v[o],l={left:"",top:"",bottom:"",right:""};"floatingLayout"in e&&(e.floatingLayout="left"===o||"right"===o?"horizontal":"vertical"),Object.assign(c.style,{...l,[i]:`${"left"==i?t:n}px`,[o]:"100%",transform:r})}const w=(null==(u=y.hide)?void 0:u.referenceHidden)?"hidden":null,x=w?"none":null;n.setAttribute(m,p);const{open:b}=e;Object.assign(n.style,{visibility:w,pointerEvents:x,position:h,transform:b?`translate(${roundByDPR(g)}px,${roundByDPR(d)}px)`:"",top:0,left:0})},m="data-placement",p=100,h=["top","bottom","right","left","top-start","top-end","bottom-start","bottom-end","right-start","right-end","left-start","left-end","leading","trailing","leading-start","leading-end","trailing-start","trailing-end"],y="bottom-start",w={animation:"calcite-floating-ui-anim",animationActive:"calcite-floating-ui-anim--active"};function getMiddleware({placement:e,flipDisabled:t,flipPlacements:n,offsetDistance:o,offsetSkidding:i,arrowEl:r,type:l}){const s=[shift(),hide()];if("menu"===l)return[...s,flip({fallbackPlacements:n||["top-start","top","top-end","bottom-start","bottom","bottom-end"]})];if("popover"===l||"tooltip"===l){const l=[...s,offset({mainAxis:"number"==typeof o?o:0,crossAxis:"number"==typeof i?i:0})];return"auto"===e||"auto-start"===e||"auto-end"===e?l.push(autoPlacement({alignment:"auto-start"===e?"start":"auto-end"===e?"end":null})):t||l.push(flip(n?{fallbackPlacements:n}:{})),r&&l.push(arrow({element:r})),l}return[]}function filterValidFlipPlacements(e,t){const n=e.filter((e=>h.includes(e)));return n.length,e.length,n}function getEffectivePlacement(t,n){const o=["left","right"];return"rtl"===e(t)&&o.reverse(),n.replace(/leading/gi,o[0]).replace(/trailing/gi,o[1])}async function reposition(e,n,o=!1){if(!e.open||!n.floatingEl||!n.referenceEl)return;if(!x.get(e))return runAutoUpdate(e,n.referenceEl,n.floatingEl);const i=o?function getDebouncedReposition(e){let n=b.get(e);if(n)return n;return n=t(positionFloatingUI,p,{leading:!0,maxWait:p}),b.set(e,n),n}(e):positionFloatingUI;await i(e,n)}const v={top:"",left:"rotate(-90deg)",bottom:"rotate(180deg)",right:"rotate(90deg)"},x=new WeakMap,b=new WeakMap;async function runAutoUpdate(e,t,n){if(!n.isConnected)return;const o=autoUpdate;let i;x.set(e,{state:"pending"});const r=o(t,n,(()=>{const t=e.reposition();i||(i=t)}));return x.set(e,{state:"active",cleanUp:r}),i}async function connectFloatingUI(e,t,n){if(n&&t&&(disconnectFloatingUI(e,t,n),Object.assign(n.style,{visibility:"hidden",pointerEvents:"none",position:e.overlayPositioning}),e.open))return runAutoUpdate(e,t,n)}function disconnectFloatingUI(e,t,n){var o;if(!n||!t)return;const i=x.get(e);"active"===(null==i?void 0:i.state)&&i.cleanUp(),x.delete(e),null==(o=b.get(e))||o.cancel(),b.delete(e)}const E=Math.ceil(Math.hypot(4,4));export{w as F,disconnectFloatingUI as a,E as b,connectFloatingUI as c,y as d,filterValidFlipPlacements as f,reposition as r};
