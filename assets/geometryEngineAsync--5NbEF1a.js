import{aw as n,gM as e,bf as t}from"./index-DSIPxOWi.js";function r(n){var e;return Array.isArray(n)?null==(e=n[0])?void 0:e.spatialReference:null==n?void 0:n.spatialReference}function a(n){return n?Array.isArray(n)?n.map(a):n.toJSON?n.toJSON():n:n}function i(n){return Array.isArray(n)?n.map((n=>e(n))):e(n)}let c;async function u(){return c||(c=t("geometryEngineWorker",{strategy:"distributed"})),c}async function s(n,e){return(await u()).invoke("executeGEOperation",{operation:n,parameters:a(e)})}async function f(n,e){const t=await u();return Promise.all(t.broadcast("executeGEOperation",{operation:n,parameters:a(e)}))}function l(n){return s("extendedSpatialReferenceInfo",[n])}async function y(n,e){return i(await s("clip",[r(n),n,e]))}async function w(n,e){return i(await s("cut",[r(n),n,e]))}function p(n,e){return s("contains",[r(n),n,e])}function m(n,e){return s("crosses",[r(n),n,e])}function d(n,e,t){return s("distance",[r(n),n,e,t])}function g(n,e){return s("equals",[r(n),n,e])}function h(n,e){return s("intersects",[r(n),n,e])}function S(n,e){return s("touches",[r(n),n,e])}function x(n,e){return s("within",[r(n),n,e])}function A(n,e){return s("disjoint",[r(n),n,e])}function O(n,e){return s("overlaps",[r(n),n,e])}function R(n,e,t){return s("relate",[r(n),n,e,t])}function J(n){return s("isSimple",[r(n),n])}async function N(n){return i(await s("simplify",[r(n),n]))}async function j(n,e=!1){return i(await s("convexHull",[r(n),n,e]))}async function E(n,e){return i(await s("difference",[r(n),n,e]))}async function k(n,e){return i(await s("symmetricDifference",[r(n),n,e]))}async function D(n,e){return i(await s("intersect",[r(n),n,e]))}async function b(n,e=null){const t=function o(n,e){let t;return Array.isArray(n)?t=n:(t=[],t.push(n),null!=e&&t.push(e)),t}(n,e);return i(await s("union",[r(t),t]))}async function v(n,e,t,c,$,_){return i(await s("offset",[r(n),n,e,t,c,$,_]))}async function L(n,e,t,c=!1){const $=[r(n),n,e,t,c];return i(await s("buffer",$))}async function P(n,e,t,c,$,_){const nn=[r(n),n,e,t,c,$,_];return i(await s("geodesicBuffer",nn))}async function T(e,t,c=!0){const $=await s("nearestCoordinate",[r(e),e,t,c]);return{...$,coordinate:n.fromJSON($.coordinate)}}async function V(e,t){const c=await s("nearestVertex",[r(e),e,t]);return{...c,coordinate:n.fromJSON(c.coordinate)}}async function z(e,t,c,$){return(await s("nearestVertices",[r(e),e,t,c,$])).map((e=>({...e,coordinate:n.fromJSON(e.coordinate)})))}function G(n){var e;return"xmin"in n?n.center:"x"in n?n:null==(e=n.extent)?void 0:e.center}async function H(n,e,t){if(null==n)throw new Z;const c=n.spatialReference;if(null==(t=t??G(n)))throw new Z;const $=n.constructor.fromJSON(await s("rotate",[c,n,e,t]));return $.spatialReference=c,$}async function I(n,e){if(null==n)throw new Z;const t=n.spatialReference;if(null==(e=e??G(n)))throw new Z;const c=n.constructor.fromJSON(await s("flipHorizontal",[t,n,e]));return c.spatialReference=t,c}async function q(n,e){if(null==n)throw new Z;const t=n.spatialReference;if(null==(e=e??G(n)))throw new Z;const c=n.constructor.fromJSON(await s("flipVertical",[t,n,e]));return c.spatialReference=t,c}async function B(n,e,t,c){return i(await s("generalize",[r(n),n,e,t,c]))}async function C(n,e,t){return i(await s("densify",[r(n),n,e,t]))}async function U(n,e,t,c=0){return i(await s("geodesicDensify",[r(n),n,e,t,c]))}function W(n,e){return s("planarArea",[r(n),n,e])}function F(n,e){return s("planarLength",[r(n),n,e])}function K(n,e,t){return s("geodesicArea",[r(n),n,e,t])}function M(n,e,t){return s("geodesicLength",[r(n),n,e,t])}async function Q(n,e){return i(await s("intersectLinesToPoints",[r(n),n,e]))}async function X(n,e){await f("changeDefaultSpatialReferenceTolerance",[n,e])}async function Y(n){await f("clearDefaultSpatialReferenceTolerance",[n])}class Z extends Error{constructor(){super("Illegal Argument Exception")}}export{L as buffer,X as changeDefaultSpatialReferenceTolerance,Y as clearDefaultSpatialReferenceTolerance,y as clip,p as contains,j as convexHull,m as crosses,w as cut,C as densify,E as difference,A as disjoint,d as distance,g as equals,l as extendedSpatialReferenceInfo,I as flipHorizontal,q as flipVertical,B as generalize,K as geodesicArea,P as geodesicBuffer,U as geodesicDensify,M as geodesicLength,D as intersect,Q as intersectLinesToPoints,h as intersects,J as isSimple,T as nearestCoordinate,V as nearestVertex,z as nearestVertices,v as offset,O as overlaps,W as planarArea,F as planarLength,R as relate,H as rotate,N as simplify,k as symmetricDifference,S as touches,b as union,x as within};
