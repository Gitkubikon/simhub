import{G as e}from"./geometryEngineBase-9EI9fooq.js";import{hydratedAdapter as n}from"./hydrated-DE1HcVsK.js";import"./index-DSIPxOWi.js";function t(e){return Array.isArray(e)?e[0].spatialReference:e&&e.spatialReference}function r(n){return e.extendedSpatialReferenceInfo(n)}function u(K,M){return e.clip(n,t(K),K,M)}function i(K,M){return e.cut(n,t(K),K,M)}function c(K,M){return e.contains(n,t(K),K,M)}function o(K,M){return e.crosses(n,t(K),K,M)}function f(K,M,Q){return e.distance(n,t(K),K,M,Q)}function s(K,M){return e.equals(n,t(K),K,M)}function a(K,M){return e.intersects(n,t(K),K,M)}function l(K,M){return e.touches(n,t(K),K,M)}function p(K,M){return e.within(n,t(K),K,M)}function d(K,M){return e.disjoint(n,t(K),K,M)}function m(K,M){return e.overlaps(n,t(K),K,M)}function g(K,M,Q){return e.relate(n,t(K),K,M,Q)}function h(K){return e.isSimple(n,t(K),K)}function w(K){return e.simplify(n,t(K),K)}function R(K,M=!1){return e.convexHull(n,t(K),K,M)}function x(K,M){return e.difference(n,t(K),K,M)}function y(K,M){return e.symmetricDifference(n,t(K),K,M)}function S(K,M){return e.intersect(n,t(K),K,M)}function A(K,M=null){return e.union(n,t(K),K,M)}function D(K,M,Q,U,W,X){return e.offset(n,t(K),K,M,Q,U,W,X)}function j(K,M,Q,U=!1){return e.buffer(n,t(K),K,M,Q,U)}function E(K,M,Q,U,W,X){return e.geodesicBuffer(n,t(K),K,M,Q,U,W,X)}function J(K,M,Q=!0){return e.nearestCoordinate(n,t(K),K,M,Q)}function L(K,M){return e.nearestVertex(n,t(K),K,M)}function N(K,M,Q,U){return e.nearestVertices(n,t(K),K,M,Q,U)}function O(e){var n;return"xmin"in e?"center"in e?e.center:null:"x"in e?e:"extent"in e?(null==(n=e.extent)?void 0:n.center)??null:null}function T(n,K,M){if(null==n)throw new F;const Q=n.spatialReference;if(null==(M=M??O(n)))throw new F;const U=n.constructor.fromJSON(e.rotate(n,K,M));return U.spatialReference=Q,U}function V(n,K){if(null==n)throw new F;const M=n.spatialReference;if(null==(K=K??O(n)))throw new F;const Q=n.constructor.fromJSON(e.flipHorizontal(n,K));return Q.spatialReference=M,Q}function v(n,K){if(null==n)throw new F;const M=n.spatialReference;if(null==(K=K??O(n)))throw new F;const Q=n.constructor.fromJSON(e.flipVertical(n,K));return Q.spatialReference=M,Q}function z(K,M,Q,U){return e.generalize(n,t(K),K,M,Q,U)}function B(K,M,Q){return e.densify(n,t(K),K,M,Q)}function H(K,M,Q,U=0){return e.geodesicDensify(n,t(K),K,M,Q,U)}function I(K,M){return e.planarArea(n,t(K),K,M)}function b(K,M){return e.planarLength(n,t(K),K,M)}function k(K,M,Q){return e.geodesicArea(n,t(K),K,M,Q)}function q(K,M,Q){return e.geodesicLength(n,t(K),K,M,Q)}function C(K,M){return e.intersectLinesToPoints(n,t(K),K,M)}function G(n,K){e.changeDefaultSpatialReferenceTolerance(n,K)}function P(n){e.clearDefaultSpatialReferenceTolerance(n)}class F extends Error{constructor(){super("Illegal Argument Exception")}}export{j as buffer,G as changeDefaultSpatialReferenceTolerance,P as clearDefaultSpatialReferenceTolerance,u as clip,c as contains,R as convexHull,o as crosses,i as cut,B as densify,x as difference,d as disjoint,f as distance,s as equals,r as extendedSpatialReferenceInfo,V as flipHorizontal,v as flipVertical,z as generalize,k as geodesicArea,E as geodesicBuffer,H as geodesicDensify,q as geodesicLength,S as intersect,C as intersectLinesToPoints,a as intersects,h as isSimple,J as nearestCoordinate,L as nearestVertex,N as nearestVertices,D as offset,m as overlaps,I as planarArea,b as planarLength,g as relate,T as rotate,w as simplify,y as symmetricDifference,l as touches,A as union,p as within};
