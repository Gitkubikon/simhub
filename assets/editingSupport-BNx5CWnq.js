import{eV as e,eW as t,eX as a,bn as r,b as s,eY as i,ad as n,n as l,eZ as o,e_ as d,V as u,v as p,e$ as c,f0 as h,G as f,f1 as m,cM as y}from"./index-DSIPxOWi.js";import{R as g}from"./normalizeUtils-BrH-PrZy.js";import{u as b,i as w}from"./infoFor3D-BTCPmnmy.js";import"./normalizeUtilsCommon-BU8xfl77.js";function F(e){return null!=(null==e?void 0:e.applyEdits)}function A(e){return"object"==typeof e&&null!=e&&"objectId"in e&&!!e.objectId}function v(e){return e.every(A)}function I(e){return"object"==typeof e&&null!=e&&"globalId"in e&&!!e.globalId}function $(e){return e.every(I)}async function E(o,u,p,c={}){var h;let f;const m="gdbVersion"in o?o.gdbVersion:null,y=c.gdbVersion??m;if(e(o)&&o.url)f=t(o.url,o.layerId,y,"original-and-current-features"===c.returnServiceEditsOption);else{f=a(),f.promise.then((e=>{(e.addedFeatures.length||e.updatedFeatures.length||e.deletedFeatures.length||e.addedAttachments.length||e.updatedAttachments.length||e.deletedAttachments.length)&&o.emit("edits",e)}));const e={result:f.promise};o.emit("apply-edits",e)}try{const{results:e,edits:t}=await async function S(e,t,a,r){var o,u,p,c,h,f;if(await e.load(),!F(t))throw new s(`${e.type}-layer:no-editing-support`,"Layer source does not support applyEdits capability",{layer:e});if(!i(e))throw new s(`${e.type}-layer:editing-disabled`,"Editing is disabled for layer",{layer:e});const{edits:m,options:y}=await async function R(e,t,a){const r=n(e),i=t&&(t.addFeatures||t.updateFeatures||t.deleteFeatures),o=t&&(t.addAttachments||t.updateAttachments||t.deleteAttachments),u=null!=e.infoFor3D;if(M(t,r,a,!!i,!!o,`${e.type}-layer`),!r.data.isVersioned&&(null==a?void 0:a.gdbVersion))throw new s(`${e.type}-layer:invalid-parameter`,"'gdbVersion' is applicable only if the layer supports versioned data. See: 'capabilities.data.isVersioned'");if(!r.editing.supportsRollbackOnFailure&&(null==a?void 0:a.rollbackOnFailureEnabled))throw new s(`${e.type}-layer:invalid-parameter`,"This layer does not support 'rollbackOnFailureEnabled' parameter. See: 'capabilities.editing.supportsRollbackOnFailure'");const p={...a};if(null!=p.rollbackOnFailureEnabled||r.editing.supportsRollbackOnFailure||(p.rollbackOnFailureEnabled=!0),p.rollbackOnFailureEnabled||"original-and-current-features"!==p.returnServiceEditsOption||(!1===p.rollbackOnFailureEnabled&&l.getLogger("esri.layers.graphics.editingSupport").warn(`${e.type}-layer:invalid-parameter`,"'original-and-current-features' is valid for 'returnServiceEditsOption' only when 'rollBackOnFailure' is true, but 'rollBackOnFailure' was set to false. 'rollBackOnFailure' has been overwritten and set to true."),p.rollbackOnFailureEnabled=!0),!r.editing.supportsReturnServiceEditsInSourceSpatialReference&&p.returnServiceEditsInSourceSR)throw new s(`${e.type}-layer:invalid-parameter`,"This layer does not support 'returnServiceEditsInSourceSR' parameter. See: 'capabilities.editing.supportsReturnServiceEditsInSourceSpatialReference'");if(p.returnServiceEditsInSourceSR&&"original-and-current-features"!==p.returnServiceEditsOption)throw new s(`${e.type}-layer:invalid-parameter`,"'returnServiceEditsInSourceSR' is valid only when 'returnServiceEditsOption' is set to 'original-and-current-features'");const c=V(t,r,`${e.type}-layer`),h=(null==a?void 0:a.globalIdUsed)||u,f=e.fields.filter((e=>"big-integer"===e.type||"oid"===e.type&&(e.length||0)>=8));if(h){const{globalIdField:t}=e;if(null==t)throw new s(`${e.type}-layer:invalid-parameter`,"Layer does not specify a global id field.");c.addFeatures.forEach((e=>function T(e,t){const{attributes:a}=e;null==a[t]&&(a[t]=d())}(e,t)))}return c.addFeatures.forEach((t=>function U(e,t,a,r){j(e,t,a,r),O(e,t)}(t,e,h,f))),c.updateFeatures.forEach((t=>function L(e,t,a,r){j(e,t,a,r),O(e,t);const i=n(t);if("geometry"in e&&null!=e.geometry&&!(null==i?void 0:i.editing.supportsGeometryUpdate))throw new s(`${t.type}-layer:unsupported-operation`,"Layer does not support geometry updates.")}(t,e,h,f))),c.deleteFeatures.forEach((t=>function k(e,t,a,r){j(e,t,a,r)}(t,e,h,f))),c.addAttachments.forEach((t=>B(t,e))),c.updateAttachments.forEach((t=>B(t,e))),u&&await async function z(e,t){if(null==t.infoFor3D)return;const{infoFor3D:a}=t,r=b("model/gltf-binary",a.supportedFormats)??w("glb",a.supportedFormats);if(!r||!a.editFormats.includes(r))throw new s(`${t.type}-layer:binary-gltf-asset-not-supported`,"3DObjectFeatureLayer requires binary glTF (.glb) support for updating mesh geometry.");e.addAssetFeatures??(e.addAssetFeatures=[]);const{addAssetFeatures:i}=e;for(const s of e.addFeatures??[])q(s)&&i.push(s);for(const s of e.updateFeatures??[])q(s)&&i.push(s)}(c,e),{edits:await D(c),options:p}}(e,a,r);return(null==(o=m.addFeatures)?void 0:o.length)||(null==(u=m.updateFeatures)?void 0:u.length)||(null==(p=m.deleteFeatures)?void 0:p.length)||(null==(c=m.addAttachments)?void 0:c.length)||(null==(h=m.updateAttachments)?void 0:h.length)||(null==(f=m.deleteAttachments)?void 0:f.length)?{edits:m,results:await t.applyEdits(m,y)}:{edits:m,results:{addFeatureResults:[],updateFeatureResults:[],deleteFeatureResults:[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}}}(o,u,p,c),l2=e=>e.filter((e=>!e.error)).map(r),a={edits:t,addedFeatures:l2(e.addFeatureResults),updatedFeatures:l2(e.updateFeatureResults),deletedFeatures:l2(e.deleteFeatureResults),addedAttachments:l2(e.addAttachmentResults),updatedAttachments:l2(e.updateAttachmentResults),deletedAttachments:l2(e.deleteAttachmentResults),exceededTransferLimit:!1,historicMoment:e.editMoment?new Date(e.editMoment):null,globalIdToObjectId:c.globalIdToObjectId};return(null==(h=e.editedFeatureResults)?void 0:h.length)&&(a.editedFeatures=e.editedFeatureResults),f.resolve(a),e}catch(g){throw f.reject(g),g}}function j(e,t,a,r){var i,n;if(a){if("attributes"in e&&!e.attributes[t.globalIdField])throw new s(`${t.type}-layer:invalid-parameter`,`Feature should have '${t.globalIdField}' when 'globalIdUsed' is true`);if(!("attributes"in e)&&!e.globalId)throw new s(`${t.type}-layer:invalid-parameter`,"`'globalId' of the feature should be passed when 'globalIdUsed' is true")}if(r.length&&"attributes"in e)for(const l of r){const a=e.attributes[l.name];if(void 0!==a&&!c(l,a))throw new s(`${t.type}-layer:invalid-parameter`,`Big-integer field '${l.name}' of the feature must be less than ${Number.MAX_SAFE_INTEGER}`,{feature:e})}if("geometry"in e&&null!=e.geometry){if(e.geometry.hasZ&&!1===(null==(i=t.capabilities)?void 0:i.data.supportsZ))throw new s(`${t.type}-layer:z-unsupported`,"Layer does not support z values while feature has z values.");if(e.geometry.hasM&&!1===(null==(n=t.capabilities)?void 0:n.data.supportsM))throw new s(`${t.type}-layer:m-unsupported`,"Layer does not support m values while feature has m values.")}}function O(e,t){var a;if("geometry"in e&&"mesh"===(null==(a=e.geometry)?void 0:a.type)&&null!=t.infoFor3D&&null!=t.spatialReference){const{geometry:a}=e,{spatialReference:r,vertexSpace:i}=a,n=t.spatialReference,l="local"===i.type,o=h(n),d=f(n,r),u=d||m(n)&&(m(r)||y(r));if(!(l&&o&&u||!l&&!o&&d))throw new s(`${t.type}-layer:mesh-unsupported`,`Uploading a mesh with a ${i.type} vertex space and a spatial reference wkid:${r.wkid} to a layer with a spatial reference wkid:${n.wkid} is not supported.`)}}function B(e,t){var a;const{feature:r,attachment:i}=e;if(!r||"attributes"in r&&!r.attributes[t.globalIdField])throw new s(`${t.type}-layer:invalid-parameter`,"Attachment should have reference to a feature with 'globalId'");if(!("attributes"in r)&&!r.globalId)throw new s(`${t.type}-layer:invalid-parameter`,"Attachment should have reference to 'globalId' of the parent feature");if(!i.globalId)throw new s(`${t.type}-layer:invalid-parameter`,"Attachment should have 'globalId'");if(!i.data&&!i.uploadId)throw new s(`${t.type}-layer:invalid-parameter`,"Attachment should have 'data' or 'uploadId'");if(!(i.data instanceof File&&i.data.name||i.name))throw new s(`${t.type}-layer:invalid-parameter`,"'name' is required when attachment is specified as Base64 encoded string using 'data'");if(!(null==(a=t.capabilities)?void 0:a.editing.supportsUploadWithItemId)&&i.uploadId)throw new s(`${t.type}-layer:invalid-parameter`,"This layer does not support 'uploadId' parameter. See: 'capabilities.editing.supportsUploadWithItemId'");if("string"==typeof i.data){const e=o(i.data);if(e&&!e.isBase64)throw new s(`${t.type}-layer:invalid-parameter`,"Attachment 'data' should be a Blob, File or Base64 encoded string")}}async function D(e){const t=e.addFeatures??[],a=e.updateFeatures??[],r=t.concat(a).map((e=>e.geometry)),s=await g(r),i=t.length,n=a.length;return s.slice(0,i).forEach(((e,a)=>t[a].geometry=e)),s.slice(i,i+n).forEach(((e,t)=>a[t].geometry=e)),e}function G(e){return{addFeatures:Array.from((null==e?void 0:e.addFeatures)??[]),updateFeatures:Array.from((null==e?void 0:e.updateFeatures)??[]),deleteFeatures:e&&u.isCollection(e.deleteFeatures)?e.deleteFeatures.toArray():e.deleteFeatures||[],addAttachments:e.addAttachments||[],updateAttachments:e.updateAttachments||[],deleteAttachments:e.deleteAttachments||[]}}function V(e,t,a){var r,i,n;const l=G(e);if((null==(r=l.addFeatures)?void 0:r.length)&&!t.operations.supportsAdd)throw new s(`${a}:unsupported-operation`,"Layer does not support adding features.");if((null==(i=l.updateFeatures)?void 0:i.length)&&!t.operations.supportsUpdate)throw new s(`${a}:unsupported-operation`,"Layer does not support updating features.");if((null==(n=l.deleteFeatures)?void 0:n.length)&&!t.operations.supportsDelete)throw new s(`${a}:unsupported-operation`,"Layer does not support deleting features.");return l.addFeatures=l.addFeatures.map(x),l.updateFeatures=l.updateFeatures.map(x),l.addAssetFeatures=[],l}function M(e,t,a,r,i,n){if(!e||!r&&!i)throw new s(`${n}:missing-parameters`,"'addFeatures', 'updateFeatures', 'deleteFeatures', 'addAttachments', 'updateAttachments' or 'deleteAttachments' parameter is required");if(!t.editing.supportsGlobalId&&(null==a?void 0:a.globalIdUsed))throw new s(`${n}:invalid-parameter`,"This layer does not support 'globalIdUsed' parameter. See: 'capabilities.editing.supportsGlobalId'");if(!t.editing.supportsGlobalId&&i)throw new s(`${n}:invalid-parameter`,"'addAttachments', 'updateAttachments' and 'deleteAttachments' are applicable only if the layer supports global ids. See: 'capabilities.editing.supportsGlobalId'");if(!(null==a?void 0:a.globalIdUsed)&&i)throw new s(`${n}:invalid-parameter`,"When 'addAttachments', 'updateAttachments' or 'deleteAttachments' is specified, globalIdUsed should be set to true")}function x(e){const t=new p;return e.attributes||(e.attributes={}),t.geometry=e.geometry,t.attributes=e.attributes,t}function q(e){var t;return"mesh"===(null==(t=null==e?void 0:e.geometry)?void 0:t.type)}function W(e,t,a,r){if(!F(t))throw new s(`${e.type}-layer:no-editing-support`,"Layer source does not support applyEdits capability",{layer:e});if(!t.uploadAssets)throw new s(`${e.type}-layer:no-asset-upload-support`,"Layer source does not support uploadAssets capability",{layer:e});return t.uploadAssets(a,r)}export{E as applyEdits,M as checkEditingCapabilities,$ as isFeatureIdentifierArrayWithGlobalId,v as isFeatureIdentifierArrayWithObjectId,I as isFeatureIdentifierWithGlobalId,A as isFeatureIdentifierWithObjectId,G as normalizeCollections,V as normalizeEdits,D as normalizeGeometries,x as shallowCloneFeature,W as uploadAssets};
