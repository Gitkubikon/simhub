import{rl as c,rm as d,rn as x,ro as p,rp as _,rq as m,rr as M,rs as w,rt as P,ru as T,rv as D,rw as B,rx as v,hJ as V,ry as k,kw as S,rz as C,rA as E,rB as O,hX as R,rC as F,rD as z,rE as N,rF as U,rG as G,rH as H,rI as K,rJ as W,rK as j,rL as q,c as Y,W as $,rM as J,rN as Z}from"./index-DSIPxOWi.js";import{t as X}from"./Rect-3ZUgN72u.js";import{n as Q}from"./pbf-B53Txr8m.js";import{a as ee,c as te,i as se}from"./TurboLine-C4MsOSzA.js";function e$1(c){return 746===c||747===c||!(c<4352)&&(c>=12704&&c<=12735||c>=12544&&c<=12591||c>=65072&&c<=65103&&!(c>=65097&&c<=65103)||c>=63744&&c<=64255||c>=13056&&c<=13311||c>=11904&&c<=12031||c>=12736&&c<=12783||c>=12288&&c<=12351&&!(c>=12296&&c<=12305||c>=12308&&c<=12319||12336===c)||c>=13312&&c<=19903||c>=19968&&c<=40959||c>=12800&&c<=13055||c>=12592&&c<=12687||c>=43360&&c<=43391||c>=55216&&c<=55295||c>=4352&&c<=4607||c>=44032&&c<=55215||c>=12352&&c<=12447||c>=12272&&c<=12287||c>=12688&&c<=12703||c>=12032&&c<=12255||c>=12784&&c<=12799||c>=12448&&c<=12543&&12540!==c||c>=65280&&c<=65519&&!(65288===c||65289===c||65293===c||c>=65306&&c<=65310||65339===c||65341===c||65343===c||c>=65371&&c<=65503||65507===c||c>=65512&&c<=65519)||c>=65104&&c<=65135&&!(c>=65112&&c<=65118||c>=65123&&c<=65126)||c>=5120&&c<=5759||c>=6320&&c<=6399||c>=65040&&c<=65055||c>=19904&&c<=19967||c>=40960&&c<=42127||c>=42128&&c<=42191)}function c$1(c){return!(c<11904)&&(c>=12704&&c<=12735||c>=12544&&c<=12591||c>=65072&&c<=65103||c>=63744&&c<=64255||c>=13056&&c<=13311||c>=11904&&c<=12031||c>=12736&&c<=12783||c>=12288&&c<=12351||c>=13312&&c<=19903||c>=19968&&c<=40959||c>=12800&&c<=13055||c>=65280&&c<=65519||c>=12352&&c<=12447||c>=12272&&c<=12287||c>=12032&&c<=12255||c>=12784&&c<=12799||c>=12448&&c<=12543||c>=65040&&c<=65055||c>=42128&&c<=42191||c>=40960&&c<=42127)}function s$3(c){switch(c){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function a$1(c){switch(c){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}const ie=24;let re=class l{constructor(c,d,x,p,_,m,M){this._glyphItems=c,this._maxWidth=d,this._lineHeight=x,this._letterSpacing=p,this._hAnchor=_,this._vAnchor=m,this._justify=M}getShaping(c,d,x){const p=this._letterSpacing,_=this._lineHeight,m=this._justify,M=this._maxWidth,w=[];let P=0,T=0;for(const O of c){const c=O.codePointAt(0);if(null==c)continue;const d=x&&e$1(c);let _;for(const x of this._glyphItems)if(_=x[c],_)break;w.push({codePoint:c,x:P,y:T,vertical:d,glyphMosaicItem:_}),_&&(P+=_.metrics.advance+p)}let D=P;M>0&&(D=P/Math.max(1,Math.ceil(P/M)));const B=c.includes("â€‹"),v=[],V=w.length;for(let O=0;O<V-1;O++){const c=w[O].codePoint,d=c$1(c);if(s$3(c)||d){let x=0;if(10===c)x-=1e4;else if(d&&B)x+=150;else{40!==c&&65288!==c||(x+=50);const d=w[O+1].codePoint;41!==d&&65289!==d||(x+=50)}v.push(this._buildBreak(O+1,w[O].x,D,v,x,!1))}}const k=this._optimalBreaks(this._buildBreak(V,P,D,v,0,!0));let S=0;const C=d?-_:_;let E=0;for(let O=0;O<k.length;O++){const c=k[O];let d=E;for(;d<c&&a$1(w[d].codePoint);)w[d].glyphMosaicItem=null,++d;let x=c-1;for(;x>d&&a$1(w[x].codePoint);)w[x].glyphMosaicItem=null,--x;if(d<=x){const c=w[d].x;for(let _=d;_<=x;_++)w[_].x-=c,w[_].y=T;let p=w[x].x;w[x].glyphMosaicItem&&(p+=w[x].glyphMosaicItem.metrics.advance),S=Math.max(p,S),m&&this._applyJustification(w,d,x)}E=c,T+=C}if(w.length>0){const c=k.length-1,x=(m-this._hAnchor)*S;let p=(-this._vAnchor*(c+1)+.5)*_;d&&c&&(p+=c*_);for(const d of w)d.x+=x,d.y+=p}return w.filter((c=>c.glyphMosaicItem))}static getTextBox(c,d){if(!c.length)return null;let x=1/0,p=1/0,_=0,m=0;for(const M of c){const c=M.glyphMosaicItem.metrics.advance,w=M.x,P=M.y-17,T=w+c,D=P+d;x=Math.min(x,w),_=Math.max(_,T),p=Math.min(p,P),m=Math.max(m,D)}return{x:x,y:p,width:_-x,height:m-p}}static getBox(c){if(!c.length)return null;let d=1/0,x=1/0,p=0,_=0;for(const m of c){const{height:c,left:M,top:w,width:P}=m.glyphMosaicItem.metrics,T=m.x,D=m.y-(c-Math.abs(w)),B=T+P+M,v=D+c;d=Math.min(d,T),p=Math.max(p,B),x=Math.min(x,D),_=Math.max(_,v)}return{x:d,y:x,width:p-d,height:_-x}}static addDecoration(c,d){const x=c.length;if(0===x)return;let p=c[0].x+c[0].glyphMosaicItem.metrics.left,_=c[0].y;for(let M=1;M<x;M++){const x=c[M];if(x.y!==_){const m=c[M-1].x+c[M-1].glyphMosaicItem.metrics.left+c[M-1].glyphMosaicItem.metrics.width;c.push({codePoint:0,x:p,y:_+d-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new X(4,0,4,8),metrics:{width:m-p,height:8,left:0,top:0,advance:0},page:0,code:0}}),_=x.y,p=x.x+x.glyphMosaicItem.metrics.left}}const m=c[x-1].x+c[x-1].glyphMosaicItem.metrics.left+c[x-1].glyphMosaicItem.metrics.width;c.push({codePoint:0,x:p,y:_+d-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new X(4,0,4,8),metrics:{width:m-p,height:8,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(c,d,x,p){const _=(c-d)*(c-d);return p?c<d?_/2:2*_:_+Math.abs(x)*x}_buildBreak(c,d,x,p,_,m){let M=null,w=this._breakScore(d,x,_,m);for(const P of p){const c=d-P.x,p=this._breakScore(c,x,_,m)+P.score;p<=w&&(M=P,w=p)}return{index:c,x:d,score:w,previousBreak:M}}_optimalBreaks(c){return c?this._optimalBreaks(c.previousBreak).concat(c.index):[]}_applyJustification(c,d,x){const p=c[x],_=p.vertical?ie:p.glyphMosaicItem?p.glyphMosaicItem.metrics.advance:0,m=(p.x+_)*this._justify;for(let M=d;M<=x;M++)c[M].x-=m}};const ne=.5;class y{constructor(c,d,x=0,p=-1,_=ne){this.x=c,this.y=d,this.angle=x,this.segment=p,this.minzoom=_}}class f{constructor(c,d,x,p,_,m=ne,w=M){this.anchor=c,this.labelAngle=d,this.glyphAngle=x,this.page=p,this.alternateVerticalGlyph=_,this.minzoom=m,this.maxzoom=w}}let ae=class I{constructor(c,d,x,p,_,m,M,w,P,T,D,B){this.tl=c,this.tr=d,this.bl=x,this.br=p,this.mosaicRect=_,this.labelAngle=m,this.minAngle=M,this.maxAngle=w,this.anchor=P,this.minzoom=T,this.maxzoom=D,this.page=B}},le=class u{constructor(c){this.shapes=c}},oe=class b{getIconPlacement(m,M,w){const P=new c(m.x,m.y),T=w.rotationAlignment===d.MAP,D=w.keepUpright;let B=w.rotate*x;T&&(B+=m.angle);const v=new le([]);return w.allowOverlap&&w.ignorePlacement||!p||(v.iconColliders=[]),this._addIconPlacement(v,P,M,w,B),T&&D&&this._addIconPlacement(v,P,M,w,B+_),v}_addIconPlacement(d,x,_,w,P){const T=_.rasterizationScale,D=_.width/T,B=_.height/T,v=w.offset;let V=v[0],k=v[1];switch(w.anchor){case m.CENTER:V-=D/2,k-=B/2;break;case m.LEFT:k-=B/2;break;case m.RIGHT:V-=D,k-=B/2;break;case m.TOP:V-=D/2;break;case m.BOTTOM:V-=D/2,k-=B;break;case m.TOP_LEFT:break;case m.BOTTOM_LEFT:k-=B;break;case m.TOP_RIGHT:V-=D;break;case m.BOTTOM_RIGHT:V-=D,k-=B}const S=_.rect,C=2/T,E=V-C,O=k-C,R=E+S.width/T,F=O+S.height/T,z=new c(E,O),N=new c(R,F),U=new c(E,F),G=new c(R,O);if(0!==P){const c=Math.cos(P),d=Math.sin(P);z.rotate(c,d),N.rotate(c,d),U.rotate(c,d),G.rotate(c,d)}const H=new ae(z,G,U,N,S,P,0,256,x,ne,M,0);if(d.shapes.push(H),(!w.allowOverlap||!w.ignorePlacement)&&p){const c=w.size,p=w.padding,_={xTile:x.x,yTile:x.y,dxPixels:V*c-p,dyPixels:k*c-p,hard:!w.optional,partIndex:0,width:D*c+2*p,height:B*c+2*p,angle:P,minLod:ne,maxLod:M};d.iconColliders.push(_)}}getTextPlacement(p,w,P,T){const D=new c(p.x,p.y),B=T.rotate*x,v=T.rotationAlignment===d.MAP,V=T.keepUpright,k=T.padding;let S=ne;const C=v?p.angle:0,E=p.segment>=0&&v,O=T.allowOverlap&&T.ignorePlacement?null:[],R=[],F=!E;let z=Number.POSITIVE_INFINITY,N=Number.NEGATIVE_INFINITY,U=z,G=N;const H=(E||v)&&V,K=T.size/ie;let W=!1;for(const c of w)if(c.vertical){W=!0;break}let j,q=0,Y=0;if(!E&&W){const c=re.getTextBox(w,T.lineHeight*ie);switch(T.anchor){case m.LEFT:q=c.height/2,Y=-c.width/2;break;case m.RIGHT:q=-c.height/2,Y=c.width/2;break;case m.TOP:q=c.height/2,Y=c.width/2;break;case m.BOTTOM:q=-c.height/2,Y=-c.width/2;break;case m.TOP_LEFT:q=c.height;break;case m.BOTTOM_LEFT:Y=-c.width;break;case m.TOP_RIGHT:Y=c.width;break;case m.BOTTOM_RIGHT:q=-c.height}}q+=T.offset[0]*ie,Y+=T.offset[1]*ie;for(const d of w){const x=d.glyphMosaicItem;if(!x||x.rect.isEmpty)continue;const m=x.rect,w=x.metrics,$=x.page;if(O&&F){if(void 0!==j&&j!==d.y){let c,d,x,_;W?(c=-G+q,d=z+Y,x=G-U,_=N-z):(c=z+q,d=U+Y,x=N-z,_=G-U);const m={xTile:p.x,yTile:p.y,dxPixels:c*K-k,dyPixels:d*K-k,hard:!T.optional,partIndex:1,width:x*K+2*k,height:_*K+2*k,angle:B,minLod:ne,maxLod:M};O.push(m),z=Number.POSITIVE_INFINITY,N=Number.NEGATIVE_INFINITY,U=z,G=N}j=d.y}const J=[];if(E){const c=.5*x.metrics.width,_=(d.x+w.left-4+c)*K*8;if(S=this._placeGlyph(p,S,_,P,p.segment,1,d.vertical,$,J),V&&(S=this._placeGlyph(p,S,_,P,p.segment,-1,d.vertical,$,J)),S>=2)break}else J.push(new f(D,C,C,$,!1)),v&&V&&J.push(new f(D,C+_,C+_,$,!1));const Z=d.x+w.left,X=d.y-17-w.top,Q=Z+w.width,ee=X+w.height;let te,se,ie,re,le,oe,he,ce;if(!E&&W)if(d.vertical){const d=(Z+Q)/2-w.height/2,x=(X+ee)/2+w.width/2;te=new c(-x-4+q,d-4+Y),se=new c(te.x+m.width,te.y+m.height),ie=new c(te.x,se.y),re=new c(se.x,te.y)}else te=new c(4-X+q,Z-4+Y),se=new c(te.x-m.height,te.y+m.width),ie=new c(se.x,te.y),re=new c(te.x,se.y);else te=new c(Z-4+q,X-4+Y),se=new c(te.x+m.width,te.y+m.height),ie=new c(te.x,se.y),re=new c(se.x,te.y);for(const _ of J){let x,M,P,D;if(_.alternateVerticalGlyph){if(!le){const d=(X+ee)/2+Y;le=new c((Z+Q)/2+q-w.height/2-4,d+w.width/2+4),oe=new c(le.x+m.height,le.y-m.width),he=new c(oe.x,le.y),ce=new c(le.x,oe.y)}x=le,M=he,P=ce,D=oe}else x=te,M=ie,P=re,D=se;const v=X,V=ee,S=_.glyphAngle+B;if(0!==S){const c=Math.cos(S),d=Math.sin(S);x=x.clone(),M=null==M?void 0:M.clone(),P=null==P?void 0:P.clone(),D=null==D?void 0:D.clone(),x.rotate(c,d),null==D||D.rotate(c,d),null==M||M.rotate(c,d),null==P||P.rotate(c,d)}let C=0,j=256;if(E&&W?d.vertical?_.alternateVerticalGlyph?(C=32,j=96):(C=224,j=32):(C=224,j=96):(C=192,j=64),R.push(new ae(x,P,M,D,m,_.labelAngle,C,j,_.anchor,_.minzoom,_.maxzoom,_.page)),O&&(!H||this._legible(_.labelAngle)))if(F)Z<z&&(z=Z),v<U&&(U=v),Q>N&&(N=Q),V>G&&(G=V);else if(_.minzoom<2){const c={xTile:p.x,yTile:p.y,dxPixels:(Z+q)*K-k,dyPixels:(v+q)*K-k,hard:!T.optional,partIndex:1,width:(Q-Z)*K+2*k,height:(V-v)*K+2*k,angle:S,minLod:_.minzoom,maxLod:_.maxzoom};O.push(c)}}}if(S>=2)return null;if(O&&F){let c,d,x,_;W?(c=-G+q,d=z+Y,x=G-U,_=N-z):(c=z+q,d=U+Y,x=N-z,_=G-U);const m={xTile:p.x,yTile:p.y,dxPixels:c*K-k,dyPixels:d*K-k,hard:!T.optional,partIndex:1,width:x*K+2*k,height:_*K+2*k,angle:B,minLod:ne,maxLod:M};O.push(m)}const $=new le(R);return O&&O.length>0&&($.textColliders=O),$}_legible(c){const d=w(c);return d<65||d>=193}_placeGlyph(d,x,p,m,w,D,B,v,V){let k=D;const S=k<0?P(d.angle+_,T):d.angle;let C=0;p<0&&(k*=-1,p*=-1,C=_),k>0&&++w;let E=new c(d.x,d.y),O=m[w],R=M;if(m.length<=w)return R;for(;;){const c=O.x-E.x,d=O.y-E.y,_=Math.sqrt(c*c+d*d),M=Math.max(p/_,x),D=c/_,F=d/_,z=P(Math.atan2(F,D)+C,T);if(V.push(new f(E,S,z,v,!1,M,R)),B&&V.push(new f(E,S,z,v,!0,M,R)),M<=x)return M;E=O.clone();do{if(w+=k,m.length<=w||w<0)return M;O=m[w]}while(E.isEqual(O));let N=O.x-E.x,U=O.y-E.y;const G=Math.sqrt(N*N+U*U);N*=_/G,U*=_/G,E.x-=N,E.y-=U,R=M}}};var he,ce;(ce=he||(he={}))[ce.moveTo=1]="moveTo",ce[ce.lineTo=2]="lineTo",ce[ce.close=7]="close";let ue=class s{constructor(c,d,x=0){this.values={},this._geometry=void 0,this._pbfGeometry=null,this.featureIndex=x;const p=d.keys,_=d.values,m=c.asUnsafe();for(;m.next();)switch(m.tag()){case 1:this.id=m.getUInt64();break;case 2:{const c=m.getMessage().asUnsafe(),d=this.values;for(;!c.empty();){const x=c.getUInt32(),m=c.getUInt32();d[p[x]]=_[m]}c.release();break}case 3:this.type=m.getUInt32();break;case 4:this._pbfGeometry=m.getMessage();break;default:m.skip()}}getGeometry(d){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const x=this._pbfGeometry.asUnsafe();let p,_;this._pbfGeometry=null,d?d.reset(this.type):p=[];let m,M=he.moveTo,w=0,P=0,T=0;for(;!x.empty();){if(0===w){const c=x.getUInt32();M=7&c,w=c>>3}switch(w--,M){case he.moveTo:P+=x.getSInt32(),T+=x.getSInt32(),d?d.moveTo(P,T):p&&(_&&p.push(_),_=[],_.push(new c(P,T)));break;case he.lineTo:P+=x.getSInt32(),T+=x.getSInt32(),d?d.lineTo(P,T):_&&_.push(new c(P,T));break;case he.close:d?d.close():_&&!_[0].equals(P,T)&&_.push(_[0].clone());break;default:throw x.release(),new Error("Invalid path operation")}}return d?m=d.result():p&&(_&&p.push(_),m=p),x.release(),this._geometry=m,m}},fe=class r extends D{constructor(){super(12)}add(c,d,x){const p=this.array;p.push(c),p.push(d),p.push(x)}};class e{constructor(c){this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=c.clone();const d=c.asUnsafe();for(;d.next();)switch(d.tag()){case 1:this.name=d.getString();break;case 3:this.keys.push(d.getString());break;case 4:this.values.push(d.processMessage(e._parseValue));break;case 5:this.extent=d.getUInt32();break;default:d.skip()}}getData(){return this._pbfLayer}static _parseValue(c){for(;c.next();)switch(c.tag()){case 1:return c.getString();case 2:return c.getFloat();case 3:return c.getDouble();case 4:return c.getInt64();case 5:return c.getUInt64();case 6:return c.getSInt64();case 7:return c.getBool();default:c.skip()}return null}}let de=class o extends D{constructor(c){super(c)}add(c,d,x,p,_,m,M,w,P,T,B,v){const V=this.array;let k=D.i1616to32(c,d);V.push(k);const S=31;k=D.i8888to32(Math.round(S*x),Math.round(S*p),Math.round(S*_),Math.round(S*m)),V.push(k),k=D.i8888to32(Math.round(S*M),Math.round(S*w),Math.round(S*P),Math.round(S*T)),V.push(k),k=D.i1616to32(B,0),V.push(k),v&&V.push(...v)}},xe=class r2 extends D{constructor(c){super(c)}add(c,d,x){const p=this.array;p.push(D.i1616to32(c,d)),x&&p.push(...x)}};class u2 extends D{constructor(c){super(c)}add(c,d,x,p,_,m,M){const w=this.array,P=this.index;let T=D.i1616to32(c,d);w.push(T);return T=D.i8888to32(Math.round(15*x),Math.round(15*p),_,m),w.push(T),M&&w.push(...M),P}}class h extends D{constructor(c){super(c)}add(c,d,x,p,_,m,M,P,T,B,v,V){const k=this.array;let S=D.i1616to32(c,d);k.push(S),S=D.i1616to32(Math.round(8*x),Math.round(8*p)),k.push(S),S=D.i8888to32(_/4,m/4,P,T),k.push(S),S=D.i8888to32(0,w(M),10*B,Math.min(10*v,255)),k.push(S),V&&k.push(...V)}}class a extends D{constructor(c){super(c)}add(c,d,x,p,_){const m=this.array,M=D.i1616to32(2*c+x,2*d+p);m.push(M),_&&m.push(..._)}}class t{constructor(c,d,x){this.layerExtent=4096,this._features=[],this.layer=c,this.zoom=d,this._spriteInfo=x,this._filter=c.getFeatureFilter()}pushFeature(c){this._filter&&!this._filter.filter(c,this.zoom)||this._features.push(c)}hasFeatures(){return this._features.length>0}getResources(c,d,x){}}let ye=class r3 extends t{constructor(c,d,x,p,_){super(c,d,x),this.type=B.CIRCLE,this._circleVertexBuffer=p,this._circleIndexBuffer=_}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(c){const d=this._circleVertexBuffer,x=this._circleIndexBuffer;this._circleIndexStart=3*x.index,this._circleIndexCount=0;const p=this.layer,_=this.zoom;c&&c.setExtent(this.layerExtent);for(const m of this._features){const M=m.getGeometry(c);if(!M)continue;const w=p.circleMaterial.encodeAttributes(m,_,p);for(const c of M)if(c)for(const p of c){const c=d.index;d.add(p.x,p.y,0,0,w),d.add(p.x,p.y,0,1,w),d.add(p.x,p.y,1,0,w),d.add(p.x,p.y,1,1,w),x.add(c,c+1,c+2),x.add(c+1,c+2,c+3),this._circleIndexCount+=6}}}serialize(){let c=6;c+=this.layerUIDs.length,c+=this._circleVertexBuffer.array.length,c+=this._circleIndexBuffer.array.length;const d=new Uint32Array(c),x=new Int32Array(d.buffer);let p=0;d[p++]=this.type,d[p++]=this.layerUIDs.length;for(let _=0;_<this.layerUIDs.length;_++)d[p++]=this.layerUIDs[_];d[p++]=this._circleIndexStart,d[p++]=this._circleIndexCount,d[p++]=this._circleVertexBuffer.array.length;for(let _=0;_<this._circleVertexBuffer.array.length;_++)x[p++]=this._circleVertexBuffer.array[_];d[p++]=this._circleIndexBuffer.array.length;for(let _=0;_<this._circleIndexBuffer.array.length;_++)d[p++]=this._circleIndexBuffer.array[_];return d.buffer}},ge=class s2 extends t{constructor(c,d,x,p,_,m,M){super(c,d,x),this.type=B.FILL,this._patternMap=new Map,this._fillVertexBuffer=p,this._fillIndexBuffer=_,this._outlineVertexBuffer=m,this._outlineIndexBuffer=M}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(c,d,x){const p=this.layer,_=this.zoom,m=p.getPaintProperty("fill-pattern");if(m)if(m.isDataDriven)for(const M of this._features)d(m.getValue(_,M),!0);else d(m.getValue(_),!0)}processFeatures(c){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const d=this.layer,x=this.zoom,{fillMaterial:p,outlineMaterial:_,hasDataDrivenFill:m,hasDataDrivenOutline:M}=d;c&&c.setExtent(this.layerExtent);const w=d.getPaintProperty("fill-pattern"),P=null==w?void 0:w.isDataDriven;let T=!w&&d.getPaintValue("fill-antialias",x);if(d.outlineUsesFillColor){if(T&&!d.hasDataDrivenOpacity){const c=d.getPaintValue("fill-opacity",x),p=d.getPaintValue("fill-opacity",x+1);c<1&&p<1&&(T=!1)}if(T&&!d.hasDataDrivenColor){const c=d.getPaintValue("fill-color",x),p=d.getPaintValue("fill-color",x+1);c[3]<1&&p[3]<1&&(T=!1)}}const D=this._features,B=null==c?void 0:c.validateTessellation;if(P){const m=[];for(const P of D){const D=w.getValue(x,P),v=this._spriteInfo[D];if(!(null==v?void 0:v.rect))continue;const V=p.encodeAttributes(P,x,d,v),k=T&&M?_.encodeAttributes(P,x,d):[],S=P.getGeometry(c);m.push({ddFillAttributes:V,ddOutlineAttributes:k,page:v.page,geometry:S}),m.sort(((c,d)=>c.page-d.page));for(const{ddFillAttributes:c,ddOutlineAttributes:x,page:p,geometry:_}of m)this._processFeature(_,T,d.outlineUsesFillColor,c,x,B,p)}}else for(const v of D){const w=m?p.encodeAttributes(v,x,d):null,P=T&&M?_.encodeAttributes(v,x,d):null,D=v.getGeometry(c);this._processFeature(D,T,d.outlineUsesFillColor,w,P,B)}}serialize(){let c=10;c+=this.layerUIDs.length,c+=this._fillVertexBuffer.array.length,c+=this._fillIndexBuffer.array.length,c+=this._outlineVertexBuffer.array.length,c+=this._outlineIndexBuffer.array.length,c+=3*this._patternMap.size+1;const d=new Uint32Array(c),x=new Int32Array(d.buffer);let p=0;d[p++]=this.type,d[p++]=this.layerUIDs.length;for(let M=0;M<this.layerUIDs.length;M++)d[p++]=this.layerUIDs[M];d[p++]=this._fillIndexStart,d[p++]=this._fillIndexCount,d[p++]=this._outlineIndexStart,d[p++]=this._outlineIndexCount;const _=this._patternMap,m=_.size;if(d[p++]=m,m>0)for(const[M,[w,P]]of _)d[p++]=M,d[p++]=w,d[p++]=P;d[p++]=this._fillVertexBuffer.array.length;for(let M=0;M<this._fillVertexBuffer.array.length;M++)x[p++]=this._fillVertexBuffer.array[M];d[p++]=this._fillIndexBuffer.array.length;for(let M=0;M<this._fillIndexBuffer.array.length;M++)d[p++]=this._fillIndexBuffer.array[M];d[p++]=this._outlineVertexBuffer.array.length;for(let M=0;M<this._outlineVertexBuffer.array.length;M++)x[p++]=this._outlineVertexBuffer.array[M];d[p++]=this._outlineIndexBuffer.array.length;for(let M=0;M<this._outlineIndexBuffer.array.length;M++)d[p++]=this._outlineIndexBuffer.array[M];return d.buffer}_processFeature(c,d,x,p,_,m,M){if(!c)return;const w=c.length,P=!_||0===_.length;if(d&&(!x||P))for(let D=0;D<w;D++)this._processOutline(c[D],_);let T;for(let D=0;D<w;D++){const d=s2._area(c[D]);d>32?(void 0!==T&&this._processFill(c,T,p,m,M),T=[D]):d<-32&&void 0!==T&&T.push(D)}void 0!==T&&this._processFill(c,T,p,m,M)}_processOutline(d,x){const p=this._outlineVertexBuffer,_=this._outlineIndexBuffer,m=_.index;let M,w,P;const T=new c(0,0),D=new c(0,0),B=new c(0,0);let v=-1,V=-1,k=-1,S=-1,C=-1,E=!1;let O=d.length;if(O<2)return;const R=d[0];let F=d[O-1];for(;O&&F.isEqual(R);)--O,F=d[O-1];if(!(O-0<2)){for(let c=0;c<O;++c){0===c?(M=d[O-1],w=d[0],P=d[1],T.assignSub(w,M),T.normalize(),T.rightPerpendicular()):(M=w,w=P,P=c!==O-1?d[c+1]:d[0],T.assign(D));const m=this._isClipEdge(M,w);-1===S&&(E=m),D.assignSub(P,w),D.normalize(),D.rightPerpendicular();const R=T.x*D.y-T.y*D.x;B.assignAdd(T,D),B.normalize();const F=-B.x*-T.x+-B.y*-T.y;let z=Math.abs(0!==F?1/F:1);z>8&&(z=8),R>=0?(k=p.add(w.x,w.y,T.x,T.y,0,1,x),-1===S&&(S=k),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k),V=p.add(w.x,w.y,z*-B.x,z*-B.y,0,-1,x),-1===C&&(C=V),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k),v=V,V=k,k=p.add(w.x,w.y,B.x,B.y,0,1,x),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k),V=p.add(w.x,w.y,D.x,D.y,0,1,x),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k)):(k=p.add(w.x,w.y,z*B.x,z*B.y,0,1,x),-1===S&&(S=k),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k),V=p.add(w.x,w.y,-T.x,-T.y,0,-1,x),-1===C&&(C=V),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k),v=V,V=k,k=p.add(w.x,w.y,-B.x,-B.y,0,-1,x),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k),v=p.add(w.x,w.y,-D.x,-D.y,0,-1,x),v>=0&&V>=0&&k>=0&&!m&&_.add(v,V,k))}v>=0&&V>=0&&S>=0&&!E&&_.add(v,V,S),v>=0&&S>=0&&C>=0&&!E&&_.add(v,C,S),this._outlineIndexCount+=3*(_.index-m)}}_processFill(c,d,x,p,_){let m;d.length>1&&(m=[]);let M=0;for(const D of d)0!==M&&m.push(M),M+=c[D].length;const w=2*M,P=v.acquire();for(const D of d){const d=c[D],x=d.length;for(let c=0;c<x;++c)P.push(d[c].x,d[c].y)}const T=V(P,m,2);if(V.deviation(P,m,2,T)>0){const p=d.map((d=>c[d].length)),{buffer:m,vertexCount:M}=ee(P,p);if(M>0){const c=this._fillVertexBuffer.index;for(let d=0;d<M;d++)this._fillVertexBuffer.add(m[2*d],m[2*d+1],x);for(let d=0;d<M;d+=3){const x=c+d;this._fillIndexBuffer.add(x,x+1,x+2)}if(void 0!==_){const c=this._patternMap,d=c.get(_);d?d[1]+=M:c.set(_,[this._fillIndexStart+this._fillIndexCount,M])}this._fillIndexCount+=M}}else{const c=T.length;if(c>0){const d=this._fillVertexBuffer.index;let p=0;for(;p<w;)this._fillVertexBuffer.add(P[p++],P[p++],x);let m=0;for(;m<c;)this._fillIndexBuffer.add(d+T[m++],d+T[m++],d+T[m++]);if(void 0!==_){const d=this._patternMap,x=d.get(_);x?x[1]+=c:d.set(_,[this._fillIndexStart+this._fillIndexCount,c])}this._fillIndexCount+=c}}v.release(P)}_isClipEdge(c,d){return c.x===d.x?c.x<=-64||c.x>=4160:c.y===d.y&&(c.y<=-64||c.y>=4160)}static _area(c){let d=0;const x=c.length-1;for(let p=0;p<x;p++)d+=(c[p].x-c[p+1].x)*(c[p].y+c[p+1].y);return d+=(c[x].x-c[0].x)*(c[x].y+c[0].y),.5*d}};class n extends t{constructor(c,d,x,p,_){super(c,d,x),this.type=B.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=p,this.tessellationProperties._lineIndexBuffer=_,this._lineTessellator=new te(r4(this.tessellationProperties),l2(this.tessellationProperties),c.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(c,d,x){const p=this.layer,_=this.zoom,m=p.getPaintProperty("line-pattern"),M=p.getPaintProperty("line-dasharray"),w=p.getLayoutProperty("line-cap");if(!m&&!M)return;const P=(null==w?void 0:w.getValue(_))||0,T=null==w?void 0:w.isDataDriven,D=null==m?void 0:m.isDataDriven,B=null==M?void 0:M.isDataDriven;if(D||B)for(const v of this._features)d(D?m.getValue(_,v):this._getDashArrayKey(v,_,p,M,T,w,P));else if(m)d(m.getValue(_));else if(M){const c=M.getValue(_);d(p.getDashKey(c,P))}}processFeatures(c){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const d=this.layer,x=this.zoom,p=this._features,_=this._tessellationOptions,{hasDataDrivenLine:m,lineMaterial:M}=d;c&&c.setExtent(this.layerExtent);const w=d.getPaintProperty("line-pattern"),P=d.getPaintProperty("line-dasharray"),T=null==w?void 0:w.isDataDriven,D=null==P?void 0:P.isDataDriven;let B;B=d.getLayoutProperty("line-cap");const v=(null==B?void 0:B.isDataDriven)?B:null,V=v?null:d.getLayoutValue("line-cap",x),k=V||0,S=!!v;B=d.getLayoutProperty("line-join");const C=(null==B?void 0:B.isDataDriven)?B:null,E=C?null:d.getLayoutValue("line-join",x);B=d.getLayoutProperty("line-miter-limit");const O=(null==B?void 0:B.isDataDriven)?B:null,R=O?null:d.getLayoutValue("line-miter-limit",x);B=d.getLayoutProperty("line-round-limit");const F=(null==B?void 0:B.isDataDriven)?B:null,z=F?null:d.getLayoutValue("line-round-limit",x);B=d.getPaintProperty("line-width");const N=(null==B?void 0:B.isDataDriven)?B:null,U=N?null:d.getPaintValue("line-width",x);B=d.getPaintProperty("line-offset");const G=(null==B?void 0:B.isDataDriven)?B:null,H=G?null:d.getPaintValue("line-offset",x);if(T||D){const m=[];for(const _ of p){const p=T?w.getValue(x,_):this._getDashArrayKey(_,x,d,P,S,v,k),D=this._spriteInfo[p];if(!(null==D?void 0:D.rect))continue;const B=M.encodeAttributes(_,x,d,D),K=_.getGeometry(c);m.push({ddAttributes:B,page:D.page,cap:v?v.getValue(x,_):V,join:C?C.getValue(x,_):E,miterLimit:O?O.getValue(x,_):R,roundLimit:F?F.getValue(x,_):z,halfWidth:.5*(N?N.getValue(x,_):U),offset:G?G.getValue(x,_):H,geometry:K})}m.sort(((c,d)=>c.page-d.page)),_.textured=!0;for(const{ddAttributes:c,page:d,cap:x,join:p,miterLimit:M,roundLimit:w,halfWidth:P,offset:T,geometry:D}of m)_.capType=x,_.joinType=p,_.miterLimit=M,_.roundLimit=w,_.halfWidth=P,_.offset=T,this._processFeature(D,c,d)}else{if(w){const c=w.getValue(x),d=this._spriteInfo[c];if(!(null==d?void 0:d.rect))return}_.textured=!(!w&&!P),_.capType=V,_.joinType=E,_.miterLimit=R,_.roundLimit=z,_.halfWidth=.5*U,_.offset=H;for(const w of p){const p=m?M.encodeAttributes(w,x,d):null;v&&(_.capType=v.getValue(x,w)),C&&(_.joinType=C.getValue(x,w)),O&&(_.miterLimit=O.getValue(x,w)),F&&(_.roundLimit=F.getValue(x,w)),N&&(_.halfWidth=.5*N.getValue(x,w)),G&&(_.offset=G.getValue(x,w));const P=w.getGeometry(c);this._processFeature(P,p)}}}serialize(){let c=6;c+=this.layerUIDs.length,c+=this.tessellationProperties._lineVertexBuffer.array.length,c+=this.tessellationProperties._lineIndexBuffer.array.length,c+=3*this._patternMap.size+1;const d=new Uint32Array(c),x=new Int32Array(d.buffer);let p=0;d[p++]=this.type,d[p++]=this.layerUIDs.length;for(let M=0;M<this.layerUIDs.length;M++)d[p++]=this.layerUIDs[M];d[p++]=this._lineIndexStart,d[p++]=this._lineIndexCount;const _=this._patternMap,m=_.size;if(d[p++]=m,m>0)for(const[M,[w,P]]of _)d[p++]=M,d[p++]=w,d[p++]=P;d[p++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let M=0;M<this.tessellationProperties._lineVertexBuffer.array.length;M++)x[p++]=this.tessellationProperties._lineVertexBuffer.array[M];d[p++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let M=0;M<this.tessellationProperties._lineIndexBuffer.array.length;M++)d[p++]=this.tessellationProperties._lineIndexBuffer.array[M];return d.buffer}_processFeature(c,d,x){if(!c)return;const p=c.length;for(let _=0;_<p;_++)this._processGeometry(c[_],d,x)}_processGeometry(c,d,x){if(c.length<2)return;let p,_,m=c[0],M=1;for(;M<c.length;)p=c[M].x-m.x,_=c[M].y-m.y,p*p+_*_<1e-6?c.splice(M,1):(m=c[M],++M);if(c.length<2)return;const w=this.tessellationProperties._lineIndexBuffer,P=3*w.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=d,this._lineTessellator.tessellate(c,this._tessellationOptions);const T=3*w.index-P;if(void 0!==x){const c=this._patternMap,d=c.get(x);d?d[1]+=T:c.set(x,[P+this._lineIndexCount,T])}this._lineIndexCount+=T}_getDashArrayKey(c,d,x,p,_,m,M){const w=_?m.getValue(d,c):M,P=p.getValue(d,c);return x.getDashKey(P,w)}}const r4=c=>(d,x,p,_,m,M,w,P,T,D,B)=>(c._lineVertexBuffer.add(d,x,w,P,p,_,m,M,T,D,B,c._ddValues),c._lineVertexBuffer.index-1),l2=c=>(d,x,p)=>{c._lineIndexBuffer.add(d,x,p)};function A(c,d){return c.iconMosaicItem&&d.iconMosaicItem?c.iconMosaicItem.page===d.iconMosaicItem.page?0:c.iconMosaicItem.page-d.iconMosaicItem.page:c.iconMosaicItem&&!d.iconMosaicItem?1:!c.iconMosaicItem&&d.iconMosaicItem?-1:0}class L extends t{constructor(c,d,x,p,_,m,M,w,P){super(d,x,P.getSpriteItems()),this.type=B.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._sourceTileKey=c,this._iconVertexBuffer=p,this._iconIndexBuffer=_,this._textVertexBuffer=m,this._textIndexBuffer=M,this._placementEngine=w,this._workerTileHandler=P}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(c,d,x){const p=this.layer,_=this.zoom;c&&c.setExtent(this.layerExtent);const m=p.getLayoutProperty("icon-image"),M=p.getLayoutProperty("text-field");let w=p.getLayoutProperty("text-transform"),P=p.getLayoutProperty("text-font");const T=[];let D,B,v,V;m&&!m.isDataDriven&&(D=m.getValue(_)),M&&!M.isDataDriven&&(B=M.getValue(_)),w&&w.isDataDriven||(v=p.getLayoutValue("text-transform",_),w=null),P&&P.isDataDriven||(V=p.getLayoutValue("text-font",_),P=null);for(const C of this._features){const E=C.getGeometry(c);if(!E||0===E.length)continue;let O,R;m&&(O=m.isDataDriven?m.getValue(_,C):this._replaceKeys(D,C.values),O&&d(O));let F=!1;if(M&&(R=M.isDataDriven?M.getValue(_,C):this._replaceKeys(B,C.values),R)){switch(R=R.replaceAll("\\n","\n"),w&&(v=w.getValue(_,C)),v){case k.LOWERCASE:R=R.toLowerCase();break;case k.UPPERCASE:R=R.toUpperCase()}if(L._bidiEngine.hasBidiChar(R)){let c;c="rtl"===L._bidiEngine.checkContextual(R)?"IDNNN":"ICNNN",R=L._bidiEngine.bidiTransform(R,c,"VLYSN"),F=!0}if(R.length>0){P&&(V=P.getValue(_,C));for(const c of V){let d=x[c];d||(d=x[c]=new Set);for(const c of R){const x=c.codePointAt(0);null!=x&&d.add(x)}}}}if(!O&&!R)continue;const z=p.getLayoutValue("symbol-sort-key",_,C),N={feature:C,sprite:O,label:R,rtl:F,geometry:E,hash:(R?S(R):0)^(O?S(O):0),priority:z,textFont:V};T.push(N)}this._symbolFeatures=T}processFeatures(c){c&&c.setExtent(this.layerExtent);const p=this.layer,_=this.zoom,M=p.getLayoutValue("symbol-placement",_),w=M!==C.POINT,P=8*p.getLayoutValue("symbol-spacing",_),T=p.getLayoutProperty("icon-image"),D=p.getLayoutProperty("text-field"),B=T?new E(p,_,w):null,v=D?new O(p,_,w):null,V=this._workerTileHandler;let k;T&&(k=V.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const S=[];let U=1;(null==v?void 0:v.size)&&(U=v.size/ie);const G=v?v.maxAngle*x:0,H=v?8*v.size:0;for(const x of this._symbolFeatures){let c,p;B&&k&&x.sprite&&(c=k[x.sprite],c&&c.sdf&&(this._isIconSDF=!0)),c&&B.update(_,x.feature);let T=0;const D=x.label;if(D){R(v),v.update(_,x.feature);const c=w&&v.rotationAlignment===d.MAP?v.keepUpright:v.writingMode&&v.writingMode.includes(F.VERTICAL);let M=.5;switch(v.anchor){case m.TOP_LEFT:case m.LEFT:case m.BOTTOM_LEFT:M=0;break;case m.TOP_RIGHT:case m.RIGHT:case m.BOTTOM_RIGHT:M=1}let P=.5;switch(v.anchor){case m.TOP_LEFT:case m.TOP:case m.TOP_RIGHT:P=0;break;case m.BOTTOM_LEFT:case m.BOTTOM:case m.BOTTOM_RIGHT:P=1}let B=.5;switch(v.justify){case z.AUTO:B=M;break;case z.LEFT:B=0;break;case z.RIGHT:B=1}const k=v.letterSpacing*ie,S=w?0:v.maxWidth*ie,C=v.lineHeight*ie,E=x.textFont.map((c=>V.getGlyphItems(c)));if(p=new re(E,S,C,k,M,P,B).getShaping(D,x.rtl,c),p&&p.length>0){let c=1e30,d=-1e30;for(const x of p)c=Math.min(c,x.x),d=Math.max(d,x.x);T=(d-c+48)*U*8}}for(let _ of x.geometry){const m=[];if(M===C.LINE){if((null==p?void 0:p.length)&&(null==v?void 0:v.size)){const c=8*v.size*(2+Math.min(2,4*Math.abs(v.offset[1])));_=L._smoothVertices(_,c)}L._pushAnchors(m,_,P,T)}else M===C.LINE_CENTER?L._pushCenterAnchor(m,_):x.feature.type===N.Polygon?L._pushCentroid(m,_):m.push(new y(_[0].x,_[0].y));for(const M of m){if(M.x<0||M.x>4096||M.y<0||M.y>4096)continue;if(w&&T>0&&(null==v?void 0:v.rotationAlignment)===d.MAP&&!L._honorsTextMaxAngle(_,M,T,G,H))continue;const m={shaping:p,line:_,iconMosaicItem:c,anchor:M,symbolFeature:x,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};S.push(m),this._processFeature(m,B,v)}}}S.sort(A),this._addPlacedGlyphs(),this._symbolInstances=S}serialize(){let c=14;c+=this.layerUIDs.length,c+=3*this.markerPageMap.size,c+=3*this.glyphsPageMap.size,c+=L._symbolsSerializationLength(this._symbolInstances),c+=this._iconVertexBuffer.array.length,c+=this._iconIndexBuffer.array.length,c+=this._textVertexBuffer.array.length,c+=this._textIndexBuffer.array.length;const d=new Uint32Array(c),x=new Int32Array(d.buffer),p=new Float32Array(d.buffer),[_,m,M]=this._sourceTileKey.split("/");let w=0;d[w++]=this.type,d[w++]=this.layerUIDs.length;for(let P=0;P<this.layerUIDs.length;P++)d[w++]=this.layerUIDs[P];d[w++]=this._isIconSDF?1:0,d[w++]=parseFloat(_),d[w++]=parseFloat(m),d[w++]=parseFloat(M),d[w++]=this.markerPageMap.size;for(const[P,[T,D]]of this.markerPageMap)d[w++]=P,d[w++]=T,d[w++]=D;d[w++]=this.glyphsPageMap.size;for(const[P,[T,D]]of this.glyphsPageMap)d[w++]=P,d[w++]=T,d[w++]=D;d[w++]=this._iconVertexBuffer.index/4,d[w++]=this._textVertexBuffer.index/4,w=L.serializeSymbols(d,x,p,w,this._symbolInstances),d[w++]=this._iconVertexBuffer.array.length;for(let P=0;P<this._iconVertexBuffer.array.length;P++)x[w++]=this._iconVertexBuffer.array[P];d[w++]=this._iconIndexBuffer.array.length;for(let P=0;P<this._iconIndexBuffer.array.length;P++)d[w++]=this._iconIndexBuffer.array[P];d[w++]=this._textVertexBuffer.array.length;for(let P=0;P<this._textVertexBuffer.array.length;P++)x[w++]=this._textVertexBuffer.array[P];d[w++]=this._textIndexBuffer.array.length;for(let P=0;P<this._textIndexBuffer.array.length;P++)d[w++]=this._textIndexBuffer.array[P];return d.buffer}static _symbolsSerializationLength(c){let d=0;d+=1;for(const x of c||[]){d+=5,d+=1;for(const c of x.textColliders)d+=10;for(const c of x.iconColliders)d+=10;d+=1,d+=2*x.textVertexRanges.length,d+=1,d+=2*x.iconVertexRanges.length}return d}static serializeSymbols(c,d,x,p,_){_=_||[],d[p++]=_.length;for(const m of _){d[p++]=m.anchor.x,d[p++]=m.anchor.y,d[p++]=m.symbolFeature.hash,d[p++]=m.symbolFeature.priority,d[p++]=m.symbolFeature.feature.featureIndex,d[p++]=m.textColliders.length+m.iconColliders.length;for(const c of m.textColliders)d[p++]=c.xTile,d[p++]=c.yTile,d[p++]=c.dxPixels,d[p++]=c.dyPixels,d[p++]=c.hard?1:0,d[p++]=c.partIndex,x[p++]=c.minLod,x[p++]=c.maxLod,d[p++]=c.width,d[p++]=c.height;for(const c of m.iconColliders)d[p++]=c.xTile,d[p++]=c.yTile,d[p++]=c.dxPixels,d[p++]=c.dyPixels,d[p++]=c.hard?1:0,d[p++]=c.partIndex,x[p++]=c.minLod,x[p++]=c.maxLod,d[p++]=c.width,d[p++]=c.height;d[p++]=m.textVertexRanges.length;for(const[c,x]of m.textVertexRanges)d[p++]=c,d[p++]=x;d[p++]=m.iconVertexRanges.length;for(const[c,x]of m.iconVertexRanges)d[p++]=c,d[p++]=x}return p}_replaceKeys(c,d){return c.replaceAll(/{([^{}]+)}/g,((c,x)=>x in d?d[x]:""))}_processFeature(c,x,p){const{line:_,iconMosaicItem:m,shaping:M,anchor:w}=c,P=this.zoom,T=this.layer,D=!!m;let B=!0;D&&(B=(null==x?void 0:x.optional)||!m);const v=M&&M.length>0,V=!v||(null==p?void 0:p.optional);let k,S;if(D&&(k=this._placementEngine.getIconPlacement(w,m,x)),(k||B)&&(v&&(S=this._placementEngine.getTextPlacement(w,M,_,p)),S||V)){if(k&&S||(V||B?V||S?B||k||(S=null):k=null:(k=null,S=null)),S){const d=T.hasDataDrivenText?T.textMaterial.encodeAttributes(c.symbolFeature.feature,P,T):null;if(this._storePlacedGlyphs(c,S.shapes,P,p.rotationAlignment,d),S.textColliders){c.textColliders=S.textColliders;for(const c of S.textColliders){c.minLod=Math.max(P+U(c.minLod),0),c.maxLod=Math.min(P+U(c.maxLod),25);const d=c.angle;if(d){const x=Math.cos(d),p=Math.sin(d),_=c.dxPixels*x-c.dyPixels*p,m=c.dxPixels*p+c.dyPixels*x,M=(c.dxPixels+c.width)*x-c.dyPixels*p,w=(c.dxPixels+c.width)*p+c.dyPixels*x,P=c.dxPixels*x-(c.dyPixels+c.height)*p,T=c.dxPixels*p+(c.dyPixels+c.height)*x,D=(c.dxPixels+c.width)*x-(c.dyPixels+c.height)*p,B=(c.dxPixels+c.width)*p+(c.dyPixels+c.height)*x,v=Math.min(_,M,P,D),V=Math.max(_,M,P,D),k=Math.min(m,w,T,B),S=Math.max(m,w,T,B);c.dxPixels=v,c.dyPixels=k,c.width=V-v,c.height=S-k}}}}if(k){const p=T.hasDataDrivenIcon?T.iconMaterial.encodeAttributes(c.symbolFeature.feature,P,T):null;if(this._addPlacedIcons(c,k.shapes,P,m.page,x.rotationAlignment===d.VIEWPORT,p),k.iconColliders){c.iconColliders=k.iconColliders;for(const c of k.iconColliders){c.minLod=Math.max(P+U(c.minLod),0),c.maxLod=Math.min(P+U(c.maxLod),25);const d=c.angle;if(d){const x=Math.cos(d),p=Math.sin(d),_=c.dxPixels*x-c.dyPixels*p,m=c.dxPixels*p+c.dyPixels*x,M=(c.dxPixels+c.width)*x-c.dyPixels*p,w=(c.dxPixels+c.width)*p+c.dyPixels*x,P=c.dxPixels*x-(c.dyPixels+c.height)*p,T=c.dxPixels*p+(c.dyPixels+c.height)*x,D=(c.dxPixels+c.width)*x-(c.dyPixels+c.height)*p,B=(c.dxPixels+c.width)*p+(c.dyPixels+c.height)*x,v=Math.min(_,M,P,D),V=Math.max(_,M,P,D),k=Math.min(m,w,T,B),S=Math.max(m,w,T,B);c.dxPixels=v,c.dyPixels=k,c.width=V-v,c.height=S-k}}}}}}_addPlacedIcons(c,d,x,p,_,m){const M=Math.max(x-1,0),w=this._iconVertexBuffer,P=this._iconIndexBuffer,T=this._markerMap;for(const D of d){const d=_?0:Math.max(x+U(D.minzoom),M),B=_?25:Math.min(x+U(D.maxzoom),25);if(B<=d)continue;const v=D.tl,V=D.tr,k=D.bl,S=D.br,C=D.mosaicRect,E=D.labelAngle,O=D.minAngle,R=D.maxAngle,F=D.anchor,z=w.index,N=C.x,G=C.y,H=N+C.width,K=G+C.height,W=w.index;w.add(F.x,F.y,v.x,v.y,N,G,E,O,R,d,B,m),w.add(F.x,F.y,V.x,V.y,H,G,E,O,R,d,B,m),w.add(F.x,F.y,k.x,k.y,N,K,E,O,R,d,B,m),w.add(F.x,F.y,S.x,S.y,H,K,E,O,R,d,B,m),c.iconVertexRanges.length>0&&c.iconVertexRanges[0][0]+c.iconVertexRanges[0][1]===W?c.iconVertexRanges[0][1]+=4:c.iconVertexRanges.push([W,4]),P.add(z,z+1,z+2),P.add(z+1,z+2,z+3),T.has(p)?T.get(p)[1]+=6:T.set(p,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const c=this._textVertexBuffer,d=this._textIndexBuffer,x=this._glyphMap;for(const[p,_]of this._glyphBufferDataStorage)for(const m of _){const _=c.index,M=m.symbolInstance,w=m.ddAttributes,P=c.index;c.add(m.glyphAnchor[0],m.glyphAnchor[1],m.tl[0],m.tl[1],m.xmin,m.ymin,m.labelAngle,m.minAngle,m.maxAngle,m.minLod,m.maxLod,w),c.add(m.glyphAnchor[0],m.glyphAnchor[1],m.tr[0],m.tr[1],m.xmax,m.ymin,m.labelAngle,m.minAngle,m.maxAngle,m.minLod,m.maxLod,w),c.add(m.glyphAnchor[0],m.glyphAnchor[1],m.bl[0],m.bl[1],m.xmin,m.ymax,m.labelAngle,m.minAngle,m.maxAngle,m.minLod,m.maxLod,w),c.add(m.glyphAnchor[0],m.glyphAnchor[1],m.br[0],m.br[1],m.xmax,m.ymax,m.labelAngle,m.minAngle,m.maxAngle,m.minLod,m.maxLod,w),M.textVertexRanges.length>0&&M.textVertexRanges[0][0]+M.textVertexRanges[0][1]===P?M.textVertexRanges[0][1]+=4:M.textVertexRanges.push([P,4]),d.add(_,_+1,_+2),d.add(_+1,_+2,_+3),x.has(p)?x.get(p)[1]+=6:x.set(p,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(c,x,p,_,m){const M=Math.max(p-1,0),w=_===d.VIEWPORT;let P,T,D,B,v,V,k,S,C,E,O;for(const d of x)P=w?0:Math.max(p+U(d.minzoom),M),T=w?25:Math.min(p+U(d.maxzoom),25),T<=P||(D=d.tl,B=d.tr,v=d.bl,V=d.br,k=d.labelAngle,S=d.minAngle,C=d.maxAngle,E=d.anchor,O=d.mosaicRect,this._glyphBufferDataStorage.has(d.page)||this._glyphBufferDataStorage.set(d.page,[]),this._glyphBufferDataStorage.get(d.page).push({glyphAnchor:[E.x,E.y],tl:[D.x,D.y],tr:[B.x,B.y],bl:[v.x,v.y],br:[V.x,V.y],xmin:O.x,ymin:O.y,xmax:O.x+O.width,ymax:O.y+O.height,labelAngle:k,minAngle:S,maxAngle:C,minLod:P,maxLod:T,placementLod:M,symbolInstance:c,ddAttributes:m}))}static _pushAnchors(d,x,p,_){p+=_;let m=0;const M=x.length-1;for(let v=0;v<M;v++)m+=c.distance(x[v],x[v+1]);let w=_||p;if(w*=.5,m<=w)return;const P=w/m;let T=0,D=-(p=m/Math.max(Math.round(m/p),1))/2;const B=x.length-1;for(let c=0;c<B;c++){const _=x[c],m=x[c+1],M=m.x-_.x,w=m.y-_.y,B=Math.sqrt(M*M+w*w);let v;for(;D+p<T+B;){D+=p;const x=(D-T)/B,V=G(_.x,m.x,x),k=G(_.y,m.y,x);void 0===v&&(v=Math.atan2(w,M)),d.push(new y(V,k,v,c,P))}T+=B}}static _pushCenterAnchor(d,x){let p=0;const _=x.length-1;for(let P=0;P<_;P++)p+=c.distance(x[P],x[P+1]);const m=p/2;let M=0;const w=x.length-1;for(let c=0;c<w;c++){const p=x[c],_=x[c+1],w=_.x-p.x,P=_.y-p.y,T=Math.sqrt(w*w+P*P);if(m<M+T){const x=(m-M)/T,D=G(p.x,_.x,x),B=G(p.y,_.y,x),v=Math.atan2(P,w);return void d.push(new y(D,B,v,c,0))}M+=T}}static _deviation(c,d,x){const p=(d.x-c.x)*(x.x-d.x)+(d.y-c.y)*(x.y-d.y),_=(d.x-c.x)*(x.y-d.y)-(d.y-c.y)*(x.x-d.x);return Math.atan2(_,p)}static _honorsTextMaxAngle(d,x,p,_,m){let M=0;const w=p/2;let P=new c(x.x,x.y),T=x.segment+1;for(;M>-w;){if(--T,T<0)return!1;M-=c.distance(d[T],P),P=d[T]}M+=c.distance(d[T],d[T+1]);const D=[];let B=0;const v=d.length;for(;M<w;){const x=d[T];let p,w=T;do{if(++w,w===v)return!1;p=d[w]}while(p.isEqual(x));let P,V=w;do{if(++V,V===v)return!1;P=d[V]}while(P.isEqual(p));const k=this._deviation(x,p,P);for(D.push({deviation:k,distToAnchor:M}),B+=k;M-D[0].distToAnchor>m;)B-=D.shift().deviation;if(Math.abs(B)>_)return!1;M+=c.distance(p,P),T=w}return!0}static _smoothVertices(d,x){if(x<=0)return d;let p=d.length;if(p<3)return d;const _=[];let m=0,M=0;_.push(0);for(let S=1;S<p;S++){const x=c.distance(d[S],d[S-1]);x>0&&(m+=x,_.push(m),M++,M!==S&&(d[M]=d[S]))}if(p=M+1,p<3)return d;x=Math.min(x,.2*m);const w=d[0].x,P=d[0].y,T=d[p-1].x,D=d[p-1].y,B=c.sub(d[0],d[1]);B.normalize(),d[0].x+=x*B.x,d[0].y+=x*B.y,B.assignSub(d[p-1],d[p-2]),B.normalize(),d[p-1].x+=x*B.x,d[p-1].y+=x*B.y,_[0]-=x,_[p-1]+=x;const v=[];v.push(new c(w,P));const V=1e-6,k=.5*x;for(let S=1;S<p-1;S++){let m=0,M=0,w=0;for(let c=S-1;c>=0;c--){const p=k+_[c+1]-_[S];if(p<0)break;const P=_[c+1]-_[c],T=_[S]-_[c]<k?1:p/P;if(T<V)break;const D=T*T,B=T*p-.5*D*P,v=T*P/x,C=d[c+1],E=d[c].x-C.x,O=d[c].y-C.y;m+=v/B*(C.x*T*p+.5*D*(p*E-P*C.x)-D*T*P*E/3),M+=v/B*(C.y*T*p+.5*D*(p*O-P*C.y)-D*T*P*O/3),w+=v}for(let c=S+1;c<p;c++){const p=k-_[c-1]+_[S];if(p<0)break;const P=_[c]-_[c-1],T=_[c]-_[S]<k?1:p/P;if(T<V)break;const D=T*T,B=T*p-.5*D*P,v=T*P/x,C=d[c-1],E=d[c].x-C.x,O=d[c].y-C.y;m+=v/B*(C.x*T*p+.5*D*(p*E-P*C.x)-D*T*P*E/3),M+=v/B*(C.y*T*p+.5*D*(p*O-P*C.y)-D*T*P*O/3),w+=v}v.push(new c(m/w,M/w))}return v.push(new c(T,D)),d[0].x=w,d[0].y=P,d[p-1].x=T,d[p-1].y=D,v}static _pushCentroid(c,d){const x=4096,p=4096,_=d.length-1;let m=0,M=0,w=0,P=d[0].x,T=d[0].y;P>x&&(P=x),P<0&&(P=0),T>p&&(T=p),T<0&&(T=0);for(let D=1;D<_;D++){let c=d[D].x,_=d[D].y,B=d[D+1].x,v=d[D+1].y;c>x&&(c=x),c<0&&(c=0),_>p&&(_=p),_<0&&(_=0),B>x&&(B=x),B<0&&(B=0),v>p&&(v=p),v<0&&(v=0);const V=(c-P)*(v-T)-(B-P)*(_-T);m+=V*(P+c+B),M+=V*(T+_+v),w+=V}m/=3*w,M/=3*w,isNaN(m)||isNaN(M)||c.push(new y(m,M))}}var pe,_e;L._bidiEngine=new H,(_e=pe||(pe={}))[_e.INITIALIZED=0]="INITIALIZED",_e[_e.NO_DATA=1]="NO_DATA",_e[_e.READY=2]="READY",_e[_e.MODIFIED=3]="MODIFIED",_e[_e.INVALID=4]="INVALID";class g{constructor(c,d,x,p,_,m){var M;if(this._pbfTiles={},this._tileClippers={},this._client=x,this._tile=d,this._sourceDataMaxLOD=p,m){this._styleLayerUIDs=new Set;for(const c of m)this._styleLayerUIDs.add(c)}this._styleRepository=_,this._layers=(null==(M=this._styleRepository)?void 0:M.layers)??[];const[w,P,T]=d.tileKey.split("/").map(parseFloat);this._level=w;const D=K(this._level);for(const B of Object.keys(c)){const d=c[B];if(this._pbfTiles[B]=new Q(new Uint8Array(d.protobuff),new DataView(d.protobuff)),d.refKey){const[c]=d.refKey.split("/").map(parseFloat),x=w-c;if(x>0){const c=(1<<x)-1,d=P&c,p=T&c;this._tileClippers[B]=new W(x,d,p,8,D)}}this._tileClippers[B]||(this._tileClippers[B]=new j)}}_canParseStyleLayer(c){return!this._styleLayerUIDs||this._styleLayerUIDs.has(c)}async parse(c){const d=se(),x=this._initialize(c),{returnedBuckets:p}=x;this._processLayers(x),this._linkReferences(x),this._filterFeatures(x);const _=[],m=new Set,n2=(c,d)=>{m.has(c)||(_.push({name:c,repeat:d}),m.add(c))},M={};for(const P of p)P.getResources(P.tileClipper,n2,M);if(this._tile.status===pe.INVALID)return[];const w=this._fetchResources(_,M,c);return Promise.all([...w,d]).then((()=>this._processFeatures(x.returnedBuckets)))}_initialize(c){return{signal:null==c?void 0:c.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(c){const{sourceNameToTileData:d,zoom:x,layers:p,sourceNameToTileClipper:_,sourceNameToUniqueSourceLayerBuckets:m,sourceNameToUniqueSourceLayers:M,returnedBuckets:w,layerIdToBucket:P,referencerUIDToReferencedId:T}=c,D=this._sourceDataMaxLOD;for(let B=p.length-1;B>=0;B--){const c=p[B];if(x<D){if(c.minzoom&&x<Math.floor(c.minzoom)||c.maxzoom&&x>=c.maxzoom)continue}else if(c.maxzoom&&x>=c.maxzoom)continue;if(c.type===q.BACKGROUND||!this._canParseStyleLayer(c.uid)||!d[c.source]||!_[c.source])continue;const v=d[c.source],V=_[c.source],k=c.sourceLayer,S=v[k];if(S){let d=M[c.source];if(d||(d=M[c.source]=new Set),d.add(c.sourceLayer),c.refLayerId)T.set(c.uid,c.refLayerId);else{const d=this._createBucket(c);if(d){d.layerUIDs=[c.uid],d.layerExtent=S.extent,d.tileClipper=V;let x=m[c.source];x||(x=m[c.source]={});let p=x[k];p||(p=x[k]=[]),p.push(d),w.push(d),P[c.id]=d}}}}}_linkReferences(c){const{layerIdToBucket:d,referencerUIDToReferencedId:x}=c;x.forEach(((c,x)=>{d[c]&&d[c].layerUIDs.push(x)}))}_filterFeatures(c){const{signal:d,sourceNameToTileData:x,sourceNameToUniqueSourceLayerBuckets:p,sourceNameToUniqueSourceLayers:_}=c,m=10*this._level,M=10*(this._level+1),w=[],P=[];for(const T of Object.keys(_))_[T].forEach((c=>{w.push(c),P.push(T)}));for(let T=0;T<w.length;T++){const c=P[T],_=w[T];if(!x[c]||!p[c])continue;const D=x[c][_],B=p[c][_];if(!B||0===B.length)continue;if(Y(d))return;let v=0;const V=D.getData();for(;V.nextTag(2);){const c=V.getMessage(),d=new ue(c,D,v++);c.release();const x=d.values;if(x){const c=x._minzoom;if(c&&c>=M)continue;const d=x._maxzoom;if(d&&d<=m)continue}for(const p of B)p.pushFeature(d)}}}_fetchResources(c,d,x){const p=[],_=this._tile.getWorkerTileHandler();let m,M;c.length>0&&(m=_.fetchSprites(c,this._client,x),p.push(m));for(const w in d){const c=d[w];c.size>0&&(M=_.fetchGlyphs(this._tile.tileKey,w,c,this._client,x),p.push(M))}return p}_processFeatures(c){const d=c.filter((c=>c.hasFeatures()||this._canParseStyleLayer(c.layer.uid)));for(const x of d)x.processFeatures(x.tileClipper);return d}_parseTileData(c){const d={};for(const x of Object.keys(c)){const p=c[x],_={};for(;p.next();)switch(p.tag()){case 3:{const c=p.getMessage(),d=new e(c);c.release(),_[d.name]=d;break}default:p.skip()}d[x]=_}return d}_createBucket(c){switch(c.type){case q.BACKGROUND:return null;case q.FILL:return this._createFillBucket(c);case q.LINE:return this._createLineBucket(c);case q.CIRCLE:return this._createCircleBucket(c);case q.SYMBOL:return this._createSymbolBucket(c)}}_createFillBucket(c){return new ge(c,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new xe(c.fillMaterial.getStride()),new fe,new u2(c.outlineMaterial.getStride()),new fe)}_createLineBucket(c){return new n(c,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new de(c.lineMaterial.getStride()),new fe)}_createCircleBucket(c){return new ye(c,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new a(c.circleMaterial.getStride()),new fe)}_createSymbolBucket(c){const d=this._tile;return new L(d.tileKey,c,this._level,new h(c.iconMaterial.getStride()),new fe,new h(c.textMaterial.getStride()),new fe,d.placementEngine,d.getWorkerTileHandler())}}let me=class i{constructor(c,d,x,p){this.status=pe.INITIALIZED,this.placementEngine=new oe,this.tileKey=c,this.refKeys=d,this._workerTileHandler=x,this._styleRepository=p}release(){this.tileKey="",this.refKeys=null,this.status=pe.INITIALIZED,this._workerTileHandler=null}async parse(c,d){const x=null==d?void 0:d.signal;if(null!=x){const t2=()=>{x.removeEventListener("abort",t2),this.status=pe.INVALID};x.addEventListener("abort",t2)}let p;const _={bucketsWithData:[],emptyBuckets:null};try{p=await this._parse(c,d)}catch(T){if($(T))throw T;return{result:_,transferList:[]}}this.status=pe.READY;const m=_.bucketsWithData,M=[];for(const D of p)if(D.hasFeatures()){const c=D.serialize();m.push(c)}else M.push(D.layer.uid);const w=[...m];let P=null;return M.length>0&&(P=Uint32Array.from(M),w.push(P.buffer)),_.emptyBuckets=P,{result:_,transferList:w}}setObsolete(){this.status=pe.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}async _parse(c,d){const x=c.sourceName2DataAndRefKey;return 0===Object.keys(x).length?[]:(this.status=pe.MODIFIED,new g(x,this,d.client,c.sourceDataMaxLOD,this._styleRepository,c.styleLayerUIDs).parse(d))}};class i2{constructor(){this._spriteInfo={},this._glyphInfo={},this._sourceDataMaxLOD=25}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){var c;return(null==(c=this._styleRepository)?void 0:c.layers)??[]}async createTileAndParse(c,d){const{key:x}=c,p={};for(const M of Object.keys(c.sourceName2DataAndRefKey)){const d=c.sourceName2DataAndRefKey[M];p[M]=d.refKey}const _=new me(x,p,this,this._styleRepository);try{return await _.parse({...c,sourceDataMaxLOD:this._sourceDataMaxLOD},d)}catch(m){if(_.setObsolete(),_.release(),!$(m))throw m;return null}}updateStyle(c){if(!c||0===c.length||!this._styleRepository)return;const d=this._styleRepository;for(const x of c){const c=x.type,p=x.data;switch(c){case J.PAINTER_CHANGED:d.setPaintProperties(p.layer,p.paint);break;case J.LAYOUT_CHANGED:d.setLayoutProperties(p.layer,p.layout);break;case J.LAYER_REMOVED:d.deleteStyleLayer(p.layer);break;case J.LAYER_CHANGED:d.setStyleLayer(p.layer,p.index);break;case J.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(c){const{style:d,sourceDataMaxLOD:x}=c;this._styleRepository=new Z(d),this._sourceDataMaxLOD=x,this._spriteInfo={},this._glyphInfo={}}fetchSprites(c,d,x){const p=[],_=this._spriteInfo;for(const m of c)void 0===_[m.name]&&p.push(m);return 0===p.length?Promise.resolve():d.invoke("getSprites",p,{signal:null==x?void 0:x.signal}).then((c=>{for(const d in c){const x=c[d];_[d]=x}}))}getSpriteItems(){return this._spriteInfo}fetchGlyphs(c,d,x,p,_){const m=[];let M=this._glyphInfo[d];return M?x.forEach((c=>{M[c]||m.push(c)})):(M=this._glyphInfo[d]=[],x.forEach((c=>m.push(c)))),0===m.length?Promise.resolve():p.invoke("getGlyphs",{tileID:c,font:d,codePoints:m},_).then((c=>{for(let d=0;d<c.length;d++)c[d]&&(M[d]=c[d])}))}getGlyphItems(c){return this._glyphInfo[c]}}export{i2 as default};
