import{lW as t,cM as e,I as n,f0 as s,lX as i,b as o,aI as c,ax as h,j as d,lY as $,lZ as R,ec as v,Q as j,dv as q,cW as S,kg as x,du as k,l_ as N,kh as I,G as T,l$ as W}from"./index-DSIPxOWi.js";import{geodesicLength as Z}from"./geometryEngine-Bp1TD6MM.js";function p$3(t){if(!t)return null;if(s(t)&&t.wkid){const e=i[t.wkid];if(e)return e}const e=t.wkt2||t.wkt;if(e){const t=function u$2(t){const e=$.exec(t);if(!e||2!==e.length)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),i=parseFloat(n[2]);return isNaN(s)||isNaN(i)?null:{a:s,f:0===i?0:1/i}}(e);if(t)return t}return null}function d$2(t){const e=p$3(t);if(function m$1(t){return null!=t&&"b"in t&&"eSq"in t&&"radius"in t}(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function M(e,n,s){const{a:i,eSq:o}=d$2(s),c=Math.sqrt(o),h=Math.sin(n[1]*t),d=i*n[0]*t;let $;return $=o>0?i*((1-o)*(h/(1-o*(h*h))-1/(2*c)*Math.log((1-c*h)/(1+c*h))))*.5:i*h,e[0]=d,e[1]=$,e}function w(t){return null!==p$3(t)}function y$1(t,e="square-meters"){if(t.some((t=>!w(t.spatialReference))))throw new o("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let o=0;o<t.length;o++){const e=t[o],s=e.spatialReference,{radius:i,densificationRatio:c}=d$2(s),h=i*c;n.push(R$2(e,h))}const s=[],i=[0,0],h=[0,0];for(let o=0;o<n.length;o++){const{rings:t,spatialReference:d}=n[o];let $=0;for(let e=0;e<t.length;e++){const n=t[e];M(i,n[0],d),M(h,n[n.length-1],d);let s=h[0]*i[1]-i[0]*h[1];for(let t=0;t<n.length-1;t++)M(i,n[t+1],d),M(h,n[t],d),s+=h[0]*i[1]-i[0]*h[1];$+=s}$=c($,"square-meters",e),s.push($/-2)}return s}function R$2(t,e){if("polyline"!==t.type&&"polygon"!==t.type)throw new o("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=t;if(!w(n))throw new o("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s="polyline"===t.type?t.paths:t.rings,i=[],c=[0,0],$=new z;for(const o of s){const t=[];i.push(t),t.push([o[0][0],o[0][1]]);let s,h,d=o[0][0],R=o[0][1];for(let i=0;i<o.length-1;i++){if(s=o[i+1][0],h=o[i+1][1],d===s&&R===h)continue;const v=[d,R];j$2($,[d,R],[s,h],n);const{azimuth:j,distance:q}=$,S=q/e;if(S>1){for(let s=1;s<=S-1;s++)b(c,v,j,s*e,n),t.push(c.slice(0));b(c,v,j,(q+Math.floor(S-1)*e)/2,n),t.push(c.slice(0))}b(c,v,j,q,n),t.push(c.slice(0)),d=c[0],R=c[1]}}return"polyline"===t.type?new h({paths:i,spatialReference:n}):new d({rings:i,spatialReference:n})}class z{constructor(t=0,e=void 0,n=void 0){this.distance=t,this.azimuth=e,this.reverseAzimuth=n}}function b(e,n,s,i,o){const c=n[0],h=n[1],d=c*t,$=h*t,R=(s??0)*t,{a:v,b:j,f:q}=d$2(o),S=Math.sin(R),x=Math.cos(R),k=(1-q)*Math.tan($),N=1/Math.sqrt(1+k*k),I=k*N,T=Math.atan2(k,x),W=N*S,Z=W*W,C=1-Z,F=C*(v*v-j*j)/(j*j),G=1+F/16384*(4096+F*(F*(320-175*F)-768)),E=F/1024*(256+F*(F*(74-47*F)-128));let H,L,O,P,Q=i/(j*G),X=2*Math.PI;for(;Math.abs(Q-X)>1e-12;)O=Math.cos(2*T+Q),H=Math.sin(Q),L=Math.cos(Q),P=E*H*(O+E/4*(L*(2*O*O-1)-E/6*O*(4*H*H-3)*(4*O*O-3))),X=Q,Q=i/(j*G)+P;const Y=I*H-N*L*x,_=Math.atan2(I*L+N*H*x,(1-q)*Math.sqrt(Z+Y*Y)),B=Math.atan2(H*S,N*L-I*H*x),D=q/16*C*(4+q*(4-3*C)),J=_/t,K=(d+(B-(1-D)*q*W*(Q+D*H*(O+D*L*(2*O*O-1)))))/t;return e[0]=K,e[1]=J,e}function j$2(e,n,s,i){const o=n[0]*t,c=n[1]*t,h=s[0]*t,d=s[1]*t,{a:$,b:R,f:v,radius:j}=d$2(i),q=h-o,S=Math.atan((1-v)*Math.tan(c)),x=Math.atan((1-v)*Math.tan(d)),k=Math.sin(S),N=Math.cos(S),I=Math.sin(x),T=Math.cos(x);let W,Z,C,F,G,E,H,L,O,P,Q=1e3,X=q;do{if(H=Math.sin(X),L=Math.cos(X),C=Math.sqrt(T*H*(T*H)+(N*I-k*T*L)*(N*I-k*T*L)),0===C)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;G=k*I+N*T*L,E=Math.atan2(C,G),O=N*T*H/C,Z=1-O*O,F=G-2*k*I/Z,isNaN(F)&&(F=0),P=v/16*Z*(4+v*(4-3*Z)),W=X,X=q+(1-P)*v*O*(E+P*C*(F+P*G*(2*F*F-1)))}while(Math.abs(X-W)>1e-12&&--Q>0);if(0===Q){const n=j,s=Math.acos(Math.sin(c)*Math.sin(d)+Math.cos(c)*Math.cos(d)*Math.cos(h-o))*n,i=h-o,$=Math.sin(i)*Math.cos(d),R=Math.cos(c)*Math.sin(d)-Math.sin(c)*Math.cos(d)*Math.cos(i),v=Math.atan2($,R);return e.azimuth=v/t,e.distance=s,e.reverseAzimuth=void 0,e}const Y=Z*($*$-R*R)/(R*R),_=Y/1024*(256+Y*(Y*(74-47*Y)-128)),B=R*(1+Y/16384*(4096+Y*(Y*(320-175*Y)-768)))*(E-_*C*(F+_/4*(G*(2*F*F-1)-_/6*F*(4*C*C-3)*(4*F*F-3)))),D=Math.atan2(T*Math.sin(X),N*I-k*T*Math.cos(X)),J=Math.atan2(N*Math.sin(X),N*I*Math.cos(X)-k*T);return e.azimuth=D/t,e.distance=B,e.reverseAzimuth=J/t,e}function A(t){return w(t)?t:e(t)?n.WGS84:null}function p$2(t,e,n,s){n.projectToRenderScreen(t,G),n.projectToRenderScreen(e,E),S(s,E,G),x(s,s)}function l$1(t,e,n,s,i=j()){const o=k(F,t);return o[2]=N(s,o,e,n)||0,s.renderCoordsHelper.toRenderCoords(o,e,i),i}function d$1(t,e,n,s){return"2d"===s.type?(C.x=t[0],C.y=t[1],C.spatialReference=e,s.toScreen(C)):(l$1(t,e,n,s,F),s.state.camera.projectToScreen(F,H),R(H[0],H[1]))}const C=v(0,0,0,null),F=j(),G=I(),E=I(),H=q();function r(t){return s(t)&&w(t)||e(t)}function p$1(t,n,i,...o){return s(t)&&w(t)?n.apply(void 0,o):e(t)?i.apply(void 0,o):null}const L=1e5;function m(t){const{spatialReference:e}=t;return p$1(e,l,g,t)}function f(t,e){if(!T(t.spatialReference,e.spatialReference))return null;const{spatialReference:n}=t;return P[0]=t.x,P[1]=t.y,P[2]=t.hasZ?t.z:0,Q[0]=e.x,Q[1]=e.y,Q[2]=e.hasZ?e.z:0,u(P,Q,n)}function u(t,e,n){return p$1(n,a,p,t,e,n)}function a(t,e,n){return W(j$2(O,t,e,n).distance,"meters")}function p(t,e,n){return W(Z(function y(t,e,n){return{type:"polyline",spatialReference:n,paths:[[[...t],[...e]]]}}(t,e,n),"meters"),"meters")}function l(t){return W(function v$1(t,e="meters"){if(!t)throw new o("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some((t=>!w(t.spatialReference))))throw new o("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const i=t[s],{spatialReference:o}=i,h="polyline"===i.type?i.paths:i.rings;let d=0;for(let t=0;t<h.length;t++){const e=h[t];let n=0;for(let t=1;t<e.length;t++){const s=e[t-1][0],i=e[t][0],c=e[t-1][1],h=e[t][1];if(c!==h||s!==i){const t=new z;j$2(t,[s,c],[i,h],o),n+=t.distance}}d+=n}d=c(d,"meters",e),n.push(d)}return n}([t],"meters")[0],"meters")}function g(t){return W(Z(t,"meters"),"meters")}const O=new z,P=j(),Q=j();export{A,p$2 as a,b,d$1 as d,f,L as i,j$2 as j,l$1 as l,m,p$1 as p,r,u,y$1 as y,z};
