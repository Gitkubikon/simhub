const __vite__fileDeps=["assets/GroupLayer-Cztd08er.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/fetchService-CJQ8-6Ub.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{_ as e,eg as r,b as a,eh as t,ei as l,ej as s,ek as n,el as o}from"./index-DSIPxOWi.js";import{t as u,i,a as c,b as y}from"./fetchService-CJQ8-6Ub.js";const P={FeatureLayer:!0,SceneLayer:!0};async function f(y){const{properties:O,url:T}=y,U={...O,url:T},C=await async function w(e,y){var O,T,U,C,F,V,N;let k=r(e);if(null==k&&(k=await async function v(e,r){var a;const n=await u(e,{customParameters:r});let o=null,i=null;const c=n.type;if("Feature Layer"===c||"Table"===c?(o="FeatureServer",i=n.id??null):"indexedVector"===c?o="VectorTileServer":n.hasOwnProperty("mapName")?o="MapServer":n.hasOwnProperty("bandCount")&&n.hasOwnProperty("pixelSizeX")?o="ImageServer":n.hasOwnProperty("maxRecordCount")&&n.hasOwnProperty("allowGeometryUpdates")?o="FeatureServer":n.hasOwnProperty("streamUrls")?o="StreamServer":S(n)?(o="SceneServer",i=n.id):n.hasOwnProperty("layers")&&S(null==(a=n.layers)?void 0:a[0])&&(o="SceneServer"),!o)return null;const y=null!=i?t(e):null;return{title:null!=y&&n.name||l(e),serverType:o,sublayer:i,url:{path:null!=y?y.serviceUrl:s(e).path}}}(e,y)),null==k)throw new a("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:e});const{serverType:J,sublayer:x}=k;let E;const M={FeatureServer:"FeatureLayer",KnowledgeGraphServer:"KnowledgeGraphLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer",VideoServer:"VideoLayer"},_="FeatureServer"===J,G="SceneServer"===J,j={parsedUrl:k,Constructor:null,layerId:_||G?x??void 0:void 0,layers:[],tables:[]};switch(J){case"MapServer":if(null!=x){const{type:r}=await u(e,{customParameters:y});switch(E="FeatureLayer",r){case"Catalog Layer":E="CatalogLayer";break;case"Catalog Dynamic Group Layer":throw new a("arcgis-layers:unsupported",`fromUrl() not supported for "${r}" layers`)}}else E=await async function L(e,r){return(await u(e,{customParameters:r})).tileInfo}(e,y)?"TileLayer":"MapImageLayer";break;case"ImageServer":{const r=await u(e,{customParameters:y}),{tileInfo:a,cacheType:t}=r;E=a?"LERC"!==(null==(O=null==a?void 0:a.format)?void 0:O.toUpperCase())||t&&"elevation"!==t.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await u(k.url.path,{customParameters:y});if(E="SceneLayer",e){const r=null==e?void 0:e.layers;if("Voxel"===(null==e?void 0:e.layerType))E="VoxelLayer";else if(null==r?void 0:r.length){const e=null==(T=r[0])?void 0:T.layerType;null!=e&&null!=o[e]&&(E=o[e])}}break}case"3DTilesServer":throw new a("arcgis-layers:unsupported","fromUrl() not supported for 3DTiles layers");case"FeatureServer":if(E="FeatureLayer",null!=x){const r=await u(e,{customParameters:y});j.sourceJSON=r,E=i(r.type)}break;default:E=M[J]}if(P[E]&&null==x){const r=await async function b(e,r,a){let t,l,s=!1;switch(r){case"FeatureServer":{const r=await c(e,{customParameters:a});s=!!r.layersJSON,t=r.layersJSON||r.serviceJSON;break}case"SceneServer":{const r=await async function h(e,r){var a;const t=await u(e,{customParameters:r}),l=null==(a=t.layers)?void 0:a[0];if(!l)return{serviceInfo:t};try{const{serverUrl:a}=await n(e),l=await u(a,{customParameters:r}).catch((()=>null));return l&&(t.tables=l.tables),{serviceInfo:t,tableServerUrl:a}}catch{return{serviceInfo:t}}}(e,a);t=r.serviceInfo,l=r.tableServerUrl;break}default:t=await u(e,{customParameters:a})}const o=null==t?void 0:t.layers,i=null==t?void 0:t.tables;return{layers:(null==o?void 0:o.map((e=>({id:e.id}))).reverse())||[],tables:(null==i?void 0:i.map((e=>({serverUrl:l,id:e.id}))).reverse())||[],layerInfos:s?o:[],tableInfos:s?i:[]}}(e,J,y);if(_&&(j.sublayerInfos=r.layerInfos,j.tableInfos=r.tableInfos),1!==r.layers.length+r.tables.length)j.layers=r.layers,j.tables=r.tables,_&&(null==(U=r.layerInfos)?void 0:U.length)&&(j.sublayerConstructorProvider=await async function g(e){if(!e.length)return;const r=new Set,a=[];for(const{type:s}of e)r.has(s)||(r.add(s),a.push(I(i(s))));const t=await Promise.all(a),l=new Map;return Array.from(r).forEach(((e,r)=>{l.set(e,t[r])})),e=>l.get(e.type)}(r.layerInfos));else if(_||G){const e=(null==(C=r.layerInfos)?void 0:C[0])??(null==(F=r.tableInfos)?void 0:F[0]);if(j.layerId=(null==(V=r.layers[0])?void 0:V.id)??(null==(N=r.tables[0])?void 0:N.id),j.sourceJSON=e,_){const r=null==e?void 0:e.type;E=i(r)}}}return j.Constructor=await I(E),j}(T,null==O?void 0:O.customParameters),{Constructor:F,layerId:V,sourceJSON:N,parsedUrl:k,layers:J,tables:x}=C;if(J.length+x.length===0)return null!=V&&(U.layerId=V),null!=N&&(U.sourceJSON=N),new F(U);const E=new((await e((async()=>{const{default:e}=await import("./GroupLayer-Cztd08er.js");return{default:e}}),__vite__mapDeps([0,1,2,3]))).default)({title:k.title});return await async function d(e,r,a){const t=r.sublayerConstructorProvider;for(const{id:l,serverUrl:s}of r.layers){const n=p(r.sublayerInfos,l),o=m(s,l,n,(n&&(null==t?void 0:t(n)))??r.Constructor,a);e.add(o)}if(r.tables.length){const t=await I("FeatureLayer");r.tables.forEach((({id:l,serverUrl:s})=>{const n=m(s,l,p(r.tableInfos,l),t,a);e.tables.add(n)}))}}(E,C,U),E}function p(e,r){return e?e.find((({id:e})=>e===r)):null}function m(e,r,a,t,l){const s={...l,layerId:r};return null!=e&&(s.url=e),null!=a&&(s.sourceJSON=a),"sublayerTitleMode"in t.prototype&&(s.sublayerTitleMode="service-name"),new t(s)}function S(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function I(e){return(0,y[e])()}export{f as fromUrl};
