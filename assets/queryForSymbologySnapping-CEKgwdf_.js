import{I as e,hv as n,hw as a,b3 as s,ec as t,hx as o,hy as i,hz as c,e2 as d,hA as p,Q as u,c4 as f}from"./index-DSIPxOWi.js";async function m$1(f,h,g,y,m){const{elevationProvider:I,renderCoordsHelper:b}=f,{elevationInfo:v}=h,{pointsInFeatures:w,spatialReference:S}=y,R=e.fromJSON(S),x=n(v,!0),j=await a(x,R,m);s(m);const D=[],z=new Set,C=new Set,F=new d,O=t(0,0,0,e.WGS84),q=new p,G=u();O.spatialReference=R;const P=f.elevationProvider.spatialReference??f.spatialReference;for(const{objectId:e,points:n}of w){const a=g(e);if(null==a){for(const e of n)D.push(e.z??0);z.add(e);continue}a.isDraped&&C.add(e);const s=a.graphic.geometry;F.setFromElevationInfo(o(s,v)),F.updateFeatureExpressionInfoContext(j,a.graphic,h);for(const{x:e,y:t,z:o}of n)O.x=e,O.y=t,O.z=o??0,await i(O,G,P,0,{signal:m}),c(G,I,F,b,q),D.push(q.z)}return{elevations:D,drapedObjectIds:C,failedObjectIds:z}}async function r(e,n,a){if(null==e||0===n.candidates.length)return h;const t=e.graphics3DGraphicsByObjectID??e.graphics3DGraphics,o=[],i=[],{renderer:c}=e,d=null!=c&&"arcadeRequired"in c&&c.arcadeRequired?f():null,l=async(n,{graphic:s,graphics3DSymbol:t})=>{const o=await d,i=await e.getRenderingInfoAsync(s,c,o,{signal:a});return null==i?[]:t.queryForSnapping(n,u,i,a)},{candidates:p,spatialReference:u}=n;for(let s=0;s<p.length;++s){const e=p[s],{objectId:n}=e,a="number"==typeof n?null==t?void 0:t.get(n):void 0;if(null==a)continue;const{graphics3DSymbol:c}=a;c.symbologySnappingSupported&&(o.push(l(e,a)),i.push(s))}if(0===o.length)return h;const g=await Promise.all(o);s(a);const y=[],m=[];for(let s=0;s<g.length;++s){const e=g[s],n=i[s];for(const a of e)y.push(a),m.push(n)}return{candidates:y,sourceCandidateIndices:m}}const h={candidates:[],sourceCandidateIndices:[]};export{m$1 as m,r};
