import{lW as v,cM as D,I as ft,f0 as J,lX as pt,b as P,aI as st,ax as dt,j as Mt,lY as gt,lZ as mt,ec as $t,Q as O,dv as yt,cW as wt,kg as Rt,du as vt,l_ as zt,kh as at,G as jt,l$ as U}from"./index-_cfZD3Ca.js";import{geodesicLength as rt}from"./geometryEngine-BDL0j_81.js";function it(t){if(!t)return null;if(J(t)&&t.wkid){const n=pt[t.wkid];if(n)return n}const e=t.wkt2||t.wkt;if(e){const n=qt(e);if(n)return n}return null}function qt(t){const e=gt.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(s)||isNaN(a)?null:{a:s,f:a===0?0:1/a}}function H(t){const e=it(t);if(bt(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function bt(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function T(t,e,n){const{a:s,eSq:a}=H(n),r=Math.sqrt(a),c=Math.sin(e[1]*v),i=s*e[0]*v;let l;return a>0?l=s*((1-a)*(c/(1-a*(c*c))-1/(2*r)*Math.log((1-r*c)/(1+r*c))))*.5:l=s*c,t[0]=i,t[1]=l,t}function I(t){return it(t)!==null}function Zt(t,e="square-meters"){if(t.some(c=>!I(c.spatialReference)))throw new P("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let c=0;c<t.length;c++){const i=t[c],l=i.spatialReference,{radius:u,densificationRatio:h}=H(l),o=u*h;n.push(xt(i,o))}const s=[],a=[0,0],r=[0,0];for(let c=0;c<n.length;c++){const{rings:i,spatialReference:l}=n[c];let u=0;for(let h=0;h<i.length;h++){const o=i[h];T(a,o[0],l),T(r,o[o.length-1],l);let d=r[0]*a[1]-a[0]*r[1];for(let M=0;M<o.length-1;M++)T(a,o[M+1],l),T(r,o[M],l),d+=r[0]*a[1]-a[0]*r[1];u+=d}u=st(u,"square-meters",e),s.push(u/-2)}return s}function St(t,e="meters"){if(!t)throw new P("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(s=>!I(s.spatialReference)))throw new P("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const a=t[s],{spatialReference:r}=a,c=a.type==="polyline"?a.paths:a.rings;let i=0;for(let l=0;l<c.length;l++){const u=c[l];let h=0;for(let o=1;o<u.length;o++){const d=u[o-1][0],M=u[o][0],y=u[o-1][1],g=u[o][1];if(y!==g||d!==M){const p=new K;V(p,[d,y],[M,g],r),h+=p.distance}}i+=h}i=st(i,"meters",e),n.push(i)}return n}function xt(t,e){if(t.type!=="polyline"&&t.type!=="polygon")throw new P("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=t;if(!I(n))throw new P("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s=t.type==="polyline"?t.paths:t.rings,a=[],r=[0,0],c=new K;for(const i of s){const l=[];a.push(l),l.push([i[0][0],i[0][1]]);let u,h,o=i[0][0],d=i[0][1];for(let M=0;M<i.length-1;M++){if(u=i[M+1][0],h=i[M+1][1],o===u&&d===h)continue;const y=[o,d];V(c,[o,d],[u,h],n);const{azimuth:g,distance:p}=c,w=p/e;if(w>1){for(let m=1;m<=w-1;m++)Y(r,y,g,m*e,n),l.push(r.slice(0));Y(r,y,g,(p+Math.floor(w-1)*e)/2,n),l.push(r.slice(0))}Y(r,y,g,p,n),l.push(r.slice(0)),o=r[0],d=r[1]}}return t.type==="polyline"?new dt({paths:a,spatialReference:n}):new Mt({rings:a,spatialReference:n})}class K{constructor(e=0,n=void 0,s=void 0){this.distance=e,this.azimuth=n,this.reverseAzimuth=s}}function Y(t,e,n,s,a){const r=e[0],c=e[1],i=r*v,l=c*v,u=(n??0)*v,{a:h,b:o,f:d}=H(a),M=Math.sin(u),y=Math.cos(u),g=(1-d)*Math.tan(l),p=1/Math.sqrt(1+g*g),w=g*p,m=Math.atan2(g,y),G=p*M,x=G*G,z=1-x,f=z*(h*h-o*o)/(o*o),k=1+f/16384*(4096+f*(f*(320-175*f)-768)),A=f/1024*(256+f*(f*(74-47*f)-128));let R,q,$,N,S=s/(o*k),j=2*Math.PI;for(;Math.abs(S-j)>1e-12;)$=Math.cos(2*m+S),R=Math.sin(S),q=Math.cos(S),N=A*R*($+A/4*(q*(2*$*$-1)-A/6*$*(4*R*R-3)*(4*$*$-3))),j=S,S=s/(o*k)+N;const b=w*R-p*q*y,C=Math.atan2(w*q+p*R*y,(1-d)*Math.sqrt(x+b*b)),L=Math.atan2(R*M,p*q-w*R*y),F=d/16*z*(4+d*(4-3*z)),Q=C/v,X=(i+(L-(1-F)*d*G*(S+F*R*($+F*q*(2*$*$-1)))))/v;return t[0]=X,t[1]=Q,t}function V(t,e,n,s){const a=e[0]*v,r=e[1]*v,c=n[0]*v,i=n[1]*v,{a:l,b:u,f:h,radius:o}=H(s),d=c-a,M=Math.atan((1-h)*Math.tan(r)),y=Math.atan((1-h)*Math.tan(i)),g=Math.sin(M),p=Math.cos(M),w=Math.sin(y),m=Math.cos(y);let G,x,z,f,k,A,R,q,$,N,S=1e3,j=d;do{if(R=Math.sin(j),q=Math.cos(j),z=Math.sqrt(m*R*(m*R)+(p*w-g*m*q)*(p*w-g*m*q)),z===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;k=g*w+p*m*q,A=Math.atan2(z,k),$=p*m*R/z,x=1-$*$,f=k-2*g*w/x,isNaN(f)&&(f=0),N=h/16*x*(4+h*(4-3*x)),G=j,j=d+(1-N)*h*$*(A+N*z*(f+N*k*(2*f*f-1)))}while(Math.abs(j-G)>1e-12&&--S>0);if(S===0){const X=o,ct=Math.acos(Math.sin(r)*Math.sin(i)+Math.cos(r)*Math.cos(i)*Math.cos(c-a))*X,tt=c-a,lt=Math.sin(tt)*Math.cos(i),ut=Math.cos(r)*Math.sin(i)-Math.sin(r)*Math.cos(i)*Math.cos(tt),ht=Math.atan2(lt,ut);return t.azimuth=ht/v,t.distance=ct,t.reverseAzimuth=void 0,t}const b=x*(l*l-u*u)/(u*u),C=b/1024*(256+b*(b*(74-47*b)-128)),L=u*(1+b/16384*(4096+b*(b*(320-175*b)-768)))*(A-C*z*(f+C/4*(k*(2*f*f-1)-C/6*f*(4*z*z-3)*(4*f*f-3)))),F=Math.atan2(m*Math.sin(j),p*w-g*m*Math.cos(j)),Q=Math.atan2(p*Math.sin(j),p*w*Math.cos(j)-g*m);return t.azimuth=F/v,t.distance=L,t.reverseAzimuth=Q/v,t}function Et(t){return I(t)?t:D(t)?ft.WGS84:null}function Ot(t,e,n,s){n.projectToRenderScreen(t,et),n.projectToRenderScreen(e,nt),wt(s,nt,et),Rt(s,s)}function kt(t,e,n,s,a=O()){const r=vt(B,t);return r[2]=zt(s,r,e,n)||0,s.renderCoordsHelper.toRenderCoords(r,e,a),a}function Ut(t,e,n,s){return s.type==="2d"?(W.x=t[0],W.y=t[1],W.spatialReference=e,s.toScreen(W)):(kt(t,e,n,s,B),s.state.camera.projectToScreen(B,_),mt(_[0],_[1]))}const W=$t(0,0,0,null),B=O(),et=at(),nt=at(),_=yt();function Ht(t){return J(t)&&I(t)||D(t)}function ot(t,e,n,...s){return J(t)&&I(t)?e.apply(void 0,s):D(t)?n.apply(void 0,s):null}const Lt=1e5;function Qt(t){const{spatialReference:e}=t;return ot(e,It,Ct,t)}function Xt(t,e){if(!jt(t.spatialReference,e.spatialReference))return null;const{spatialReference:n}=t;return Z[0]=t.x,Z[1]=t.y,Z[2]=t.hasZ?t.z:0,E[0]=e.x,E[1]=e.y,E[2]=e.hasZ?e.z:0,At(Z,E,n)}function At(t,e,n){return ot(n,Nt,Gt,t,e,n)}function Nt(t,e,n){return U(V(Pt,t,e,n).distance,"meters")}function Gt(t,e,n){return U(rt(Ft(t,e,n),"meters"),"meters")}function It(t){return U(St([t],"meters")[0],"meters")}function Ct(t){return U(rt(t,"meters"),"meters")}function Ft(t,e,n){return{type:"polyline",spatialReference:n,paths:[[[...t],[...e]]]}}const Pt=new K,Z=O(),E=O();export{Et as A,Ot as a,Y as b,Ut as d,Xt as f,Lt as i,V as j,kt as l,Qt as m,ot as p,Ht as r,At as u,Zt as y,K as z};
