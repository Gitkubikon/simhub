import{fZ as r,bJ as f,b3 as p,k8 as g,kv as y,bn as _,kw as C}from"./index-DSIPxOWi.js";function i$2(r=!1,f){if(r){const{elevationInfo:r,alignPointsInFeatures:p}=f;return new z(r,p)}return new x}let x=class a{async alignCandidates(r,f,p){return r}notifyElevationSourceChange(){}};let z=class c{constructor(f,p){this._elevationInfo=f,this._alignPointsInFeatures=p,this._alignmentsCache=new r(1024),this._cacheVersion=0}async alignCandidates(r,f,p){const _=this._elevationInfo;return null==_||"absolute-height"!==_.mode||_.featureExpressionInfo?this._alignComputedElevationCandidates(r,f,p):(function l(r,f,p){const{offset:_,unit:C}=p;if(null==_)return;const x=g(f),z=_*(y(C??"meters")/x);for(const g of r)switch(g.type){case"edge":g.start.z+=z,g.end.z+=z;continue;case"vertex":g.target.z+=z;continue}}(r,f,_),r)}notifyElevationSourceChange(){this._alignmentsCache.clear(),this._cacheVersion++}async _alignComputedElevationCandidates(r,g,y){const _=new Map;for(const p of r)f(_,p.objectId,d).push(p);const[C,x,z]=this._prepareQuery(_,g),$=await this._alignPointsInFeatures(C,y);if(p(y),z!==this._cacheVersion)return this._alignComputedElevationCandidates(r,g,y);this._applyCacheAndResponse(C,$,x);const{drapedObjectIds:I,failedObjectIds:b}=$,m=[];for(const f of r){const{objectId:r}=f;I.has(r)&&"edge"===f.type&&(f.draped=!0),b.has(r)||m.push(f)}return m}_prepareQuery(r,f){const p=[],g=[];for(const[y,_]of r){const r=[];for(const f of _)this._addToQueriesOrCachedResult(y,f.target,r,g),"edge"===f.type&&(this._addToQueriesOrCachedResult(y,f.start,r,g),this._addToQueriesOrCachedResult(y,f.end,r,g));0!==r.length&&p.push({objectId:y,points:r})}return[{spatialReference:f.toJSON(),pointsInFeatures:p},g,this._cacheVersion]}_addToQueriesOrCachedResult(r,f,p,g){const y=u(r,f),_=this._alignmentsCache.get(y);null==_?p.push(f):g.push(new h(f,_))}_applyCacheAndResponse(r,{elevations:f,drapedObjectIds:p,failedObjectIds:g},y){for(const x of y)x.apply();let _=0;const C=this._alignmentsCache;for(const{objectId:x,points:z}of r.pointsInFeatures){if(g.has(x)){_+=z.length;continue}const r=!p.has(x);for(const p of z){const g=u(x,p),y=f[_++];p.z=y,r&&C.put(g,y,1)}}}};class h{constructor(r,f){this.point=r,this.z=f}apply(){this.point.z=this.z}}function u(r,{x:f,y:p,z:g,spatialReference:y}){return`${r}-${f}-${p}-${g??0}}-wkid:${null==y?void 0:y.wkid}`}function d(){return[]}class t{filter(r,f){return f}notifyElevationSourceChange(){}}let $=class n{filter(r,f){const{point:p,distance:g}=r,{z:y}=p;if(null==y)return f;if(0===f.length)return f;const _=function s(r){return"number"==typeof r?{x:r,y:r,z:r}:r}(g),C=this._updateCandidatesTo3D(f,p,_).filter(e);return C.sort(a$1),C}_updateCandidatesTo3D(r,f,p){for(const g of r)switch(g.type){case"edge":c$1(g,f,p);continue;case"vertex":o(g,f,p);continue}return r}};function e(r){return r.distance<=1}function r$1(r=!1){return r?new $:new t}function c$1(r,f,{x:p,y:g,z:y}){const{start:_,end:C,target:x}=r;r.draped||function i$1(r,f,p,g){const y=g.x-p.x,_=g.y-p.y,C=g.z-p.z,x=y*y+_*_+C*C,z=(f.x-p.x)*y+(f.y-p.y)*_+C*(f.z-p.z),$=Math.min(1,Math.max(0,z/x)),I=p.x+y*$,b=p.y+_*$,m=p.z+C*$;r.x=I,r.y=b,r.z=m}(x,f,_,C);const z=(f.x-x.x)/p,$=(f.y-x.y)/g,I=(f.z-x.z)/y;r.distance=Math.sqrt(z*z+$*$+I*I)}function o(r,f,{x:p,y:g,z:y}){const{target:_}=r,C=(f.x-_.x)/p,x=(f.y-_.y)/g,z=(f.z-_.z)/y,$=Math.sqrt(C*C+x*x+z*z);r.distance=$}function a$1(r,f){return r.distance-f.distance}function n2(r=!1,f){return r?new i(f):new c2}class c2{async fetch(){return[]}notifySymbologyChange(){}}class i{constructor(f){this._getSymbologyCandidates=f,this._candidatesCache=new r(1024),this._cacheVersion=0}async fetch(r,f){if(0===r.length)return[];const g=[],y=[],C=this._candidatesCache;for(const p of r){const r=a2(p),f=C.get(r);if(f)for(const p of f)y.push(_(p));else g.push(p),C.put(r,[],1)}if(0===g.length)return y;const x=this._cacheVersion,{candidates:z,sourceCandidateIndices:$}=await this._getSymbologyCandidates(g,f);if(p(f),x!==this._cacheVersion)return this.fetch(r,f);const I=[],{length:b}=z;for(let p=0;p<b;++p){const r=z[p],f=a2(g[$[p]]),y=C.get(f);y.push(r),C.put(f,y,y.length),I.push(_(r))}return y.concat(I)}notifySymbologyChange(){this._candidatesCache.clear(),this._cacheVersion++}}function a2(r){switch(r.type){case"vertex":{const{objectId:f,target:p}=r,g=`${f}-vertex-${p.x}-${p.y}-${p.z??0}`;return C(g).toString()}case"edge":{const{objectId:f,start:p,end:g}=r,y=`${f}-edge-${p.x}-${p.y}-${p.z??0}-to-${g.x}-${g.y}-${g.z??0}`;return C(y).toString()}default:return""}}export{i$2 as i,n2 as n,r$1 as r};
