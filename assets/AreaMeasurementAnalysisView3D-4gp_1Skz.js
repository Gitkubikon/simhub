import{du as e,dD as t,H as s,cx as i,N as a,Q as o,O as l,dC as d,p3 as p,x9 as y,dB as v,L as w,iq as L,ql as S,ip as M,hK as P,uD as C,hL as V,ce as b,J as A,l$ as x,c_ as D,e6 as G,mb as R,xa as O,qN as F,xb as q,cd as k,hD as H,tv as N,lM as B,sg as $,to as Q,r9 as Z,hR as X,hI as Y,ee,xc as te,cw as se,di as ie,e as re,y as ne,a as ae,S as oe,g as le,i as he,bc as de,cI as ce,xd as ue,A as pe,dh as ge,n as me,aw as _e,w5 as ye,w6 as fe,dW as ve,w8 as we,wa as Le,wR as Se,xe as Me,we as Pe,wd as Ce,wg as Ve,_ as be,xf as Ae,tf as xe,wj as De,wk as Ge,wV as Re,wl as Oe,wm as Ee,wo as Ie,wp as Te,wq as ze,wr as je,ws as Ue,wi as Fe,wx as We,wy as qe,kz as ke,wA as He,wE as Ne,wC as Be,xg as $e,wH as Je,nZ as Ke,br as Qe,dJ as Ze,si as Xe,dM as Ye,dN as et,lq as tt,ea as st,eb as it,oK as rt,pf as nt,oI as at,um as ot,oi as lt,bV as ht,n0 as dt,qT as ct,P as ut,u as pt,aI as gt,e9 as mt,qU as _t,aQ as yt,aP as ft,aK as vt,aH as wt,xh as Lt}from"./index-DSIPxOWi.js";import{e as St,a as Mt}from"./interfaces-BqQPACG7.js";import{s as Pt}from"./AnalysisView3D-CNsY6W7Z.js";import{o as Ct,k as Vt}from"./euclideanAreaMeasurementUtils-D_-Y3voK.js";import{r as bt,u as At,f as xt}from"./geodesicLengthMeasurementUtils-Pq-FipkN.js";import{t as Dt}from"./projectionUtils-B1mpMSec.js";import{E as Gt,p as Rt,P as Ot,a as Et}from"./EditGeometryOperations-sseMUvB1.js";import{g as It}from"./TextOverlayItem-BcN_gvXw.js";import{f as Tt,_ as zt,m as jt}from"./Segment-ByPzCwlk.js";import{a as Ut,f as Ft}from"./LineVisualElement-EjMrPPob.js";import"./geometryEngine-Bp1TD6MM.js";import"./geometryEngineBase-9EI9fooq.js";import"./hydrated-DE1HcVsK.js";import"./geometry2dUtils-4c9qUvJ6.js";import"./unitFormatUtils-B9MPZ1wj.js";function f(o,l,d,p,y){e(Wt,o),t(qt,o,l),s(Wt,d,Wt,y),s(qt,d,qt,y),i(p,qt,Wt),a(p,p)}const Wt=o(),qt=o();function m$2(t,s,i,a){const o=kt;return e(o.rings[0][0],t),e(o.rings[0][1],s),e(o.rings[0][2],i),e(o.rings[0][3],t),o.spatialReference=a,Ct(o)}const kt={hasM:!1,hasZ:!0,rings:[[o(),o(),o(),o()]],spatialReference:null,type:"polygon"},Ht=o();class J{get numVertices(){return this._length}get hasStagedVertex(){return this._hasCursorPoint}constructor(e){this.validMeasurement=!1,this.positionsWorld=[],this.positionsRender=[],this.positionsFittedWorld=[],this.positionsFittedRender=[],this.positionsGeodesic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=o(),this.areaCentroidRenderCoords=o(),this.geodesicAreaCentroidRenderCoords=o(),this.fittingMode=null,this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=o(),this._planeWorldCoords=S(),this._worldUp=o(),this._worldTangent=o(),this._frame=[o(),o(),o()],this._pathVersion=-1,this._hasCursorPoint=!1,this._mode=null,this._tempU=o(),this._tempV=o(),this._tempVec3=o(),this._tempSphere=M(),this._sceneView=e;const t=P(e.spatialReference);this._measurementSR=t,this._lengthMeasurementUnit=C(t)??"meters",this._areaMeasurementUnit=V(t)??"square-meters"}update(e,t,s,i,a,o){const l=null!=t,d=this._pathVersion===e.version,p=this._hasCursorPoint===l,y=this._mode===a;return!(d&&!o&&p&&y&&e.isValidPolygon||(this._pathVersion=e.version,this._hasCursorPoint=l,this._updateCursorSegmentLength(e,t),this._update(e,t,s,i,a),0))}_update(e,t,s,i,o){const l=this._sceneView.renderSpatialReference,d=this._measurementSR,p=s.spatialReference;let y=e.numVertices;const v=!(null==t||t.equals(e.lastPoint)||y>2&&t.equals(e.firstPoint));v&&(y+=1);const w=!e.polygonIsClosed&&y>2,L=e.polygonIsClosed||w;this._resize(y);const S=b(p),M=null!=p&&bt(p)?p:null,P=null!=M&&A(p,S),{positionsGeodesic:C,positionsWorld:V,positionsRender:D,positionsSpherical:G}=this,P2=(e,t)=>{(function K(e,t){t.hasZ||(t.z=ie(e,t,"ground")??0)})(s.elevationProvider,e),se(e,V[t],d),se(e,D[t],l),P&&(se(e,C[t],M),se(e,G[t],S),a(G[t],G[t]))};e.forEachVertexPosition(((e,t)=>P2(e,t))),v&&P2(t,y-1);const R=this._updatePathLengths(L);if(this.pathLength=this._length>1?x(R,this._lengthMeasurementUnit):null,P){const e=this._updateGeodesicPathLengths(L,M);this.geodesicPathLength=null!=e&&this._length>1?e:null}else this.geodesicPathLength=null;if(this._updateMode(o),!L)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),void(this.validMeasurement=!1);this._updateAreaAndPerimeterLength(s,l,d,i),P&&this._updateGeodesicArea(s,M),this.validMeasurement=!0}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,positionsRender:this.positionsRender,positionsFittedWorld:this.positionsFittedWorld,positionsFittedRender:this.positionsFittedRender,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorld.length=e,this.positionsRender.length=e,this.positionsFittedWorld.length=e,this.positionsFittedRender.length=e,this.positionsGeodesic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorld.push(o()),this.positionsRender.push(o()),this.positionsFittedWorld.push(D()),this.positionsFittedRender.push(o()),this.positionsGeodesic.push(o()),this.positionsSpherical.push(o()),this.positionsStereographic.push(D()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorld,s=this.pathSegmentLengths;let i=0;const a=this._length;for(let o=0;o<a;++o){const l=s[o]=G(t[o],t[(o+1)%a]);(o<a-1||e)&&(i+=l)}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeodesic,i=this.geodesicPathSegmentLengths;let a=0;const o=this._length;for(let l=0;l<o;++l){const d=At(s[l],s[(l+1)%o],t);if(null==d)return null;const p=R(d,"meters").value,y=i[l]=p;(l<o-1||e)&&(a+=y)}return x(a,"meters")}_updateAreaAndPerimeterLength(a,o,l,p){const L=a.renderCoordsHelper,S=this.positionsWorld,M=this.positionsRender,P=this.positionsFittedWorld,C=this.positionsFittedRender,V=this._planeWorldCoords,b=this._centroidRenderCoords;O(M,b),L.worldUpAtPosition(b,this._worldUp),L.worldBasisAtPosition(b,F.X,this._worldTangent),f(b,this._worldUp,o,this._worldUp,l),f(b,this._worldTangent,o,this._worldTangent,l),S.length>2&&function h$1(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");y(e[0],e[1],e[2],t)}(S,V),this.fittingMode=this._selectFittingMode(V,S,this._worldUp,p);let A=0;if("horizontal"===this.fittingMode){let e=-1/0;M.forEach(((t,s)=>{const i=L.getAltitude(M[s]);i>e&&(e=i,A=s)}))}const x=S[A];let D=V,G=this._worldTangent;"horizontal"===this.fittingMode?D=this._worldUp:"vertical"===this.fittingMode&&(D=this._tempVec3,G=this._worldUp,q(V,this._worldUp,D)),e(this._frame[2],D),q(G,D,this._frame[0]),w(this._frame[1],this._frame[0],this._frame[2]),k(this._frame[1],this._frame[1]);const R=this._tempVec3,N=this._tempU,B=this._tempV;for(let e=0;e<this._length;++e){const a=P[e],p=C[e];i(R,S[e],x),H(a,v(this._frame[0],R),v(this._frame[1],R)),d(N,this._frame[0],a[0]),d(B,this._frame[1],a[1]),t(R,N,B),t(R,R,x),s(R,l,p,o)}this.perimeterLength=this._length>0?this._updatePerimeterLengths():null,O(C,this.areaCentroidRenderCoords),s(this.areaCentroidRenderCoords,o,this.areaCentroidWorldCoords,l),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?this._computeArea():null}_updateGeodesicArea(s,i){const{renderCoordsHelper:o,spatialReference:p}=s,{positionsSpherical:y,positionsStereographic:L}=this,S=this._tempVec3,M=function j(s,i=null,o=!0){const u2=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let s=0;s<e.length;++s)if(v(t,e[s])<-1e-6)return!1;return!0};if(0===s.length)return!1;if(1===s.length)return i&&e(i,s[0]),!0;l(Ht,0,0,0);for(let e=0;e<s.length;++e)t(Ht,Ht,s[e]);if(a(Ht,Ht),u2(s,Ht))return i&&e(i,Ht),!0;if(!o)return!1;for(let t=0;t<s.length;++t)for(let o=0;o<s.length;++o)if(t!==o&&(w(Ht,s[t],s[o]),a(Ht,Ht),u2(s,Ht)))return i&&e(i,Ht),!0;return!1}(y,S);if(!M)return void(this.geodesicArea=null);const P=this._tempU,C=this._tempV;N(S,P,C);for(let e=0;e<this._length;++e){const t=v(y[e],P),s=v(y[e],C),i=v(y[e],S);H(L[e],t/i,s/i)}d(S,S,B(p).radius),o.toRenderCoords(S,b(p),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=M&&0===this.geodesicIntersectingSegments.size?this._computeGeodesicArea(i):null}_updatePerimeterLengths(){const e=this.positionsFittedWorld,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i)s+=t[i]=$(e[i],e[(i+1)%this._length]);return x(s,this._lengthMeasurementUnit)}_updateIntersectingSegments(){const e=this.positionsFittedWorld,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const a=e[s],o=e[(s+1)%this._length],l=e[i],d=e[(i+1)%this._length];Q(a,o,l,d)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsFittedWorld,t=this.triangleIndices=Z(Vt(e));let s=0;for(let i=0;i<t.length;i+=3)s+=X(e[t[i]],e[t[i+1]],e[t[i+2]]);return Y(s,this._areaMeasurementUnit)}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const a=e[s],o=e[(s+1)%this._length],l=e[i],d=e[(i+1)%this._length];Q(a,o,l,d)&&(t.add(s),t.add(i))}}_computeGeodesicArea(e){const t=this.positionsGeodesic,s=this.positionsStereographic,i=this.geodesicTriangleIndices=Z(Vt(s));let a=0;for(let o=0;o<i.length;o+=3){const s=m$2(t[i[o]],t[i[o+1]],t[i[o+2]],e);if(null==s)return null;a+=R(s,"square-meters").value}return Y(a,"square-meters")}_selectFittingMode(e,s,i,a){const o=s.map((t=>Math.abs(function p$1(e,t){return v(e,t)+e[3]}(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);!function g$2(e,s){const i=L(s);l(i,0,0,0);for(let o=0;o<e.length;++o)t(i,i,e[o]);d(i,i,1/e.length);let a=0;for(let t=0;t<e.length;++t)a=Math.max(a,p(i,e[t]));s[3]=Math.sqrt(a)}(s,this._tempSphere);const y=o/(2*this._tempSphere[3]),w=y<a.maxRelativeErrorCoplanar,S=y<a.maxRelativeErrorAlmostCoplanar;let M="horizontal";return w?M="oblique":S&&(M=Math.abs(v(i,e))>Math.cos(ee(a.verticalAngleThreshold))?"horizontal":"vertical"),M}_updateCursorSegmentLength(e,t){var s;const i=e.lastPoint;e.isValidPolygon||null==i||null==t?(this.geodesicStagedSegmentLength=null,this.stagedSegmentLength=null):(this.geodesicStagedSegmentLength=xt(i,t),this.stagedSegmentLength=null==(s=te(i,t))?void 0:s.direct)}_updateMode(e){if(e===St.Auto){this.actualMeasurementMode="euclidean";let e=0;null!=this.geodesicPathLength&&(e+=this.geodesicPathLength.value),e>Nt&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=e===St.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=e}}const Nt=1e5;let Bt=class n extends oe{constructor(e){super(e)}initialize(){this._measurementDataManager=new J(this.view),this.addHandles([this.analysisViewData.path.on("change",(()=>this._update())),le((()=>this.analysisViewData.stagedPoint),(()=>this._update()),he),le((()=>this.analysisViewData.mode),(()=>this._update()),he)]),this._update()}_update(e=!1){const{analysisViewData:t,view:s}=this;this._measurementDataManager.update(t.path,t.stagedPoint,s,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80},t.mode,e)&&(t.measurementData=this._measurementDataManager.getData())}};re([ne({constructOnly:!0})],Bt.prototype,"view",void 0),re([ne({constructOnly:!0})],Bt.prototype,"analysis",void 0),re([ne({constructOnly:!0})],Bt.prototype,"analysisViewData",void 0),Bt=re([ae("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")],Bt);let $t=class g extends de.EventedAccessor{constructor(e={}){super(e),this._version=0,this._internalGeometryChange=!1,this._extent=ce()}set areaMeasurement(e){this._set("areaMeasurement",e),null!=e&&null!=this.view&&this._initialize(e,this.view)}set view(e){this._set("view",e),null!=e&&null!=this.areaMeasurement&&this._initialize(this.areaMeasurement,e)}get constructed(){return null!=this.areaMeasurement&&null!=this.view}get version(){return this._version}get isEmptyPolygon(){return!this.constructed||0===this._editGeometry.components.length}get isValidPolygon(){return this.constructed&&this.polygonIsClosed}get extent(){if(this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].vertices.length>0){const e=ce(this._extent);return this.forEachVertex((t=>{ue(e,t.pos)})),e}return null}get spatialReference(){return this.constructed?this._editGeometry.coordinateHelper.spatialReference:null}_initialize(e,t){this.removeAllHandles(),this.addHandles(le((()=>e.geometry),(()=>{this._updateEditGeometryFromModelGeometry(e,t)}),pe)),this._makeDirty(!0)}_makeDirty(e=!1){this.notifyChange("polygonIsClosed"),this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),this.notifyChange("extent"),e&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(e,t){if(this._version++,this._internalGeometryChange)return;this.removeHandles("EditGeometry");let s=e.geometry;if(null!=s){const i=ge(s,t.spatialReference);null==i&&Dt(e,s.spatialReference,me.getLogger(this)),s=i}this._editGeometryOperations=null!=s?Gt.fromGeometry(s,t.state.viewingMode):new Gt(new Rt("polygon",Ot(!0,!1,t.spatialReference)),t.state.viewingMode),this._makeDirty(!0),this.emit("change"),this.addHandles(this._editGeometry.on("change",(t=>{this._makeDirty(null!=t.addedVertices||null!=t.removedVertices),this._internalGeometryChange=!0,e.geometry=this.numVertices>0?this._editGeometry.geometry:null,this._internalGeometryChange=!1})),"EditGeometry")}get _editGeometry(){return this._editGeometryOperations.data}get vertices(){const e=[];return this.forEachVertex((t=>{e.push(t)})),e}get numVertices(){return this.constructed&&this._editGeometry.components.length>0?this._editGeometry.components[0].vertices.length:0}get polygonIsClosed(){return this._editGeometry.components.length>0&&this._editGeometry.components[0].isClosed()}get firstPoint(){if(this.constructed&&this._editGeometry.components.length>0){const e=this._editGeometry.components[0].getFirstVertex();if(null!=e)return this._editGeometry.coordinateHelper.vectorToPoint(e.pos)}return null}get lastPoint(){if(this.constructed&&this._editGeometry.components.length>0){const e=this._editGeometry.components[0].getLastVertex();if(null!=e)return this._editGeometry.coordinateHelper.vectorToPoint(e.pos)}return null}getVertex(e){if(!this.constructed||0===this._editGeometry.components.length||0===this._editGeometry.components[0].vertices.length)return null;const t=this._editGeometry.components[0].vertices[0];let s=t;do{if(s.index===e)return s;s=s.rightEdge.rightVertex}while(s!==t&&null!=s);return null}getVertexPositionAsPoint(e){return this._editGeometry.coordinateHelper.vectorToPoint(e.pos)}getVertexPositionAsPointFromIndex(e){return this._editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e).pos)}forEachVertex(e){this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].iterateVertices(e)}forEachVertexPosition(e){const t=this._editGeometry.coordinateHelper;this.forEachVertex(((s,i)=>{t.vectorToPoint(s.pos,Jt),e(Jt,i)}))}clear(){null!=this.areaMeasurement&&(this.areaMeasurement.geometry=null)}add(e){if(!this.constructed)return null;if(0===this._editGeometry.components.length){const e=this.view;this._editGeometry.components.push(new Et(e.spatialReference,e.state.viewingMode))}const t=this._editGeometryOperations.appendVertex(this._editGeometry.coordinateHelper.pointToVector(e));return this.emit("change"),t}close(){if(!this.constructed||0===this._editGeometry.components.length)return null;const e=this._editGeometryOperations.closeComponent(this._editGeometry.components[0]);return this.emit("change"),e}ensureContains(e,t=""){let s=!1;if(this._editGeometry.components.forEach((t=>{t.iterateVertices((t=>{t===e&&(s=!0)}))})),!s)throw new Error(`vertex doesnt exist ${t}`);return s}setVertexPosition(e,t){if(!this.constructed)return null;const s=this._editGeometryOperations.setVertexPosition(e,this._editGeometry.coordinateHelper.pointToVector(t));return this.emit("change"),s}equals(e){if(this.numVertices!==e.numVertices)return!1;let t=!0;return this.forEachVertexPosition(((s,i)=>{const a=e.getVertexPositionAsPointFromIndex(i);s.equals(a)||(t=!1)})),!!t}};re([ne({value:null})],$t.prototype,"areaMeasurement",null),re([ne({value:null})],$t.prototype,"view",null),re([ne()],$t.prototype,"isEmptyPolygon",null),re([ne()],$t.prototype,"isValidPolygon",null),re([ne()],$t.prototype,"extent",null),re([ne()],$t.prototype,"spatialReference",null),re([ne()],$t.prototype,"numVertices",null),re([ne()],$t.prototype,"polygonIsClosed",null),$t=re([ae("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementPathHelper")],$t);const Jt=new _e;function n2(e){const t=new ye,{vertex:s,fragment:i}=t;return fe(s,e),t.attributes.add(ve.POSITION,"vec3"),t.attributes.add(ve.UV0,"vec2"),t.varyings.add("vUV","vec2"),e.multipassEnabled&&t.varyings.add("depth","float"),s.code.add(we`
    void main(void) {
      vUV = uv0;
      ${e.multipassEnabled?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),t.include(Le,e),i.uniforms.add(new Se("size",(e=>e.size))),i.uniforms.add(new Me("color1",(e=>e.color1))),i.uniforms.add(new Me("color2",(e=>e.color2))),i.include(Pe),e.transparencyPassType===Ce.ColorAlpha&&(t.outputs.add("fragColor","vec4",0),t.outputs.add("fragAlpha","float",1)),i.code.add(we`
    void main() {
      ${e.multipassEnabled?"terrainDepthTest(depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      fragColor = mix(color2, color1, t);
      ${e.transparencyPassType===Ce.ColorAlpha?we`
              fragColor = premultiplyAlpha(fragColor);
              fragAlpha = fragColor.a;`:""}
    }
  `),t}const Kt=Object.freeze(Object.defineProperty({__proto__:null,build:n2},Symbol.toStringTag,{value:"Module"}));class h extends De{initializeProgram(e){return new Ge(e.rctx,h.shader.get().build(this.configuration),Re)}_setPipelineState(e){const t=this.configuration,s=e===Ce.NONE,i=e===Ce.FrontFace;return Oe({blending:t.transparent?s?Zt:Ee(e):null,depthTest:{func:Ie(e)},depthWrite:s?t.writeDepth?Te:null:ze(e),drawBuffers:je(e),colorWrite:Ue,polygonOffset:s||i?t.polygonOffset?Qt:null:{factor:-1,units:-25}})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}h.shader=new Ve(Kt,(()=>be((()=>Promise.resolve().then((()=>as))),void 0)));const Qt={factor:0,units:-25},Zt=Ae(xe.SRC_ALPHA,xe.ONE,xe.ONE_MINUS_SRC_ALPHA,xe.ONE_MINUS_SRC_ALPHA);class r extends We{constructor(){super(...arguments),this.transparencyPassType=Ce.NONE,this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.multipassEnabled=!1,this.cullAboveGround=!1}}re([Fe({count:Ce.COUNT})],r.prototype,"transparencyPassType",void 0),re([Fe()],r.prototype,"transparent",void 0),re([Fe()],r.prototype,"writeDepth",void 0),re([Fe()],r.prototype,"polygonOffset",void 0),re([Fe()],r.prototype,"multipassEnabled",void 0),re([Fe()],r.prototype,"cullAboveGround",void 0),re([Fe({constValue:!1})],r.prototype,"occlusionPass",void 0);class u extends qe{constructor(e){super(e,new Xt),this.produces=new Map([[ke.OPAQUE_MATERIAL,e=>He(e)&&!this.parameters.transparent],[ke.TRANSPARENT_MATERIAL,e=>He(e)&&this.parameters.transparent&&this.parameters.writeDepth],[ke.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,e=>He(e)&&this.parameters.transparent&&!this.parameters.writeDepth]]),this._configuration=new r}getConfiguration(e,t){return this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}createGLMaterial(e){return new c(e)}createBufferWriter(){return new Ne(Be)}}class c extends $e{beginSlot(e){return this.ensureTechnique(h,e)}}let Xt=class m extends Je{constructor(){super(...arguments),this.size=Ke(1,1),this.color1=Qe(.75,.75,.75,1),this.color2=Qe(.5,.5,.5,1),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1}};class _ extends Ut{constructor(e){super(e),this._checkerBoardMaterial=null,this._renderOccluded=Ze.OccludeAndTransparent,this._geometry=null,this._size=Ke(1,1),this._color1=Qe(1,.5,0,.5),this._color2=Qe(1,1,1,.5),this.applyProperties(e)}get renderOccluded(){return this._renderOccluded}set renderOccluded(e){e!==this._renderOccluded&&(this._renderOccluded=e,this._updateMaterial())}get geometry(){return this._geometry}set geometry(e){this._geometry=e,this.recreateGeometry()}get size(){return this._size}set size(e){Xe(this._size,e),this._updateMaterial()}get color1(){return this._color1}set color1(e){Ye(e,this._color1)||(et(this._color1,e),this._updateMaterial())}get color2(){return this._color2}set color2(e){Ye(e,this._color2)||(et(this._color2,e),this._updateMaterial())}_updateMaterial(){null!=this._checkerBoardMaterial&&this._checkerBoardMaterial.setParameters({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new u({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:Ze.OccludeAndTransparent,isDecoration:this.isDecoration})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(e){null!=this._checkerBoardMaterial&&e(this._checkerBoardMaterial)}createGeometries(e){if(null==this._geometry||null==this._checkerBoardMaterial)return;const t=Yt;tt(t,this.transform);const s=this._geometry,a=[],l=o();s.position.forEach((e=>{i(l,e,t),a.push(l[0],l[1],l[2])}));const d=[];s.uv.forEach((e=>{d.push(e[0],e[1])}));const p=new st(this._checkerBoardMaterial,[[ve.POSITION,new it(a,s.triangleIndices,3,!0)],[ve.UV0,new it(d,s.triangleIndices,2,!0)]]);e.addGeometry(p)}}const Yt=o();let es=class extends oe{get _parameters(){const{accentColor:e,textColor:t}=this.view.effectiveTheme,s=rt(e),i=nt(e,.5),a=nt(at(e),.5),o=at(t,ot.Low);return{accentColor:s,transparentAccentColor:i,transparentContrastColor:a,intersectingLineColor:[1,.2,0,1],textColor:t,textBackgroundColor:lt(o,.6),textCalloutColor:lt(o,.5),pathLineWidth:3,perimeterLineWidth:2,projectionLineWidth:2,projectionLineStippleSize:5,labelDistance:25}}get visible(){return this.analysisViewData.visible}get _renderUnits(){const e=this.view.renderCoordsHelper.spatialReference;return C(e)??"meters"}get testData(){}constructor(e){super(e),this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._origin=o(),this._originTransform=ht(),this.messages=null,this.viewData=is,this.areaLabel=null,this.perimeterLengthLabel=null,this.loadingMessages=!0}initialize(){const{analysisViewData:e,_parameters:t,view:s}=this;this._path=new Ft({view:s,attached:!0,width:t.pathLineWidth,polygonOffset:!0,renderOccluded:Ze.OccludeAndTransparent,isDecoration:!0}),this._intersectedPath=new Ft({view:s,attached:!0,width:t.pathLineWidth,polygonOffset:!0,renderOccluded:Ze.OccludeAndTransparent,isDecoration:!0}),this._perimeter=new Ft({view:s,attached:!0,width:t.perimeterLineWidth,polygonOffset:!0,renderOccluded:Ze.OccludeAndTransparent,isDecoration:!0}),this._intersectedPerimeter=new Ft({view:s,attached:!0,width:t.perimeterLineWidth,color:t.intersectingLineColor,polygonOffset:!0,renderOccluded:Ze.OccludeAndTransparent,isDecoration:!0}),this._projectionLines=new Ft({view:s,attached:!0,width:t.projectionLineWidth,stipplePattern:dt(t.projectionLineStippleSize),polygonOffset:!0,renderOccluded:Ze.OccludeAndTransparent,isDecoration:!0}),this._measurementArea=new _({view:s,attached:!0,isDecoration:!0});const i={attached:!0,view:s,isDecoration:!0};this._areaLabel=new Tt({...i,fontSize:ts.Large}),this._perimeterLengthLabel=new Tt({...i,fontSize:ts.Small}),this.addHandles([le((()=>[e.mode,this.visible,e.unit,e.measurementData,e.stagedPoint]),(()=>this._update()),pe),le((()=>{var e;return null==(e=s.state)?void 0:e.camera}),(()=>this._updateLabels()),pe),ct((()=>this._updateMessageBundle())),le((()=>this._parameters),(({accentColor:e,transparentAccentColor:t,transparentContrastColor:s,textColor:i,textBackgroundColor:a,textCalloutColor:o})=>{const{_path:l,_intersectedPath:d,_perimeter:p,_projectionLines:y,_measurementArea:v,_areaLabel:w,_perimeterLengthLabel:L}=this;l.color=e,d.color=e,p.color=e,y.color=e,v.color1=t,v.color2=s,w.textColor=i,w.backgroundColor=a,w.calloutColor=o,L.textColor=i,L.backgroundColor=a,L.calloutColor=o}),ut)]),this._updateMessageBundle()}destroy(){this._measurementArea=pt(this._measurementArea),this._path=pt(this._path),this._intersectedPath=pt(this._intersectedPath),this._perimeter=pt(this._perimeter),this._intersectedPerimeter=pt(this._intersectedPerimeter),this._areaLabel=pt(this._areaLabel),this._perimeterLengthLabel=pt(this._perimeterLengthLabel),this._projectionLines=pt(this._projectionLines),this.set("view",null)}_update(){if(this.destroyed||!this.view.ready||!this.view.renderCoordsHelper)return;const{analysisViewData:{measurementData:e},analysisViewData:t}=this;null!=e&&(this._updateViewData(e,t.path),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(e,t){const s=e.validMeasurement,i="geodesic"===e.actualMeasurementMode,a=i?e.geodesicArea:e.area;let o=1;if(a){const e=function I(e,t){return R(e,U(e,t))}(a,this.analysisViewData.unit);o=Lt(Math.sqrt(e.value)/Math.sqrt(300)),o*=Math.sqrt(gt(1,e.unit,"square-meters")),o=gt(o,"meters",this._renderUnits)}const l={validMeasurement:s,numVertices:e.numVertices,hasStagedVertex:e.hasStagedVertex,path:t,mode:e.actualMeasurementMode,positionsRender:e.positionsRender,positionsFittedWorld:e.positionsFittedWorld,positionsFittedRender:e.positionsFittedRender,intersectingSegments:i?e.geodesicIntersectingSegments:e.intersectingSegments,triangleIndices:i?e.geodesicTriangleIndices:e.triangleIndices,areaCentroid:i?e.geodesicAreaCentroidRenderCoords:e.areaCentroidRenderCoords,perimeterLengthLabelSegmentIndex:0,area:i?e.geodesicArea:e.area,pathLength:i?e.geodesicPathLength:e.pathLength,perimeterLength:e.perimeterLength,checkerSize:o};this._set("viewData",l)}_updateOrigin(){const e=this.viewData;O(e.positionsRender,this._origin),mt(this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(e){const t=this.viewData,s=this.view.renderCoordsHelper.spatialReference,i=t.mode,a=[],o=[],l=[],d=t.numVertices,p=t.validMeasurement?d:d-1;for(let v=0;v<p;++v){const p=t[e][v],y=t[e][(v+1)%d];let w=null;switch(i){case"euclidean":w=new jt(p,y);break;case"geodesic":w=new zt(p,y,s)}t.intersectingSegments.has(v)?l.push(w):o.push(w),a.push(w)}let y=null;return t.validMeasurement&&t.hasStagedVertex&&p>=2?y=a[a.length-2]:t.hasStagedVertex&&p>=1&&(y=a[a.length-1]),{all:a,nonIntersecting:o,intersecting:l,stagedSegment:y}}_updatePathSegments(){const{visible:e}=this,t=this._createSegments("positionsRender");this._path.setGeometryFromSegments(t.nonIntersecting,this._origin),this._path.visible=e,this._intersectedPath.setGeometryFromSegments(t.intersecting,this._origin),this._intersectedPath.visible=e,this._pathSegments=t.all}_updatePerimeterSegments(){const e=this.visible&&"euclidean"===this.viewData.mode,t=this._createSegments("positionsFittedRender");this._perimeter.setGeometryFromSegments(t.nonIntersecting,this._origin),this._perimeter.visible=e,this._intersectedPerimeter.setGeometryFromSegments(t.intersecting,this._origin),this._intersectedPerimeter.visible=e,this._perimeterSegments=t.all}_updateArea(){const e=this.viewData;switch(e.mode){case"euclidean":this._updateAreaEuclidean(e);break;case"geodesic":this._updateAreaGeodesic()}}_updateAreaEuclidean(e){const t=this.visible;e.validMeasurement&&0===e.intersectingSegments.size&&e.triangleIndices?(this._measurementArea.geometry={uv:e.positionsFittedWorld,position:e.positionsFittedRender,triangleIndices:e.triangleIndices},this._measurementArea.size=[e.checkerSize,e.checkerSize],this._measurementArea.visible=t):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const e=this.viewData,t=this.visible,s=e.mode,a=e.numVertices;if(a>0&&e.validMeasurement&&"euclidean"===s){const s=[];for(let t=0;t<a;++t){const a=o();i(a,e.positionsRender[t],this._origin);const l=o();i(l,e.positionsFittedRender[t],this._origin),s.push([a,l])}this._projectionLines.geometry=s,this._projectionLines.visible=t}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const{viewData:e}=this,{area:t,path:s}=e;if(!s)return;const i=this.visible,a=function z(e,t,s){return e&&t&&It(e,t,U(t,s))}(this.messages,t,this.analysisViewData.unit);if(null!=a?(this._areaLabel.geometry={type:"point",point:e.areaCentroid},this._areaLabel.text=a,this._areaLabel.visible=e.validMeasurement&&0===e.intersectingSegments.size&&i):this._areaLabel.visible=!1,this._set("areaLabel",a),e.validMeasurement&&0===e.intersectingSegments.size){const t="geodesic"===e.mode||!e.validMeasurement,s=t?e.pathLength:e.perimeterLength,a=function W(e,t,s){return e&&t&&It(e,t,function T(e,t){const s=function E(e){switch(e){case"metric":case"ares":case"hectares":return"metric";case"imperial":case"acres":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers"}throw new Error("unhandled area unit")}(t);switch(s){case"metric":return wt(e.value,e.unit);case"imperial":return vt(e.value,e.unit);default:return s}}(t,s))}(this.messages,s,this.analysisViewData.unit);this._set("perimeterLengthLabel",a),this._perimeterLengthLabel.distance=this._parameters.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=a,this._perimeterLengthLabel.visible=!0;let o=!0;for(let i=0;i<e.numVertices;++i){const s=(e.perimeterLengthLabelSegmentIndex+i)%e.numVertices,a=t?this._pathSegments[s]:this._perimeterSegments[s];if(o=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:a,sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;o=!1}this._perimeterLengthLabel.visible=o&&i}else this._perimeterLengthLabel.visible=!1}_updateMessageBundle(){this.loadingMessages=!0,_t("esri/core/t9n/Units").then((e=>{this.messages=e,this.view&&this._update()})).finally((()=>{this.loadingMessages=!1}))}};function U(e,t){switch(t){case"metric":return ft(e.value,e.unit);case"imperial":return yt(e.value,e.unit);default:return t}}var ts,ss;re([ne()],es.prototype,"_parameters",null),re([ne()],es.prototype,"view",void 0),re([ne()],es.prototype,"messages",void 0),re([ne()],es.prototype,"analysis",void 0),re([ne()],es.prototype,"viewData",void 0),re([ne()],es.prototype,"analysisViewData",void 0),re([ne({readOnly:!0})],es.prototype,"areaLabel",void 0),re([ne({readOnly:!0})],es.prototype,"perimeterLengthLabel",void 0),re([ne()],es.prototype,"loadingMessages",void 0),re([ne()],es.prototype,"visible",null),re([ne()],es.prototype,"_renderUnits",null),es=re([ae("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")],es),(ss=ts||(ts={}))[ss.Small=12]="Small",ss[ss.Large=16]="Large";const is={validMeasurement:!1,numVertices:0,hasStagedVertex:!1,path:null,mode:null,positionsRender:null,positionsFittedWorld:null,positionsFittedRender:null,intersectingSegments:null,triangleIndices:null,areaCentroid:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null,area:null,pathLength:null,perimeterLength:null};let rs=class extends(Pt(oe)){constructor(e){super(e),this.type="area-measurement-view-3d",this.analysis=null,this.measurementData=null,this.lastDraggedVertex=null,this.stagedPoint=null,this.mode=St.Auto}initialize(){const{analysis:e,view:t}=this;this.path=new $t({view:t,areaMeasurement:e}),this.analysisVisualization=new es({view:t,analysis:e,analysisViewData:this}),this.analysisController=new Bt({view:t,analysis:e,analysisViewData:this})}destroy(){this.analysisController=pt(this.analysisController),this.analysisVisualization=pt(this.analysisVisualization),this.path.destroy()}get updating(){var e;return!!(null==(e=this.analysisVisualization)?void 0:e.loadingMessages)}get result(){const{measurementData:e}=this;return null==e?{area:null,mode:null,perimeter:null}:"euclidean"===e.actualMeasurementMode?{area:e.area,perimeter:e.perimeterLength,mode:"euclidean"}:{area:e.geodesicArea,perimeter:e.pathLength,mode:"geodesic"}}get viewData(){return this.analysisVisualization.viewData}get validMeasurement(){return this.path.isValidPolygon}get unit(){return this.analysis.unit??this._defaultUnit}get testData(){}};re([ne({readOnly:!0})],rs.prototype,"type",void 0),re([ne({constructOnly:!0,nonNullable:!0})],rs.prototype,"analysis",void 0),re([ne()],rs.prototype,"updating",null),re([ne()],rs.prototype,"analysisVisualization",void 0),re([ne()],rs.prototype,"analysisController",void 0),re([ne()],rs.prototype,"result",null),re([ne()],rs.prototype,"measurementData",void 0),re([ne()],rs.prototype,"viewData",null),re([ne()],rs.prototype,"validMeasurement",null),re([ne()],rs.prototype,"path",void 0),re([ne()],rs.prototype,"lastDraggedVertex",void 0),re([ne()],rs.prototype,"stagedPoint",void 0),re([ne()],rs.prototype,"mode",void 0),re([ne()],rs.prototype,"unit",null),re([ne(Mt)],rs.prototype,"_defaultUnit",void 0),rs=re([ae("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")],rs);const ns=rs,as=Object.freeze(Object.defineProperty({__proto__:null,build:n2},Symbol.toStringTag,{value:"Module"}));export{ns as default};
