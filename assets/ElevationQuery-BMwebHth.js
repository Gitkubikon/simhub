import{hV as e,b as i,fO as n,d8 as s,hW as a,hH as o,hX as r,gQ as c,er as u,hY as h,cG as f,hr as p,ay as m,ax as d,aw as y,hZ as R,d9 as V}from"./index-DSIPxOWi.js";class t{constructor(i,n=null){if(this.tile=i,null!=n&&null!=i){const s=i.extent;this._samplerData=new e(n,s)}}get zmin(){return null!=this._samplerData?this._samplerData.data.minValue:0}get zmax(){return null!=this._samplerData?this._samplerData.data.maxValue:0}get hasNoDataValues(){var e;return!!(null==(e=this._samplerData)?void 0:e.data.hasNoDataValues)}sample(e,i){if(null==this._samplerData)return;const{safeWidth:n,data:s,dx:a,dy:o,y1:r,x0:c}=this._samplerData,{width:u,values:h,noDataValue:f}=s,p=l(o*(r-i),0,n),m=l(a*(e-c),0,n),d=Math.floor(p),y=Math.floor(m),R=d*u+y,V=R+u,O=h[R],P=h[V],Z=h[R+1],$=h[V+1];if(O!==f&&P!==f&&Z!==f&&$!==f){const e=m-y,i=O+(Z-O)*e;return i+(P+($-P)*e-i)*(p-d)}}}function l(e,i,n){return e<i?i:e>n?n:e}class T{async queryAll(e,n,s){if(!(e=(null==s?void 0:s.ignoreInvisibleLayers)?e.filter((e=>e.visible)):e.slice()).length)throw new i("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const a=w.fromGeometry(n);let o=!1;(null==s?void 0:s.returnSampleInfo)||(o=!0);const r={...O,...s,returnSampleInfo:!0},c=await this.query(e[e.length-1],a,r),u=await this._queryAllContinue(e,c,r);return u.geometry=u.geometry.export(),o&&delete u.sampleInfo,u}async query(e,a,o){if(!e)throw new i("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!a||!(a instanceof w)&&"point"!==a.type&&"multipoint"!==a.type&&"polyline"!==a.type)throw new i("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const c={...O,...o},u=new x(e,a.spatialReference,c),h=c.signal;return await e.load({signal:h}),await async function q(e,a,o){let r;const c=e.layer.tileInfo.spatialReference;if(a instanceof w?r=await a.project(c,o):(await n([{source:a.spatialReference,dest:c}],{signal:o}),r=s(a,c)),!r)throw new i("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${a.spatialReference.wkid}' on an elevation service in '${c.wkid}'`);e.geometry=w.fromGeometry(r)}(u,a,h),await this._selectTiles(u,h),await F(u,h),function j(e){e.geometry.coordinates.forEach((i=>{const n=i.elevationTile;let s=e.options.noDataValue;if(n){const e=n.sample(i.x,i.y);null!=e?s=e:i.elevationTile=null}i.z=s}))}(u),async function b(e,i){const n=await e.geometry.project(e.outSpatialReference,i);r(n);const s={geometry:n.export(),noDataValue:e.options.noDataValue};return e.options.returnSampleInfo&&(s.sampleInfo=function k(e){const i=e.layer.tileInfo,n=V(i.spatialReference);return e.geometry.coordinates.map((s=>{let a=-1;return s.elevationTile&&s.elevationTile!==e.outsideExtentTile&&(a=i.lodAt(s.elevationTile.tile.level).resolution*n),{demResolution:a}}))}(e)),e.geometry.coordinates.forEach((e=>{e.tile=null,e.elevationTile=null})),s}(u,h)}async createSampler(e,n,s){if(!e)throw new i("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!n||"extent"!==n.type)throw new i("elevation-query:invalid-extent","Invalid or undefined extent");const a={...O,...s};return this._createSampler(e,n,a)}async createSamplerAll(e,n,s){if(!(e=(null==s?void 0:s.ignoreInvisibleLayers)?e.filter((e=>e.visible)):e.slice()).length)throw new i("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!n||"extent"!==n.type)throw new i("elevation-query:invalid-extent","Invalid or undefined extent");const a={...O,...s,returnSampleInfo:!0},o=await this._createSampler(e[e.length-1],n,a);return this._createSamplerAllContinue(e,n,o,a)}async _createSampler(e,i,o,r){const c=o.signal;await e.load({signal:c});const u=i.spatialReference,h=e.tileInfo.spatialReference;u.equals(h)||(await n([{source:u,dest:h}],{signal:c}),i=s(i,h));const f=new _(e,i,o,r);return await this._selectTiles(f,c),await F(f,c),new a(f.elevationTiles,f.layer.tileInfo,f.options.noDataValue)}async _createSamplerAllContinue(e,i,n,s){if(e.pop(),!e.length)return n;const r=n.samplers.filter((e=>!e.tile.hasNoDataValues)).map((e=>o(e.extent))),c=await this._createSampler(e[e.length-1],i,s,r);if(0===c.samplers.length)return n;const u=n.samplers.concat(c.samplers),h=new a(u,s.noDataValue);return this._createSamplerAllContinue(e,i,h,s)}async _queryAllContinue(e,i,n){const s=e.pop(),a=i.geometry.coordinates,o=i.sampleInfo;r(o);const c=[],u=[];for(let r=0;r<a.length;r++){const i=o[r];i.demResolution>=0?i.source||(i.source=s):e.length&&(c.push(a[r]),u.push(r))}if(!e.length||0===c.length)return i;const h=i.geometry.clone(c),f=await this.query(e[e.length-1],h,n),p=f.sampleInfo;if(!p)throw new Error("no sampleInfo");return u.forEach(((e,i)=>{a[e].z=f.geometry.coordinates[i].z,o[e].demResolution=p[i].demResolution})),this._queryAllContinue(e,i,n)}async _selectTiles(e,n){"geometry"===e.type&&function I(e){if(null==e.layer.fullExtent)return;const i=new t(null);i.sample=()=>e.options.noDataValue,e.outsideExtentTile=i;const n=e.layer.fullExtent;e.geometry.coordinates.forEach((e=>{const s=e.x,a=e.y;(s<n.xmin||s>n.xmax||a<n.ymin||a>n.ymax)&&(e.elevationTile=i)}))}(e);const s=e.options.demResolution;if("number"==typeof s)!function C(e,i){const n=function A(e,i){const{tileInfo:n,tilemapCache:s}=e.layer,a=i/V(n.spatialReference),o=D(n,s);let r=o[0],c=0;for(let u=1;u<o.length;u++){const e=o[u];Math.abs(e.resolution-a)<Math.abs(r.resolution-a)&&(r=e,c=u)}return c}(e,i);e.selectTilesAtLOD(n)}(e,s);else if("finest-contiguous"===s)await this._selectTilesFinestContiguous(e,n);else{if("auto"!==s)throw new i("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${s}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(e,n)}}async _selectTilesFinestContiguous(e,i){const{tileInfo:n,tilemapCache:s}=e.layer,a=E(n,s,e.options.minDemResolution);await this._selectTilesFinestContiguousAt(e,a,i)}async _selectTilesFinestContiguousAt(e,n,s){const a=e.layer;if(e.selectTilesAtLOD(n),n<0)return;const o=a.tilemapCache,r=e.getTilesToFetch();try{if(o&&!L(o))await c(Promise.all(r.map((e=>o.fetchAvailability(e.level,e.row,e.col,{signal:s})))),s);else if(await F(e,s),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new i("elevation-query:has-unavailable-tiles")}catch(h){u(h),await this._selectTilesFinestContiguousAt(e,n-1,s)}}async _selectTilesAuto(e,i){(function M(e){const{tileInfo:i,tilemapCache:n}=e.layer,s=E(i,n,e.options.minDemResolution);e.selectTilesAtLOD(s,e.options.maximumAutoTileRequests)})(e),function S(e){const i=e.layer.tileInfo;let n=0;const s={},o2=e=>{null!=e.id&&(e.id in s?s[e.id]++:(s[e.id]=1,n++))},l2=e=>{if(null==e.id)return;const i=s[e.id];1===i?(delete s[e.id],n--):s[e.id]=i-1};e.forEachTileToFetch(o2,l2);let a=!0;for(;a&&(a=!1,e.forEachTileToFetch((s=>{n<=e.options.maximumAutoTileRequests||(l2(s),i.upsampleTile(s)&&(a=!0),o2(s))}),l2),a););}(e);const n=e.layer.tilemapCache;if(!n||L(n))return this._selectTilesAutoPrefetchUpsample(e,i);const s=e.getTilesToFetch(),a={},o=s.map((async e=>{const s=new h(null,0,0,0,f()),o=await p(n.fetchAvailabilityUpsample(e.level,e.row,e.col,s,{signal:i}));!1!==o.ok?null!=e.id&&(a[e.id]=s):u(o.error)}));await c(Promise.all(o),i),e.remapTiles(a)}async _selectTilesAutoPrefetchUpsample(e,i){const n=e.layer.tileInfo;await F(e,i);let s=!1;e.forEachTileToFetch(((e,i)=>{n.upsampleTile(e)?s=!0:i()})),s&&await this._selectTilesAutoPrefetchUpsample(e,i)}}class w{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const i=new w;return i.geometry=this.geometry,i.spatialReference=this.spatialReference,i.coordinates=e||this.coordinates.map((e=>e.clone())),i._exporter=this._exporter,i}async project(e,i){if(this.spatialReference.equals(e))return this.clone();await n([{source:this.spatialReference,dest:e}],{signal:i});const a=new m({spatialReference:this.spatialReference,points:this.coordinates.map((e=>[e.x,e.y]))}),o=s(a,e);if(!o)return null;const r=this.coordinates.map(((e,i)=>{const n=e.clone(),s=o.points[i];return n.x=s[0],n.y=s[1],n})),c=this.clone(r);return c.spatialReference=e,c}static fromGeometry(e){const i=new w;if(i.geometry=e,i.spatialReference=e.spatialReference,e instanceof w)i.coordinates=e.coordinates.map((e=>e.clone())),i._exporter=(i,n)=>{const s=e.clone(i);return s.spatialReference=n,s};else switch(e.type){case"point":{const n=e,{hasZ:s,hasM:a}=n;i.coordinates=s&&a?[new v(n.x,n.y,n.z,n.m)]:s?[new v(n.x,n.y,n.z)]:a?[new v(n.x,n.y,null,n.m)]:[new v(n.x,n.y)],i._exporter=(i,n)=>e.hasM?new y(i[0].x,i[0].y,i[0].z,i[0].m,n):new y(i[0].x,i[0].y,i[0].z,n);break}case"multipoint":{const n=e,{hasZ:s,hasM:a}=n;i.coordinates=s&&a?n.points.map((e=>new v(e[0],e[1],e[2],e[3]))):s?n.points.map((e=>new v(e[0],e[1],e[2]))):a?n.points.map((e=>new v(e[0],e[1],null,e[2]))):n.points.map((e=>new v(e[0],e[1]))),i._exporter=(i,n)=>e.hasM?new m({points:i.map((e=>[e.x,e.y,e.z,e.m])),hasZ:!0,hasM:!0,spatialReference:n}):new m(i.map((e=>[e.x,e.y,e.z])),n);break}case"polyline":{const n=e,s=[],a=[],{hasZ:o,hasM:r}=e;let c=0;for(const e of n.paths)if(a.push([c,c+e.length]),c+=e.length,o&&r)for(const i of e)s.push(new v(i[0],i[1],i[2],i[3]));else if(o)for(const i of e)s.push(new v(i[0],i[1],i[2]));else if(r)for(const i of e)s.push(new v(i[0],i[1],null,i[2]));else for(const i of e)s.push(new v(i[0],i[1]));i.coordinates=s,i._exporter=(i,n)=>{const s=e.hasM?i.map((e=>[e.x,e.y,e.z,e.m])):i.map((e=>[e.x,e.y,e.z])),o=a.map((e=>s.slice(e[0],e[1])));return new d({paths:o,hasM:e.hasM,hasZ:!0,spatialReference:n})};break}}return i}}class v{constructor(e,i,n=null,s=null,a=null,o=null){this.x=e,this.y=i,this.z=n,this.m=s,this.tile=a,this.elevationTile=o}clone(){return new v(this.x,this.y,this.z,this.m)}}class g{constructor(e,i){this.layer=e,this.options=i}}class x extends g{constructor(e,i,n){super(e,n),this.outSpatialReference=i,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach((e=>e.tile=null));else{const{tileInfo:i,tilemapCache:n}=this.layer,s=D(i,n)[e].level;this.geometry.coordinates.forEach((e=>e.tile=i.tileAt(s,e.x,e.y)))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((e=>!e.elevationTile))}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){var i;for(const n of this.geometry.coordinates)!n.elevationTile&&(null==(i=n.tile)?void 0:i.id)&&(n.elevationTile=e[n.tile.id])}remapTiles(e){var i;for(const n of this.geometry.coordinates){const s=null==(i=n.tile)?void 0:i.id;n.tile=s?e[s]:null}}getTilesToFetch(){var e;const i={},n=[];for(const s of this.geometry.coordinates){const a=s.tile;if(!a)continue;const o=null==(e=s.tile)?void 0:e.id;s.elevationTile||!o||i[o]||(i[o]=a,n.push(a))}return n}forEachTileToFetch(e){for(const i of this.geometry.coordinates)i.tile&&!i.elevationTile&&e(i.tile,(()=>{i.tile=null}))}}class _ extends g{constructor(e,i,n,s){super(e,n),this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=i.clone().intersection(e.fullExtent),this.maskExtents=s}selectTilesAtLOD(e,i){const n=this._maximumLodForRequests(i),s=Math.min(n,e);s<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(s)}_maximumLodForRequests(e){const{tileInfo:i,tilemapCache:n}=this.layer,s=D(i,n);if(!e)return s.length-1;const a=this.extent;if(null==a)return-1;for(let o=s.length-1;o>=0;o--){const n=s[o],r=n.resolution*i.size[0],c=n.resolution*i.size[1];if(Math.ceil(a.width/r)*Math.ceil(a.height/c)<=e)return o}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(const i of this._candidateTiles){const n=i.id&&e[i.id];n&&(this._fetchedCandidates.add(i),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=z(this._candidateTiles.map((i=>e[i.id])))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,i){const n=this._candidateTiles;this._candidateTiles=[],n.forEach((n=>{if(this._fetchedCandidates.has(n))return void(i&&i(n));let s=!1;e(n,(()=>s=!0)),s?i&&i(n):this._candidateTiles.push(n)})),this._candidateTiles=z(this._candidateTiles,i)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;const i=this.extent;if(null==i)return;const{tileInfo:n,tilemapCache:s}=this.layer,a=D(n,s)[e],o=n.tileAt(a.level,i.xmin,i.ymin),r=o.extent;if(null==r)return;const c=a.resolution*n.size[0],u=a.resolution*n.size[1],f=Math.ceil((i.xmax-r[0])/c),p=Math.ceil((i.ymax-r[1])/u);for(let m=0;m<p;m++)for(let e=0;e<f;e++){const i=new h(null,o.level,o.row-m,o.col+e);n.updateTileInfo(i),this._tileIsMasked(i)||this._candidateTiles.push(i)}}_tileIsMasked(e){return!!this.maskExtents&&this.maskExtents.some((i=>e.extent&&R(i,e.extent)))}}function E(e,i,n=0){const s=D(e,i);let a=s.length-1;if(n>0){const i=n/V(e.spatialReference),o=s.findIndex((e=>e.resolution<i));0===o?a=0:o>0&&(a=o-1)}return a}const O={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};function D(e,i){const n=e.lods;if(L(i)){const{effectiveMinLOD:e,effectiveMaxLOD:s}=i;return n.filter((i=>i.level>=e&&i.level<=s))}return n}async function F(e,i){const n=e.getTilesToFetch(),s={},a=e.options.cache,o=e.options.noDataValue,r=n.map((async n=>{if(null==n.id)return;const r=`${e.layer.uid}:${n.id}:${o}`,c=null!=a?a.get(r):null,u=null!=c?c:await e.layer.fetchTile(n.level,n.row,n.col,{noDataValue:o,signal:i});null!=a&&a.put(r,u),s[n.id]=new t(n,u)}));await c(Promise.allSettled(r),i),e.populateElevationTiles(s)}function z(e,i){const n={},s=[];for(const o of e){const e=o.id;e&&!n[e]?(n[e]=o,s.push(o)):i&&i(o)}const a=s.sort(((e,i)=>e.level-i.level));return a.filter(((e,n)=>{for(let s=0;s<n;s++){const n=a[s].extent;if(n&&e.extent&&R(n,e.extent))return i&&i(e),!1}return!0}))}function L(e){return null!=(null==e?void 0:e.tileInfo)}export{T as ElevationQuery,w as GeometryDescriptor,E as getFinestLodIndex};
