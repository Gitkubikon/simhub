import{hI as t,hJ as e,hK as r,hL as s,Q as a,O as u,H as c,hM as l,hN as f,hO as g,hP as m,dy as p,hQ as d,hR as y}from"./index-DSIPxOWi.js";import{geodesicArea as M}from"./geometryEngine-Bp1TD6MM.js";import{p as R,y as C}from"./geodesicLengthMeasurementUtils-Pq-FipkN.js";function o(t){const{spatialReference:e}=t;return R(e,n,i,t)}function n(e){return t(Math.abs(C([e],"square-meters")[0]),"square-meters")}function i(e){try{return t(Math.abs(M(e,"square-meters")),"square-meters")}catch(r){return null}}function j(e,M={positionsWorldCoords:[]}){return function h(e,M,R=e.hasZ){const C=r(e.spatialReference),x=s(C);if(null==x)return null;const q2=(t,e)=>!(e.length<2||(u(t,e[0],e[1],R&&e[2]||0),0));let A=0;for(const t of e.rings){const r=t.length;if(r<3)continue;const{positionsWorldCoords:s}=M;for(;s.length<r;)s.push(a());const R=W,x=u(b,0,0,0),L=1/r;for(let a=0;a<r;a++){if(!q2(R,t[a]))return null;if(!c(R,e.spatialReference,s[a],C))return null;l(x,x,s[a],L)}const O=f(s[0],s[1],x,g());if(0===m(p(O)))continue;for(let t=0;t<r;t++)d(O,x,s[t],s[t]);const Q=k(s);for(let t=0;t<Q.length;t+=3)A+=y(s[Q[t]],s[Q[t+1]],s[Q[t+2]])}return t(A,x)}(e,M,!1)}const W=a(),b=a();function U(){return{positionsWorldCoords:[]}}function k(t){return e(function q(t){const e=new Float64Array(2*t.length);for(let r=0;r<t.length;++r){const s=t[r],a=2*r;e[a]=s[0],e[a+1]=s[1]}return e}(t),[],2)}export{U,j,k,o};
