import{aw as e,j as n,ax as t,ay as o,az as i}from"./index-DSIPxOWi.js";const r={convertToGEGeometry:function s(e,n){if(null==n)return null;let t="cache"in n?n.cache._geVersion:void 0;return null==t&&(t=e.convertJSONToGeometry(n),"cache"in n&&(n.cache._geVersion=t)),t},exportPoint:function a(n,t,o){const i=n.hasZ(t),r=n.hasM(t),g=new e({x:n.getPointX(t),y:n.getPointY(t),spatialReference:o});return i&&(g.z=n.getPointZ(t)),r&&(g.m=n.getPointM(t)),g.cache._geVersion=t,g},exportPolygon:function c(e,t,o){const i=new n({rings:e.exportPaths(t),hasZ:e.hasZ(t),hasM:e.hasM(t),spatialReference:o});return i.cache._geVersion=t,i},exportPolyline:function h(e,n,o){const i=new t({paths:e.exportPaths(n),hasZ:e.hasZ(n),hasM:e.hasM(n),spatialReference:o});return i.cache._geVersion=n,i},exportMultipoint:function m(e,n,t){const i=new o({hasZ:e.hasZ(n),hasM:e.hasM(n),points:e.exportPoints(n),spatialReference:t});return i.cache._geVersion=n,i},exportExtent:function x(e,n,t){const o=e.hasZ(n),r=e.hasM(n),g=new i({xmin:e.getXMin(n),ymin:e.getYMin(n),xmax:e.getXMax(n),ymax:e.getYMax(n),spatialReference:t});if(o){const t=e.getZExtent(n);g.zmin=t.vmin,g.zmax=t.vmax}if(r){const t=e.getMExtent(n);g.mmin=t.vmin,g.mmax=t.vmax}return g.cache._geVersion=n,g}};export{r as hydratedAdapter};
