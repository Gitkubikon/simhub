const __vite__fileDeps=["assets/i3s-BPmjNSqG.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{_ as t,fS as r,I as n,fc as o,ka as s,kb as a,cs as f,kc as c,kd as g}from"./index-DSIPxOWi.js";import{r as w}from"./I3SNode-mlgend4K.js";var O,P,R;function i(t){return r(`esri/libs/i3s/${t}`)}let T,F,M;function E(t){if(!M)return;const r=t.modifications,n=M._malloc(8*r.length),o=new Float64Array(M.HEAPU8.buffer,n,r.length);for(let s=0;s<r.length;++s)o[s]=r[s];M.setModifications(t.context,n,r.length,t.isGeodetic),M._free(n)}function j(t,r,n){const{context:o,globalTrafo:s,mbs:a,obbData:f,elevationOffset:c,geometryBuffer:g,geometryDescriptor:w,indexToVertexProjector:P,vertexToRenderProjector:R}=r,T=t._malloc(g.byteLength),F=t._malloc(33*Float64Array.BYTES_PER_ELEMENT),M=new Uint8Array(t.HEAPU8.buffer,T,g.byteLength);M.set(new Uint8Array(g));const N=new Float64Array(t.HEAPU8.buffer,F,33);S(N,[NaN,NaN,NaN]);let v=N.byteOffset+3*N.BYTES_PER_ELEMENT,D=new Float64Array(N.buffer,v);S(D,s),v+=16*N.BYTES_PER_ELEMENT,D=new Float64Array(N.buffer,v),S(D,a),v+=4*N.BYTES_PER_ELEMENT,f&&(D=new Float64Array(N.buffer,v),S(D,f));const U=w,B={isDraco:!1,isLegacy:!1,color:r.layouts.some((t=>t.some((t=>"color"===t.name)))),normal:r.needNormals&&r.layouts.some((t=>t.some((t=>"normalCompressed"===t.name)))),uv0:r.layouts.some((t=>t.some((t=>"uv0"===t.name)))),uvRegion:r.layouts.some((t=>t.some((t=>"uvRegion"===t.name)))),featureIndex:U.featureIndex},C=t.process(o,!!r.obbData,T,M.byteLength,U,B,F,c,P,R,r.normalReferenceFrame);if(t._free(F),t._free(T),C.error.length>0)throw new Error(`i3s.wasm: ${C.error}`);if(C.discarded)return null;const V=C.componentOffsets.length>0?C.componentOffsets.slice():null,k=C.featureIds.length>0?C.featureIds.slice():null,H=C.anchorIds.length>0?Array.from(C.anchorIds):null,Y=C.anchors.length>0?Array.from(C.anchors):null,z=C.interleavedVertedData.slice().buffer,J=C.indicesType===O.Int16?new Uint16Array(C.indices.buffer,C.indices.byteOffset,C.indices.byteLength/2).slice():new Uint32Array(C.indices.buffer,C.indices.byteOffset,C.indices.byteLength/4).slice(),$=C.positions.slice(),G=C.positionIndicesType===O.Int16?new Uint16Array(C.positionIndices.buffer,C.positionIndices.byteOffset,C.positionIndices.byteLength/2).slice():new Uint32Array(C.positionIndices.buffer,C.positionIndices.byteOffset,C.positionIndices.byteLength/4).slice(),X={layout:r.layouts[0],interleavedVertexData:z,indices:J,hasColors:C.hasColors,hasModifications:C.hasModifications,positionData:{data:$,indices:G}};return k&&n.push(k.buffer),V&&n.push(V.buffer),n.push(z),n.push(J.buffer),n.push($.buffer),n.push(G.buffer),{componentOffsets:V,featureIds:k,anchorIds:H,anchors:Y,transformedGeometry:X,obb:C.obb,globalTrafo:s}}function A(t){return 0===t?w.Unmodified:1===t?w.PotentiallyModified:2===t?w.Culled:w.Unknown}function L(t){if(!M)return;const{context:r,buffer:n}=t,o=M._malloc(n.byteLength),s=n.byteLength/Float64Array.BYTES_PER_ELEMENT,a=new Float64Array(M.HEAPU8.buffer,o,s),f=new Float64Array(n);a.set(f),M.filterOBBs(r,o,s),f.set(a),M._free(o)}function I(t){M&&0===M.destroy(t)&&(M=null)}function S(t,r){for(let n=0;n<r.length;++n)t[n]=r[n]}async function _(){M||await x()}function x(){return M?Promise.resolve(M):(F||(F=function e(){return T||(T=new Promise((r=>t((()=>import("./i3s-BPmjNSqG.js")),__vite__mapDeps([0,1,2])).then((t=>t.i)).then((({default:t})=>{const n=t({locateFile:i,onRuntimeInitialized:()=>r(n)});delete n.then})))).catch((t=>{throw t}))),T}().then((t=>(M=t,F=null,M)))),F)}(R=O||(O={}))[R.None=0]="None",R[R.Int16=1]="Int16",R[R.Int32=2]="Int32",function(t){t[t.Replace=0]="Replace",t[t.Outside=1]="Outside",t[t.Inside=2]="Inside",t[t.Finished=3]="Finished"}(P||(P={}));const N={transform:(t,r)=>M&&j(M,t,r),destroy:I},v=Object.freeze(Object.defineProperty({__proto__:null,destroyContext:function h(t){I(t)},dracoDecompressPointCloudData:async function u(t){var r;M=await x();const n=[t.geometryBuffer],{geometryBuffer:o}=t,s=o.byteLength,a=M._malloc(s),f=new Uint8Array(M.HEAPU8.buffer,a,s);f.set(new Uint8Array(o));const c=M.dracoDecompressPointCloudData(a,f.byteLength);if(M._free(a),c.error.length>0)throw new Error(`i3s.wasm: ${c.error}`);const g=(null==(r=c.featureIds)?void 0:r.length)>0?c.featureIds.slice():null,w=c.positions.slice();return g&&n.push(g.buffer),n.push(w.buffer),{result:{positions:w,featureIds:g},transferList:n}},filterObbsForModifications:async function m(t){await x(),L(t);const r={buffer:t.buffer};return{result:r,transferList:[r.buffer]}},filterObbsForModificationsSync:L,initialize:_,interpretObbModificationResults:A,process:async function l(t){M=await x();const r=[t.geometryBuffer];return{result:j(M,t,r),transferList:r}},project:async function d(r){const{localMatrix:f,origin:c,positions:g,vertexSpace:w,localMode:O}=r,P=n.fromJSON(r.inSpatialReference),R=n.fromJSON(r.outSpatialReference);let T;const[{projectBuffer:F},{initializeProjection:M}]=await Promise.all([t((()=>import("./index-DSIPxOWi.js").then((t=>t.yB))),__vite__mapDeps([1,2])),t((()=>import("./index-DSIPxOWi.js").then((t=>t.yC))),__vite__mapDeps([1,2]))]);await M(P,R);const N=[0,0,0];if(!F(c,P,0,N,R,0,1))throw new Error("Failed to project");if("georeferenced"===w.type&&null==w.origin){if(T=new Float64Array(g.length),!F(g,P,0,T,R,0,T.length/3))throw new Error("Failed to project")}else{const r="georeferenced"===w.type?o.fromJSON(w):s.fromJSON(w),{project:n}=await t((async()=>{const{project:t}=await import("./index-DSIPxOWi.js").then((t=>t.yE));return{project:t}}),__vite__mapDeps([1,2])),c=n({positions:g,transform:f?{localMatrix:f}:void 0,vertexSpace:r,inSpatialReference:P,outSpatialReference:R,localMode:O});if(!c)throw new Error("Failed to project");T=a(c)}const v=T.length,[D,U,B]=N;for(let t=0;t<v;t+=3)T[t]-=D,T[t+1]-=U,T[t+2]-=B;return{result:{projected:T,original:g,projectedOrigin:N},transferList:[T.buffer,g.buffer]}},setLegacySchema:async function p(t){M=await x(),M.setLegacySchema(t.context,t.jsonSchema)},setModifications:async function y(t){await x(),E(t)},setModificationsSync:E,test:N,transformNormals:async function b({normalMatrix:t,normals:r}){const n=new Float32Array(r.length);return f(n,r,t),c(t)&&g(n,n),{result:{transformed:n,original:r},transferList:[n.buffer,r.buffer]}}},Symbol.toStringTag,{value:"Module"}));export{A,E,L,v as S,_,P as e};
