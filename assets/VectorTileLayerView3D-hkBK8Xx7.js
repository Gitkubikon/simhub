import{m1 as i,m3 as _,hq as m,m5 as g,bZ as v,sY as y,z as x,fz as w,bf as S,mO as M,er as P,sZ as b,W as T,jM as R,s_ as D,gE as I,b3 as E,cG as L,s$ as C,q8 as U,t0 as A,t1 as z,m4 as O,t2 as k,kA as N,ld as V,t3 as F,t4 as W,t5 as B,t6 as G,t7 as $,t8 as q,pk as K,t9 as Y,rm as j,rz as X,ta as Q,tb as Z,tc as J,td as ee,m7 as te,rL as ie,te as ae,tf as ne,m as re,b as se,tg as oe,th as le,ae as ce,g as ue,A as he,rN as de,c as _e,u as fe,e as pe,y as me,a as ge}from"./index-DSIPxOWi.js";import{t as ve}from"./Rect-3ZUgN72u.js";import{n as ye}from"./pbf-B53Txr8m.js";import{o as xe}from"./constants-D5zmR9t2.js";import{r as we}from"./vec4f32-APunXZaC.js";import{l as Se}from"./LayerView3D-ApO6iJqK.js";import{p as Me}from"./TiledLayerView3D-BIihePS5.js";import{y as Pe}from"./LayerView-DMoB2q_T.js";let be=class t{constructor(i,_,m){this._scale=i,this._shift=_,this._levelShift=m}getLevelRowColumn(i){const _=this.getLevelShift(i[0]),m=this._shift+_;return m?[i[0]-_,i[1]>>m,i[2]>>m]:i}getLevelShift(i){return Math.min(i,this._levelShift)}getOffset(i,_){let m=0,g=0;const v=this._shift+this.getLevelShift(i[0]);if(v){const y=(1<<v)-1,x=_/(this._scale*(1<<v-1));m=(i[2]&y)*x,g=(i[1]&y)*x}return[m,g]}getScale(i){return this._scale*(1<<this._shift+this.getLevelShift(i))}},Te=class e{constructor(i,_){this._width=0,this._height=0,this._free=[],this._width=i,this._height=_,this._free.push(new ve(0,0,i,_))}get width(){return this._width}get height(){return this._height}allocate(i,_){if(i>this._width||_>this._height)return new ve;let m=null,g=-1;for(let v=0;v<this._free.length;++v){const y=this._free[v];i<=y.width&&_<=y.height&&(null===m||y.y<=m.y&&y.x<=m.x)&&(m=y,g=v)}return null===m?new ve:(this._free.splice(g,1),m.width<m.height?(m.width>i&&this._free.push(new ve(m.x+i,m.y,m.width-i,_)),m.height>_&&this._free.push(new ve(m.x,m.y+_,m.width,m.height-_))):(m.width>i&&this._free.push(new ve(m.x+i,m.y,m.width-i,m.height)),m.height>_&&this._free.push(new ve(m.x,m.y+_,i,m.height-_))),new ve(m.x,m.y,i,_))}release(i){for(let _=0;_<this._free.length;++_){const m=this._free[_];if(m.y===i.y&&m.height===i.height&&m.x+m.width===i.x)m.width+=i.width;else if(m.x===i.x&&m.width===i.width&&m.y+m.height===i.y)m.height+=i.height;else if(i.y===m.y&&i.height===m.height&&i.x+i.width===m.x)m.x=i.x,m.width+=i.width;else{if(i.x!==m.x||i.width!==m.width||i.y+i.height!==m.y)continue;m.y=i.y,m.height+=i.height}this._free.splice(_,1),this.release(i)}this._free.push(i)}},Re=class n{constructor(i,_,m){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=i,this.height=_,this._glyphSource=m,this._binPack=new Te(i-4,_-4),this._glyphData.push(new Uint8Array(i*_)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,_){const m=[],g=this._glyphSource,v=new Set,y=1/256;for(const w of _){const i=Math.floor(w*y);v.add(i)}const x=[];return v.forEach((_=>{const m=i+_;if(this._rangePromises.has(m))x.push(this._rangePromises.get(m));else{const v=g.getRange(i,_).then((()=>{this._rangePromises.delete(m)}),(()=>{this._rangePromises.delete(m)}));this._rangePromises.set(m,v),x.push(v)}})),Promise.all(x).then((()=>{let v=this._glyphIndex[i];v||(v={},this._glyphIndex[i]=v);for(const y of _){const _=v[y];if(_){m[y]={sdf:!0,rect:_.rect,metrics:_.metrics,page:_.page,code:y};continue}const x=g.getGlyph(i,y);if(!(null==x?void 0:x.metrics))continue;const w=x.metrics;let S;if(0===w.width)S=new ve(0,0,0,0);else{const i=3,_=w.width+2*i,m=w.height+2*i;let g=_%4?4-_%4:4,v=m%4?4-m%4:4;1===g&&(g=5),1===v&&(v=5),S=this._binPack.allocate(_+g,m+v),S.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new Te(this.width-4,this.height-4),S=this._binPack.allocate(_+g,m+v));const y=this._glyphData[this._currentPage],M=x.bitmap;let P,b;if(M)for(let x=0;x<m;x++){P=_*x,b=this.width*(S.y+x+1)+S.x;for(let i=0;i<_;i++)y[b+i+1]=M.at(P+i)}}v[y]={rect:S,metrics:w,tileIDs:null,page:this._currentPage},m[y]={sdf:!0,rect:S,metrics:w,page:this._currentPage,code:y},this._dirties[this._currentPage]=!0}return m}))}removeGlyphs(i){for(const _ in this._glyphIndex){const m=this._glyphIndex[_];if(!m)continue;let g;for(const _ in m)if(g=m[_],g.tileIDs.delete(i),0===g.tileIDs.size){const i=this._glyphData[g.page],v=g.rect;let y,x;for(let _=0;_<v.height;_++)for(y=this.width*(v.y+_)+v.x,x=0;x<v.width;x++)i[y+x]=0;delete m[_],this._dirties[g.page]=!0}}}bind(v,y,x,w=0){if(!this._textures[x]){const y=new i;y.pixelFormat=_.ALPHA,y.wrapMode=m.CLAMP_TO_EDGE,y.width=this.width,y.height=this.height,this._textures[x]=new g(v,y,new Uint8Array(this.width*this.height))}const S=this._textures[x];S.setSamplingMode(y),this._dirties[x]&&S.setData(this._glyphData[x]),v.bindTexture(S,w),this._dirties[x]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const i of this._textures)i&&i.dispose();this._textures.length=0}},De=class s{constructor(i){if(this._metrics=[],!i)return void(this._allBitmaps=null);const _=new Map;let m=0;for(;i.next();)switch(i.tag()){case 1:{const g=i.getMessage();for(;g.next();)switch(g.tag()){case 3:{const i=g.getMessage();let v,y,x,w,S,M,P;for(;i.next();)switch(i.tag()){case 1:v=i.getUInt32();break;case 2:y=i.getBytes();break;case 3:x=i.getUInt32();break;case 4:w=i.getUInt32();break;case 5:S=i.getSInt32();break;case 6:M=i.getSInt32();break;case 7:P=i.getUInt32();break;default:i.skip()}if(i.release(),v){const i=(null==y?void 0:y.length)??0;this._metrics[v]={width:x,height:w,left:S,top:M,advance:P,startOffset:m,length:i},_.set(v,y),m+=i}break}default:g.skip()}g.release();break}default:i.skip()}const g=new Uint8Array(m),v=this._metrics;for(const[y,x]of _){const{startOffset:i,length:_}=v[y];if(x)for(let m=0;m<_;++m)g[i+m]=x[m]}this._allBitmaps=g}getMetrics(i){return this._metrics[i]}getBitmap(i){if(!this._allBitmaps)return;const _=this._metrics[i];if(void 0===_)return;const{startOffset:m,length:g}=_;return 0!==g?new Le(this._allBitmaps,m,g):void 0}},Ie=class a{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(i){return this._ranges[i]}addRange(i,_){this._ranges[i]=_}},Ee=class r{constructor(i){this._glyphInfo={},this._baseURL=i}getRange(i,_){const m=this._getFontStack(i);if(m.getRange(_))return Promise.resolve();const g=256*_,y=g+255;if(this._baseURL){const x=this._baseURL.replace("{fontstack}",i).replace("{range}",g+"-"+y);return v(x,{responseType:"array-buffer"}).then((i=>{m.addRange(_,new De(new ye(new Uint8Array(i.data),new DataView(i.data))))})).catch((()=>{m.addRange(_,new De)}))}return m.addRange(_,new De),Promise.resolve()}getGlyph(i,_){const m=this._getFontStack(i);if(!m)return;const g=Math.floor(_/256),v=m.getRange(g);return v?{metrics:v.getMetrics(_),bitmap:v.getBitmap(_)}:void 0}_getFontStack(i){let _=this._glyphInfo[i];return _||(_=this._glyphInfo[i]=new Ie),_}},Le=class n2{constructor(i,_,m){this._array=i,this._start=_,this.length=m}at(i){return 0<=i&&i<this.length?this._array[this._start+i]:void 0}};let Ce=class o{constructor(i,_,m=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,this._pageWidth=i,this._pageHeight=_,m>0&&(this._maxItemSize=m),this._binPack=new Te(i-4,_-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const i of this._textures)i&&i.dispose();this._textures.length=0}getWidth(i){return i>=this._size.length?-1:this._size[i][0]}getHeight(i){return i>=this._size.length?-1:this._size[i][1]}getPageSize(i){return i>=this._size.length?null:this._size[i]}setSpriteSource(i){if(this.dispose(),this.pixelRatio=i.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new Te(this._pageWidth-4,this._pageHeight-4);const i=Math.floor(this._pageWidth),_=Math.floor(this._pageHeight),m=new Uint32Array(i*_);this._mosaicsData[0]=m,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=i}getSpriteItem(i,_=!1){let m,g,v=this._mosaicRects[i];if(v)return v;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(i&&i.startsWith("dasharray-")?([m,g]=this._rasterizeDash(i),_=!0):m=this._sprites.getSpriteInfo(i),!(null==m?void 0:m.width)||!m.height||m.width<0||m.height<0)return null;const y=m.width,x=m.height,[w,S,M]=this._allocateImage(y,x);return w.width<=0?null:(this._copy(w,m,S,M,_,g),v={type:"sprite",rect:w,width:y,height:x,sdf:m.sdf,simplePattern:!1,rasterizationScale:m.pixelRatio,page:S},this._mosaicRects[i]=v,v)}getSpriteItems(i){const _={};for(const m of i)_[m.name]=this.getSpriteItem(m.name,m.repeat);return _}getMosaicItemPosition(i,_){const m=this.getSpriteItem(i,_),g=null==m?void 0:m.rect;if(!g)return null;g.width=m.width,g.height=m.height;const v=m.width,y=m.height;return{tl:[g.x+2,g.y+2],br:[g.x+2+v,g.y+2+y],page:m.page}}bind(_,v,y=0,x=0){if(y>=this._size.length||y>=this._mosaicsData.length)return;if(!this._textures[y]){const v=new i;v.wrapMode=m.CLAMP_TO_EDGE,v.width=this._size[y][0],v.height=this._size[y][1],this._textures[y]=new g(_,v,new Uint8Array(this._mosaicsData[y].buffer))}const w=this._textures[y];w.setSamplingMode(v),this._dirties[y]&&w.setData(new Uint8Array(this._mosaicsData[y].buffer)),_.bindTexture(w,x),this._dirties[y]=!1}static _copyBits(i,_,m,g,v,y,x,w,S,M,P){let b=g*_+m,T=w*y+x;if(P){T-=y;for(let x=-1;x<=M;x++,b=((x+M)%M+g)*_+m,T+=y)for(let _=-1;_<=S;_++)v[T+_]=i[b+(_+S)%S]}else for(let R=0;R<M;R++){for(let _=0;_<S;_++)v[T+_]=i[b+_];b+=_,T+=y}}_copy(i,_,m,g,v,y){if(!this._sprites||"loaded"!==this._sprites.loadStatus||m>=this._mosaicsData.length)return;const x=new Uint32Array(y?y.buffer:this._sprites.image.buffer),w=this._mosaicsData[m],S=y?_.width:this._sprites.width;o._copyBits(x,S,_.x,_.y,w,g[0],i.x+2,i.y+2,_.width,_.height,v),this._dirties[m]=!0}_allocateImage(i,_){i+=2,_+=2;const m=Math.max(i,_);if(this._maxItemSize&&this._maxItemSize<m){const m=new ve(0,0,i,_);return this._mosaicsData.push(new Uint32Array(i*_)),this._dirties.push(!0),this._size.push([i,_]),this._textures.push(void 0),[m,this._mosaicsData.length-1,[i,_]]}let g=i%4?4-i%4:4,v=_%4?4-_%4:4;1===g&&(g=5),1===v&&(v=5);const y=this._binPack.allocate(i+g,_+v);return y.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new Te(this._pageWidth-4,this._pageHeight-4),this._allocateImage(i,_)):[y,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(i){const _=i.match(/\[(.*?)\]/);if(!_)return null;const m=_[1].split(",").map(Number),g=i.slice(i.lastIndexOf("-")+1),[v,x,w]=function i$1(i,_){null==i&&(i=[]);const m="Butt"===_,g="Square"===_,v=!m&&!g;i.length%2==1&&(i=[...i,...i]);const x=xe,w=2*x;let S=0;for(const y of i)S+=y;const M=Math.round(S*x),P=new Float32Array(M*w),b=.5*x;let T=0,R=0,D=.5,I=!0;for(const y of i){for(T=R,R+=y*x;D<=R;){let i=.5;for(;i<w;){const _=(i-.5)*M+D-.5,y=v?(i-x)*(i-x):Math.abs(i-x);P[_]=I?m?Math.max(Math.max(T+b-D,y),Math.max(D-R+b,y)):y:v?Math.min((D-T)*(D-T)+y,(D-R)*(D-R)+y):g?Math.min(Math.max(D-T,y),Math.max(R-D,y)):Math.min(Math.max(D-T+b,y),Math.max(R+b-D,y)),i++}D++}I=!I}const E=P.length,L=new Uint8Array(4*E);for(let C=0;C<E;++C){const i=(v?Math.sqrt(P[C]):P[C])/x;y(i,L,4*C)}return[L,M,w]}(m,g);return[{x:0,y:0,width:x,height:w,sdf:!0,pixelRatio:1},new Uint8Array(v.buffer)]}},Ue=class h{constructor(i,_,m,g){this._layer=i,this._styleRepository=_,this.devicePixelRatio=m,this._sourceDataMaxLOD=g,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){var i,_,m;null==(i=this._connection)||i.close(),this._connection=null,this._styleRepository=null,this._layer=null,null==(_=this._spriteMosaic)||_.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=x(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&(null==(m=this._startOptionsInputSignal)||m.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(i){this._requestSprite(i);const _=this._layer.currentStyleInfo.glyphsUrl,m=new Ee(_?w(_,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new Re(1024,1024,m),this._broadcastPromise=S("WorkerTileHandler",{client:this,schedule:i.schedule,signal:i.signal}).then((_=>{var m;if(this._layer&&(null==(m=this._connection)||m.close(),this._connection=_,this._layer&&!this._connection.closed)){const m=_.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},i);Promise.all(m).catch((i=>M(i)))}}))}_requestSprite(i){var _,m;null==(_=this._spriteSourceAbortController)||_.abort();const g=new AbortController;this._spriteSourceAbortController=g;const v=null==i?void 0:i.signal;this._inputSignalEventListener&&(null==(m=this._startOptionsInputSignal)||m.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,v&&(this._inputSignalEventListener=function p$1(i){return()=>i.abort()}(g),v.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:y}=g,x={...i,signal:y};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,x),this._spriteSourcePromise.then((i=>{P(y),this._spriteMosaic=new Ce(1024,1024,250),this._spriteMosaic.setSpriteSource(i)}))}async updateStyle(i){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",i)),this._broadcastPromise}setSpriteSource(i){const _=new Ce(1024,1024,250);return _.setSpriteSource(i),this._spriteMosaic=_,this._spriteSourcePromise=Promise.resolve(i),this._spriteSourceAbortController=null,_}async setStyle(i,_,m){await this._broadcastPromise,this._styleRepository=i,this._sourceDataMaxLOD=m,this._requestSprite();const g=new Ee(this._layer.currentStyleInfo.glyphsUrl?w(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new Re(1024,1024,g),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:_,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(i,_){const m=await this._getRefKeys(i,_);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),m,_)}async fetchTilePBFs(i){const _=Object.keys(this._layer.sourceNameToSource),m={},g=await this._getRefKeys(i,m),v=[],y=[];for(let x=0;x<g.length;x++)if(null==g[x].value||null==_[x])y.push(null);else{const i=g[x].value,w=this._getTilePayload(i,_[x],m);w.then((_=>{v.push({..._,key:i})})),y.push(w)}return Promise.all(y).then((()=>v))}async parseTileData(i,_){const m=i&&i.data;if(!m)return null;const{sourceName2DataAndRefKey:g,transferList:v}=m;return 0===Object.keys(g).length?null:this._broadcastPromise.then((()=>this._connection.invoke("createTileAndParse",{key:i.key.id,sourceName2DataAndRefKey:g,styleLayerUIDs:i.styleLayerUIDs},{..._,transferList:v})))}async getSprites(i){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(i)}getGlyphs(i){return this._glyphMosaic.getGlyphItems(i.font,i.codePoints)}async _getTilePayload(i,_,m){const g=b.pool.acquire(i.id),v=this._layer.sourceNameToSource[_],{level:y,row:x,col:w}=g;b.pool.release(g);try{return{protobuff:await v.requestTile(y,x,w,m),sourceName:_}}catch(S){if(T(S))throw S;return{protobuff:null,sourceName:_}}}async _getRefKeys(i,_){const m=this._layer.sourceNameToSource,g=new Array;for(const v in m){const y=m[v].getRefKey(i,_);g.push(y)}return R(g)}_getSourcesData(i,_,m){const g=[];for(let v=0;v<_.length;v++)if(null==_[v].value||null==i[v])g.push(null);else{const y=_[v].value,x=this._getTilePayload(y,i[v],m);g.push(x)}return R(g).then((i=>{const m={},g=[];for(let v=0;v<i.length;v++){const y=i[v].value;if(y&&y.protobuff&&y.protobuff.byteLength>0){const i=_[v].value.id;m[y.sourceName]={refKey:i,protobuff:y.protobuff},g.push(y.protobuff)}}return{sourceName2DataAndRefKey:m,transferList:g}}))}};let Ae=class t2 extends D{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(i){const _=b.pool.acquire(i),m=0===_.level?null:b.getId(_.level-1,_.row>>1,_.col>>1,_.world);return b.pool.release(_),m}getTileCoverage(i,_,m=!0,g){const v=super.getTileCoverage(i,_,m,g);if(!v)return v;const y=1<<v.lodInfo.level;return v.spans=v.spans.filter((i=>i.row>=0&&i.row<y)),v}scaleToLevel(i){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[i])return this._levelByScale[i];{const _=this._fullCacheLodInfos;if(i>_[0].scale)return _[0].level;let m,g;for(let v=0;v<_.length-1;v++)if(g=_[v+1],i>g.scale)return m=_[v],m.level+(m.scale-i)/(m.scale-g.scale);return _[_.length-1].level}}_initializeFullCacheLODs(i){let _;if(0===i[0].level)_=i.map((i=>({level:i.level,resolution:i.resolution,scale:i.scale})));else{const i=this.tileInfo.size[0],m=this.tileInfo.spatialReference;_=I.create({size:i,spatialReference:m}).lods.map((i=>({level:i.level,resolution:i.resolution,scale:i.scale})))}for(let m=0;m<_.length;m++)this._levelByScale[_[m].scale]=_[m].level;this._fullCacheLodInfos=_}},ze=class a2 extends Ue{constructor(i,_,m,g){super(i,_,m,i.tileInfo.lods.length-1),this._memCache=g,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new Ae(i.tileInfo,i.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach((i=>i.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(i,_){const m=new b(i[0],i[1],i[2],0);let g=this._memCache.get(m.id);if(null!=g)return g.retain(),g;const v=await this._getVectorTileData(m);if(E(_),!this._layer)return null;if(g=this._memCache.get(m.id),null!=g)return g.retain(),g;const y=this._layer.tileInfo.getTileBounds(L(),m),x=this._tileInfoView.getTileResolution(i[0]);return g=new C(m,x,y[0],y[3],512,512,this._styleRepository,this._memCache),g.setData(v),v&&(g.retain(),this._memCache.put(m.id,g,g.usedMemory,U)),g.neededForCoverage=!0,g.transforms.tileUnitsToPixels=A(1/8,0,0,0,1/8,0,0,0,1),g}_getVectorTileData(i){const _=i.id;if(this._ongoingTileRequests.has(_))return this._ongoingTileRequests.get(_);const m=new AbortController,g={signal:m.signal},v=this._getParsedVectorTileData(i,g).then((i=>(this._ongoingTileRequests.delete(_),this._ongoingRequestToController.delete(_),i))).catch((()=>(this._ongoingTileRequests.delete(_),this._ongoingRequestToController.delete(_),null)));return this._ongoingTileRequests.set(_,v),this._ongoingRequestToController.set(_,m),v}_getParsedVectorTileData(i,_){return this.fetchTileData(i,_).then((m=>this.parseTileData({key:i,data:m},_)))}},Oe=class t3{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(i,_){}draw(i,_,m){}drawMany(i,_,m){for(const g of _)g.visible&&this.draw(i,g,m)}};const ke=1/65536;const Ne=256/360;function c(i){return function u2(i,_){return(i%=_)>=0?i:i+_}(i*Ne,256)}const Ve=1/65536;const Fe={vtlBackground:class u extends Oe{constructor(){super(...arguments),this._color=we(1,0,0,1),this._patternMatrix=z(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(i,_){const{context:m,painter:g,requestRender:v,allowDelayedRender:y}=i;this._loadWGLResources(i);const x=i.displayLevel,w=i.styleLayer,S=w.backgroundMaterial,M=g.vectorTilesMaterialManager,P=w.getPaintValue("background-color",x),b=w.getPaintValue("background-opacity",x),T=w.getPaintValue("background-pattern",x),R=void 0!==T,D=1|window.devicePixelRatio,I=i.spriteMosaic;let E,L;const C=D>G?2:1,U=this._programOptions;U.pattern=R;const A=M.getMaterialProgram(m,S,U);if(!y||null==v||A.compiled){if(m.bindVAO(this._vao),m.useProgram(A),R){const i=I.getMosaicItemPosition(T,!0);if(null!=i){const{tl:_,br:g,page:v}=i;E=g[0]-_[0],L=g[1]-_[1];const y=I.getPageSize(v);null!=y&&(I.bind(m,O.LINEAR,v,k),A.setUniform4f("u_tlbr",_[0],_[1],g[0],g[1]),A.setUniform2fv("u_mosaicSize",y),A.setUniform1i("u_texture",k))}A.setUniform1f("u_opacity",b)}else{const i=P[3]*b;this._color[0]=i*P[0],this._color[1]=i*P[1],this._color[2]=i*P[2],this._color[3]=i,A.setUniform4fv("u_color",this._color)}A.setUniform1f("u_depth",w.z||0);for(const i of _){if(A.setUniform1f("u_coord_range",i.rangeX),A.setUniformMatrix3fv("u_dvsMat3",i.transforms.displayViewScreenMat3),R){const _=Math.max(2**(Math.round(x)-i.key.level),1),m=C*i.width*_,g=m/$(E),v=m/$(L);this._patternMatrix[0]=g,this._patternMatrix[4]=v,A.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}m.setStencilFunction(N.EQUAL,0,255),m.drawArrays(V.TRIANGLE_STRIP,0,4)}}else v()}_loadWGLResources(i){if(this._vao)return;const{context:_,styleLayer:m}=i,g=m.backgroundMaterial,v=new Int8Array([0,0,1,0,0,1,1,1]),y=F.createVertex(_,W.STATIC_DRAW,v),x=new B(_,g.getAttributeLocations(),g.getLayoutInfo(),{geometry:y});this._vao=x}},vtlFill:class f extends Oe{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(i,_){const{displayLevel:m,renderPass:g,spriteMosaic:v,styleLayerUID:y}=i;let x=!1;for(const C of _)if(C.layerData.has(y)){const i=C.layerData.get(y);if(i.fillIndexCount>0||i.outlineIndexCount>0){x=!0;break}}if(!x)return;const w=i.styleLayer,S=w.getPaintProperty("fill-pattern"),M=void 0!==S,P=M&&S.isDataDriven;let b;if(M&&!P){const i=S.getValue(m);b=v.getMosaicItemPosition(i,!0)}const T=!M&&w.getPaintValue("fill-antialias",m);let R=!0,D=1;if(!M){const i=w.getPaintProperty("fill-color"),_=w.getPaintProperty("fill-opacity");if(!(null==i?void 0:i.isDataDriven)&&!(null==_?void 0:_.isDataDriven)){const i=w.getPaintValue("fill-color",m);D=w.getPaintValue("fill-opacity",m)*i[3],D>=1&&(R=!1)}}if(R&&"opaque"===g)return;const I=w.getPaintValue("fill-translate",m),E=w.getPaintValue("fill-translate-anchor",m);(R||"translucent"!==g)&&this._drawFill(i,y,w,_,I,E,M,b,P);const L=!w.hasDataDrivenOutlineColor&&w.outlineUsesFillColor&&D<1;T&&"opaque"!==g&&!L&&this._drawOutline(i,y,w,_,I,E)}_drawFill(i,_,m,g,v,y,x,w,S){if(x&&!S&&null==w)return;const{context:M,displayLevel:P,state:b,painter:T,pixelRatio:R,spriteMosaic:D,requestRender:I,allowDelayedRender:E}=i,L=m.fillMaterial,C=T.vectorTilesMaterialManager,U=R>G?2:1,A=this._fillProgramOptions;A.pattern=x;const z=C.getMaterialProgram(M,L,A);if(E&&null!=I&&!z.compiled)return void I();if(M.useProgram(z),null!=w){const{page:i}=w,_=D.getPageSize(i);null!=_&&(D.bind(M,O.LINEAR,i,k),z.setUniform2fv("u_mosaicSize",_),z.setUniform1i("u_texture",k))}z.setUniformMatrix3fv("u_displayMat3",y===q.VIEWPORT?b.displayMat3:b.displayViewMat3),z.setUniform2fv("u_fillTranslation",v),z.setUniform1f("u_depth",m.z+ke);let F=-1;for(const W of g){if(!W.layerData.has(_))continue;W.key.level!==F&&(F=W.key.level,L.setDataUniforms(z,P,m,F,D));const i=W.layerData.get(_);if(!i.fillIndexCount)continue;i.prepareForRendering(M);const g=i.fillVAO;if(null!=g){if(M.bindVAO(g),z.setUniformMatrix3fv("u_dvsMat3",W.transforms.displayViewScreenMat3),M.setStencilFunction(N.EQUAL,W.stencilRef,255),x){const i=Math.max(2**(Math.round(P)-W.key.level),1),_=W.rangeX/(U*W.width*i);z.setUniform1f("u_patternFactor",_)}if(S){const _=i.patternMap;if(!_)continue;for(const[i,m]of _){const _=D.getPageSize(i);null!=_&&(D.bind(M,O.LINEAR,i,k),z.setUniform2fv("u_mosaicSize",_),z.setUniform1i("u_texture",k),M.drawElements(V.TRIANGLES,m[1],K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*m[0]))}}else M.drawElements(V.TRIANGLES,i.fillIndexCount,K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i.fillIndexStart);W.triangleCount+=i.fillIndexCount/3}}}_drawOutline(i,_,m,g,v,y){const{context:x,displayLevel:w,state:S,painter:M,pixelRatio:P,spriteMosaic:b,requestRender:T,allowDelayedRender:R}=i,D=m.outlineMaterial,I=M.vectorTilesMaterialManager,E=.75/P,L=this._outlineProgramOptions,C=I.getMaterialProgram(x,D,L);if(R&&null!=T&&!C.compiled)return void T();x.useProgram(C),C.setUniformMatrix3fv("u_displayMat3",y===q.VIEWPORT?S.displayMat3:S.displayViewMat3),C.setUniform2fv("u_fillTranslation",v),C.setUniform1f("u_depth",m.z+ke),C.setUniform1f("u_outline_width",E);let U=-1;for(const A of g){if(!A.layerData.has(_))continue;A.key.level!==U&&(U=A.key.level,D.setDataUniforms(C,w,m,U,b));const i=A.layerData.get(_);if(i.prepareForRendering(x),!i.outlineIndexCount)continue;const g=i.outlineVAO;null!=g&&(x.bindVAO(g),C.setUniformMatrix3fv("u_dvsMat3",A.transforms.displayViewScreenMat3),x.setStencilFunction(N.EQUAL,A.stencilRef,255),x.drawElements(V.TRIANGLES,i.outlineIndexCount,K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i.outlineIndexStart),A.triangleCount+=i.outlineIndexCount/3)}}},vtlLine:class s2 extends Oe{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(i,_){const{context:m,displayLevel:g,state:v,painter:y,pixelRatio:x,spriteMosaic:w,styleLayerUID:S,requestRender:M,allowDelayedRender:P}=i;if(!_.some((i=>{var _;return(null==(_=i.layerData.get(S))?void 0:_.lineIndexCount)??!1})))return;const b=i.styleLayer,T=b.lineMaterial,R=y.vectorTilesMaterialManager,D=b.getPaintValue("line-translate",g),I=b.getPaintValue("line-translate-anchor",g),E=b.getPaintProperty("line-pattern"),L=void 0!==E,C=L&&E.isDataDriven;let U,A;if(L&&!C){const i=E.getValue(g);U=w.getMosaicItemPosition(i)}let z=!1;if(!L){const i=b.getPaintProperty("line-dasharray");if(A=void 0!==i,z=A&&i.isDataDriven,A&&!z){const _=i.getValue(g),m=b.getDashKey(_,b.getLayoutValue("line-cap",g));U=w.getMosaicItemPosition(m)}}const F=1/x,W=this._programOptions;W.pattern=L,W.sdf=A;const B=R.getMaterialProgram(m,T,W);if(P&&null!=M&&!B.compiled)return void M();if(m.useProgram(B),B.setUniformMatrix3fv("u_displayViewMat3",v.displayViewMat3),B.setUniformMatrix3fv("u_displayMat3",I===q.VIEWPORT?v.displayMat3:v.displayViewMat3),B.setUniform2fv("u_lineTranslation",D),B.setUniform1f("u_depth",b.z),B.setUniform1f("u_antialiasing",F),U&&null!=U){const{page:i}=U,_=w.getPageSize(i);null!=_&&(w.bind(m,O.LINEAR,i,k),B.setUniform2fv("u_mosaicSize",_),B.setUniform1i("u_texture",k))}let G=-1;for(const $ of _){if(!$.layerData.has(S))continue;$.key.level!==G&&(G=$.key.level,T.setDataUniforms(B,g,b,G,w));const i=2**(g-G)/x;B.setUniform1f("u_zoomFactor",i);const _=$.layerData.get(S);if(!_.lineIndexCount)continue;_.prepareForRendering(m);const v=_.vao;if(null!=v){if(m.bindVAO(v),B.setUniformMatrix3fv("u_dvsMat3",$.transforms.displayViewScreenMat3),m.setStencilFunction(N.EQUAL,$.stencilRef,255),C||z){const i=_.patternMap;if(!i)continue;for(const[_,g]of i){const i=w.getPageSize(_);null!=i&&(w.bind(m,O.LINEAR,_,k),B.setUniform2fv("u_mosaicSize",i),B.setUniform1i("u_texture",k),m.drawElements(V.TRIANGLES,g[1],K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*g[0]))}}else m.drawElements(V.TRIANGLES,_.lineIndexCount,K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*_.lineIndexStart);$.triangleCount+=_.lineIndexCount/3}}}},vtlCircle:class n3 extends Oe{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(i,_){const{context:m,displayLevel:g,requiredLevel:v,state:y,painter:x,spriteMosaic:w,styleLayerUID:S,requestRender:M,allowDelayedRender:P}=i;if(!_.some((i=>{var _;return(null==(_=i.layerData.get(S))?void 0:_.circleIndexCount)??!1})))return;const b=i.styleLayer,T=b.circleMaterial,R=x.vectorTilesMaterialManager,D=b.getPaintValue("circle-translate",g),I=b.getPaintValue("circle-translate-anchor",g),E=this._programOptions,L=R.getMaterialProgram(m,T,E);if(P&&null!=M&&!L.compiled)return void M();m.useProgram(L),L.setUniformMatrix3fv("u_displayMat3",I===q.VIEWPORT?y.displayMat3:y.displayViewMat3),L.setUniform2fv("u_circleTranslation",D),L.setUniform1f("u_depth",b.z),L.setUniform1f("u_antialiasingWidth",1.2);let C=-1;for(const U of _){if(!U.layerData.has(S))continue;U.key.level!==C&&(C=U.key.level,T.setDataUniforms(L,g,b,C,w));const i=U.layerData.get(S);if(!i.circleIndexCount)continue;i.prepareForRendering(m);const _=i.vao;null!=_&&(m.bindVAO(_),L.setUniformMatrix3fv("u_dvsMat3",U.transforms.displayViewScreenMat3),v!==U.key.level?m.setStencilFunction(N.EQUAL,U.stencilRef,255):m.setStencilFunction(N.GREATER,255,255),m.drawElements(V.TRIANGLES,i.circleIndexCount,K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i.circleIndexStart),U.triangleCount+=i.circleIndexCount/3)}}},vtlSymbol:class d extends Oe{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=Y()}dispose(){}drawMany(i,_){const m=i.styleLayer;this._drawIcons(i,m,_),this._drawText(i,m,_)}_drawIcons(i,_,m){const{context:g,displayLevel:v,painter:y,spriteMosaic:x,state:w,styleLayerUID:S,requestRender:M,allowDelayedRender:P}=i,b=_.iconMaterial,T=y.vectorTilesMaterialManager;let R,D=!1;for(const k of m)if(k.layerData.has(S)&&(R=k.layerData.get(S),R.iconPerPageElementsMap.size>0)){D=!0;break}if(!D)return;const I=_.getPaintValue("icon-translate",v),E=_.getPaintValue("icon-translate-anchor",v);let L=_.getLayoutValue("icon-rotation-alignment",v);L===j.AUTO&&(L=_.getLayoutValue("symbol-placement",v)===X.POINT?j.VIEWPORT:j.MAP);const C=L===j.MAP,U=_.getLayoutValue("icon-keep-upright",v)&&C,A=R.isIconSDF,z=this._iconProgramOptions;z.sdf=A;const O=T.getMaterialProgram(g,b,z);if(P&&null!=M&&!O.compiled)return void M();g.useProgram(O),O.setUniformMatrix3fv("u_displayViewMat3",L===j.MAP?w.displayViewMat3:w.displayMat3),O.setUniformMatrix3fv("u_displayMat3",E===q.VIEWPORT?w.displayMat3:w.displayViewMat3),O.setUniform2fv("u_iconTranslation",I),O.setUniform1f("u_depth",_.z),O.setUniform1f("u_mapRotation",c(w.rotation)),O.setUniform1f("u_keepUpright",U?1:0),O.setUniform1f("u_level",10*v),O.setUniform1i("u_texture",k),O.setUniform1f("u_fadeDuration",Q/1e3);let N=-1;for(const k of m){if(!k.layerData.has(S))continue;if(k.key.level!==N&&(N=k.key.level,b.setDataUniforms(O,v,_,N,x)),R=k.layerData.get(S),0===R.iconPerPageElementsMap.size)continue;R.prepareForRendering(g),R.updateOpacityInfo();const m=R.iconVAO;if(null!=m){g.bindVAO(m),O.setUniformMatrix3fv("u_dvsMat3",k.transforms.displayViewScreenMat3),O.setUniform1f("u_time",(performance.now()-R.lastOpacityUpdate)/1e3);for(const[_,m]of R.iconPerPageElementsMap)this._renderIconRange(i,O,m,_,k)}}}_renderIconRange(i,_,m,g,v){const{context:y,spriteMosaic:x}=i;this._spritesTextureSize[0]=x.getWidth(g)/4,this._spritesTextureSize[1]=x.getHeight(g)/4,_.setUniform2fv("u_mosaicSize",this._spritesTextureSize),x.bind(y,O.LINEAR,g,k),this._setStencilState(i,v),y.drawElements(V.TRIANGLES,m[1],K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*m[0]),v.triangleCount+=m[1]/3}_drawText(i,_,m){const{context:g,displayLevel:v,glyphMosaic:y,painter:x,pixelRatio:w,spriteMosaic:S,state:M,styleLayerUID:P,requestRender:b,allowDelayedRender:T}=i,R=_.textMaterial,D=x.vectorTilesMaterialManager;let I,E=!1;for(const q of m)if(q.layerData.has(P)&&(I=q.layerData.get(P),I.glyphPerPageElementsMap.size>0)){E=!0;break}if(!E)return;const L=_.getPaintProperty("text-opacity");if(L&&!L.isDataDriven&&0===L.getValue(v))return;const C=_.getPaintProperty("text-color"),U=!C||C.isDataDriven||C.getValue(v)[3]>0,A=_.getPaintProperty("text-halo-width"),z=_.getPaintProperty("text-halo-color"),O=(!A||A.isDataDriven||A.getValue(v)>0)&&(!z||z.isDataDriven||z.getValue(v)[3]>0);if(!U&&!O)return;let k=_.getLayoutValue("text-rotation-alignment",v);k===j.AUTO&&(k=_.getLayoutValue("symbol-placement",v)===X.POINT?j.VIEWPORT:j.MAP);const N=k===j.MAP,V=_.getLayoutValue("text-keep-upright",v)&&N,F=.8*3/w;this._glyphTextureSize||(this._glyphTextureSize=Z(y.width/4,y.height/4));const W=_.getPaintValue("text-translate",v),B=_.getPaintValue("text-translate-anchor",v),G=this._sdfProgramOptions,$=D.getMaterialProgram(g,R,G);if(T&&null!=b&&!$.compiled)return void b();g.useProgram($),$.setUniformMatrix3fv("u_displayViewMat3",k===j.MAP?M.displayViewMat3:M.displayMat3),$.setUniformMatrix3fv("u_displayMat3",B===q.VIEWPORT?M.displayMat3:M.displayViewMat3),$.setUniform2fv("u_textTranslation",W),$.setUniform1f("u_depth",_.z+Ve),$.setUniform2fv("u_mosaicSize",this._glyphTextureSize),$.setUniform1f("u_mapRotation",c(M.rotation)),$.setUniform1f("u_keepUpright",V?1:0),$.setUniform1f("u_level",10*v),$.setUniform1i("u_texture",J),$.setUniform1f("u_antialiasingWidth",F),$.setUniform1f("u_fadeDuration",Q/1e3);let K=-1;for(const q of m){if(!q.layerData.has(P))continue;if(q.key.level!==K&&(K=q.key.level,R.setDataUniforms($,v,_,K,S)),I=q.layerData.get(P),0===I.glyphPerPageElementsMap.size)continue;I.prepareForRendering(g),I.updateOpacityInfo();const m=I.textVAO;if(null==m)continue;g.bindVAO(m),$.setUniformMatrix3fv("u_dvsMat3",q.transforms.displayViewScreenMat3),this._setStencilState(i,q);const x=(performance.now()-I.lastOpacityUpdate)/1e3;$.setUniform1f("u_time",x),I.glyphPerPageElementsMap.forEach(((i,_)=>{this._renderGlyphRange(g,i,_,y,$,O,U,q)}))}}_renderGlyphRange(i,_,m,g,v,y,x,w){g.bind(i,O.LINEAR,m,J),y&&(v.setUniform1f("u_halo",1),i.drawElements(V.TRIANGLES,_[1],K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*_[0]),w.triangleCount+=_[1]/3),x&&(v.setUniform1f("u_halo",0),i.drawElements(V.TRIANGLES,_[1],K.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*_[0]),w.triangleCount+=_[1]/3)}_setStencilState(i,_){const{context:m,is3D:g,stencilSymbols:v}=i;if(m.setStencilTestEnabled(!0),v)return m.setStencilWriteMask(255),void m.setStencilFunction(N.ALWAYS,_.stencilRef,255);m.setStencilWriteMask(0),g?m.setStencilFunction(N.EQUAL,_.stencilRef,255):m.setStencilFunction(N.GREATER,255,255)}}},We={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};const He=new class e2{constructor(i){this._readFile=i}resolveIncludes(i){return this._resolve(i)}_resolve(i,_=new Map){if(_.has(i))return _.get(i);const m=this._read(i);if(!m)throw new Error(`cannot find shader file ${i}`);const g=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let v=g.exec(m);const y=[];for(;null!=v;)y.push({path:v[1],start:v.index,length:v[0].length}),v=g.exec(m);let x=0,w="";return y.forEach((i=>{w+=m.slice(x,i.start),w+=_.has(i.path)?"":this._resolve(i.path,_),x=i.start+i.length})),w+=m.slice(x),_.set(i,w),w}_read(i){return this._readFile(i)}}((function o$2(i){let _=We;return i.split("/").forEach((i=>{_&&(_=_[i])})),_}));function n$2(i){return He.resolveIncludes(i)}function e3(i){const{options:_,value:m}=i;return"number"==typeof _[m]}function n$1(i){let _="";for(const m in i){const g=i[m];if("boolean"==typeof g)g&&(_+=`#define ${m}\n`);else if("number"==typeof g)_+=`#define ${m} ${g.toFixed()}\n`;else if("object"==typeof g)if(e3(g)){const{value:i,options:v,namespace:y}=g,x=y?`${y}_`:"";for(const m in v)_+=`#define ${x}${m} ${v[m].toFixed()}\n`;_+=`#define ${m} ${x}${i}\n`}else{const i=g.options;let v=0;for(const m in i)_+=`#define ${i[m]} ${(v++).toFixed()}\n`;_+=`#define ${m} ${i[g.value]}\n`}}return _}const t4=i=>n$1({PATTERN:i.pattern}),Be={shaders:i=>({vertexShader:t4(i)+n$2("background/background.vert"),fragmentShader:t4(i)+n$2("background/background.frag")})},Ge={shaders:i=>({vertexShader:n$2("circle/circle.vert"),fragmentShader:n$2("circle/circle.frag")})},n4=i=>n$1({PATTERN:i.pattern}),$e={shaders:i=>({vertexShader:n4(i)+n$2("fill/fill.vert"),fragmentShader:n4(i)+n$2("fill/fill.frag")})},qe={shaders:i=>({vertexShader:n$2("outline/outline.vert"),fragmentShader:n$2("outline/outline.frag")})},s3=i=>n$1({SDF:i.sdf}),Ke={shaders:i=>({vertexShader:s3(i)+n$2("icon/icon.vert"),fragmentShader:s3(i)+n$2("icon/icon.frag")})},h2=i=>n$1({PATTERN:i.pattern,SDF:i.sdf}),Ye={shaders:i=>({vertexShader:h2(i)+n$2("line/line.vert"),fragmentShader:h2(i)+n$2("line/line.frag")})},je={shaders:i=>({vertexShader:n$2("text/text.vert"),fragmentShader:n$2("text/text.frag")})};class p{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((i=>i.dispose())),this._programByKey.clear()}getMaterialProgram(i,_,m){const g=_.key<<3|this._getMaterialOptionsValue(_.type,m);if(this._programByKey.has(g))return this._programByKey.get(g);const v=this._getProgramTemplate(_.type),{shaders:y}=v,{vertexShader:x,fragmentShader:w}=y(m),S=_.getShaderHeader(),M=_.getShaderMain(),P=x.replace("#pragma header",S).replace("#pragma main",M),b=i.programCache.acquire(P,w,_.getAttributeLocations());return this._programByKey.set(g,b),b}_getMaterialOptionsValue(i,_){switch(i){case ee.BACKGROUND:case ee.FILL:return(_.pattern?1:0)<<1;case ee.OUTLINE:return 0;case ee.LINE:{const i=_;return(i.sdf?1:0)<<2|(i.pattern?1:0)<<1}case ee.ICON:return(_.sdf?1:0)<<1;case ee.CIRCLE:case ee.TEXT:default:return 0}}_getProgramTemplate(i){switch(i){case ee.BACKGROUND:return Be;case ee.CIRCLE:return Ge;case ee.FILL:return $e;case ee.ICON:return Ke;case ee.LINE:return Ye;case ee.OUTLINE:return qe;case ee.TEXT:return je;default:return null}}}const Xe=1e-6;class l{constructor(i,_){this.spriteMosaic=i,this.glyphMosaic=_,this._brushCache=new Map,this._vtlMaterialManager=new p}dispose(){this._brushCache&&(this._brushCache.forEach((i=>i.dispose())),this._brushCache=null),this._vtlMaterialManager=te(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(i,_,m){const g=m.layers;i.renderPass="translucent";for(let v=0;v<g.length;v++){const m=g[v];if(m.type!==ie.SYMBOL)continue;const y=m.getLayoutProperty("visibility");if(y&&y.getValue()===ae.NONE)continue;const x=i.displayLevel;void 0!==m.minzoom&&m.minzoom>x+Xe||void 0!==m.maxzoom&&m.maxzoom<=x-Xe||(i.styleLayerUID=m.uid,i.styleLayer=m,this._drawWithBrush(i,_,"vtlSymbol"))}}drawBackground(i,_,m){if(0===m.backgroundBucketIds.length)return;const{context:g,displayLevel:v,requiredLevel:y}=i;_.key.level=y,g.setBlendingEnabled(!0),g.setDepthTestEnabled(!1),g.setStencilTestEnabled(!1),i.renderPass="background",m.backgroundBucketIds.forEach((g=>{const y=m.getLayerById(g);if(y.type!==ie.BACKGROUND)return;const x=y.getLayoutProperty("visibility");x&&x.getValue()===ae.NONE||void 0!==y.minzoom&&y.minzoom>v+Xe||void 0!==y.maxzoom&&y.maxzoom<=v-Xe||(i.styleLayerUID=y.uid,i.styleLayer=y,this._drawWithBrush(i,_,"vtlBackground"))}))}drawTile(i,_,m,g){const{context:v}=i,y=m.layers;v.setBlendingEnabled(!1),v.setDepthTestEnabled(!0),v.setDepthWriteEnabled(!0),v.setDepthFunction(N.LEQUAL),i.renderPass="opaque";for(let x=y.length-1;x>=0;x--){const m=y[x];null!=g&&g!==m.type||this._renderStyleLayer(m,i,_,!1)}v.setDepthWriteEnabled(!1),v.setBlendingEnabled(!0),v.setBlendFunctionSeparate(ne.ONE,ne.ONE_MINUS_SRC_ALPHA,ne.ONE,ne.ONE_MINUS_SRC_ALPHA),i.renderPass="translucent";for(let x=0;x<y.length;x++){const m=y[x];null!=g&&g!==m.type||this._renderStyleLayer(m,i,_,!1)}v.setDepthTestEnabled(!1),v.bindVAO()}_renderStyleLayer(i,_,m,g){if(!(g||i&&m.layerData.has(i.uid)))return;const v=i.getLayoutProperty("visibility");if(v&&v.getValue()===ae.NONE)return;const{renderPass:y}=_;let x;switch(i.type){case ie.BACKGROUND:if("background"!==y)return;x="vtlBackground";break;case ie.FILL:if("opaque"!==y&&"translucent"!==_.renderPass)return;x="vtlFill";break;case ie.LINE:if("translucent"!==y)return;x="vtlLine";break;case ie.CIRCLE:if("translucent"!==y)return;x="vtlCircle";break;case ie.SYMBOL:if("translucent"!==y)return;x="vtlSymbol"}const w=_.displayLevel;if(void 0!==i.minzoom&&i.minzoom>w+Xe||void 0!==i.maxzoom&&i.maxzoom<=w-Xe)return;const{context:S}=_;S.setStencilTestEnabled(!1),S.setStencilWriteMask(0),_.styleLayerUID=i.uid,_.styleLayer=i,this._drawWithBrush(_,m,x)}_drawWithBrush(i,_,m){if(!this._brushCache.has(m)){const i=Fe[m];this._brushCache.set(m,new i)}this._brushCache.get(m).drawMany(i,[_])}}let Qe=class extends(Me(Se(Pe))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=re("disable-feature:vtl-level-shift")?0:1}initialize(){if(null==this.layer.fullExtent)return void this.addResolvingPromise(Promise.reject(new se("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:i,spatialReference:_,state:m,viewingMode:g}=this.view,v="local"===g&&!oe(_)||le.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),y=this._getTileInfoSupportError(v,this.layer.fullExtent);if(null!=y)return this.addResolvingPromise(Promise.reject(y));const x=ce((()=>{var i,_;return null==(_=null==(i=this.view)?void 0:i.basemapTerrain)?void 0:_.tilingSchemeLocked})).then((()=>{var _,m;const g=i.tilingScheme,v=g.pixelSize,y=256===v?1:2,x=(null==(_=i.spatialReference)?void 0:_.isGeographic)&&256===v?1:0,w=(null==(m=i.spatialReference)?void 0:m.isGeographic)||256!==v?0:1;let S;this.schemaHelper=new be(y,x,this.levelShift+w),S=256===v||512===v?this.layer.tileInfo.getCompatibleForVTL(v):this.layer.tileInfo;const M=this._getTileInfoCompatibilityError(S,g);if(M)throw M;this.tileInfo=S}));this._tileHandlerController=new AbortController;const w=this.view.resourceController;this._memCache=w.memoryController.newCache(`vtl-${this.layer.uid}`,(i=>{i.release()})),this.addHandles(ue((()=>this.view.qualitySettings.memoryLimit),(i=>this._memCache.maxSize=Math.ceil(i/10*1048576)),he));const S=new de(this.layer.currentStyleInfo.style);this._tileHandler=new ze(this.layer,S,m.contentPixelRatio,this._memCache);const M=this._tileHandlerController.signal,P=function H(i){return _=>i.immediate.schedule(_)}(w),b=this._tileHandler.start({signal:M,schedule:P}),T=this._tileHandler.spriteMosaic;T.then((i=>{!_e(M)&&this._tileHandler&&(this.painter=new l(i,this._tileHandler.glyphMosaic))})),b.then((()=>this._tileHandlerController=null));const L2=()=>{var i;this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const _=this.layer.currentStyleInfo.style,m=(null==(i=this.view.state)?void 0:i.contentPixelRatio)??1,g=new de(_),v=new ze(this.layer,g,m,this._memCache),y=v.start({signal:this._tileHandlerController.signal,schedule:P}),x=v.spriteMosaic;y.then((()=>this._tileHandlerController=null)),this._updatingHandles.addPromise(Promise.all([y,x]).then((([,i])=>{const _=this._tileHandler,m=this.painter;this.painter=new l(i,v.glyphMosaic),this._tileHandler=v,this.emit("data-changed"),_.destroy(),m&&m.dispose()})))};this._updatingHandles.add((()=>{var i;return{style:this.layer.currentStyleInfo.style,pixelRatio:null==(i=this.view.state)?void 0:i.contentPixelRatio}}),L2),this.addHandles([this.layer.on("paint-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-change",L2),this.layer.on("delete-style-layer",L2),this.layer.on("spriteSource-change",(()=>this.emit("data-changed"))),this.layer.on("layout-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-visibility-change",(()=>this.emit("data-changed")))]);const R=Promise.all([x,b,T]);this.addResolvingPromise(R)}destroy(){this.painter=te(this.painter),this._tileHandlerController=x(this._tileHandlerController),this._tileHandler=fe(this._tileHandler),this._memCache=fe(this._memCache)}get contentZoom(){return re("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const i=this.tileInfo.lods,_=this.layer.minScale||i[0].scale,m=this.layer.maxScale||i[i.length-1].scale,g=this.levelRangeFromScaleRange(_,m);return this.layer.maxScale?g.maxLevel++:g.maxLevel+=this.levelShift,g}get dataScaleRange(){const i=this.tileInfo.lods;return{minScale:i[0].scale,maxScale:i[i.length-1].scale}}get dataLevelRange(){const{minScale:i,maxScale:_}=this.dataScaleRange,m=this.levelRangeFromScaleRange(i,_);return 1===m.minLevel&&256===this.tileInfo.size[0]&&(m.minLevel=0),m.maxLevel+=this.levelShift,m}async fetchTile(i,_){const m=this.schemaHelper.getLevelRowColumn(i);return this._tileHandler.getVectorTile(m,_)}};pe([me()],Qe.prototype,"layer",void 0),pe([me()],Qe.prototype,"levelShift",void 0),pe([me()],Qe.prototype,"contentZoom",null),pe([me()],Qe.prototype,"displayLevelRange",null),pe([me()],Qe.prototype,"tileInfo",void 0),pe([me()],Qe.prototype,"dataScaleRange",null),pe([me()],Qe.prototype,"dataLevelRange",null),pe([me()],Qe.prototype,"updatingProgressValue",void 0),Qe=pe([ge("esri.views.3d.layers.VectorTileLayerView3D")],Qe);const Ze=Qe;export{Ze as default};
