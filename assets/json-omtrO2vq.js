const t={convertToGEGeometry:function s(t,u){return null==u?null:t.convertJSONToGeometry(u)},exportPoint:function n(t,u,l){const v=new i(t.getPointX(u),t.getPointY(u),l),M=t.hasZ(u),p=t.hasM(u);return M&&(v.z=t.getPointZ(u)),p&&(v.m=t.getPointM(u)),v},exportPolygon:function o(t,u,l){return new e(t.exportPaths(u),l,t.hasZ(u),t.hasM(u))},exportPolyline:function a(t,u,l){return new h(t.exportPaths(u),l,t.hasZ(u),t.hasM(u))},exportMultipoint:function c(t,u,l){return new r(t.exportPoints(u),l,t.hasZ(u),t.hasM(u))},exportExtent:function m(t,u,l){const v=t.hasZ(u),M=t.hasM(u),p=new x(t.getXMin(u),t.getYMin(u),t.getXMax(u),t.getYMax(u),l);if(v){const l=t.getZExtent(u);p.zmin=l.vmin,p.zmax=l.vmax}if(M){const l=t.getMExtent(u);p.mmin=l.vmin,p.mmax=l.vmax}return p}};class i{constructor(t,u,l){this.x=t,this.y=u,this.spatialReference=l,this.z=void 0,this.m=void 0}}class e{constructor(t,u,l,v){this.rings=t,this.spatialReference=u,this.hasZ=void 0,this.hasM=void 0,l&&(this.hasZ=l),v&&(this.hasM=v)}}class h{constructor(t,u,l,v){this.paths=t,this.spatialReference=u,this.hasZ=void 0,this.hasM=void 0,l&&(this.hasZ=l),v&&(this.hasM=v)}}class r{constructor(t,u,l,v){this.points=t,this.spatialReference=u,this.hasZ=void 0,this.hasM=void 0,l&&(this.hasZ=l),v&&(this.hasM=v)}}class x{constructor(t,u,l,v,M){this.xmin=t,this.ymin=u,this.xmax=l,this.ymax=v,this.spatialReference=M,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}export{t};
