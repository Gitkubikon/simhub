import{fd as e,fe as t,b as s,ff as i,fg as n,fh as r,aY as a,x as o,W as l,n as u,G as d,fi as p,fj as c,bZ as y,fk as h,fl as m,fm as f,fn as g}from"./index-DSIPxOWi.js";import{m as _}from"./FeatureStore-Dpo5Syxq.js";import{$ as j,x as F,j as E}from"./QueryEngine-DAD9skS_.js";import{I,N as b,E as T}from"./geojson-CFL0cZN1.js";import{o as w,c as q,i as x}from"./clientSideDefaults-Cn_svm8L.js";import{j as S,p as R,d as k,f as C,y as O}from"./sourceUtils-BFIlJ45V.js";import"./BoundsStore-BQ0MOdb7.js";import"./PooledRBush-DOZnXWx2.js";import"./quickselect-D9ta8ndX.js";import"./optimizedFeatureQueryEngineAdapter--U1rvwBV.js";import"./normalizeUtils-BrH-PrZy.js";import"./normalizeUtilsCommon-BU8xfl77.js";import"./WhereClause-DYd7Xwn9.js";import"./TimeOnly-C5lZbbIX.js";import"./json-omtrO2vq.js";import"./QueryEngineCapabilities-CTDe3LlQ.js";import"./utils-B-uQJqPz.js";import"./utils-DEUXBrCj.js";import"./utils-1_4Re7um.js";import"./ClassBreaksDefinition-Dt1HCCB7.js";import"./date-Do_V47iR.js";const v={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};class Q{constructor(){this._queryEngine=null,this._snapshotFeatures=async e=>{const t=await this._fetch(e);return this._createFeatures(t)}}destroy(){var e;null==(e=this._queryEngine)||e.destroy(),this._queryEngine=this._createDefaultAttributes=null}async load(o,l={}){this._loadOptions={url:o.url,customParameters:o.customParameters};const u=[],[d]=await Promise.all([o.url?this._fetch(null==l?void 0:l.signal):null,this._checkProjection(o.spatialReference)]),p=I(d,{geometryType:o.geometryType}),c=o.fields||p.fields||[],y=null!=o.hasZ?o.hasZ:p.hasZ,h=p.geometryType;let m=o.objectIdField||p.objectIdFieldName||"__OBJECTID";const f=o.spatialReference||e;let g=o.timeInfo;c===p.fields&&p.unknownFields.length>0&&u.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:p.unknownFields}});const F=new t(c);let E=F.get(m);E?("esriFieldTypeString"!==E.type&&(E.type="esriFieldTypeOID"),E.editable=!1,E.nullable=!1,m=E.name):(E={alias:m,name:m,type:"string"===p.objectIdFieldType?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},c.unshift(E));const b={};for(const e of c){if(null==e.name&&(e.name=e.alias),null==e.alias&&(e.alias=e.name),!e.name)throw new s("geojson-layer:invalid-field-name","field name is missing",{field:e});if(!i.jsonValues.includes(e.type))throw new s("geojson-layer:invalid-field-type",`invalid type for field "${e.name}"`,{field:e});if(e.name!==E.name){const t=n(e);void 0!==t&&(b[e.name]=t)}null==e.length&&(e.length=r(e))}if(g){if(g.startTimeField){const e=F.get(g.startTimeField);e?(g.startTimeField=e.name,e.type="esriFieldTypeDate"):g.startTimeField=null}if(g.endTimeField){const e=F.get(g.endTimeField);e?(g.endTimeField=e.name,e.type="esriFieldTypeDate"):g.endTimeField=null}if(g.trackIdField){const e=F.get(g.trackIdField);e?g.trackIdField=e.name:(g.trackIdField=null,u.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:g}}))}g.startTimeField||g.endTimeField||(u.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:g}}),g=null)}const T=h?w(h):void 0,S=F.dateFields.length?{timeZoneIANA:a}:null,R={warnings:u,featureErrors:[],layerDefinition:{...v,drawingInfo:T??void 0,templates:q(b),extent:void 0,geometryType:h,objectIdField:m,fields:c,hasZ:!!y,timeInfo:g,dateFieldsTimeReference:S}};this._queryEngine=new j({fieldsIndex:t.fromLayerJSON({fields:c,timeInfo:g,dateFieldsTimeReference:S}),geometryType:h,hasM:!1,hasZ:y,objectIdField:m,spatialReference:f,timeInfo:g,featureStore:new _({geometryType:h,hasM:!1,hasZ:y}),cacheSpatialQueries:!0});const k=this._queryEngine.fieldsIndex.requiredFields.indexOf(E);k>-1&&this._queryEngine.fieldsIndex.requiredFields.splice(k,1),this._createDefaultAttributes=x(b,m);const C=await this._createFeatures(d);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,C);const O=this._normalizeFeatures(C,R.featureErrors);this._queryEngine.featureStore.addMany(O);const{fullExtent:D,timeExtent:A}=await this._queryEngine.fetchRecomputedExtents();if(R.layerDefinition.extent=D,A){const{start:e,end:t}=A;R.layerDefinition.timeInfo.timeExtent=[e,t]}return R}async applyEdits(e){const{spatialReference:t,geometryType:s}=this._queryEngine;return await Promise.all([S(t,s),F(e.adds,t),F(e.updates,t)]),await this._waitSnapshotComplete(),this._applyEdits(e)}async queryFeatures(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(e,t.signal)}async querySnapping(e,t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(e,t.signal)}async refresh(e){var t;this._loadOptions.customParameters=e,null==(t=this._snapshotTask)||t.abort(),this._snapshotTask=o(this._snapshotFeatures),this._snapshotTask.promise.then((e=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,e);const t=this._normalizeFeatures(e);t&&this._queryEngine.featureStore.addMany(t)}),(e=>{this._queryEngine.featureStore.clear(),l(e)||u.getLogger("esri.layers.GeoJSONLayer").error(new s("geojson-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete();const{fullExtent:i,timeExtent:n}=await this._queryEngine.fetchRecomputedExtents();return{extent:i,timeExtent:n}}async _createFeatures(t){if(null==t)return[];const{geometryType:s,hasZ:i,objectIdField:n}=this._queryEngine,r=b(t,{geometryType:s,hasZ:i,objectIdField:n});if(!d(this._queryEngine.spatialReference,e))for(const a of r)null!=a.geometry&&(a.geometry=p(E(c(a.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),e,this._queryEngine.spatialReference)));return r}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(e){const{url:t,customParameters:s}=this._loadOptions,i=(await y(t??"",{responseType:"json",query:{...s},signal:e})).data;return T(i),i}_normalizeFeatures(e,t){const{objectIdField:s,fieldsIndex:i}=this._queryEngine,n=[];for(const r of e){const e=this._createDefaultAttributes(),a=R(i,e,r.attributes,!0);a?null==t||t.push(a):(this._assignObjectId(e,r.attributes,!0),r.attributes=e,r.objectId=e[s],n.push(r))}return n}async _applyEdits(e){const{adds:t,updates:s,deletes:i}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if((null==t?void 0:t.length)&&this._applyAddEdits(n,t),(null==s?void 0:s.length)&&this._applyUpdateEdits(n,s),null==i?void 0:i.length){for(const e of i)n.deleteResults.push(k(e));this._queryEngine.featureStore.removeManyById(i)}const{fullExtent:r,timeExtent:a}=await this._queryEngine.fetchRecomputedExtents();return{extent:r,timeExtent:a,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:s}=e,{geometryType:i,hasM:n,hasZ:r,objectIdField:a,spatialReference:o,featureStore:l,fieldsIndex:u}=this._queryEngine,d=[];for(const p of t){if(p.geometry&&i!==h(p.geometry)){s.push(C("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=R(u,t,p.attributes);if(n)s.push(n);else{if(this._assignObjectId(t,p.attributes),p.attributes=t,null!=p.uid){const t=p.attributes[a];e.uidToObjectId[p.uid]=t}if(null!=p.geometry){const e=p.geometry.spatialReference??o;p.geometry=E(O(p.geometry,e),e,o)}d.push(p),s.push(k(p.attributes[a]))}}l.addMany(m([],d,i,r,n,a))}_applyUpdateEdits({updateResults:e},t){const{geometryType:s,hasM:i,hasZ:n,objectIdField:r,spatialReference:a,featureStore:o,fieldsIndex:l}=this._queryEngine;for(const u of t){const{attributes:t,geometry:d}=u,p=null==t?void 0:t[r];if(null==p){e.push(C(`Identifier field ${r} missing`));continue}if(!o.has(p)){e.push(C(`Feature with object id ${p} missing`));continue}const c=f(o.getFeature(p),s,n,i);if(null!=d){if(s!==h(d)){e.push(C("Incorrect geometry type."));continue}const t=d.spatialReference??a;c.geometry=E(O(d,t),t,a)}if(t){const s=R(l,c.attributes,t);if(s){e.push(s);continue}}o.add(g(c,s,n,i,r)),e.push(k(p))}}_createObjectIdGenerator(e,t){const s=e.fieldsIndex.get(e.objectIdField);if("esriFieldTypeString"===s.type)return()=>s.name+"-"+Date.now().toString(16);let i=Number.NEGATIVE_INFINITY;for(const n of t)n.objectId&&(i=Math.max(i,n.objectId));return i=Math.max(0,i)+1,()=>i++}_assignObjectId(e,t,s=!1){const i=this._queryEngine.objectIdField;e[i]=s&&i in t?t[i]:this._objectIdGenerator()}async _checkProjection(t){try{await F(e,t)}catch{throw new s("geojson-layer","Projection not supported")}}}export{Q as default};
