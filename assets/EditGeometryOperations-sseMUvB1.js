import{c_ as n,nZ as o,aw as _,nY as m,sg as y,sh as x,si as v,O as V,Q as T,sj as P,bM as w,kj as A,e6 as C,bK as D,du as Z,p1 as S,ql as G,br as b,sk as U,ok as L,dN as I,sl as X,b$ as k,kH as N,bc as O,ii as H,ax as B,j as q,bY as F,bg as $,dx as j,sm as W,L as K,N as Q,dC as J,sn as ee,dB as te,cd as ie,dD as se,dz as re,mW as ne,cW as oe,kg as ae,c$ as he,so as ce,sp as le,sq as de,dy as pe,ee as ue,sr as _e,nX as ge,ss as fe,st as me,a0 as ye,bO as xe}from"./index-DSIPxOWi.js";import{b as ve,j as Ve}from"./geometry2dUtils-4c9qUvJ6.js";var Ee,Te,Pe,Me;(Te=Ee||(Ee={}))[Te.Z=0]="Z",Te[Te.M=1]="M";class R{constructor(n){this.spatialReference=n}createVector(){return this._tag(n())}pointToVector(n){return this._tag(o(n.x,n.y))}arrayToVector(n){return this._tag(o(n[0],n[1]))}vectorToArray(n){return[n[0],n[1]]}pointToArray(n){return[n.x,n.y]}vectorToPoint(n,o=new _){return o.x=n[0],o.y=n[1],o.z=void 0,o.m=void 0,o.spatialReference=this.spatialReference,o}arrayToPoint(n,o=new _){return o.x=n[0],o.y=n[1],o.z=void 0,o.m=void 0,o.spatialReference=this.spatialReference,o}vectorToDehydratedPoint(n,o){if(n)return o??(o={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}),o.x=n[0],o.y=n[1],o.z=void 0,o.m=void 0,o.hasZ=!1,o.hasM=!1,o.spatialReference=this.spatialReference,o}lerp(n,o,_,y){return m(y,n,o,_)}addDelta(n,o,_){n[0]+=o,n[1]+=_}distance(n,o){return y(n,o)}getZ(n,o=void 0){return o}hasZ(){return!1}getM(n,o=void 0){return o}hasM(){return!1}clone(n){return this._tag(x(n))}copy(n,o){return v(o,n)}fromXYZ(n){return this._tag(o(n[0],n[1]))}toXYZ(n,o=T()){return V(o,n[0],n[1],0)}pointToXYZ(n,o=T()){return V(o,n.x,n.y,0)}equals(n,o){return P(n,o)}_tag(n){return n}}class M{constructor(n,o){this._valueType=n,this.spatialReference=o}createVector(){return this._tag(T())}pointToVector(n){return this._tag(w(n.x,n.y,this._valueType===Ee.Z?n.z:n.m))}arrayToVector(n){return this._tag(w(n[0],n[1],n[2]||0))}vectorToArray(n){return[n[0],n[1],n[2]]}pointToArray(n){return this._valueType===Ee.Z?[n.x,n.y,n.z]:[n.x,n.y,n.m]}vectorToPoint(n,o=new _){return o.x=n[0],o.y=n[1],o.z=this._valueType===Ee.Z?n[2]:void 0,o.m=this._valueType===Ee.M?n[2]:void 0,o.spatialReference=this.spatialReference,o}arrayToPoint(n,o=new _){return o.x=n[0],o.y=n[1],o.z=this._valueType===Ee.Z?n[2]:void 0,o.m=this._valueType===Ee.M?n[2]:void 0,o.spatialReference=this.spatialReference,o}vectorToDehydratedPoint(n,o){if(!n)return;o??(o={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"});const _=this._valueType===Ee.Z,m=this._valueType===Ee.M;return o.x=n[0],o.y=n[1],o.z=_?n[2]:void 0,o.m=m?n[2]:void 0,o.hasZ=_,o.hasM=m,o.spatialReference=this.spatialReference,o}lerp(n,o,_,m){return A(m,n,o,_)}addDelta(n,o,_,m){n[0]+=o,n[1]+=_,this._valueType===Ee.Z&&(n[2]+=m)}distance(n,o){return this._valueType===Ee.Z?C(n,o):y(n,o)}getZ(n,o=void 0){return this._valueType===Ee.Z?n[2]:o}hasZ(){return this._valueType===Ee.Z}getM(n,o=void 0){return this._valueType===Ee.M?n[2]:o}hasM(){return this._valueType===Ee.M}clone(n){return this._tag(D(n))}copy(n,o){return Z(o,n)}fromXYZ(n,o=0,_=0){return this._tag(w(n[0],n[1],this._valueType===Ee.Z?n.length>2?n[2]:o:_))}toXYZ(n,o=T()){return V(o,n[0],n[1],this._valueType===Ee.Z?n[2]:0)}pointToXYZ(n,o=T()){return V(o,n.x,n.y,this._valueType===Ee.Z?n.z??0:0)}equals(n,o){return S(n,o)}_tag(n){return n}}class z{constructor(n){this.spatialReference=n}createVector(){return this._tag(G())}pointToVector(n){return this._tag(b(n.x,n.y,n.z,n.m))}arrayToVector(n){return this._tag(b(n[0],n[1],n[2]||0,n[3]||0))}vectorToArray(n){return[n[0],n[1],n[2],n[3]]}pointToArray(n){return[n.x,n.y,n.z,n.m]}vectorToPoint(n,o=new _){return o.x=n[0],o.y=n[1],o.z=n[2],o.m=n[3],o.spatialReference=this.spatialReference,o}arrayToPoint(n,o=new _){return o.x=n[0],o.y=n[1],o.z=n[2],o.m=n[3],o.spatialReference=this.spatialReference,o}vectorToDehydratedPoint(n,o){if(n)return o??(o={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}),o.x=n[0],o.y=n[1],o.z=n[2],o.m=n[3],o.hasZ=!0,o.hasM=!0,o.spatialReference=this.spatialReference,o}lerp(n,o,_,m){return U(m,n,o,_)}addDelta(n,o,_,m){n[0]+=o,n[1]+=_,n[2]+=m}distance(n,o){return C(n,o)}getZ(n){return n[2]}hasZ(){return!0}getM(n){return n[3]}hasM(){return!0}clone(n){return this._tag(L(n))}copy(n,o){return I(o,n)}fromXYZ(n,o=0,_=0){return this._tag(b(n[0],n[1],n.length>2?n[2]:o,_))}toXYZ(n,o=T()){return V(o,n[0],n[1],n[2])}pointToXYZ(n,o=T()){return V(o,n.x,n.y,n.z??0)}equals(n,o){return X(n,o)}_tag(n){return n}}function P$1(n,o,_){return n&&o?new z(_):o?new M(Ee.M,_):n?new M(Ee.Z,_):new R(_)}class h{constructor(n){this.component=n,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(n){this._pos=n,this.component.unnormalizeVertexPositions()}}class l{constructor(n,o,_){this.component=n,this.leftVertex=o,this.rightVertex=_,this.type="edge",o.rightEdge=this,_.leftEdge=this}}class a{constructor(n,o){this._spatialReference=n,this._viewingMode=o,this.vertices=[],this.edges=[],this.index=null}unnormalizeVertexPositions(){this.vertices.length<=1||function e$2(n,o){if(!o.supported)return;let _=1/0,m=-1/0;const y=o.upperBoundX-o.lowerBoundX;n.forEach((n=>{let x=n.pos[0];for(;x<o.lowerBoundX;)x+=y;for(;x>o.upperBoundX;)x-=y;_=Math.min(_,x),m=Math.max(m,x),n.pos[0]=x}));const x=m-_;y-x<x&&n.forEach((n=>{n.pos[0]<0&&(n.pos[0]+=y)}))}(this.vertices,function p$1(n,o){const _=k(n);return o===N.Global&&_?{supported:!0,lowerBoundX:_.valid[0],upperBoundX:_.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}(this._spatialReference,this._viewingMode))}updateVertexIndex(n,o){if(0===this.vertices.length)return;const _=this.vertices[0];let m=null,y=n,x=o;do{m=y,m.index=x++,y=m.rightEdge?m.rightEdge.rightVertex:null}while(null!=y&&y!==_);m.leftEdge&&m!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(m),this.vertices.length-1)}getFirstVertex(){return this.vertices.at(0)}getLastVertex(){return this.vertices.at(-1)}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(n,o){const _=this.vertices[n];this.vertices[n]=this.vertices[o],this.vertices[o]=_}iterateVertices(n){if(0===this.vertices.length)return;const o=this.vertices[0];let _=o;do{n(_,_.index),_=null!=_.rightEdge?_.rightEdge.rightVertex:null}while(_!==o&&null!=_)}}class p extends O{constructor(n,o){super(),this.type=n,this.coordinateHelper=o,this._geometry=null,this._dirty=!0,this.components=[]}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this._toPoint();break;case"polyline":this._geometry=this._toPolyline();break;case"polygon":this._geometry=this._toPolygon();break;case"mesh":break;default:H(this.type)}this._dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}get allVertices(){return Array.from(this.iterateVertices())}*iterateVertices(){for(const n of this.components)for(const o of n.vertices)yield o}notifyChanges(n){this._dirty=!0,this.emit("change",n)}_toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}_toPolyline(){const n=[],o=this.coordinateHelper.vectorToArray;for(const _ of this.components){if(_.vertices.length<1)continue;const m=[];let y=_.vertices.find((n=>null==n.leftEdge));const x=y;do{m.push(o(y.pos)),y=y.rightEdge?y.rightEdge.rightVertex:null}while(y&&y!==x);n.push(m)}return new B({paths:n,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}_toPolygon(){const n=[],o=this.coordinateHelper.vectorToArray;for(const _ of this.components){if(_.vertices.length<1)continue;const m=[],y=_.vertices[0];let x=y;const v=x;do{m.push(o(x.pos)),x=null!=x.rightEdge?x.rightEdge.rightVertex:null}while(x&&x!==v);_.isClosed()&&m.push(o(y.pos)),n.push(m)}return new q({rings:n,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(n,o){const _=n.spatialReference,m=P$1(n.hasZ,n.hasM,_),y=new p(n.type,m);switch(n.type){case"polygon":!function g(n,o,_){const m=o.spatialReference,y=n.coordinateHelper,x=o.rings;for(let v=0;v<x.length;++v){const o=x[v],V=new a(m,_);V.index=v;const T=o.length>2&&F(o[0],o[o.length-1]),P=T?o.length-1:o.length;for(let n=0;n<P;++n){const _=y.arrayToVector(o[n]),m=new h(V);V.vertices.push(m),m.pos=_,m.index=n}const w=V.vertices.length-1;for(let n=0;n<w;++n){const o=V.vertices[n],_=V.vertices[n+1],m=new l(V,o,_);V.edges.push(m)}if(T){const n=new l(V,V.vertices[V.vertices.length-1],V.vertices[0]);V.edges.push(n)}n.components.push(V)}}(y,n,o);break;case"polyline":!function d(n,o,_){const m=o.spatialReference,y=n.coordinateHelper,x=o.paths;for(let v=0;v<x.length;++v){const o=x[v],V=new a(m,_);V.index=v;const T=o.length;for(let n=0;n<T;++n){const _=y.arrayToVector(o[n]),m=new h(V);V.vertices.push(m),m.pos=_,m.index=n}const P=V.vertices.length-1;for(let n=0;n<P;++n){const o=V.vertices[n],_=V.vertices[n+1],m=new l(V,o,_);V.edges.push(m)}n.components.push(V)}}(y,n,o);break;case"point":u(y,n,o);break;case"mesh":u(y,n.anchor,o),y._geometry=n,y._dirty=!1}return y}}function u(n,o,_){const m=o.spatialReference,y=n.coordinateHelper,x=new a(m,_);x.index=0;const v=new h(x);v.index=0,v.pos=y.pointToVector(o),x.vertices.push(v),n.components.push(x)}function f(n){return"mesh"===n.type}(Me=Pe||(Pe={}))[Me.NEW_STEP=0]="NEW_STEP",Me[Me.ACCUMULATE_STEPS=1]="ACCUMULATE_STEPS";let we=class i{constructor(n,o,_){this._editGeometry=n,this._component=o,this._pos=_,this._addedVertex=null,this._originalEdge=null,this._left=null,this._right=null}apply(){let n="redo";null==this._addedVertex&&(n="apply",this._addedVertex=new h(this._component));const o=this._component.getLastVertex();if(null==o)this._component.vertices.push(this._addedVertex),this._addedVertex.pos=this._pos,this._addedVertex.index=0;else{let n=null;o.rightEdge&&(this._originalEdge=o.rightEdge,n=this._originalEdge.rightVertex,this._component.edges.splice(this._component.edges.indexOf(this._originalEdge),1)),this._component.vertices.push(this._addedVertex),this._addedVertex.pos=this._pos,null==this._left&&(this._left=new l(this._component,o,this._addedVertex)),this._component.edges.push(this._left),o.rightEdge=this._left,null!=this._originalEdge&&null!=n&&(null==this._right&&(this._right=new l(this._component,this._addedVertex,n)),this._component.edges.push(this._right),n.leftEdge=this._right),this._component.updateVertexIndex(this._addedVertex,o.index+1)}this._editGeometry.notifyChanges({operation:n,addedVertices:[this._addedVertex]})}undo(){null!=this._addedVertex&&(this._component.vertices.splice(this._component.vertices.indexOf(this._addedVertex),1),null!=this._left&&(this._component.edges.splice(this._component.edges.indexOf(this._left),1),this._left.leftVertex.rightEdge=null),null!=this._right&&(this._component.edges.splice(this._component.edges.indexOf(this._right),1),this._right.rightVertex.leftEdge=null),null!=this._originalEdge&&(this._component.edges.push(this._originalEdge),this._originalEdge.leftVertex.rightEdge=this._originalEdge,this._originalEdge.rightVertex.leftEdge=this._originalEdge),null!=this._left?this._component.updateVertexIndex(this._left.leftVertex,this._left.leftVertex.index):this._component.updateVertexIndex(this._addedVertex,0),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this._addedVertex]}))}accumulate(){return!1}},Ae=class t{constructor(n,o,_){this._editGeometry=n,this._vertices=o,this.operation=_,this._undone=!1}apply(){this._vertices.forEach((n=>this.operation.apply(n))),this._editGeometry.components.forEach((n=>n.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:this._undone?"redo":"apply",updatedVertices:this._vertices})}undo(){this._vertices.forEach((n=>this.operation.undo(n))),this._editGeometry.notifyChanges({operation:"undo",updatedVertices:this._vertices}),this._undone=!0}canAccumulate(n){if(this._undone||n._vertices.length!==this._vertices.length)return!1;for(let o=0;o<n._vertices.length;++o)if(n._vertices[o]!==this._vertices[o])return!1;return this.operation.canAccumulate(n.operation)}accumulate(n){return!!(n instanceof t&&this.canAccumulate(n))&&(this._vertices.forEach((o=>this.operation.accumulate(o,n.operation))),this.operation.accumulateParams(n.operation),this._editGeometry.components.forEach((n=>n.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:"apply",updatedVertices:this._vertices}),!0)}};var Ce,De;(De=Ce||(Ce={}))[De.CUMULATIVE=0]="CUMULATIVE",De[De.REPLACE=1]="REPLACE";let Re=class t2{constructor(n,o,_=0){this._editGeometry=n,this._vertices=o,this._minNumberOfVertices=_,this.removedVertices=null}apply(){let n="redo";if(null==this.removedVertices){const o=this.removedVertices=[];this._vertices.forEach((n=>{const _=this._removeVertex(n);null!=_&&o.push(_)})),n="apply"}else this.removedVertices.forEach((n=>{this._removeVertex(n.removedVertex)}));this._editGeometry.notifyChanges({operation:n,removedVertices:this._vertices})}undo(){var n;null==(n=this.removedVertices)||n.forEach((n=>{this._undoRemoveVertex(n)})),this._editGeometry.notifyChanges({operation:"undo",addedVertices:this._vertices})}accumulate(){return!1}_removeVertex(n){const o=n.component;if(o.vertices.length<=this._minNumberOfVertices)return null;const _={removedVertex:n,createdEdge:null},m=n.leftEdge,y=n.rightEdge;return o.vertices.splice(o.vertices.indexOf(n),1),m&&(o.edges.splice(o.edges.indexOf(m),1),m.leftVertex.rightEdge=null),y&&(o.edges.splice(o.edges.indexOf(y),1),y.rightVertex.leftEdge=null),0===n.index&&y&&this._vertices.length>0&&o.swapVertices(o.vertices.indexOf(y.rightVertex),0),m&&y&&(_.createdEdge=new l(o,m.leftVertex,y.rightVertex),o.edges.push(_.createdEdge)),y&&o.updateVertexIndex(y.rightVertex,y.rightVertex.index-1),_}_undoRemoveVertex(n){const o=n.removedVertex,_=n.removedVertex.component,m=o.leftEdge,y=o.rightEdge;n.createdEdge&&_.edges.splice(_.edges.indexOf(n.createdEdge),1),_.vertices.push(o),m&&(_.edges.push(m),m.leftVertex.rightEdge=m),y&&(_.edges.push(y),y.rightVertex.leftEdge=y),_.updateVertexIndex(o,o.index)}},Ze=class i2{constructor(n,o,_){this._editGeometry=n,this._edge=o,this._t=_,this.createdVertex=null,this._left=null,this._right=null}apply(){let n="redo";const o=this._edge,_=o.component,m=o.leftVertex,y=o.rightVertex;_.edges.splice(_.edges.indexOf(o),1),null==this.createdVertex&&(n="apply",this.createdVertex=new h(o.component)),_.vertices.push(this.createdVertex),this.createdVertex.pos=this._editGeometry.coordinateHelper.lerp(o.leftVertex.pos,o.rightVertex.pos,this._t,this._editGeometry.coordinateHelper.createVector()),null==this._left&&(this._left=new l(_,m,this.createdVertex)),this._left.leftVertex.leftEdge?_.edges.push(this._left):_.edges.unshift(this._left),m.rightEdge=this._left,null==this._right&&(this._right=new l(_,this.createdVertex,y)),_.edges.push(this._right),y.leftEdge=this._right,_.updateVertexIndex(this.createdVertex,m.index+1),this._editGeometry.notifyChanges({operation:n,addedVertices:[this.createdVertex]})}undo(){if(null==this.createdVertex||null==this._left||null==this._right)return null;const n=this._edge,o=n.component,_=this.createdVertex.leftEdge,m=this.createdVertex.rightEdge,y=null==_?void 0:_.leftVertex,x=null==m?void 0:m.rightVertex;o.vertices.splice(o.vertices.indexOf(this.createdVertex),1),o.edges.splice(o.edges.indexOf(this._left),1),o.edges.splice(o.edges.indexOf(this._right),1),this._edge.leftVertex.leftEdge?o.edges.push(this._edge):o.edges.unshift(this._edge),y&&(y.rightEdge=n),x&&(x.leftEdge=n),y&&o.updateVertexIndex(y,y.index),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this.createdVertex]})}accumulate(){return!1}},Se=class t3{constructor(n,o,_){this._editGeometry=n,this._vertex=o,this._pos=_}apply(){const n=null==this._originalPosition;n&&(this._originalPosition=this._vertex.pos),this._apply(n?"apply":"redo")}undo(){this._vertex.pos=this._originalPosition,this._editGeometry.notifyChanges({operation:"undo",updatedVertices:[this._vertex]})}accumulate(n){return n instanceof t3&&n._vertex===this._vertex&&(this._pos=n._pos,this._apply("apply"),!0)}_apply(n){this._vertex.pos=this._pos,this._editGeometry.components.forEach((n=>n.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:n,updatedVertices:[this._vertex]})}};class r{constructor(n,o){this._editGeometry=n,this._component=o,this._createdEdge=null}apply(){let n="redo";if(null==this._createdEdge){n="apply";const o=this._component.getFirstVertex(),_=this._component.getLastVertex();if(this._component.isClosed()||this._component.vertices.length<3||null==o||null==_)return;this._createdEdge=new l(this._component,_,o)}this._createdEdge.leftVertex.rightEdge=this._createdEdge,this._createdEdge.rightVertex.leftEdge=this._createdEdge,this._component.edges.push(this._createdEdge),this._editGeometry.notifyChanges({operation:n})}undo(){null!=this._createdEdge&&($(this._component.edges,this._createdEdge),this._createdEdge.leftVertex.rightEdge=null,this._createdEdge.rightVertex.leftEdge=null,this._editGeometry.notifyChanges({operation:"undo"}))}accumulate(){return!1}}let ze=class t4{constructor(n,o,_,m){this._editGeometry=n,this.dx=o,this.dy=_,this.dz=m,this._firstTime=!0}apply(){const n=this._firstTime?"apply":"redo";this._firstTime=!1,this._apply(n,this.dx,this.dy,this.dz)}undo(){this._apply("undo",-this.dx,-this.dy,-this.dz)}accumulate(n){const o=this._editGeometry.geometry;return n instanceof t4&&n._editGeometry.geometry===o&&(this._apply("apply",n.dx,n.dy,n.dz),this.dx+=n.dx,this.dy+=n.dy,this.dz+=n.dz,!0)}_apply(n,o,_,m){const y=this._editGeometry.geometry;y.offset(o,_,m);const x=this._editGeometry.components[0].getFirstVertex();if(!x)return;const v=this._editGeometry.coordinateHelper;x.pos=v.pointToVector(y.anchor),this._editGeometry.notifyChanges({operation:n,updatedVertices:[x]})}},Ge=class t5{constructor(n,o,_,m){this._helper=n,this.dx=o,this.dy=_,this.dz=m}_move(n,o,_,m){this._helper.addDelta(n.pos,o,_,m)}apply(n){this._move(n,this.dx,this.dy,this.dz)}undo(n){this._move(n,-this.dx,-this.dy,-this.dz)}canAccumulate(n){return n instanceof t5}accumulate(n,o){this._move(n,o.dx,o.dy,o.dz)}accumulateParams(n){this.dx+=n.dx,this.dy+=n.dy,this.dz+=n.dz}};class Y{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(n,o,_,m=0,y=Ie.IMMEDIATE){this._helper=n,this._planeType=o,this._edge=_,this.distance=m,this._plane=j(),this._offsetPlane=j(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,y===Ie.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){var n,o,_,m;const y=this._toXYZ(this._edge.leftVertex.pos),x=this._toXYZ(null==(o=null==(n=this._edge.leftVertex.leftEdge)?void 0:n.leftVertex)?void 0:o.pos),v=this._toXYZ(this._edge.rightVertex.pos),V=this._toXYZ(null==(m=null==(_=this._edge.rightVertex.rightEdge)?void 0:_.rightVertex)?void 0:m.pos);this._edgeDirection=W(T(),y,v),x?(this._left=this._computeNeighbor(y,x,this._edgeDirection),this._right=this._computeNeighbor(v,V,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(v,V,this._edgeDirection),this._left=this._computeNeighbor(y,x,this._edgeDirection,this._right))}_toXYZ(n){return null!=n?this._helper.toXYZ(n):null}_pointToXYZ(n){return this._toXYZ(this._helper.pointToVector(n))}_computeNeighbor(n,o,_,m){const y=T();if(o){W(y,n,o);const m=!this._passesBisectingAngleThreshold(y,_);return{start:n,end:o,direction:m?this._bisectVectorsPerpendicular(_,y):y,isOriginalDirection:!m}}return this._helper.hasZ()?m&&(K(y,_,m.direction),K(y,y,_),Q(y,y),Math.sign(y[1])!==Math.sign(_[0])&&J(y,y,-1)):V(y,-_[1],_[0],0),{start:n,end:o,direction:y,isOriginalDirection:!0}}_passesBisectingAngleThreshold(n,o){const _=Math.abs(ee(o,n));return _>=be&&_<=Math.PI-be}_bisectVectorsPerpendicular(n,o){const _=te(n,o)<0?n:ie(T(),n),m=Math.abs(te(_,o));if(!(m<Ue||m>1-Ue))return this._bisectDirection(_,o);const y=K(T(),_,[0,0,1]);return Q(y,y)}_bisectDirection(n,o){const _=se(T(),n,o);return Q(_,_)}_initializePlane(){const n=this._computeNormalDirection(this._left),o=this._computeNormalDirection(this._right);te(n,o)<0&&ie(o,o),re(this._left.start,this._bisectDirection(n,o),this._plane)}_computeNormalDirection(n){const o=K(T(),n.direction,this._edgeDirection);Q(o,o);const _=K(T(),this._edgeDirection,o);return this._planeType===Le.XY&&(_[2]=0),Q(_,_)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(ne(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(ne(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(n){n<=0&&(this._minDistance=Math.max(this._minDistance,n)),n>=0&&(this._maxDistance=Math.min(this._maxDistance,n))}_updateIntersectDistanceConstraint(o){const _=pe(o),m=this._edgeDirection,y=se(T(),this._left.start,this._left.direction),x=se(T(),this._right.start,this._right.direction),v=this._pointInBasis2D(n(),_,m,this._left.start),V=this._pointInBasis2D(n(),_,m,y),P=this._pointInBasis2D(n(),_,m,this._right.start),w=this._pointInBasis2D(n(),_,m,x),[A]=ve({start:V,end:v,type:Ve.LINE},{start:w,end:P,type:Ve.LINE});if(!A)return;const C=oe(n(),v,V);ae(C,C);const D=oe(n(),A,V),Z=he(C,D),S=se(T(),y,J(T(),this._left.direction,-Z)),G=ne(o,S);this._updateDistanceConstraint(G)}_pointInBasis2D(n,o,_,m){return n[0]=ce(o,m),n[1]=ce(_,m),n}_offset(n,o){Number.isFinite(this._minDistance)&&(o=Math.max(this._minDistance,o)),Number.isFinite(this._maxDistance)&&(o=Math.min(this._maxDistance,o)),le(this._offsetPlane,this._plane),this._offsetPlane[3]-=o;const e2=(n,o,_)=>null!=o&&_e(this._offsetPlane,n,se(T(),n,o),_),_=T();(n===this._edge.leftVertex?e2(this._left.start,this._left.direction,_):e2(this._right.start,this._right.direction,_))&&this._helper.copy(this._helper.fromXYZ(_,void 0,this._helper.getM(n.pos)),n.pos)}selectArrowFromStartPoint(n){this._selectedArrow=de(this.plane,this._pointToXYZ(n))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(n){return ne(this.plane,this._pointToXYZ(n))}apply(n){this._offset(n,this.distance)}undo(n){this._offset(n,0)}canAccumulate(n){return n instanceof Y&&this._edge.leftVertex.index===n._edge.leftVertex.index&&this._edge.rightVertex.index===n._edge.rightVertex.index&&this._edge.component===n._edge.component&&this._maybeEqualsVec3(this._left.direction,n._left.direction)&&this._maybeEqualsVec3(this._right.direction,n._right.direction)&&S(pe(this._plane),pe(n._plane))}accumulate(n,o){const _=this._plane[3]-o._plane[3]+o.distance;this._offset(n,_)}accumulateParams(n){const o=n.distance-n._plane[3];this.distance=o+this._plane[3]}clone(){const n=new Y(this._helper,this._planeType,this._edge,this.distance,Ie.DEFERRED);return le(n._plane,this._plane),le(n._offsetPlane,this._offsetPlane),n._maxDistance=this._maxDistance,n._minDistance=this._minDistance,n._left=this._cloneNeighbor(this._left),n._right=this._cloneNeighbor(this._right),n._edgeDirection=Z(T(),this._edgeDirection),n}_maybeEqualsVec3(n,o){return null==n&&null==o||null!=n&&null!=o&&S(n,o)}_cloneNeighbor({start:n,end:o,direction:_,isOriginalDirection:m}){return{start:Z(T(),n),end:null!=o?Z(T(),o):null,direction:Z(T(),_),isOriginalDirection:m}}}const be=ue(15),Ue=.001;var Le,Ie,Xe;!function(n){n[n.XYZ=0]="XYZ",n[n.XY=1]="XY"}(Le||(Le={})),function(n){n[n.IMMEDIATE=0]="IMMEDIATE",n[n.DEFERRED=1]="DEFERRED"}(Ie||(Ie={}));class e{constructor(n,o,_=Ce.CUMULATIVE){this.origin=n,this.angle=o,this._accumulationType=_}_rotate(n,o){ge(n.pos,n.pos,this.origin,o)}apply(n){this._rotate(n,this.angle)}undo(n){this._rotate(n,-this.angle)}canAccumulate(n){return n instanceof e&&F(this.origin,n.origin)}accumulate(n,o){const _=o._accumulationType===Ce.REPLACE;this._rotate(n,_?o.angle-this.angle:o.angle)}accumulateParams(n){const o=n._accumulationType===Ce.REPLACE;this.angle=o?n.angle:this.angle+n.angle}}class c{constructor(n,_,m,y,x=Ce.CUMULATIVE){this.origin=n,this.axis1=_,this.factor1=m,this.factor2=y,this._accumulationType=x,this.axis2=o(_[1],-_[0])}_scale(n,o,_){fe(n.pos,n.pos,this.origin,this.axis1,o),fe(n.pos,n.pos,this.origin,this.axis2,_)}apply(n){this._scale(n,this.factor1,this.factor2)}undo(n){this._scale(n,1/this.factor1,1/this.factor2)}canAccumulate(n){return n instanceof c&&F(this.origin,n.origin)&&F(this.axis1,n.axis1)}accumulate(n,o){o._accumulationType===Ce.REPLACE?this._scale(n,o.factor1/this.factor1,o.factor2/this.factor2):this._scale(n,o.factor1,o.factor2)}accumulateParams(n){const o=n._accumulationType===Ce.REPLACE;this.factor1=o?n.factor1:this.factor1*n.factor1,this.factor2=o?n.factor2:this.factor2*n.factor2}}class i3{constructor(n,o){this._editGeometry=n,this._newPositions=o}apply(){const n=null==this._originalPositions?"apply":"redo";if(!this._originalPositions){const n=this._editGeometry.coordinateHelper;this._originalPositions=this._editGeometry.allVertices.map((o=>n.clone(o.pos)))}this._apply(n,this._newPositions)}undo(){this._originalPositions&&this._apply("undo",this._originalPositions)}accumulate(n){return n instanceof i3&&(this._newPositions=n._newPositions,this._apply("apply",this._newPositions),!0)}_apply(n,o){const _=this._editGeometry.coordinateHelper,m=this._editGeometry.allVertices;for(let y=0;y<m.length;y++)_.copy(o[y],m[y].pos);this._editGeometry.components.forEach((n=>n.unnormalizeVertexPositions())),this._editGeometry.notifyChanges({operation:n,updatedVertices:m})}}const Ye=Symbol();class s{constructor(n){this._operations=[],this._closed=!1,this[Xe]=!0,n&&(this._operations=n,this._closed=!0)}close(){this._closed=!0}apply(){for(const n of this._operations)n.apply()}undo(){for(let n=this._operations.length-1;n>=0;n--)this._operations[n].undo()}accumulate(n){if(this._closed)return!1;const o=this._operations.length?this._operations[this._operations.length-1]:null;return o&&o.accumulate(n)||(this._operations.push(n),n.apply()),!0}}Xe=Ye;class E extends O{constructor(n,o){super(),this.data=n,this.viewingMode=o,this._undoStack=[],this._redoStack=[],this._listener=this.data.on("change",(n=>{n.addedVertices&&this.emit("vertex-add",{type:"vertex-add",vertices:n.addedVertices,operation:n.operation}),n.removedVertices&&this.emit("vertex-remove",{type:"vertex-remove",vertices:n.removedVertices,operation:n.operation}),n.updatedVertices&&this.emit("vertex-update",{type:"vertex-update",vertices:n.updatedVertices,operation:n.operation})}))}destroy(){this._listener.remove()}splitEdge(n,o){return this._apply(new Ze(this.data,n,o))}updateVertices(n,o,_=Pe.ACCUMULATE_STEPS){return this._apply(new Ae(this.data,n,o),_)}move(n,o,_,m=Pe.ACCUMULATE_STEPS){return f(this.data)?this._apply(new ze(this.data,n,o,_),m):this.moveVertices(this.data.allVertices,n,o,_,m)}moveVertices(n,o,_,m,y=Pe.ACCUMULATE_STEPS){return f(this.data)?this._apply(new ze(this.data,o,_,m),y):this.updateVertices(n,new Ge(this.data.coordinateHelper,o,_,m),y)}scale(n,o,_,m,y=Pe.ACCUMULATE_STEPS,x=Ce.CUMULATIVE){return this.scaleVertices(this.data.allVertices,n,o,_,m,y,x)}scaleVertices(n,o,_,m,y,x=Pe.ACCUMULATE_STEPS,v=Ce.CUMULATIVE){return this.updateVertices(n,new c(o,_,m,y,v),x)}rotate(n,o,_=Pe.ACCUMULATE_STEPS,m=Ce.CUMULATIVE){return this.rotateVertices(this.data.allVertices,n,o,_,m)}rotateVertices(n,o,_,m=Pe.ACCUMULATE_STEPS,y=Ce.CUMULATIVE){return this.updateVertices(n,new e(o,_,y),m)}removeVertices(n){return this._apply(new Re(this.data,n,this._minNumVerticesPerType))}appendVertex(n){return 0===this.data.components.length?null:this._apply(new we(this.data,this.data.components[0],n))}setVertexPosition(n,o){return this._apply(new Se(this.data,n,o))}offsetEdge(n,o,_,m=Pe.ACCUMULATE_STEPS){return this.updateVertices([o.leftVertex,o.rightVertex],new Y(this.data.coordinateHelper,n,o,_),m)}trySetGeometry(n,o=Pe.ACCUMULATE_STEPS){const{data:_}=this,{coordinateHelper:m}=_;if(_.type!==n.type||!_.spatialReference.equals(n.spatialReference)||m.hasZ()!==n.hasZ||m.hasM()!==n.hasM||!me(_.geometry,n)||f(_))return;const y=Array.from(p.fromGeometry(n,this.viewingMode).iterateVertices(),(n=>n.pos));return this.setVertexPositions(y,o)}setVertexPositions(n,o=Pe.ACCUMULATE_STEPS){return this._apply(new i3(this.data,n),o)}createResetState(){if(f(this.data))return this._createResetStateMesh();const n=this.data.geometry.clone();return ye((()=>this.trySetGeometry(n)))}closeComponent(n){return this.data.components.includes(n)?this._apply(new r(this.data,n)):null}canRemoveVertex(n){return n.vertices.length>this._minNumVerticesPerType}createUndoGroup(){const n=new s;return this._apply(n),ye((()=>n.close()))}undo(){if(this._undoStack.length>0){const n=this._undoStack.pop();return n.undo(),this._redoStack.push(n),n}return null}redo(){if(this._redoStack.length>0){const n=this._redoStack.pop();return n.apply(),this._undoStack.push(n),n}return null}get canUndo(){return this._undoStack.length>0}get canRedo(){return this._redoStack.length>0}get lastOperation(){return this._undoStack.length>0?this._undoStack[this._undoStack.length-1]:null}get _minNumVerticesPerType(){switch(this.data.type){case"point":return 1;case"polyline":return 2;case"polygon":return 3;default:return 0}}_apply(n,o=Pe.ACCUMULATE_STEPS){return o!==Pe.NEW_STEP&&null!=this.lastOperation&&this.lastOperation.accumulate(n)||(n.apply(),this._undoStack.push(n),this._redoStack=[]),n}_createResetStateMesh(){if(!f(this.data))return ye();const n=this.data.geometry,{vertexSpace:o}=n;if(o.origin){const _=xe(o.origin);return ye((()=>{n.vertexSpace.origin=_}))}const _=n.vertexAttributes.clonePositional();return ye((()=>{n.vertexAttributes=_,n.vertexAttributesChanged()}))}static fromGeometry(n,o){return new E(p.fromGeometry(n,o),o)}}export{E,P$1 as P,Y,Le as Z,a,Pe as b,Ge as c,e as d,Ce as e,c as f,p,Ae as t};
