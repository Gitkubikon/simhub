const __vite__fileDeps=["assets/geometryEngineJSON-CrXS8d22.js","assets/geometryEngineBase-9EI9fooq.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/json-omtrO2vq.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{po as e,fr as i,pp as a,pq as d,pr as F,ps as S,pt as R,pu as A,id as E,pv as M,cD as V,fO as z,fw as Q,G as D,pw as O,cM as Z,ie as B,eX as k,fZ as L,b as J,ff as H,aS as Y,aT as W,c3 as X,c4 as ee,px as te,py as ie,aR as se,fu as re,pz as ae,_ as ne,pA as le,pB as oe,pC as ue,pD as ce,bn as he,c7 as de,gM as fe,cP as me,b0 as pe,cQ as ye,J as ge,lJ as xe,f0 as _e,fd as Fe,pE as Se,pF as we,pG as Re,pH as ve,pI as Ie,fk as Te,pJ as be,pK as Ae,cL as $e,fe as Ee,hS as qe,u as Me,pL as Pe,b3 as Ce,pM as Ve,kT as Ne,cC as Ge,kV as ze,d9 as Qe,pN as De,at as je,df as Oe,fi as Ze,lK as Be,cR as ke,cG as Ue,au as Le}from"./index-DSIPxOWi.js";import{R as Je}from"./normalizeUtils-BrH-PrZy.js";import{O as He}from"./WhereClause-DYd7Xwn9.js";import{t as Ye}from"./json-omtrO2vq.js";import{t as Ke}from"./QueryEngineCapabilities-CTDe3LlQ.js";import{w as We}from"./utils-B-uQJqPz.js";import{c as Xe,B as et,d as tt,p as it,C as st,k as rt,$ as at,E as nt,P as lt,U as ot,T as ut,v as ct,f as ht}from"./utils-1_4Re7um.js";const dt=new i,ft=new i,mt=new i,pt={esriGeometryPoint:a,esriGeometryPolyline:d,esriGeometryPolygon:F,esriGeometryMultipoint:S};function y$3(e,i,d,F=e.hasZ,S=e.hasM){if(null==i)return null;const A=e.hasZ&&F,E=e.hasM&&S;if(d){const M=R(mt,i,e.hasZ,e.hasM,"esriGeometryPoint",d,F,S);return a(M,A,E)}return a(i,A,E)}function a$1(i,a,d,F,S,E,M=a,V=d){var z,Q,D;const O=a&&M,Z=d&&V,B=null!=F?"coords"in F?F:F.geometry:null;if(null==B)return null;if(S){let e=A(ft,B,a,d,i,S,M,V);return E&&(e=R(mt,e,O,Z,i,E)),(null==(z=pt[i])?void 0:z.call(pt,e,O,Z))??null}if(E){const e=R(mt,B,a,d,i,E,M,V);return(null==(Q=pt[i])?void 0:Q.call(pt,e,O,Z))??null}return e(dt,B,a,d,M,V),(null==(D=pt[i])?void 0:D.call(pt,dt,O,Z))??null}function h$3(e){return e&&yt in e?JSON.parse(JSON.stringify(e,G$2)):e}const yt="_geVersion",G$2=(e,i)=>e!==yt?i:void 0,gt=[0,0];function h$2(e,i){if(!i)return null;if("x"in i){const a={x:0,y:0};return[a.x,a.y]=e(i.x,i.y,gt),null!=i.z&&(a.z=i.z),null!=i.m&&(a.m=i.m),a}if("xmin"in i){const a={xmin:0,ymin:0,xmax:0,ymax:0};return[a.xmin,a.ymin]=e(i.xmin,i.ymin,gt),[a.xmax,a.ymax]=e(i.xmax,i.ymax,gt),i.hasZ&&(a.zmin=i.zmin,a.zmax=i.zmax,a.hasZ=!0),i.hasM&&(a.mmin=i.mmin,a.mmax=i.mmax,a.hasM=!0),a}return"rings"in i?{rings:l$2(i.rings,e),hasM:i.hasM,hasZ:i.hasZ}:"paths"in i?{paths:l$2(i.paths,e),hasM:i.hasM,hasZ:i.hasZ}:"points"in i?{points:f$3(i.points,e),hasM:i.hasM,hasZ:i.hasZ}:null}function l$2(e,i){const a=[];for(const d of e)a.push(f$3(d,i));return a}function f$3(e,i){const a=[];for(const d of e){const e=i(d[0],d[1],[0,0]);a.push(e),d.length>2&&e.push(d[2]),d.length>3&&e.push(d[3])}return a}async function x$1(e,i){if(!e||!i)return;const a=Array.isArray(e)?e.map((e=>null!=e.geometry?e.geometry.spatialReference:null)).filter(V):[e];await z(a.map((e=>({source:e,dest:i}))))}const xt=h$2.bind(null,E),_t=h$2.bind(null,M);function j$2(e,i,a,d){if(!e)return e;if(a||(a=i,i=e.spatialReference),!Q(i)||!Q(a)||D(i,a))return e;if(O(i,a)){const i=Z(a)?xt(e):_t(e);return i.spatialReference=a,i}return B(Ye,[e],i,a,null,d)[0]}const Ft=new class _{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,i,a,d){if(!(null==e?void 0:e.length)||!i||!a||D(i,a))return e;const F={geometries:e,inSpatialReference:i,outSpatialReference:a,geographicTransformation:d,resolve:k()};return this._jobs.push(F),this._timer??(this._timer=setTimeout(this._process,10)),F.resolve.promise}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:i,inSpatialReference:a,outSpatialReference:d,resolve:F,geographicTransformation:S}=e;O(a,d)?Z(d)?F(i.map(xt)):F(i.map(_t)):F(B(Ye,i,a,d,S,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}};const St=new class r{constructor(e,i){this._cache=new L(e),this._invalidCache=new L(i)}get(e,i){const a=`${i.uid}:${e}`,d=this._cache.get(a);if(d)return d;if(null!=this._invalidCache.get(a))return null;try{const d=He.create(e,i);return this._cache.put(a,d),d}catch(F){return this._invalidCache.put(a,F),null}}getError(e,i){const a=`${i.uid}:${e}`;return this._invalidCache.get(a)??null}}(50,500),wt="unsupported-query",Rt=" as ",vt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),It=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),Tt=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...vt,...It]);function d$2(e,i,a={}){const d=c$2(i,e);if(!d){const a=St.getError(i,e);throw new J(wt,"invalid SQL expression",{expression:i,error:a})}const F=a.expressionName||"expression";if(a.validateStandardized&&!d.isStandardized)throw new J(wt,`${F} is not standard`,{expression:i});if(a.validateAggregate&&!d.isAggregate)throw new J(wt,`${F} does not contain a valid aggregate function`,{expression:i});return d.fieldNames}function c$2(e,i){return e?St.get(e,i):null}function u$2(e){return/\((.*?)\)/.test(e)?e:e.split(Rt)[0]}function g$2(e,i,a,d={}){const F=new Map;if(function m$1(e,i,a,d,S){const R=S.includes("*")?[...a,...S.filter((e=>"*"!==e))]:S;for(const A of R)if(i.get(A))T(e,i,a,d,A);else try{const F=d$2(i,u$2(A),{validateStandardized:!0});for(const S of F)T(e,i,a,d,S)}catch(F){e.set(A,{type:"expression-error",expression:A,error:F})}}(F,e,i,d.allowedFieldTypes??Tt,a),F.size){const e=d.expressionName??"expression";throw new J(wt,`${e} contains invalid or missing fields`,{errors:Array.from(F.values()),query:d.query})}}function T(e,i,a,d,F){const S=i.get(F);S?a.has(S.name)?"all"!==d&&!1===(null==d?void 0:d.has(S.type))&&e.set(F,{type:"invalid-type",fieldName:S.name,fieldType:H.fromJSON(S.type),allowedFieldTypes:Array.from(d,(e=>H.fromJSON(e)))}):e.set(F,{type:"missing-field",fieldName:S.name}):e.set(F,{type:"invalid-field",fieldName:F})}let bt=class c{constructor(e,i,a){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=a,this.featureAdapter=i;const d=e.outFields;if(d&&!d.includes("*")){this.outFields=d;let e=0;for(const i of d){const d=u$2(i),F=this.fieldsIndex.get(d),S=F?null:c$2(d,a),R=F?F.name:i.split(Rt)[1]||"FIELD_EXP_"+e++;this._fieldDataCache.set(i,{alias:R,clause:S})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach((e=>this.getAttributes(e))),this._returnDistinctMap.size):e.length}getAttributes(e){const i=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(i)}getFieldValue(e,i,a){var d;const F=a?a.name:i;let S=null;return this._fieldDataCache.has(F)?S=null==(d=this._fieldDataCache.get(F))?void 0:d.clause:a||(S=c$2(i,this.fieldsIndex),this._fieldDataCache.set(F,{alias:F,clause:S})),a?this.featureAdapter.getAttribute(e,F):null==S?void 0:S.calculateValue(e,this.featureAdapter)}getDataValues(e,i,a=!0){const d=i.normalizationType,F=i.normalizationTotal,S=this.fieldsIndex.get(i.field),R=Y(S)||W(S),A=X(S);return e.map((e=>{let S=i.field&&this.getFieldValue(e,i.field,this.fieldsIndex.get(i.field));if(i.field2?(S=`${Xe(S)}${i.fieldDelimiter}${Xe(this.getFieldValue(e,i.field2,this.fieldsIndex.get(i.field2)))}`,i.field3&&(S=`${S}${i.fieldDelimiter}${Xe(this.getFieldValue(e,i.field3,this.fieldsIndex.get(i.field3)))}`)):"string"==typeof S&&a&&(R?S=S?new Date(S).getTime():null:A&&(S=S?We(S):null)),d&&Number.isFinite(S)){const a="field"===d&&i.normalizationField?this.getFieldValue(e,i.normalizationField,this.fieldsIndex.get(i.normalizationField)):null;S=et(S,d,a,F)}return S}))}async getExpressionValues(e,i,a,d,F){const{arcadeUtils:S}=await ee(),R=S.hasGeometryOperations(i);R&&await S.enableGeometryOperations();const A=S.createFunction(i),E=S.getViewInfo(a),M={fields:this.fieldsIndex.fields};return e.map((e=>{const i={attributes:this.featureAdapter.getAttributes(e),layer:M,geometry:R?{...a$1(d.geometryType,d.hasZ,d.hasM,this.featureAdapter.getGeometry(e)),spatialReference:null==a?void 0:a.spatialReference}:null},V=S.createExecContext(i,E,F);return S.executeFunction(A,V)}))}validateItem(e,i){var a,d;return this._fieldDataCache.has(i)||this._fieldDataCache.set(i,{alias:i,clause:c$2(i,this.fieldsIndex)}),(null==(d=null==(a=this._fieldDataCache.get(i))?void 0:a.clause)?void 0:d.testFeature(e,this.featureAdapter))??!1}validateItems(e,i){var a,d;return this._fieldDataCache.has(i)||this._fieldDataCache.set(i,{alias:i,clause:c$2(i,this.fieldsIndex)}),(null==(d=null==(a=this._fieldDataCache.get(i))?void 0:a.clause)?void 0:d.testSet(e,this.featureAdapter))??!1}_processAttributesForOutFields(e){const i=this.outFields;if(!(null==i?void 0:i.length))return this.featureAdapter.getAttributes(e);const a={};for(const d of i){const{alias:i,clause:F}=this._fieldDataCache.get(d);a[i]=F?F.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,i)}return a}_processAttributesForDistinctValues(e){if(null==e||!this.returnDistinctValues)return e;const i=this.outFields,a=[];if(i)for(const S of i){const{alias:i}=this._fieldDataCache.get(S);a.push(e[i])}else for(const S in e)a.push(e[S]);const d=`${(i||["*"]).join(",")}=${a.join(",")}`;let F=this._returnDistinctMap.get(d)||0;return this._returnDistinctMap.set(d,++F),F>1?null:e}};class q{constructor(e,i,a){this.items=e,this.query=i,this.geometryType=a.geometryType,this.hasM=a.hasM,this.hasZ=a.hasZ,this.fieldsIndex=a.fieldsIndex,this.objectIdField=a.objectIdField,this.spatialReference=a.spatialReference,this.featureAdapter=a.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new bt(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:a,outStatistics:d}=this.query;if(!(null==i?void 0:i.length))return 1;const F=new Map,S=new Map,R=new Set;for(const A of d){const{statisticType:d}=A,E="exceedslimit"!==d?A.onStatisticField:void 0;if(!S.has(E)){const a=[];for(const d of i){const i=this._getAttributeValues(e,d,F);a.push(i)}S.set(E,this._calculateUniqueValues(a,e.returnDistinctValues))}const M=S.get(E);for(const i in M){const{data:d,items:F}=M[i],S=d.join(",");a&&!e.validateItems(F,a)||R.add(S)}}return R.size}async createQueryResponse(){let e;if(e=this.query.outStatistics?this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const i=this.query.geometry;Q(this.query.outSR)&&!D(i.spatialReference,this.query.outSR)?e.queryGeometry=h$3({spatialReference:this.query.outSR,...j$2(i,i.spatialReference,this.query.outSR)}):e.queryGeometry=h$3({spatialReference:this.query.outSR,...i})}return e}createSnappingResponse(e,i){const a=this.featureAdapter,d=C(this.hasZ,this.hasM),{point:F,mode:S}=e,R="number"==typeof e.distance?e.distance:e.distance.x,A="number"==typeof e.distance?e.distance:e.distance.y,E={candidates:[]},M="esriGeometryPolygon"===this.geometryType,V=this._getPointCreator(S,this.spatialReference,i),z=new At(null,0),Q=new At(null,0),D={x:0,y:0,z:0};for(const O of this.items){const i=a.getGeometry(O);if(null==i)continue;const{coords:S,lengths:Z}=i;if(z.coords=S,Q.coords=S,e.returnEdge){let e=0;for(let i=0;i<Z.length;i++){const S=Z[i];for(let i=0;i<S;i++,e+=d){const M=z;if(M.coordsIndex=e,i!==S-1){const i=Q;i.coordsIndex=e+d;const S=D;N(D,F,M,i);const z=(F.x-S.x)/R,Z=(F.y-S.y)/A,B=z*z+Z*Z;B<=1&&E.candidates.push(te(a.getObjectId(O),V(S),Math.sqrt(B),V(M),V(i)))}}}}if("none"!==e.vertexMode){const i=M?S.length-d:S.length;if("all"===e.vertexMode)for(let e=0;e<i;e+=d){const i=z;i.coordsIndex=e;const d=(F.x-i.x)/R,S=(F.y-i.y)/A,M=d*d+S*S;M<=1&&E.candidates.push(ie(a.getObjectId(O),V(i),Math.sqrt(M)))}else if("ends"===e.vertexMode){const e=[0];M||e.push(S.length-d);for(const i of e){const e=z;e.coordsIndex=i;const d=(F.x-e.x)/R,S=(F.y-e.y)/A,M=d*d+S*S;M<=1&&E.candidates.push(ie(a.getObjectId(O),V(e),Math.sqrt(M)))}}}}return E.candidates.sort(((e,i)=>e.distance-i.distance)),E}_getPointCreator(e,i,a){const d=null==a||D(i,a)?e=>e:e=>j$2(e,i,a),{hasZ:F}=this;return"3d"===e?F?({x:e,y:i,z:a})=>d({x:e,y:i,z:a}):({x:e,y:i})=>d({x:e,y:i,z:0}):({x:e,y:i})=>d({x:e,y:i})}async createSummaryStatisticsResponse(e){const{field:i,valueExpression:a,normalizationField:d,normalizationType:F,normalizationTotal:S,minValue:R,maxValue:A,scale:E,timeZone:M}=e,V=this.fieldsIndex.get(i),z=se(V)||Y(V)||W(V),Q=await this._getDataValues({field:i,valueExpression:a,normalizationField:d,normalizationType:F,normalizationTotal:S,scale:E,timeZone:M}),D=ht({normalizationType:F,normalizationField:d,minValue:R,maxValue:A}),O={value:.5,fieldType:null==V?void 0:V.type},Z=re(V)?tt({values:Q,supportsNullCount:D,percentileParams:O}):it({values:Q,minValue:R,maxValue:A,useSampleStdDev:!F,supportsNullCount:D,percentileParams:O});return st(Z,z)}async createUniqueValuesResponse(e){const{field:i,valueExpression:a,domains:d,returnAllCodedValues:F,scale:S,timeZone:R}=e,A=await this._getDataValues({field:i,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:a,scale:S,timeZone:R},!1),E=rt(A);return at(E,d,F,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:i,valueExpression:a,normalizationField:d,normalizationType:F,normalizationTotal:S,classificationMethod:R,standardDeviationInterval:A,minValue:E,maxValue:M,numClasses:V,scale:z,timeZone:Q}=e,D=await this._getDataValues({field:i,valueExpression:a,normalizationField:d,normalizationType:F,normalizationTotal:S,scale:z,timeZone:Q}),O=nt(D,{field:i,normalizationField:d,normalizationType:F,normalizationTotal:S,classificationMethod:R,standardDeviationInterval:A,minValue:E,maxValue:M,numClasses:V});return lt(O,R)}async createHistogramResponse(e){const{field:i,valueExpression:a,normalizationField:d,normalizationType:F,normalizationTotal:S,classificationMethod:R,standardDeviationInterval:A,minValue:E,maxValue:M,numBins:V,scale:z,timeZone:Q}=e,D=await this._getDataValues({field:i,valueExpression:a,normalizationField:d,normalizationType:F,normalizationTotal:S,scale:z,timeZone:Q});return ot(D,{field:i,normalizationField:d,normalizationType:F,normalizationTotal:S,classificationMethod:R,standardDeviationInterval:A,minValue:E,maxValue:M,numBins:V})}_sortFeatures(e,i,a){if(e.length>1&&(null==i?void 0:i.length))for(const d of i.reverse()){const i=d.split(" "),F=i[0],S=this.fieldsIndex.get(F),R=!!i[1]&&"desc"===i[1].toLowerCase(),A=ut(null==S?void 0:S.type,R);e.sort(((e,i)=>{const d=a(e,F,S),R=a(i,F,S);return A(d,R)}))}}_createFeatureQueryResponse(e){const i=this.items,{geometryType:a,hasM:d,hasZ:F,objectIdField:S,spatialReference:R}=this,{outFields:A,outSR:E,quantizationParameters:M,resultRecordCount:V,resultOffset:z,returnZ:Q,returnM:D}=e,O=null!=V&&i.length>(z||0)+V,Z=A&&(A.includes("*")?[...this.fieldsIndex.fields]:A.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:O,features:this._createFeatures(e,i),fields:Z,geometryType:a,hasM:d&&D,hasZ:F&&Q,objectIdFieldName:S,spatialReference:h$3(E||R),transform:M&&ae(M)||null}}_createFeatures(e,i){const a=new bt(e,this.featureAdapter,this.fieldsIndex),{hasM:d,hasZ:F}=this,{orderByFields:S,quantizationParameters:R,returnGeometry:A,returnCentroid:E,maxAllowableOffset:M,resultOffset:V,resultRecordCount:z,returnZ:Q=!1,returnM:D=!1}=e,O=F&&Q,Z=d&&D;let B=[],k=0;const L=[...i];if(this._sortFeatures(L,S,((e,i,d)=>a.getFieldValue(e,i,d))),this.geometryType&&(A||E)){const e=ae(R)??void 0,i="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(A&&!E)for(const d of L){const F=this.featureAdapter.getGeometry(d),S={attributes:a.getAttributes(d),geometry:a$1(this.geometryType,this.hasZ,this.hasM,F,M,e,O,Z)};i&&F&&!S.geometry&&(S.centroid=y$3(this,this.featureAdapter.getCentroid(d,this),e)),B[k++]=S}else if(!A&&E)for(const d of L)B[k++]={attributes:a.getAttributes(d),centroid:y$3(this,this.featureAdapter.getCentroid(d,this),e)};else for(const d of L)B[k++]={attributes:a.getAttributes(d),centroid:y$3(this,this.featureAdapter.getCentroid(d,this),e),geometry:a$1(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(d),M,e,O,Z)}}else for(const H of L){const e=a.getAttributes(H);e&&(B[k++]={attributes:e})}const J=V||0;if(null!=z){const e=J+z;B=B.slice(J,Math.min(B.length,e))}return B}_createExceedsLimitQueryResponse(e){let i=!1,a=Number.POSITIVE_INFINITY,d=Number.POSITIVE_INFINITY,F=Number.POSITIVE_INFINITY;for(const S of e.outStatistics??[])if("exceedslimit"===S.statisticType){a=null!=S.maxPointCount?S.maxPointCount:Number.POSITIVE_INFINITY,d=null!=S.maxRecordCount?S.maxRecordCount:Number.POSITIVE_INFINITY,F=null!=S.maxVertexCount?S.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>a;else if(this.items.length>d)i=!0;else{const e=C(this.hasZ,this.hasM),a=this.featureAdapter;i=this.items.reduce(((e,i)=>{const d=a.getGeometry(i);return e+(null!=d&&d.coords.length||0)}),0)/e>F}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}async _createStatisticsQueryResponse(e){var i;const a={attributes:{}},d=[],F=new Map,S=new Map,R=new Map,A=new Map,E=new bt(e,this.featureAdapter,this.fieldsIndex),M=e.outStatistics,{groupByFieldsForStatistics:V,having:z,orderByFields:Q,resultRecordCount:D}=e,O=null==V?void 0:V.length,Z=!!O,B=Z?V[0]:null,k=Z&&!this.fieldsIndex.get(B);for(const J of M??[]){const{outStatisticFieldName:e,statisticType:M}=J,Q=J,D="exceedslimit"!==M?J.onStatisticField:void 0,L="percentile_disc"===M||"percentile_cont"===M,H="EnvelopeAggregate"===M||"CentroidAggregate"===M||"ConvexHullAggregate"===M,Y=Z&&1===O&&(D===B||k)&&"count"===M;if(Z){if(!R.has(D)){const e=[];for(const i of V){const a=this._getAttributeValues(E,i,F);e.push(a)}R.set(D,this._calculateUniqueValues(e,!H&&E.returnDistinctValues))}const i=R.get(D);if(!i)continue;const a=Object.keys(i);for(const d of a){const{count:a,data:S,items:R,itemPositions:M}=i[d],O=S.join(",");if(!z||E.validateItems(R,z)){const i=A.get(O)||{attributes:{}};if(H){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:a}=await this._getAggregateGeometry(Q,R);i.aggregateGeometries[a]=e}else{let d=null;if(Y)d=a;else{const e=this._getAttributeValues(E,D,F),i=M.map((i=>e[i]));d=L&&"statisticParameters"in Q?this._getPercentileValue(Q,i):this._getStatisticValue(Q,i,null,E.returnDistinctValues)}i.attributes[e]=d}let d=0;V.forEach(((e,a)=>i.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++d]=S[a])),A.set(O,i)}}}else if(H){a.aggregateGeometries||(a.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(Q,this.items);a.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(E,D,F);a.attributes[e]=L&&"statisticParameters"in Q?this._getPercentileValue(Q,i):this._getStatisticValue(Q,i,S,E.returnDistinctValues)}const W="min"!==M&&"max"!==M||!re(this.fieldsIndex.get(D))&&!this._isAnyDateField(D)?null:null==(i=this.fieldsIndex.get(D))?void 0:i.type;d.push({name:e,alias:e,type:W||"esriFieldTypeDouble"})}const L=Z?Array.from(A.values()):[a];return this._sortFeatures(L,Q,((e,i)=>e.attributes[i])),D&&(L.length=Math.min(D,L.length)),{fields:d,features:L}}_isAnyDateField(e){const i=this.fieldsIndex.get(e);return se(i)||Y(i)||W(i)||X(i)}async _getAggregateGeometry(e,i){const{convexHull:a,union:d}=await ne((()=>import("./geometryEngineJSON-CrXS8d22.js").then((e=>e.g))),__vite__mapDeps([0,1,2,3,4])),{statisticType:F,outStatisticFieldName:S}=e,{featureAdapter:R,spatialReference:A,geometryType:E,hasZ:M,hasM:V}=this,z=i.map((e=>a$1(E,M,V,R.getGeometry(e)))),Q=a(A,z,!0)[0],D={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===F){const e=Q?le(Q):oe(d(A,z));D.aggregateGeometries={...e,spatialReference:A},D.outStatisticFieldName=S||"extent"}else if("CentroidAggregate"===F){const e=Q?ue(Q):ce(oe(d(A,z)));D.aggregateGeometries={x:e[0],y:e[1],spatialReference:A},D.outStatisticFieldName=S||"centroid"}else"ConvexHullAggregate"===F&&(D.aggregateGeometries=Q,D.outStatisticFieldName=S||"convexHull");return D}_getStatisticValue(e,i,a,d){const{onStatisticField:F,statisticType:S}=e;let R=null;return R=(null==a?void 0:a.has(F))?a.get(F):re(this.fieldsIndex.get(F))||this._isAnyDateField(F)?tt({values:i,returnDistinct:d}):it({values:d?[...new Set(i)]:i,minValue:null,maxValue:null,useSampleStdDev:!0}),a&&a.set(F,R),R["var"===S?"variance":S]}_getPercentileValue(e,i){const{onStatisticField:a,statisticParameters:d,statisticType:F}=e,{value:S,orderBy:R}=d,A=this.fieldsIndex.get(a);return ct(i,{value:S,orderBy:R,fieldType:null==A?void 0:A.type,isDiscrete:"percentile_disc"===F})}_getAttributeValues(e,i,a){if(a.has(i))return a.get(i);const d=this.fieldsIndex.get(i),F=this.items.map((a=>e.getFieldValue(a,i,d)));return a.set(i,F),F}_calculateUniqueValues(e,i){const a={},d=this.items,F=d.length;for(let S=0;S<F;S++){const F=d[S],R=[];for(const i of e)R.push(i[S]);const A=R.join(",");null==a[A]?a[A]={count:1,data:R,items:[F],itemPositions:[S]}:(i||a[A].count++,a[A].items.push(F),a[A].itemPositions.push(S))}return a}async _getDataValues(e,i=!0){const a=new bt(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:d,scale:F,timeZone:S}=e;return d?a.getExpressionValues(this.items,d,{viewingMode:"map",scale:F,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},S):a.getDataValues(this.items,he(e),i)}}function N(e,i,a,d){const F=d.x-a.x,S=d.y-a.y,R=F*F+S*S,A=(i.x-a.x)*F+(i.y-a.y)*S,E=Math.min(1,Math.max(0,A/R));e.x=a.x+F*E,e.y=a.y+S*E}function C(e,i){return e?i?4:3:i?3:2}let At=class G{constructor(e,i){this.coords=e,this.coordsIndex=i}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}};const $t=new de({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),Et=Object.freeze({});async function S$1(e,i,a){const{outFields:d,orderByFields:F,groupByFieldsForStatistics:S,outStatistics:R}=e;if(d)for(let A=0;A<d.length;A++)d[A]=d[A].trim();if(F)for(let A=0;A<F.length;A++)F[A]=F[A].trim();if(S)for(let A=0;A<S.length;A++)S[A]=S[A].trim();if(R)for(let A=0;A<R.length;A++)R[A].onStatisticField&&(R[A].onStatisticField=R[A].onStatisticField.trim());return e.geometry&&!e.outSR&&(e.outSR=e.geometry.spatialReference),j$1(e,i,a)}async function j$1(e,i,a){var d;if(!e)return null;let{where:F}=e;if(e.where=F=null==F?void 0:F.trim(),(!F||/^1 *= *1$/.test(F)||i&&i===F)&&(e.where=null),!e.geometry)return e;let S=await async function d$1(e){const{distance:i,units:a}=e,d=e.geometry;if(null==i||"vertexAttributes"in d)return d;const F=d.spatialReference,S=a?$t.fromJSON(a):xe(F),R=F&&(_e(F)||Z(F))?d:await x$1(F,Fe).then((()=>j$2(d,Fe)));return(await async function U(){return(await ne((async()=>{const{geodesicBuffer:e}=await import("./geometryEngineJSON-CrXS8d22.js").then((e=>e.g));return{geodesicBuffer:e}}),__vite__mapDeps([0,1,2,3,4]))).geodesicBuffer}())(R.spatialReference,R,i,S)}(e);if(e.distance=0,e.units=null,"esriSpatialRelEnvelopeIntersects"===e.spatialRel){const{spatialReference:i}=e.geometry;S=oe(S),S.spatialReference=i}if(S){await x$1(S.spatialReference,a),S=function x(e,i){const a=e.spatialReference;return w(e,i)&&me(e)?{spatialReference:a,rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]}:e}(S,a);const i=(await Je(fe(S)))[0];if(null==i)throw Et;const F="quantizationParameters"in e&&(null==(d=e.quantizationParameters)?void 0:d.tolerance)||"maxAllowableOffset"in e&&e.maxAllowableOffset||0,R=F&&w(S,a)?{densificationStep:8*F}:void 0,A=i.toJSON(),E=j$2(A,A.spatialReference,a,R);if(!E)throw Et;E.spatialReference=a,e.geometry=E}return e}function w(e,i){if(!e)return!1;const a=e.spatialReference;return(me(e)||pe(e)||ye(e))&&!D(a,i)&&!ge(a,i)}function n$1(e,i){return e?i?4:3:i?3:2}function o(e,i,a,d,F){if(!e)return!1;const S=n$1(i,a),{coords:R,lengths:A}=e;let E=!1,M=0;for(const V of A)E=e$1(E,R,S,M,V,d,F),M+=V*S;return E}function e$1(e,i,a,d,F,S,R){let A=e,E=d;for(let M=d,V=d+F*a;M<V;M+=a){E=M+a,E===V&&(E=d);const e=i[M],F=i[M+1],z=i[E],Q=i[E+1];(F<R&&Q>=R||Q<R&&F>=R)&&e+(R-F)/(Q-F)*(z-e)<S&&(A=!A)}return A}const qt="unsupported-query",Mt={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},Pt={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function v(e,a,d,F,S){if(pe(a)&&"esriGeometryPoint"===d&&("esriSpatialRelIntersects"===e||"esriSpatialRelContains"===e)){const e=Re(new i,a,!1,!1);return Promise.resolve((i=>function t$1(e,i,a,d){return o(e,i,a,d.coords[0],d.coords[1])}(e,!1,!1,i)))}if(pe(a)&&"esriGeometryMultipoint"===d){const d=Re(new i,a,!1,!1);if("esriSpatialRelContains"===e)return Promise.resolve((e=>function r2(e,i,a,d,F,S){const R=n$1(F,S),{coords:A,lengths:E}=d;if(!E)return!1;for(let M=0,V=0;M<E.length;M++,V+=R)if(!o(e,i,a,A[V],A[V+1]))return!1;return!0}(d,!1,!1,e,F,S)))}if(me(a)&&"esriGeometryPoint"===d&&("esriSpatialRelIntersects"===e||"esriSpatialRelContains"===e))return Promise.resolve((e=>ve(a,a$1(d,F,S,e))));if(me(a)&&"esriGeometryMultipoint"===d&&"esriSpatialRelContains"===e)return Promise.resolve((e=>Ie(a,a$1(d,F,S,e))));if(me(a)&&"esriSpatialRelIntersects"===e){const e=function s(e){return"mesh"===e?Se:we(e)}(d);return Promise.resolve((i=>e(a,a$1(d,F,S,i))))}return function h$1(){return ne((()=>import("./geometryEngineJSON-CrXS8d22.js").then((e=>e.g))),__vite__mapDeps([0,1,2,3,4]))}().then((i=>{const R=i[Mt[e]].bind(null,a.spatialReference,a);return e=>R(a$1(d,F,S,e))}))}async function P(e,i,a){var d;const{spatialRel:F,geometry:S}=e;if(S){if(!function G2(e){return null!=e&&!0===Pt.spatialRelationship[e]}(F))throw new J(qt,"Unsupported query spatial relationship",{query:e});if(Q(S.spatialReference)&&Q(a)){if(!function g(e){return null!=e&&!0===Pt.queryGeometry[Te(e)]}(S))throw new J(qt,"Unsupported query geometry type",{query:e});if(!function j(e){return null!=e&&!0===Pt.layerGeometry[e]}(i))throw new J(qt,"Unsupported layer geometry type",{query:e});if(e.outSR)return x$1(null==(d=e.geometry)?void 0:d.spatialReference,e.outSR)}}}function I(e){if(me(e))return!0;if(pe(e)){for(const i of e.rings){if(5!==i.length)return!1;if(i[0][0]!==i[1][0]||i[0][0]!==i[4][0]||i[2][0]!==i[3][0]||i[0][1]!==i[3][1]||i[0][1]!==i[4][1]||i[1][1]!==i[2][1])return!1}return!0}return!1}const Ct="unsupported-query";async function p(e,{fieldsIndex:i,geometryType:a,spatialReference:d,availableFields:F}){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption&&"xyFootprint"!==e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new J(Ct,"Unsupported query options",{query:e});return c2(i,F,e),function f(e,i,a){const{outStatistics:d,groupByFieldsForStatistics:F,having:S}=a,R=null==F?void 0:F.length,A=null==d?void 0:d.length;if(S){if(!R||!A)throw new J(Ct,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:a});!function f$2(e,i,a,d,F){if(!a)return!0;const S="having clause",R=d$2(e,a,{validateAggregate:!0,expressionName:S});g$2(e,i,R,{expressionName:S,query:F});const A=c$2(a,e);if(!(null==A?void 0:A.getExpressions().every((i=>{var a;const{aggregateType:F,field:S}=i,R=null==(a=e.get(S))?void 0:a.name;return d.some((i=>{var a;const{onStatisticField:d,statisticType:S}=i;return(null==(a=e.get(d))?void 0:a.name)===R&&S.toLowerCase().trim()===F}))}))))throw new J(wt,"expressions in having clause should also exist in outStatistics",{having:a});return!0}(e,i,S,d,a)}if(A){if(!function h(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}(d))return;g$2(e,i,d.map((e=>e.onStatisticField)).filter(Boolean),{expressionName:"onStatisticFields",query:a}),R&&g$2(e,i,F,{expressionName:"groupByFieldsForStatistics",query:a});for(const F of d){const{onStatisticField:d,statisticType:S}=F;if("percentile_disc"!==S&&"percentile_cont"!==S||!("statisticParameters"in F))e.get(d)&&"count"!==S&&"min"!==S&&"max"!==S&&g$2(e,i,[d],{expressionName:`outStatistics with '${S}' statistic type`,allowedFieldTypes:Vt,query:a});else{const{statisticParameters:e}=F;if(!e)throw new J(Ct,"statisticParameters should be set for percentile type",{definition:F,query:a})}}}}(i,F,e),Promise.all([P(e,a,d),x$1(d,e.outSR)]).then((()=>e))}function c2(e,i,a){const{outFields:d,orderByFields:F,returnDistinctValues:S,outStatistics:R}=a,A=R?R.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(F&&F.length>0){const d=" asc",S=" desc";g$2(e,i,F.map((e=>{const i=e.toLowerCase();return i.includes(d)?i.split(d)[0]:i.includes(S)?i.split(S)[0]:e})).filter((e=>!A.includes(e))),{expressionName:"orderByFields",query:a})}if(d&&d.length>0)g$2(e,i,d,{expressionName:"outFields",query:a,allowedFieldTypes:"all"});else if(S)throw new J(Ct,"outFields should be specified for returnDistinctValues",{query:a});!function p$1(e,i,a,d){if(!a)return!0;const F="where clause";return g$2(e,i,d$2(e,a,{validateStandardized:!0,expressionName:F}),{expressionName:F,query:d}),!0}(e,i,a.where,a)}const Vt=new Set([...vt,...It]);async function y(e,i,a,d){let F=[];if(a.valueExpression){const{arcadeUtils:e}=await ee();F=e.extractFieldNames(a.valueExpression)}if(a.field&&F.push(a.field),a.field2&&F.push(a.field2),a.field3&&F.push(a.field3),a.normalizationField&&F.push(a.normalizationField),!F.length&&!a.valueExpression)throw new J(Ct,"field or valueExpression is required",{params:a});g$2(e,i,F,{expressionName:"statistics",query:d})}function t(e,i,a){var d;if(!i||!e)return null;const{startTimeField:F,endTimeField:S}=e;if(!F&&!S)return null;const{start:R,end:A}=i;if(null===R&&null===A)return null;if(void 0===R&&void 0===A)return()=>!1;const E=(null==(d=a.getAttributeAsTimestamp)?void 0:d.bind(a))??a.getAttribute.bind(a);return F&&S?function l(e,i,a,d,F){return null!=d&&null!=F?S=>{const R=e(S,i),A=e(S,a);return(null==R||R<=F)&&(null==A||A>=d)}:null!=d?i=>{const F=e(i,a);return null==F||F>=d}:null!=F?a=>{const d=e(a,i);return null==d||d<=F}:void 0}(E,F,S,R,A):function u(e,i,a,d){return null!=a&&null!=d&&a===d?d=>e(d,i)===a:null!=a&&null!=d?F=>{const S=e(F,i);return null!=S&&S>=a&&S<=d}:null!=a?d=>{const F=e(d,i);return null!=F&&F>=a}:null!=d?a=>{const F=e(a,i);return null!=F&&F<=d}:void 0}(E,F||S,R,A)}const Nt=new be(2e6);let Gt=0;class ${constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:Ke},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new Ae(Gt+++"$$",Nt)),this.fieldsIndex=$e(e.fieldsIndex)?e.fieldsIndex:Ee.fromJSON(e.fieldsIndex),!e.availableFields||1===e.availableFields.length&&"*"===e.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map((e=>e.name))):this.availableFields=new Set(e.availableFields.map((e=>{var i;return null==(i=this.fieldsIndex.get(e))?void 0:i.name})).filter((e=>null!=e))),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=qe(this._frameTask),this.clearCache(),Me(this._geometryQueryCache),this._changeHandle=qe(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){var e;null==(e=this._geometryQueryCache)||e.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,i){const a=Pe(i);try{return(await this._executeQuery(e,{},a)).createQueryResponse()}catch(d){if(d!==Et)throw d;return new q([],e,this).createQueryResponse()}}async executeQueryForCount(e={},i){const a=Pe(i);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},a)).createQueryResponseForCount()}catch(d){if(d!==Et)throw d;return 0}}async executeQueryForExtent(e,i){const a=Pe(i),d=e.outSR;try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},a),F=i.size;return F?{count:F,extent:await this._getBounds(i.items,i.spatialReference,d||this.spatialReference)}:{count:0,extent:null}}catch(F){if(F===Et)return{count:0,extent:null};throw F}}async executeQueryForIds(e,i){return this.executeQueryForIdSet(e,i).then((e=>Array.from(e)))}async executeQueryForIdSet(e,i){const a=Pe(i);try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},a),d=i.items,F=new Set;return await this._reschedule((()=>{for(const e of d)F.add(i.featureAdapter.getObjectId(e))}),a),F}catch(d){if(d===Et)return new Set;throw d}}async executeQueryForSnapping(e,i){const a=Pe(i),{point:d,distance:F,returnEdge:S,vertexMode:R}=e;if(!S&&"none"===R)return{candidates:[]};let A=he(e.query);A=await this._schedule((()=>j$1(A,this.definitionExpression,this.spatialReference)),a),A=await this._reschedule((()=>p(A,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),a);const E=!D(d.spatialReference,this.spatialReference);E&&await x$1(d.spatialReference,this.spatialReference);const M="number"==typeof F?F:F.x,V="number"==typeof F?F:F.y,z={xmin:d.x-M,xmax:d.x+M,ymin:d.y-V,ymax:d.y+V,spatialReference:d.spatialReference},Q=E?j$2(z,this.spatialReference):z;if(!Q)return{candidates:[]};const O=(await Je(fe(d),null,{signal:a}))[0],Z=(await Je(fe(Q),null,{signal:a}))[0];if(null==O||null==Z)return{candidates:[]};const B=new q(await this._reschedule((()=>this._searchFeatures(K(Z.toJSON()))),a),A,this);await this._reschedule((()=>this._executeObjectIdsQuery(B)),a),await this._reschedule((()=>this._executeTimeQuery(B)),a),await this._reschedule((()=>this._executeAttributesQuery(B)),a),await this._reschedule((()=>this._executeGeometryQueryForSnapping(B,a)),a);const k=O.toJSON(),L=E?j$2(k,this.spatialReference):k,J=E?Math.max(Q.xmax-Q.xmin,Q.ymax-Q.ymin)/2:F;return B.createSnappingResponse({...e,point:L,distance:J},d.spatialReference)}async executeQueryForLatestObservations(e,i){var a;const d=Pe(i);if(!(null==(a=this.timeInfo)?void 0:a.trackIdField))throw new J("unsupported-query","Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},d);return await this._reschedule((()=>this._filterLatest(i)),d),i.createQueryResponse()}catch(F){if(F!==Et)throw F;return new q([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},i,a){const d=Pe(a),{field:F,normalizationField:S,valueExpression:R}=i;return(await this._executeQueryForStatistics(e,{field:F,normalizationField:S,valueExpression:R},d)).createSummaryStatisticsResponse(i)}async executeQueryForUniqueValues(e={},i,a){const d=Pe(a),{field:F,field2:S,field3:R,valueExpression:A}=i;return(await this._executeQueryForStatistics(e,{field:F,field2:S,field3:R,valueExpression:A},d)).createUniqueValuesResponse(i)}async executeQueryForClassBreaks(e={},i,a){const d=Pe(a),{field:F,normalizationField:S,valueExpression:R}=i;return(await this._executeQueryForStatistics(e,{field:F,normalizationField:S,valueExpression:R},d)).createClassBreaksResponse(i)}async executeQueryForHistogram(e={},i,a){const d=Pe(a),{field:F,normalizationField:S,valueExpression:R}=i;return(await this._executeQueryForStatistics(e,{field:F,normalizationField:S,valueExpression:R},d)).createHistogramResponse(i)}async fetchRecomputedExtents(e){const i=Pe(e);this._timeExtentPromise||(this._timeExtentPromise=async function n(e,i){if(!e)return null;const a=i.featureAdapter,{startTimeField:d,endTimeField:F}=e;let S=Number.POSITIVE_INFINITY,R=Number.NEGATIVE_INFINITY;if(d&&F)await i.forEach((e=>{const i=a.getAttribute(e,d),A=a.getAttribute(e,F);null==i||isNaN(i)||(S=Math.min(S,i)),null==A||isNaN(A)||(R=Math.max(R,A))}));else{const e=d||F;await i.forEach((i=>{const d=a.getAttribute(i,e);null==d||isNaN(d)||(S=Math.min(S,d),R=Math.max(R,d))}))}return{start:S,end:R}}(this.timeInfo,this.featureStore));const[a,d]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return Ce(i),{fullExtent:a,timeExtent:d}}async _getBounds(e,i,a){const d=Ve(Ge(),Ne);await this.featureStore.forEachBounds(e,(e=>ze(d,e)));const F={xmin:d[0],ymin:d[1],xmax:d[3],ymax:d[4],spatialReference:h$3(this.spatialReference)};this.hasZ&&isFinite(d[2])&&isFinite(d[5])&&(F.zmin=d[2],F.zmax=d[5],F.hasZ=!0);const S=j$2(F,i,a);if(S.spatialReference=h$3(a),S.xmax-S.xmin==0){const e=Qe(S.spatialReference);S.xmin-=e,S.xmax+=e}if(S.ymax-S.ymin==0){const e=Qe(S.spatialReference);S.ymin-=e,S.ymax+=e}if(this.hasZ&&null!=S.zmin&&null!=S.zmax&&S.zmax-S.zmin==0){const e=Qe(S.spatialReference);S.zmin-=e,S.zmax+=e}return S}_getFullExtent(){return this._fullExtentPromise||(this._fullExtentPromise="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((e=>this._getBounds(e,this.spatialReference,this.spatialReference)))),this._fullExtentPromise}async _schedule(e,i){return null!=this._frameTask?this._frameTask.schedule(e,i):e(De)}async _reschedule(e,i){return null!=this._frameTask?this._frameTask.reschedule(e,i):e(De)}async _getAllFeaturesQueryEngineResult(e){return new q(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((i=>e.push(i)))})().then((()=>e))}const e=this._allFeaturesPromise,i=await e;return e===this._allFeaturesPromise?i.slice():this._getAllFeatures()}async _executeQuery(e,i,a){e=he(e),e=await this._schedule((()=>S$1(e,this.definitionExpression,this.spatialReference)),a),e=await this._reschedule((()=>p(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),a),e={...e,...i};const d=await this._reschedule((()=>this._executeSceneFilterQuery(e,a)),a),F=await this._reschedule((()=>this._executeGeometryQuery(e,d,a)),a);return await this._reschedule((()=>this._executeAggregateIdsQuery(F)),a),await this._reschedule((()=>this._executeObjectIdsQuery(F)),a),await this._reschedule((()=>this._executeTimeQuery(F)),a),await this._reschedule((()=>this._executeAttributesQuery(F)),a),F}async _executeSceneFilterQuery(e,i){if(null==e.sceneFilter)return null;const{outSR:a,returnGeometry:d,returnCentroid:F}=e,S=this.featureStore.featureSpatialReference,R=e.sceneFilter.geometry,A=null==S||D(S,R.spatialReference)?R:j$2(R,S);if(!A)return null;const E=d||F,M=Q(a)&&!D(this.spatialReference,a)&&E?async e=>this._project(e,a):e=>e,V=this.featureAdapter,z=await this._reschedule((()=>this._searchFeatures(K(A))),i);if("disjoint"===e.sceneFilter.spatialRelationship){if(!z.length)return null;const a=new Set;for(const e of z)a.add(V.getObjectId(e));const d=await this._reschedule((()=>this._getAllFeatures()),i);return M(await this._reschedule((async()=>{const F=await v("esriSpatialRelDisjoint",A,this.geometryType,this.hasZ,this.hasM),S=await this._runSpatialFilter(d,(e=>!a.has(V.getObjectId(e))||F(V.getGeometry(e))),i);return new q(S,e,this)}),i))}if(!z.length)return new q([],e,this);if(this._canExecuteSinglePass(A,e))return M(new q(z,e,this));const O=await v("esriSpatialRelContains",A,this.geometryType,this.hasZ,this.hasM),Z=await this._runSpatialFilter(z,(e=>O(V.getGeometry(e))),i);return M(new q(Z,e,this))}async _executeGeometryQuery(e,i,a){if(null!=i&&0===i.items.length)return i;e=null!=i?i.query:e;const{geometry:d,outSR:F,spatialRel:S,returnGeometry:R,returnCentroid:A}=e,E=this.featureStore.featureSpatialReference,M=!d||null==E||D(E,d.spatialReference)?d:j$2(d,E),V=R||A,z=Q(F)&&!D(this.spatialReference,F),O=this._geometryQueryCache&&null==i?z&&V?JSON.stringify({originalFilterGeometry:d,spatialRelationship:S,outSpatialReference:F}):JSON.stringify({originalFilterGeometry:d,spatialRelationship:S}):null,Z=O?this._geometryQueryCache.get(O):null;if(null!=Z)return new q(Z,e,this);const d2=async e=>(z&&V&&await this._project(e,F),O&&this._geometryQueryCache.put(O,e.items,e.items.length+1),e);if(!M)return d2(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const B=this.featureAdapter;let k=await this._reschedule((()=>this._searchFeatures(K(d))),a);if("esriSpatialRelDisjoint"===S){if(!k.length)return d2(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const d=new Set;for(const e of k)d.add(B.getObjectId(e));const F=null!=i?i.items:await this._reschedule((()=>this._getAllFeatures()),a);return d2(await this._reschedule((async()=>{const i=await v(S,M,this.geometryType,this.hasZ,this.hasM),R=await this._runSpatialFilter(F,(e=>!d.has(B.getObjectId(e))||i(B.getGeometry(e))),a);return new q(R,e,this)}),a))}if(null!=i){const e=new Le;k=k.filter((a=>je(i.items,a,i.items.length,e)>=0))}if(!k.length){const i=new q([],e,this);return O&&this._geometryQueryCache.put(O,i.items,1),i}if(this._canExecuteSinglePass(M,e))return d2(new q(k,e,this));const L=await v(S,M,this.geometryType,this.hasZ,this.hasM),J=await this._runSpatialFilter(k,(e=>L(B.getGeometry(e))),a);return d2(new q(J,e,this))}async _executeGeometryQueryForSnapping(e,i){var a;const{query:d}=e,{spatialRel:F}=d;if(!(null==(a=null==e?void 0:e.items)?void 0:a.length)||!d.geometry||!F)return;const S=await v(F,d.geometry,this.geometryType,this.hasZ,this.hasM),R=await this._runSpatialFilter(e.items,(e=>S(e.geometry)),i);e.items=R}_executeAggregateIdsQuery(e){var i;if(0===e.items.length||!(null==(i=e.query.aggregateIds)?void 0:i.length)||null==this.aggregateAdapter)return;const a=new Set;for(const F of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(F).forEach((e=>a.add(e)));const d=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>a.has(d(e))))}_executeObjectIdsQuery(e){var i;if(0===e.items.length||!(null==(i=e.query.objectIds)?void 0:i.length))return;const a=new Set(e.query.objectIds),d=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>a.has(d(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const i=t(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=i&&(e.items=e.items.filter(i))}_executeAttributesQuery(e){if(0===e.items.length)return;const i=c$2(e.query.where,this.fieldsIndex);if(i){if(!i.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>i.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,i,a){if(!i)return e;if(null==this._frameTask)return e.filter((e=>i(e)));let d=0;const F=new Array,a2=async S=>{for(;d<e.length;){const R=e[d++];i(R)&&(F.push(R),S.madeProgress()),S.done&&await this._reschedule((e=>a2(e)),a)}};return this._reschedule((e=>a2(e)),a).then((()=>F))}_filterLatest(e){const{trackIdField:i,startTimeField:a,endTimeField:d}=this.timeInfo,F=d||a,S=new Map,R=this.featureAdapter.getAttribute;for(const A of e.items){const e=R(A,i),a=R(A,F),d=S.get(e);(!d||a>R(d,F))&&S.set(e,A)}e.items=Array.from(S.values())}_canExecuteSinglePass(e,i){const{spatialRel:a}=i;return I(e)&&("esriSpatialRelEnvelopeIntersects"===a||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===a||"esriSpatialRelContains"===a))}async _project(e,i){if(!i||D(this.spatialReference,i))return e;const a=this.featureAdapter;let d;try{const e=await this._getFullExtent();d=Oe(this.spatialReference,i,e)}catch{}const F=await function b(e,i,a,d){return Ft.push(e,i,a,d)}(e.items.map((e=>a$1(this.geometryType,this.hasZ,this.hasM,a.getGeometry(e)))),this.spatialReference,i,d);return e.items=F.map(((i,d)=>a.cloneWithGeometry(e.items[d],Ze(i,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const i=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>i.add(e))))));const a=Array.from(i.values());return i.clear(),a}async _executeQueryForStatistics(e,i,a){e=he(e);try{e=await this._schedule((()=>S$1(e,this.definitionExpression,this.spatialReference)),a),e=await this._reschedule((()=>async function m(e,i,{fieldsIndex:a,geometryType:d,spatialReference:F,availableFields:S}){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new J(Ct,"Unsupported query options",{query:e});return c2(a,S,e),Promise.all([y(a,S,i,e),P(e,d,F),x$1(F,e.outSR)]).then((()=>e))}(e,i,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),a);const d=await this._reschedule((()=>this._executeSceneFilterQuery(e,a)),a),F=await this._reschedule((()=>this._executeGeometryQuery(e,d,a)),a);return await this._reschedule((()=>this._executeAggregateIdsQuery(F)),a),await this._reschedule((()=>this._executeObjectIdsQuery(F)),a),await this._reschedule((()=>this._executeTimeQuery(F)),a),await this._reschedule((()=>this._executeAttributesQuery(F)),a),F}catch(d){if(d!==Et)throw d;return new q([],e,this)}}}function K(e){if(I(e)){if(me(e))return[Be(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if(pe(e))return e.rings.map((e=>Be(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[ke(Ue(),e)]}export{$,j$1 as a,h$3 as h,j$2 as j,t,v,x$1 as x};
