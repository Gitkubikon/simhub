import{fe as e,b as t,ff as i,fh as s,fg as n,aY as r,fk as a,fl as l,fm as o,fn as u,fd as d,cN as p}from"./index-DSIPxOWi.js";import{t as f,n as c}from"./objectIdUtils-Djb6_mZK.js";import{m}from"./FeatureStore-Dpo5Syxq.js";import{$ as y,x as h,j as g}from"./QueryEngine-DAD9skS_.js";import{i as I,o as F,c as b}from"./clientSideDefaults-Cn_svm8L.js";import{j,f as E,p as T,d as _,y as x}from"./sourceUtils-BFIlJ45V.js";import"./BoundsStore-BQ0MOdb7.js";import"./PooledRBush-DOZnXWx2.js";import"./quickselect-D9ta8ndX.js";import"./optimizedFeatureQueryEngineAdapter--U1rvwBV.js";import"./normalizeUtils-BrH-PrZy.js";import"./normalizeUtilsCommon-BU8xfl77.js";import"./WhereClause-DYd7Xwn9.js";import"./TimeOnly-C5lZbbIX.js";import"./json-omtrO2vq.js";import"./QueryEngineCapabilities-CTDe3LlQ.js";import"./utils-B-uQJqPz.js";import"./utils-DEUXBrCj.js";import"./utils-1_4Re7um.js";import"./ClassBreaksDefinition-Dt1HCCB7.js";import"./date-Do_V47iR.js";const R=d,q={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:d},v={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function O(e){return p(e)?null!=e.z:!!e.hasZ}function w(e){return p(e)?null!=e.m:!!e.hasM}class S{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){var e;null==(e=this._queryEngine)||e.destroy(),this._queryEngine=this._createDefaultAttributes=null}async load(a){const l=[],{features:o}=a,u=this._inferLayerProperties(o,a.fields),d=a.fields||[],p=null!=a.hasM?a.hasM:!!u.hasM,g=null!=a.hasZ?a.hasZ:!!u.hasZ,j=!a.spatialReference&&!u.spatialReference,E=j?R:a.spatialReference||u.spatialReference,T=j?q:null,_=a.geometryType||u.geometryType,x=!_;let D=a.objectIdField||u.objectIdField,Q=a.timeInfo;const M=new e(d);if(!x&&(j&&l.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!_))throw new t("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!D)throw new t("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(u.objectIdField&&D!==u.objectIdField&&(l.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${D}" doesn't match the field name "${u.objectIdField}", found in the provided fields`}),D=u.objectIdField),D&&!u.objectIdField){const e=M.get(D);e?(D=e.name,e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):d.unshift({alias:D,name:D,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const e of d){if(null==e.name&&(e.name=e.alias),null==e.alias&&(e.alias=e.name),!e.name)throw new t("feature-layer:invalid-field-name","field name is missing",{field:e});if(e.name===D&&(e.type="esriFieldTypeOID"),!i.jsonValues.includes(e.type))throw new t("feature-layer:invalid-field-type",`invalid type for field "${e.name}"`,{field:e});null==e.length&&(e.length=s(e))}const Z={};for(const e of d)if("esriFieldTypeOID"!==e.type&&"esriFieldTypeGlobalID"!==e.type){const t=n(e);void 0!==t&&(Z[e.name]=t)}if(Q){if(Q.startTimeField){const e=M.get(Q.startTimeField);e?(Q.startTimeField=e.name,e.type="esriFieldTypeDate"):Q.startTimeField=null}if(Q.endTimeField){const e=M.get(Q.endTimeField);e?(Q.endTimeField=e.name,e.type="esriFieldTypeDate"):Q.endTimeField=null}if(Q.trackIdField){const e=M.get(Q.trackIdField);e?Q.trackIdField=e.name:(Q.trackIdField=null,l.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:Q}}))}Q.startTimeField||Q.endTimeField||(l.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:Q}}),Q=null)}const A=M.dateFields.length?{timeZoneIANA:a.dateFieldsTimeZone??r}:null;this._createDefaultAttributes=I(Z,D);const C={warnings:l,featureErrors:[],layerDefinition:{...v,drawingInfo:F(_),templates:b(Z),extent:T,geometryType:_,objectIdField:D,fields:d,hasZ:g,hasM:p,timeInfo:Q,dateFieldsTimeReference:A},assignedObjectIds:{}};if(this._queryEngine=new y({fieldsIndex:e.fromLayerJSON({fields:d,timeInfo:Q,dateFieldsTimeReference:A}),geometryType:_,hasM:p,hasZ:g,objectIdField:D,spatialReference:E,featureStore:new m({geometryType:_,hasM:p,hasZ:g}),timeInfo:Q,cacheSpatialQueries:!0}),!(null==o?void 0:o.length))return this._nextObjectId=f,C;const k=c(D,o);return this._nextObjectId=k+1,await h(o,E),this._loadInitialFeatures(C,o)}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await Promise.all([j(t,i),h(e.adds,t),h(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,t){let i,s,n=null,r=null,l=null;for(const o of e){const e=o.geometry;if(null!=e&&(n||(n=a(e)),r||(r=e.spatialReference),null==i&&(i=O(e)),null==s&&(s=w(e)),n&&r&&null!=i&&null!=s))break}if(t&&t.length){let e=null;t.some((t=>{const i="esriFieldTypeOID"===t.type,s=!t.type&&t.name&&"objectid"===t.name.toLowerCase();return e=t,i||s}))&&(l=e.name)}return{geometryType:n,spatialReference:r,objectIdField:l,hasM:s,hasZ:i}}async _loadInitialFeatures(e,t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:o,featureStore:u,fieldsIndex:d}=this._queryEngine,p=[];for(const l of t){if(null!=l.uid&&(e.assignedObjectIds[l.uid]=-1),l.geometry&&i!==a(l.geometry)){e.featureErrors.push(E("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),s=T(d,t,l.attributes,!0);s?e.featureErrors.push(s):(this._assignObjectId(t,l.attributes,!0),l.attributes=t,null!=l.uid&&(e.assignedObjectIds[l.uid]=l.attributes[r]),null!=l.geometry&&(l.geometry=g(l.geometry,l.geometry.spatialReference,o)),p.push(l))}u.addMany(l([],p,i,n,s,r));const{fullExtent:f,timeExtent:c}=await this._queryEngine.fetchRecomputedExtents();if(e.layerDefinition.extent=f,c){const{start:t,end:i}=c;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}async _applyEdits(e){const{adds:t,updates:i,deletes:s}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if((null==t?void 0:t.length)&&this._applyAddEdits(n,t),(null==i?void 0:i.length)&&this._applyUpdateEdits(n,i),null==s?void 0:s.length){for(const e of s)n.deleteResults.push(_(e));this._queryEngine.featureStore.removeManyById(s)}const{fullExtent:r,timeExtent:a}=await this._queryEngine.fetchRecomputedExtents();return{extent:r,timeExtent:a,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:n,hasZ:r,objectIdField:o,spatialReference:u,featureStore:d,fieldsIndex:p}=this._queryEngine,f=[];for(const l of t){if(l.geometry&&s!==a(l.geometry)){i.push(E("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=T(p,t,l.attributes);if(n)i.push(n);else{if(this._assignObjectId(t,l.attributes),l.attributes=t,null!=l.uid){const t=l.attributes[o];e.uidToObjectId[l.uid]=t}if(null!=l.geometry){const e=l.geometry.spatialReference??u;l.geometry=g(x(l.geometry,e),e,u)}f.push(l),i.push(_(l.attributes[o]))}}d.addMany(l([],f,s,r,n,o))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:l,featureStore:d,fieldsIndex:p}=this._queryEngine;for(const f of t){const{attributes:t,geometry:c}=f,m=null==t?void 0:t[r];if(null==m){e.push(E(`Identifier field ${r} missing`));continue}if(!d.has(m)){e.push(E(`Feature with object id ${m} missing`));continue}const y=o(d.getFeature(m),i,n,s);if(null!=c){if(i!==a(c)){e.push(E("Incorrect geometry type."));continue}const t=c.spatialReference??l;y.geometry=g(x(c,t),t,l)}if(t){const i=T(p,y.attributes,t);if(i){e.push(i);continue}}d.add(u(y,i,n,s,r)),e.push(_(m))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&t&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}}export{S as default};
