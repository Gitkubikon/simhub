import{pk as t,O as r,cx as f,L as _,N as p,Q as g,b as E,b3 as A,o1 as T,eZ as b,dL as y,e8 as R,bO as x,pl as N,oD as I,pm as S,oz as L,mi as B,ee as V,bJ as z,mh as F,hq as D,n as U,bg as v,bX as P,pn as G}from"./index-DSIPxOWi.js";import{M as k}from"./vertexSpaceConversion-C_GU75pR.js";var H,Y;(Y=H||(H={}))[Y.JSON=1313821514]="JSON",Y[Y.BIN=5130562]="BIN";let $=class e{constructor(t,r){if(!t)throw new Error("GLB requires a JSON gltf chunk");this._length=e.HEADER_SIZE,this._length+=e.CHUNK_HEADER_SIZE;const f=function n(t){return(new TextEncoder).encode(t).buffer}(t);if(this._length+=h(f.byteLength,4),r&&(this._length+=e.CHUNK_HEADER_SIZE,this._length+=r.byteLength,r.byteLength%4))throw new Error("Expected BIN chunk length to be divisible by 4 at this point");this.buffer=new ArrayBuffer(this._length),this._outView=new DataView(this.buffer),this._writeHeader();const _=this._writeChunk(f,12,H.JSON,32);r&&this._writeChunk(r,_,H.BIN)}_writeHeader(){this._outView.setUint32(0,e.MAGIC,!0),this._outView.setUint32(4,e.VERSION,!0),this._outView.setUint32(8,this._length,!0)}_writeChunk(t,r,f,_=0){const p=h(t.byteLength,4);for(this._outView.setUint32(r,p,!0),this._outView.setUint32(r+=4,f,!0),function i$6(t,r,f,_,p){new Uint8Array(t,f,p).set(new Uint8Array(r,_,p),0)}(this._outView.buffer,t,r+=4,0,t.byteLength),r+=t.byteLength;r%4;)_&&this._outView.setUint8(r,_),r++;return r}};function h(t,r){return r*Math.ceil(t/r)}var j,J,K,W,X,Z,Q,q;$.HEADER_SIZE=12,$.CHUNK_HEADER_SIZE=8,$.MAGIC=1179937895,$.VERSION=2,(q=j||(j={}))[q.External=0]="External",q[q.DataURI=1]="DataURI",q[q.GLB=2]="GLB",function(t){t[t.External=0]="External",t[t.DataURI=1]="DataURI",t[t.GLB=2]="GLB"}(J||(J={})),function(t){t[t.ARRAY_BUFFER=34962]="ARRAY_BUFFER",t[t.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(K||(K={})),function(t){t.SCALAR="SCALAR",t.VEC2="VEC2",t.VEC3="VEC3",t.VEC4="VEC4",t.MAT2="MAT2",t.MAT3="MAT3",t.MAT4="MAT4"}(W||(W={})),function(t){t[t.POINTS=0]="POINTS",t[t.LINES=1]="LINES",t[t.LINE_LOOP=2]="LINE_LOOP",t[t.LINE_STRIP=3]="LINE_STRIP",t[t.TRIANGLES=4]="TRIANGLES",t[t.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=6]="TRIANGLE_FAN"}(X||(X={})),function(t){t.OPAQUE="OPAQUE",t.MASK="MASK",t.BLEND="BLEND"}(Z||(Z={})),function(t){t[t.NoColor=0]="NoColor",t[t.FaceColor=1]="FaceColor",t[t.VertexColor=2]="VertexColor"}(Q||(Q={}));let ee=class i{constructor(t,r,f,_,p){this._buffer=t,this._componentType=f,this._dataType=_,this._data=[],this._isFinalized=!1,this._accessorIndex=-1,this._accessorAttribute=null,this._accessorMin=null,this._accessorMax=null,r.bufferViews||(r.bufferViews=[]),this.index=r.bufferViews.length,this._bufferView={buffer:t.index,byteLength:-1,target:p};const g=this._getElementSize();g>=4&&p!==K.ELEMENT_ARRAY_BUFFER&&(this._bufferView.byteStride=g),r.bufferViews.push(this._bufferView),this._numComponentsForDataType=this._calculateNumComponentsForDataType()}push(t){const r=this._data.length;if(this._data.push(t),this._accessorIndex>=0){const f=r%this._numComponentsForDataType,_=this._accessorMin[f];this._accessorMin[f]="number"!=typeof _?t:Math.min(_,t);const p=this._accessorMax[f];this._accessorMax[f]="number"!=typeof p?t:Math.max(p,t)}}get dataSize(){return this._data.length*this._sizeComponentType()}get byteSize(){return function e3(t,r){return r*Math.ceil(t/r)}(this.dataSize,4)}getByteOffset(){if(!this._isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this._buffer.getByteOffset(this)}get byteOffset(){if(!this._isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this._buffer.getByteOffset(this)}_createTypedArray(r,f){switch(this._componentType){case t.BYTE:return new Int8Array(r,f);case t.FLOAT:return new Float32Array(r,f);case t.SHORT:return new Int16Array(r,f);case t.UNSIGNED_BYTE:return new Uint8Array(r,f);case t.UNSIGNED_INT:return new Uint32Array(r,f);case t.UNSIGNED_SHORT:return new Uint16Array(r,f)}}writeOutToBuffer(t,r){this._createTypedArray(t,r).set(this._data)}writeAsync(t){if(this._asyncWritePromise)throw new Error("Can't write multiple bufferView values asynchronously");return this._asyncWritePromise=t.then((t=>{const r=new Uint8Array(t);for(let f=0;f<r.length;++f)this._data.push(r[f]);delete this._asyncWritePromise})),this._asyncWritePromise}startAccessor(t){if(this._accessorIndex>=0)throw new Error("Accessor was started without ending the previous one");this._accessorIndex=this._data.length,this._accessorAttribute=t;const r=this._numComponentsForDataType;this._accessorMin=new Array(r),this._accessorMax=new Array(r)}endAccessor(){if(this._accessorIndex<0)throw new Error("An accessor was not started, but was attempted to be ended");const r=this._getElementSize(),f=this._numComponentsForDataType,_=(this._data.length-this._accessorIndex)/f;if(_%1)throw new Error("An accessor was ended with missing component values");for(let t=0;t<this._accessorMin.length;++t)"number"!=typeof this._accessorMin[t]&&(this._accessorMin[t]=0),"number"!=typeof this._accessorMax[t]&&(this._accessorMax[t]=0);const p={byteOffset:r*(this._accessorIndex/f),componentType:this._componentType,count:_,type:this._dataType,min:this._accessorMin,max:this._accessorMax,name:this._accessorAttribute};switch(this._accessorAttribute){case"TEXCOORD_0":case"TEXCOORD_1":case"COLOR_0":case"WEIGHTS_0":switch(this._componentType){case t.UNSIGNED_BYTE:case t.UNSIGNED_SHORT:p.normalized=!0}}return this._accessorIndex=-1,this._accessorAttribute=null,this._accessorMin=null,this._accessorMax=null,p}get finalized(){return this._finalizedPromise?this._finalizedPromise:this._isFinalized?this._finalizedPromise=Promise.resolve():this._finalizedPromise=new Promise((t=>this._finalizedPromiseResolve=t))}async finalize(){const t=this._bufferView,r=this._buffer.getViewFinalizePromises(this);this._asyncWritePromise&&r.push(this._asyncWritePromise),await Promise.allSettled(r),this._isFinalized=!0,t.byteOffset=this.getByteOffset(),t.byteLength=this.dataSize,this._finalizedPromiseResolve&&this._finalizedPromiseResolve()}_getElementSize(){return this._sizeComponentType()*this._numComponentsForDataType}_sizeComponentType(){switch(this._componentType){case t.BYTE:case t.UNSIGNED_BYTE:return 1;case t.SHORT:case t.UNSIGNED_SHORT:return 2;case t.UNSIGNED_INT:case t.FLOAT:return 4}}_calculateNumComponentsForDataType(){switch(this._dataType){case W.SCALAR:return 1;case W.VEC2:return 2;case W.VEC3:return 3;case W.VEC4:case W.MAT2:return 4;case W.MAT3:return 9;case W.MAT4:return 16}}},te=class i2{constructor(t){this._gltf=t,this._bufferViews=[],this._isFinalized=!1,t.buffers||(t.buffers=[]),this.index=t.buffers.length;const r={byteLength:-1};t.buffers.push(r),this._buffer=r}addBufferView(t,r,f){if(this._finalizePromise)throw new Error("Cannot add buffer view after fiinalizing buffer");const _=new ee(this,this._gltf,t,r,f);return this._bufferViews.push(_),_}getByteOffset(t){let r=0;for(const f of this._bufferViews){if(f===t)return r;r+=f.byteSize}throw new Error("Given bufferView was not present in this buffer")}getViewFinalizePromises(t){const r=[];for(const f of this._bufferViews){if(t&&f===t)return r;r.push(f.finalized)}return r}getArrayBuffer(){if(!this._isFinalized)throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");const t=this._getTotalSize(),r=new ArrayBuffer(t);let f=0;for(const _ of this._bufferViews)_.writeOutToBuffer(r,f),f+=_.byteSize;return r}finalize(){if(this._finalizePromise)throw new Error(`Buffer ${this.index} was already finalized`);return this._finalizePromise=Promise.allSettled(this.getViewFinalizePromises()).then((()=>{this._isFinalized=!0;const t=this.getArrayBuffer();this._buffer.byteLength=t.byteLength,this._buffer.uri=t})),this._gltf.extras.promises.push(this._finalizePromise),this._finalizePromise}_getTotalSize(){let t=0;for(const r of this._bufferViews)t+=r.byteSize;return t}};function e$1(t,g){null==g.normal&&(g.normal=new Float32Array(g.position.length));const E=t.faces,{position:A,normal:T}=g,b=E.length/3;for(let p=0;p<b;++p){const t=3*E[3*p],g=3*E[3*p+1],b=3*E[3*p+2],y=r(se,A[t],A[t+1],A[t+2]),R=r(ie,A[g],A[g+1],A[g+2]),x=r(re,A[b],A[b+1],A[b+2]),N=f(R,R,y),I=f(x,x,y),S=_(N,N,I);T[t]+=S[0],T[t+1]+=S[1],T[t+2]+=S[2],T[g]+=S[0],T[g+1]+=S[1],T[g+2]+=S[2],T[b]+=S[0],T[b+1]+=S[1],T[b+2]+=S[2]}for(let f=0;f<T.length;f+=3)r(ne,T[f],T[f+1],T[f+2]),p(ne,ne),T[f]=ne[0],T[f+1]=ne[1],T[f+2]=ne[2]}const se=g(),ie=g(),re=g(),ne=g();async function i$2(t,r){const f=m(t);if(null==f)throw new E("imageToArrayBuffer","Unsupported image type");const _=function o(t){if(!(t instanceof HTMLImageElement))return"image/png";const r=t.src;if(T(r)){const t=b(r);return"image/jpeg"===(null==t?void 0:t.mediaType)?t.mediaType:"image/png"}return/\.png$/i.test(r)?"image/png":/\.(jpg|jpeg)$/i.test(r)?"image/jpeg":"image/png"}(t),p=await new Promise((t=>f.toBlob(t,_)));if(A(r),!p)throw new E("imageToArrayBuffer","Failed to encode image");const g=await p.arrayBuffer();return A(r),{data:g,type:_}}function m(t){if(t instanceof HTMLCanvasElement)return t;if(t instanceof HTMLVideoElement)return null;const r=document.createElement("canvas");r.width=t.width,r.height=t.height;const f=r.getContext("2d");return t instanceof HTMLImageElement?f.drawImage(t,0,0,t.width,t.height):t instanceof ImageData&&f.putImageData(t,0,0),r}const M=()=>U.getLogger("esri.geometry.support.meshUtils.exporters.gltf.gltf");class O{constructor(t,r){this.options=r,this._materialMap=new Array,this._imageMap=new Map,this._textureMap=new Map,this.gltf={asset:{version:"2.0",copyright:t.copyright,generator:t.generator},extras:{output:r.output,binChunkBuffer:null,promises:[]}},this._addScenes(t)}_addScenes(t){this.gltf.scene=t.defaultScene;const r=this.gltf.extras,f=r.output.buffer===j.GLB||r.output.image===J.GLB;f&&(r.binChunkBuffer=new te(this.gltf)),t.forEachScene((t=>{this._addScene(t)})),f&&r.binChunkBuffer.finalize()}_addScene(t){this.gltf.scenes||(this.gltf.scenes=[]);const r={};t.name&&(r.name=t.name),t.forEachNode((t=>{r.nodes||(r.nodes=[]),r.nodes.push(...this._addNodes(t))})),this.gltf.scenes.push(r)}_addNodes(t){this.gltf.nodes||(this.gltf.nodes=[]);const r={};t.name&&(r.name=t.name);const f=t.translation;y(f,R)||(r.translation=x(f));const _=t.rotation;N(_,I)||(r.rotation=S(_));const p=t.scale;y(p,L)||(r.scale=x(p));const g=this.gltf.nodes.length;if(this.gltf.nodes.push(r),t.mesh&&t.mesh.vertexAttributes.position){const f=this._createMeshes(t.mesh),_=[g];if(1===f.length)this._addMesh(r,f[0]);else for(const t of f){const r={};this._addMesh(r,t),_.push(this.gltf.nodes.length),this.gltf.nodes.push(r)}return _}return t.forEachNode((t=>{r.children||(r.children=[]),r.children.push(...this._addNodes(t))})),[g]}_addMesh(t,r){var f;(f=this.gltf).meshes??(f.meshes=[]);const _=this.gltf.meshes.length;this.gltf.meshes.push(r),t.mesh=_}_createMeshes(r){var f;const _=this.gltf.extras,p=_.output.buffer===j.GLB;let g;g=p?_.binChunkBuffer:new te(this.gltf);const E=this.options.origin,A=r.vertexSpace.clone();A.origin=[E.x,E.y,E.z??0];const T=k({vertexAttributes:r.vertexAttributes,vertexSpace:r.vertexSpace,transform:(null==(f=this.options)?void 0:f.ignoreLocalTransform)?null:r.transform,spatialReference:r.spatialReference},A,{targetUnit:"meters"});if(!T)return[];(function c$1(t,r){if(t.components)for(const f of t.components)f.faces&&"smooth"===f.shading&&e$1(f,r)})(r,T),function w({position:t,normal:r,tangent:f}){C(t,3),C(r,3),C(f,4)}(T);const{position:b,normal:y,tangent:R}=T,{uv:x,color:N}=r.vertexAttributes,I=g.addBufferView(t.FLOAT,W.VEC3,K.ARRAY_BUFFER);let S,L,B,V;y&&(S=g.addBufferView(t.FLOAT,W.VEC3,K.ARRAY_BUFFER)),x&&(L=g.addBufferView(t.FLOAT,W.VEC2,K.ARRAY_BUFFER)),R&&(B=g.addBufferView(t.FLOAT,W.VEC4,K.ARRAY_BUFFER)),N&&(V=g.addBufferView(t.UNSIGNED_BYTE,W.VEC4,K.ARRAY_BUFFER)),I.startAccessor("POSITION"),S&&S.startAccessor("NORMAL"),L&&L.startAccessor("TEXCOORD_0"),B&&B.startAccessor("TANGENT"),V&&V.startAccessor("COLOR_0");const z=T.position.length/3;for(let t=0;t<z;++t)I.push(b[3*t]),I.push(b[3*t+1]),I.push(b[3*t+2]),S&&null!=y&&(S.push(y[3*t]),S.push(y[3*t+1]),S.push(y[3*t+2])),L&&null!=x&&(L.push(x[2*t]),L.push(x[2*t+1])),B&&null!=R&&(B.push(R[4*t]),B.push(R[4*t+1]),B.push(R[4*t+2]),B.push(R[4*t+3])),V&&null!=N&&(V.push(N[4*t]),V.push(N[4*t+1]),V.push(N[4*t+2]),V.push(N[4*t+3]));const F=I.endAccessor(),D=this._addAccessor(I.index,F);let U,v,P,G,H;if(S){const t=S.endAccessor();U=this._addAccessor(S.index,t)}if(L){const t=L.endAccessor();v=this._addAccessor(L.index,t)}if(B){const t=B.endAccessor();P=this._addAccessor(B.index,t)}if(V){const t=V.endAccessor();G=this._addAccessor(V.index,t)}const Y=[];return r.components&&r.components.length>0&&r.components[0].faces?(H=g.addBufferView(t.UNSIGNED_INT,W.SCALAR,K.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(H,r.components,Y,D,U,v,P,G)):this._addMeshVertexNonIndexed(r.components,Y,D,U,v,P,G),I.finalize(),S&&S.finalize(),L&&L.finalize(),B&&B.finalize(),H&&H.finalize(),V&&V.finalize(),p||g.finalize(),Y}_addMaterial(t){if(null===t)return;const r=this._materialMap.indexOf(t);if(-1!==r)return r;this.gltf.materials||(this.gltf.materials=[]);const f={};switch(t.alphaMode){case"mask":f.alphaMode=Z.MASK;break;case"auto":case"blend":f.alphaMode=Z.BLEND}.5!==t.alphaCutoff&&(f.alphaCutoff=t.alphaCutoff),t.doubleSided&&(f.doubleSided=t.doubleSided),f.pbrMetallicRoughness={};const r2=t=>t**2.1,i4=t=>{const r=t.toRgba();return r[0]=r2(r[0]/255),r[1]=r2(r[1]/255),r[2]=r2(r[2]/255),r};if(null!=t.color&&(f.pbrMetallicRoughness.baseColorFactor=i4(t.color)),null!=t.colorTexture&&(f.pbrMetallicRoughness.baseColorTexture=this._createTextureInfo(t.colorTexture,t.colorTextureTransform)),null!=t.normalTexture&&(f.normalTexture=this._createTextureInfo(t.normalTexture,t.normalTextureTransform)),t instanceof B){if(null!=t.emissiveTexture&&(f.emissiveTexture=this._createTextureInfo(t.emissiveTexture,t.emissiveTextureTransform)),null!=t.emissiveColor){const r=i4(t.emissiveColor);f.emissiveFactor=[r[0],r[1],r[2]]}null!=t.occlusionTexture&&(f.occlusionTexture=this._createTextureInfo(t.occlusionTexture,t.occlusionTextureTransform)),null!=t.metallicRoughnessTexture&&(f.pbrMetallicRoughness.metallicRoughnessTexture=this._createTextureInfo(t.metallicRoughnessTexture,t.metallicRoughnessTextureTransform)),f.pbrMetallicRoughness.metallicFactor=t.metallic,f.pbrMetallicRoughness.roughnessFactor=t.roughness}else f.pbrMetallicRoughness.metallicFactor=1,f.pbrMetallicRoughness.roughnessFactor=1,M().warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");const _=this.gltf.materials.length;return this.gltf.materials.push(f),this._materialMap.push(t),_}_createTextureInfo(t,r){const f={index:this._addTexture(t)};return r?(f.extensions||(f.extensions={}),f.extensions.KHR_texture_transform={scale:r.scale,offset:r.offset,rotation:V(r.rotation)},f):f}_addTexture(t){const r=this.gltf.textures??[];return this.gltf.textures=r,z(this._textureMap,t,(()=>{const f={sampler:this._addSampler(t),source:this._addImage(t)},_=r.length;return r.push(f),_}))}_addImage(r){const f=this._imageMap.get(r);if(null!=f)return f;this.gltf.images||(this.gltf.images=[]);const _={};if(r.url)_.uri=r.url;else{const f=r.data;_.extras=f;for(let t=0;t<this.gltf.images.length;++t)if(f===this.gltf.images[t].extras)return t;const p=this.gltf.extras;switch(p.output.image){case J.GLB:{const r=p.binChunkBuffer.addBufferView(t.UNSIGNED_BYTE,W.SCALAR);if(F(f))null!=f.data&&r.writeOutToBuffer(f.data,0);else{const t=i$2(f,this.options.signal).then((({data:t,type:r})=>(_.mimeType=r,t)));p.promises.push(r.writeAsync(t).then((()=>{r.finalize()})))}_.bufferView=r.index;break}case J.DataURI:if(F(f)){M().warnOnce("Image export for basis compressed textures not available.");break}_.uri=function a(t){const r=m(t);return null!=r?r.toDataURL():""}(f);break;default:if(F(f)){M().warnOnce("Image export for basis compressed textures not available.");break}p.promises.push(i$2(f,this.options.signal).then((({data:t,type:r})=>{_.uri=t,_.mimeType=r})))}}const p=this.gltf.images.length;return this.gltf.images.push(_),this._imageMap.set(r,p),p}_addSampler(t){this.gltf.samplers||(this.gltf.samplers=[]);let r=D.REPEAT,f=D.REPEAT;if("string"==typeof t.wrap)switch(t.wrap){case"clamp":r=D.CLAMP_TO_EDGE,f=D.CLAMP_TO_EDGE;break;case"mirror":r=D.MIRRORED_REPEAT,f=D.MIRRORED_REPEAT}else{switch(t.wrap.vertical){case"clamp":f=D.CLAMP_TO_EDGE;break;case"mirror":f=D.MIRRORED_REPEAT}switch(t.wrap.horizontal){case"clamp":r=D.CLAMP_TO_EDGE;break;case"mirror":r=D.MIRRORED_REPEAT}}const _={wrapS:r,wrapT:f};for(let g=0;g<this.gltf.samplers.length;++g)if(JSON.stringify(_)===JSON.stringify(this.gltf.samplers[g]))return g;const p=this.gltf.samplers.length;return this.gltf.samplers.push(_),p}_addAccessor(t,r){this.gltf.accessors||(this.gltf.accessors=[]);const f={bufferView:t,byteOffset:r.byteOffset,componentType:r.componentType,count:r.count,type:r.type,min:r.min,max:r.max,name:r.name};r.normalized&&(f.normalized=!0);const _=this.gltf.accessors.length;return this.gltf.accessors.push(f),_}_addMeshVertexIndexed(t,r,f,_,p,g,E,A){const T=new Map;for(const b of r){t.startAccessor("INDICES");for(let f=0;f<b.faces.length;++f)t.push(b.faces[f]);const r=t.endAccessor(),y={attributes:{POSITION:_},indices:this._addAccessor(t.index,r),material:this._addMaterial(b.material)};p&&"flat"!==b.shading&&(y.attributes.NORMAL=p),g&&(y.attributes.TEXCOORD_0=g),E&&"flat"!==b.shading&&(y.attributes.TANGENT=E),A&&(y.attributes.COLOR_0=A);const R=T.get(b.name);if(R)R.primitives.push(y);else{const t={name:b.name,primitives:[y]};T.set(b.name,t),f.push(t)}}}_addMeshVertexNonIndexed(t,r,f,_,p,g,E){const A={primitives:[]};r.push(A);const T={attributes:{POSITION:f}};_&&(T.attributes.NORMAL=_),p&&(T.attributes.TEXCOORD_0=p),g&&(T.attributes.TANGENT=g),E&&(T.attributes.COLOR_0=E),t&&(T.material=this._addMaterial(t[0].material)),A.primitives.push(T)}}function C(t,r){if(null!=t)for(let f=1,_=2;f<t.length;f+=r,_+=r){const r=t[f],p=t[_];t[f]=p,t[_]=-r}}class s{constructor(){this.copyright="",this.defaultScene=0,this.generator="",this._scenes=[]}addScene(t){if(this._scenes.includes(t))throw new Error("Scene already added");this._scenes.push(t)}removeScene(t){v(this._scenes,t)}forEachScene(t){this._scenes.forEach(t)}}class d{constructor(){this.name="",this._nodes=[]}addNode(t){if(this._nodes.includes(t))throw new Error("Node already added");this._nodes.push(t)}forEachNode(t){this._nodes.forEach(t)}}class e2{constructor(t){this.mesh=t,this.name="",this.translation=g(),this.rotation=P(),this.scale=x(L),this._nodes=[]}addNode(t){if(this._nodes.includes(t))throw new Error("Node already added");this._nodes.push(t)}forEachNode(t){this._nodes.forEach(t)}set rotationAngles(t){G(this.rotation,t[0],t[1],t[2])}}const ae="model.gltf",oe="model.glb";async function u(t,r){var f,_;const p=new O(t,r).gltf,g=p.extras.promises;let E=1,T=1,b=null;await Promise.allSettled(g),A(r.signal);const y=r.jsonSpacing??4,R=new Map,x=JSON.stringify(p,((t,f)=>{var _,p;if("extras"!==t){if(f instanceof ArrayBuffer){if(function c(t){if(t.byteLength<8)return!1;const r=new Uint8Array(t);return 137===r[0]&&80===r[1]&&78===r[2]&&71===r[3]&&13===r[4]&&10===r[5]&&26===r[6]&&10===r[7]}(f))switch(null==(_=r.output)?void 0:_.image){case J.DataURI:case J.GLB:break;case J.External:default:{const t=`img${T}.png`;return T++,R.set(t,f),t}}switch(null==(p=r.output)?void 0:p.buffer){case j.DataURI:return function s$1(t){const r=[],f=new Uint8Array(t);for(let _=0;_<f.length;_++)r.push(String.fromCharCode(f[_]));return"data:application/octet-stream;base64,"+btoa(r.join(""))}(f);case j.GLB:if(b)throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");return void(b=f);case j.External:default:{const t=`data${E}.bin`;return E++,R.set(t,f),t}}}return f}}),y);return(null==(f=r.output)?void 0:f.buffer)===j.GLB||(null==(_=r.output)?void 0:_.image)===J.GLB?R.set(oe,new $(x,b).buffer):R.set(ae,x),R}async function i3(t,r){const f=new s,_=new d;return f.addScene(_),_.addNode(new e2(t)),await async function l(t,r){const f=(await u(t,{output:{buffer:j.GLB,image:J.GLB},jsonSpacing:0,...r})).get(oe);if(!(f&&f instanceof ArrayBuffer))throw new Error("failed to export to glb");return f}(f,{origin:t.origin,...r})}export{i3 as toBinaryGLTF};
