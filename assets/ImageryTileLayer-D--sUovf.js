const __vite__fileDeps=["assets/geometryEngine-Bp1TD6MM.js","assets/geometryEngineBase-9EI9fooq.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/hydrated-DE1HcVsK.js","assets/imageryUtils-BKfCadHR.js","assets/utils-CNFe6p3t.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{bb as n,su as h,gE as d,sv as f,n as y,b as g,fY as x,aw as v,az as w,bZ as b,gF as R,I as T,hm as C,e as M,y as O,ev as B,a as D,bk as N,_ as E,d9 as J,a_ as A,j as L,et as z,sw as H,b$ as $,ak as W,sx as j,jM as q,sy as U,cD as Y,m as K,b9 as Q,hX as Z,ej as ee,sz as te,g2 as ie,g4 as ne,eo as se,ep as re,gc as ae,gp as oe,en as le,g3 as ce,eq as ue,g1 as he,h5 as de,er as fe,fP as me,iJ as pe,i_ as ye,g as ge,gw as xe,c8 as ve,g7 as we,iP as Ie,Z as be}from"./index-DSIPxOWi.js";import{h as Re,D as Se,i as Te,a as _e,p as ke,c as Fe,N as Ce,l as Me,d as Oe,b as Pe,e as Be,f as De,o as Ne,g as Ee,$ as Je,W as Ae,j as Le,q as ze,U as He,E as $e,L as We,t as Ge,k as je,m as qe,n as Ue}from"./fetchRasterInfo-CRGdpINC.js";import{U as Ve,j as Ye,n as Xe,D as Ke,R as Qe,u as Ze,l as et,a as tt,g as it,f as nt,m as st,s as rt,L as at,b as ot,c as lt,E as ct,W as ut,h as ht,d as dt,P as ft,T as mt,r as pt,e as yt,F as gt,i as xt,N as vt,k as wt,B as It,o as bt,p as Rt,q as St}from"./dataUtils-DNEwlV4z.js";import{T as Tt,D as _t,j as kt,r as Ft,o as Ct,V as Mt,J as Ot,e as Pt,Z as Bt,C as Dt,U as Nt}from"./rasterProjectionHelper-WTn80RSY.js";import{S as Et,y as Jt,c as At,R as Lt}from"./PolynomialTransform-8quIBSKZ.js";import"./normalizeUtils-BrH-PrZy.js";import"./normalizeUtilsCommon-BU8xfl77.js";import"./ClassBreaksDefinition-Dt1HCCB7.js";const zt=new Map,Ht=new class t{constructor(n=15e3,h=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=n,this._interval=Math.min(n,h)}decreaseRefCount(n,h){const d=n+"/"+h,f=this._cachedBlocks;if(f.has(d)){const n=f.get(d);return n.refCount--,n.refCount<=0&&(f.delete(d),n.controller&&n.controller.abort()),n.refCount}return 0}getBlock(n,h){const d=n+"/"+h,f=this._cachedBlocks;if(f.has(d)){const n=f.get(d);return n.ts=Date.now(),n.refCount++,f.delete(d),f.set(d,n),n.block}return null}putBlock(n,h,d,f){const y=this._cachedBlocks,g=n+"/"+h;if(y.has(g)){const n=y.get(g);n.ts=Date.now(),n.refCount++}else y.set(g,{block:d,ts:Date.now(),refCount:1,controller:f});this._trim(),this._updateTimer()}deleteBlock(n,h){const d=this._cachedBlocks,f=n+"/"+h;d.has(f)&&d.delete(f)}updateMaxSize(n){this._size=n,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const n=this._cachedBlocks;this._timer=setInterval((()=>{const h=Array.from(n),d=Date.now();for(let f=0;f<h.length&&h[f][1].ts<=d-this._duration;f++)n.delete(h[f][0]);0===n.size&&this._clearTimer()}),this._interval)}_trim(){const n=this._cachedBlocks;if(-1===this._size||this._size>=n.size)return;const h=Array.from(n);for(let d=0;d<h.length-this._size;d++)n.delete(h[d][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function i$2(n,h){return null==h?n:`${n}?sliceId=${h}`}function m$4(n,h,d){var f,y,g;const x=zt.get(n);if(!x)return null==h?Ht.getBlock(n,d):null;if(null==h||null==x[h]){for(let n=0;n<x.length;n++){const h=null==(f=x[n])?void 0:f.cache.get(d);if(h)return h.refCount++,h.block}return Ht.getBlock(n,d)}const v=null==(y=x[h])?void 0:y.cache.get(d);if(v)return v.refCount++,v.block;for(let w=0;w<x.length;w++){if(w===h||!x[w])continue;const n=null==(g=x[w])?void 0:g.cache,f=null==n?void 0:n.get(d);if(n&&f)return f.refCount++,n.set(d,f),f.block}return null}function x$2(n,h,d,f,y=null){var g;const x=zt.get(n);if(!x)return void(null==h&&Ht.putBlock(n,d,f,y));if(null==h||null==x[h])return void Ht.putBlock(n,d,f,y);const v={refCount:1,block:f,isResolved:!1,isRejected:!1,controller:y};f.then((()=>v.isResolved=!0)).catch((()=>v.isRejected=!0)),null==(g=x[h])||g.cache.set(d,v)}let $t=0,Wt=class extends(n(N)){constructor(){super(...arguments),this._tileFetchQueue=new h({concurrency:32,process:(n,h)=>this._fetchRawTile(n.pyramidLevel,n.row,n.col,{...n.options,signal:h})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const n=Tt();this.addResolvingPromise(n),await this.when()}normalizeCtorArgs(n){return(null==n?void 0:n.ioConfig)&&(n={...n,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:d.create(),...n.ioConfig}}),n}get _isGlobalWrappableSource(){const{rasterInfo:n}=this,h=_t(n.spatialReference);return null!=h&&n.extent.width>=h/2}get _hasNoneOrGCSShiftTransform(){const{transform:n}=this.rasterInfo;return null==n||"gcs-shift"===n.type}set rasterJobHandler(n){var h,d;this._set("rasterJobHandler",n),"Function"===this.datasetFormat&&(null==(d=null==(h=this.primaryRasters)?void 0:h.rasters)||d.forEach((h=>h.rasterJobHandler=n)))}get rasterId(){return this.url||"rasterId-"+$t++}set url(n){this._set("url",f(n,y.getLogger(this)))}async open(n){throw new g("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(n,h,d,f={}){const y=f.tileInfo||this.rasterInfo.storageInfo.tileInfo,g=this.getTileExtentFromTileInfo(n,h,d,y);return f={noClip:!0,...f},this.fetchPixels(g,y.size[0],y.size[1],f)}async identify(n,h={}){var d;n=x(v,n).clone().normalize();const{multidimensionalDefinition:f,timeExtent:y}=h,{rasterInfo:g}=this,{hasMultidimensionalTranspose:b,multidimensionalInfo:R}=g;let{transposedVariableName:T}=h;const C=null!=R&&b&&(null!=y||Re(f));C&&!T&&(T=null!=f&&f.length>0?f[0].variableName??void 0:R.variables[0].name,h={...h,transposedVariableName:T}),h=this._getRequestOptionsWithSliceId(h);const{spatialReference:M,extent:O}=g,{datumTransformation:B}=h;let D=kt(n,M,B);if(!O.intersects(D))return{location:D,value:null};if(null!=g.transform){const n=g.transform.inverseTransform(D);if(!g.nativeExtent.intersects(n))return{location:n,value:null};D=n}let N=0;const E=null!=T&&null!=R&&g.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const n=this.primaryRasters.rasters[0];if(E)return n.identify(D,h);const{pixelSize:d}=g,y=3,x=d.x*y/2,v=d.y*y/2,b=new w({xmin:D.x-x,xmax:D.x+x,ymin:D.y-v,ymax:D.y+v,spatialReference:M}),R={interpolation:"nearest",multidimensionalDefinition:f,sliceId:h.sliceId},{pixelBlock:T}=await n.fetchPixels(b,y,y,R),{pixelBlock:C}=await this.fetchPixels(b,y,y,R);if(null==T)return{location:D,value:null};const O=Math.floor(y*y*.5),B=!T.mask||T.mask[O]?T.pixels.map((n=>n[O])):null;let N;return null!=C&&(N=!C.mask||C.mask[O]?C.pixels.map((n=>n[O])):void 0),{location:D,value:B,processedValue:N,pyramidLevel:0}}if(!E)if(h.srcResolution)N=Ft(h.srcResolution,g,this.ioConfig.sampling).pyramidLevel;else if(N=await this.computeBestPyramidLevelForLocation(n,h),null==N)return{location:D,value:null};const J=this.identifyPixelLocation(D,N,null,E);if(null===J)return{location:D,value:null};const{row:A,col:L,rowOffset:z,colOffset:H,blockWidth:$}=J,W=T??h.sliceId,j=i$2(this.rasterId,W),q=`${N}/${A}/${L}`;let U=m$4(j,null,q);null==U&&(U=this.fetchRawTile(N,A,L,h),x$2(j,null,q,U));const Y=await U;if(!(null==(d=null==Y?void 0:Y.pixels)?void 0:d.length))return{location:D,value:null};const K=z*$+H;return this._processIdentifyResult(Y,{srcLocation:D,position:K,pyramidLevel:N,useTransposedTile:!!E,requestSomeSlices:C,identifyOptions:h})}async fetchPixels(n,h,d,f={}){n=Ct(n),f=this._getRequestOptionsWithSliceId(f);const{_hasNoneOrGCSShiftTransform:y}=this;if(f.requestRawData&&y)return this._fetchPixels(n,h,d,f);const g=_t(n.spatialReference),x=Mt(n);if(null==g||0===x||1===x&&this._isGlobalWrappableSource&&y)return this._fetchPixels(n,h,d,f);if(x>=3)return{extent:n,pixelBlock:null};const v=[],{xmin:b,xmax:R}=n,T=Math.round(g/(R-b)*h),C=T-Math.round((g/2-b)/(R-b)*h);let M=0;const O=[];for(let E=0;E<=x;E++){const y=new w({xmin:0===E?b:-g/2,xmax:E===x?R-g*E:g/2,ymin:n.ymin,ymax:n.ymax,spatialReference:n.spatialReference}),B=0===E?T-C:E===x?h-M:T;M+=B,O.push(B);const D=f.disableWrapAround&&E>0?null:this._fetchPixels(y,B,d,f);v.push(D)}const B=(await Promise.all(v)).map((n=>null==n?void 0:n.pixelBlock));let D=null;const N={width:h,height:d};return D=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:N,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:O},f)).pixelBlock:Ve(B,N,{blockWidths:O}),{extent:n,srcExtent:Ot(n,this.rasterInfo.spatialReference,f.datumTransformation),pixelBlock:D}}async fetchRawPixels(n,h,d,f={}){h={x:Math.floor(h.x),y:Math.floor(h.y)};const y=await this._fetchRawTiles(n,h,d,f),{nativeExtent:g,nativePixelSize:x,storageInfo:v}=this.rasterInfo,b=2**n,R=x.x*b,T=x.y*b,C=new w({xmin:g.xmin+R*h.x,xmax:g.xmin+R*(h.x+d.width-1),ymin:g.ymax-T*(h.y+d.height-1),ymax:g.ymax-T*h.y,spatialReference:g.spatialReference});if(!y)return{extent:C,srcExtent:C,pixelBlock:null};const{pixelBlocks:M,mosaicSize:O}=y;if(1===M.length&&null!=M[0]&&M[0].width===d.width&&M[0].height===d.height)return{extent:C,srcExtent:C,pixelBlock:y.pixelBlocks[0]};const B=n>0?v.pyramidBlockWidth:v.blockWidth,D=n>0?v.pyramidBlockHeight:v.blockHeight,N={x:h.x%B,y:h.y%D};let E;return E=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:M,srcMosaicSize:O,destDimension:d,clipOffset:N,clipSize:d,coefs:null,sampleSpacing:null,interpolation:f.interpolation,alignmentInfo:null,blockWidths:null},f)).pixelBlock:Ve(M,O,{clipOffset:N,clipSize:d}),{extent:C,srcExtent:C,pixelBlock:E}}fetchRawTile(n,h,d,f){throw new g("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(n){return Ot(this.rasterInfo.extent,n)}decodePixelBlock(n,h){return!this.rasterJobHandler||h.useCanvas?Ye(n,h):this.rasterJobHandler.decode({data:n,options:h})}async request(n,h,d=0){const{customFetchParameters:f}=this.ioConfig,{range:y,query:g,headers:x}=h;d=d??h.retryCount??this.ioConfig.retryCount;const v=y?{Range:`bytes=${y.from}-${y.to}`}:null;try{return await b(n,{...h,query:{...g,...f},headers:{...x,...v}})}catch(w){if(d>0)return d--,this.request(n,h,d);throw w}}getSliceIndex(n){const{multidimensionalInfo:h}=this.rasterInfo;return null==h||null==n||0===n.length?null:Se(n,h)}getTileExtentFromTileInfo(n,h,d,f){const y=f.lodAt(n);return this.getTileExtent({x:y.resolution,y:y.resolution},h,d,f.origin,f.spatialReference,f.size)}updateTileInfo(){const{storageInfo:n,spatialReference:h,extent:f,pixelSize:y}=this.rasterInfo,{pyramidResolutions:g}=n;if(!n.tileInfo){const x=[],w=n.maximumPyramidLevel||0;let b=(y.x+y.y)/2,T=1/.0254*96*b;for(let n=0;n<=w&&(x.unshift(new R({level:w-n,resolution:b,scale:T})),n!==w);n++)if(g){const h=(g[n].x+g[n].y)/2;T*=h/b,b=h}else b*=2,T*=2;const C=new v({x:f.xmin,y:f.ymax,spatialReference:h});n.tileInfo=new d({origin:C,size:[n.blockWidth,n.blockHeight],spatialReference:h,lods:x}),n.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(n,h=512,d=512,f){const{width:y,height:g,nativeExtent:x,pixelSize:w,spatialReference:b}=n,R=new v({x:x.xmin,y:x.ymax,spatialReference:b});null==f&&(f=Math.max(0,Math.round(Math.log(Math.max(y,g))/Math.LN2-8)));const T=this.computeBlockBoundary(x,512,512,{x:x.xmin,y:x.ymax},[w],f);n.storageInfo=new Xe({blockWidth:h,blockHeight:d,pyramidBlockWidth:h,pyramidBlockHeight:d,origin:R,firstPyramidLevel:1,maximumPyramidLevel:f,blockBoundary:T})}async computeBestPyramidLevelForLocation(n,h={}){return 0}computeBlockBoundary(n,h,d,f,y,g=0,x=2){if(1===y.length&&g>0){y=[...y];let{x:n,y:h}=y[0];for(let d=0;d<g;d++)n*=x,h*=x,y.push({x:n,y:h})}const v=[],{x:w,y:b}=f;for(let R=0;R<y.length;R++){const{x:f,y:g}=y[R];v.push({minCol:Math.floor((n.xmin-w+.1*f)/h/f),maxCol:Math.floor((n.xmax-w-.1*f)/h/f),minRow:Math.floor((b-n.ymax+.1*g)/d/g),maxRow:Math.floor((b-n.ymin-.1*g)/d/g)})}return v}getPyramidPixelSize(n){const{nativePixelSize:h}=this.rasterInfo,{pyramidResolutions:d,pyramidScalingFactor:f}=this.rasterInfo.storageInfo;if(0===n)return h;if(null!=d&&d.length)return d[n-1];const y=f**n;return{x:h.x*y,y:h.y*y}}identifyPixelLocation(n,h,d,f){const{spatialReference:y,nativeExtent:g,storageInfo:x}=this.rasterInfo,{maximumPyramidLevel:v,origin:w,transposeInfo:b}=x,R=f&&null!=b?b.tileSize[0]:x.blockWidth,T=f&&null!=b?b.tileSize[1]:x.blockHeight,C=kt(n,y,d);if(!g.intersects(C))return null;if(h<0||h>v)return null;const M=this.getPyramidPixelSize(h),{x:O,y:B}=M,D=(w.y-C.y)/B/T,N=(C.x-w.x)/O/R,E=Math.min(T-1,Math.floor((D-Math.floor(D))*T)),J=Math.min(R-1,Math.floor((N-Math.floor(N))*R));return{pyramidLevel:h,row:Math.floor(D),col:Math.floor(N),rowOffset:E,colOffset:J,blockWidth:R,srcLocation:C}}getTileExtent(n,h,d,f,y,g){const[x,v]=g,b=f.x+d*x*n.x,R=b+x*n.x,T=f.y-h*v*n.y,C=T-v*n.y;return new w({xmin:b,xmax:R,ymin:C,ymax:T,spatialReference:y})}getBlockWidthHeight(n){return{blockWidth:n>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:n>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(n,h,d){const f=this.rasterInfo.storageInfo.blockBoundary[n];return!f||f.maxRow<h||f.maxCol<d||f.minRow>h||f.minCol>d}updateImageSpaceRasterInfo(n){const{extent:h,pixelSize:d}=n;if(-.5===h.xmin&&.5===h.ymax&&1===d.x&&1===d.y&&null==n.transform)return;const{width:f,height:y}=n,g=T.WebMercator;n.spatialReference=g,n.extent=n.nativeExtent=new w({xmin:-.5,ymax:.5,xmax:f-.5,ymin:.5-y,spatialReference:g}),n.isPseudoSpatialReference=!0,n.transform=null,n.pixelSize=new v({x:1,y:1,spatialReference:g});const{extent:x,storageInfo:b}=n;if(b){b.origin=new v({x:x.xmin,y:x.ymax,spatialReference:g});const{pyramidResolutions:h,tileInfo:f}=b;if(h&&h.forEach((n=>{n.x/=d.x,n.y/=d.y})),f){f.origin=b.origin;const h=(n.nativePixelSize.x+n.nativePixelSize.y)/2;f.lods.forEach(((n,d)=>{n.resolution=h*2**d,n.scale=96*n.resolution/.0254}))}}}async _fetchPixels(n,h,d,f={}){let y=Mt(n);if(y>=2)return{extent:n,pixelBlock:null};const g=this._getSourceDataInfo(n,h,d,f),{pyramidLevel:x,srcResolution:w,srcExtent:b,srcWidth:R,srcHeight:T,ul:C}=g;if(0===R||0===T)return{extent:n,srcExtent:b,pixelBlock:null};const{rasterInfo:M}=this,O=M.transform,B="gcs-shift"===(null==O?void 0:O.type),D=null!=_t(n.spatialReference);!B&&D||(y=Mt(g.srcExtent,B));const N=await this._fetchRawTiles(x,C,{width:R,height:T,wrapCount:y},f);if(!N)return{extent:n,srcExtent:b,pixelBlock:null};const E=M.storageInfo,J=x>0?E.pyramidBlockWidth:E.blockWidth,A=x>0?E.pyramidBlockHeight:E.blockHeight;let{x:L,y:z}=M.pixelSize;if(x>0){const{pyramidResolutions:n,pyramidScalingFactor:h}=E;if(null!=n&&n[x-1])({x:L,y:z}=n[x-1]);else{const n=h**x;L*=n,z*=n}}const H=M.spatialReference,$=new v({x:L,y:z,spatialReference:H}),W=J===R&&A===T&&C.x%J==0&&C.y%A==0,j=new v({x:(n.xmax-n.xmin)/h,y:(n.ymax-n.ymin)/d,spatialReference:n.spatialReference}),q=!n.spatialReference.equals(H),U=H.isGeographic?1e-9:1e-4,{datumTransformation:Y}=f;if(!q&&W&&1===N.pixelBlocks.length&&J===h&&A===d&&function X(n,h,d){return Math.abs(n.x-h.x)<d&&Math.abs(n.y-h.y)<d}(w,j,U))return{extent:n,srcExtent:b,srcTilePixelSize:$,pixelBlock:N.pixelBlocks[0]};const K=D&&null!=_t(b.spatialReference)&&this._hasNoneOrGCSShiftTransform,Q=f.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");Q&&!this.rasterJobHandler&&await Tt();const Z=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:n,srcBufferExtent:N.extent,pixelSize:j.toJSON(),datumTransformation:Y,rasterTransform:O,hasWrapAround:y>0||K,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:Q},f):Pt({projectedExtent:n,srcBufferExtent:N.extent,pixelSize:j,datumTransformation:Y,rasterTransform:O,hasWrapAround:y>0||K,isAdaptive:!1,includeGCSGrid:Q});let ee;const te=!f.requestRawData,ie={rows:Z.spacing[0],cols:Z.spacing[1]},ne=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(x,N.extent.xmin):void 0,{pixelBlocks:se,mosaicSize:re,isPartiallyFilled:ae}=N;let oe=null;if(this.rasterJobHandler){const n=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:se,srcMosaicSize:re,destDimension:te?{width:h,height:d}:null,coefs:te?Z.coefficients:null,sampleSpacing:te?ie:null,projectDirections:Q,gcsGrid:Q?Z.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:f.interpolation,alignmentInfo:ne,blockWidths:null},f);({pixelBlock:ee,localNorthDirections:oe}=n)}else{const n=Ve(se,re,{alignmentInfo:ne});ee=te?Ke(n,{width:h,height:d},Z.coefficients,ie,f.interpolation):n,Q&&Z.gcsGrid&&(oe=Qe({width:h,height:d},Z.gcsGrid),ee=Ze(ee,this.rasterInfo.dataType,oe))}return f.requestRawData||Q?{extent:n,srcExtent:b,srcTilePixelSize:$,pixelBlock:ee,transformGrid:Z,localNorthDirections:oe,isPartiallyFilled:ae}:{extent:n,srcExtent:b,srcTilePixelSize:$,pixelBlock:ee}}async _fetchRawTiles(n,h,d,f){const{origin:y,blockBoundary:g}=this.rasterInfo.storageInfo,{blockWidth:x,blockHeight:v}=this.getBlockWidthHeight(n);let{x:b,y:R}=h,{width:T,height:C,wrapCount:M}=d;const O=this._getRasterTileAlignmentInfo(n,0);f.buffer&&(b-=f.buffer.cols,R-=f.buffer.rows,T+=2*f.buffer.cols,C+=2*f.buffer.rows);let B=0,D=0,N=0;M&&null!=O&&(({worldColumnCountFromOrigin:D,originColumnOffset:N,rightPadding:B}=O),D*O.blockWidth-B>=b+T&&(B=0));const E=Math.floor(b/x),J=Math.floor(R/v),A=Math.floor((b+T+B-1)/x),L=Math.floor((R+C+B-1)/v),z=g[n];if(!z)return null;const{minRow:H,minCol:$,maxCol:W,maxRow:j}=z;if(0===M&&(L<H||A<$||J>j||E>W))return null;const q=new Array;let U=!1;const Y=null==this.ioConfig.allowPartialFill?f.allowPartialFill:this.ioConfig.allowPartialFill;for(let w=J;w<=L;w++)for(let h=E;h<=A;h++){let d=h;if(!f.disableWrapAround&&M&&null!=O&&D<=h&&(d=h-D-N),w>=H&&d>=$&&j>=w&&W>=d){const h=this._tileFetchQueue.push({pyramidLevel:n,row:w,col:d,options:f},{signal:f.signal});Y?q.push(new Promise((n=>{h.then((h=>n(h))).catch((()=>{U=!0,n(null)}))}))):q.push(h)}else q.push(Promise.resolve(null))}if(0===q.length)return null;const K=await Promise.all(q),Q={height:(L-J+1)*v,width:(A-E+1)*x},{spatialReference:Z}=this.rasterInfo,ee=this.getPyramidPixelSize(n),{x:te,y:ie}=ee;return{extent:new w({xmin:y.x+E*x*te,xmax:y.x+(A+1)*x*te,ymin:y.y-(L+1)*v*ie,ymax:y.y-J*v*ie,spatialReference:Z}),pixelBlocks:K,mosaicSize:Q,isPartiallyFilled:U}}_fetchRawTile(n,h,d,f){const y=this.rasterInfo.storageInfo.blockBoundary[n];if(!y)return Promise.resolve(null);const{minRow:g,minCol:x,maxCol:v,maxRow:w}=y;if(h<g||d<x||h>w||d>v)return Promise.resolve(null);const b=i$2(this.rasterId,f.sliceId),R=`${n}/${h}/${d}`;let T=m$4(b,f.registryId,R);if(null==T){const y=new AbortController;T=this.fetchRawTile(n,h,d,{...f,signal:y.signal}),x$2(b,f.registryId,R,T,y),T.catch((()=>function h$4(n,h,d){var f;const y=zt.get(n);y?null!=h&&null!=y[h]?null==(f=y[h])||f.cache.delete(d):Ht.deleteBlock(n,d):null==h&&Ht.deleteBlock(n,d)}(b,f.registryId,R)))}return f.signal&&C(f,(()=>{!function s(n,h,d){var f,y;const g=zt.get(n);if(!g)return null==h?Ht.decreaseRefCount(n,d):0;if(null==h||null==g[h])return Ht.decreaseRefCount(n,d);const x=null==(f=g[h])?void 0:f.cache,v=null==x?void 0:x.get(d);if(x&&v){if(v.refCount--,0===v.refCount){x.delete(d);for(let n=0;n<g.length;n++)null==(y=g[n])||y.cache.delete(d);v.controller&&v.controller.abort()}return v.refCount}return 0}(b,f.registryId,R)})),T}_computeMagDirValues(n){var h;const{bandCount:d,dataType:f}=this.rasterInfo;if((2!==d||"vector-magdir"!==f)&&"vector-uv"!==f||2!==(null==n?void 0:n.length)||!(null==(h=n[0])?void 0:h.length))return null;const y=n[0].length;if("vector-magdir"===f){const h=n[1].map((n=>(n+360)%360));return[n[0],h]}const[g,x]=n,v=[],w=[];for(let b=0;b<y;b++){const[n,h]=et([g[b],x[b]]);v.push(n),w.push(h)}return[v,w]}_getRasterTileAlignmentInfo(n,h){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=Bt(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:h,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[n]}}_getSourceDataInfo(n,h,d,f={}){const y={datumTransformation:f.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};f.srcResolution&&(y.srcResolution=f.srcResolution,this._updateSourceDataInfo(n,y));const g=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:x,srcHeight:w,pyramidLevel:b}=y,R=x/h,T=w/d,C=b<g&&R*T>=16,M=b===g&&this._requireTooManySrcTiles(x,w,h,d);if(C||M||0===x||0===w){const x=new v({x:(n.xmax-n.xmin)/h,y:(n.ymax-n.ymin)/d,spatialReference:n.spatialReference});let w=Dt(x,this.rasterInfo.spatialReference,n,y.datumTransformation);const M=!w||f.srcResolution&&w.x+w.y<f.srcResolution.x+f.srcResolution.y;if(C&&f.srcResolution&&M){const n=Math.round(Math.log(Math.max(R,T))/Math.LN2)-1;if(g-b+3>=n){const h=2**n;w={x:f.srcResolution.x*h,y:f.srcResolution.y*h}}}w&&(y.srcResolution=w,this._updateSourceDataInfo(n,y))}return this._requireTooManySrcTiles(y.srcWidth,y.srcHeight,h,d)&&(y.srcWidth=0,y.srcHeight=0),y}_requireTooManySrcTiles(n,h,d,f){const{tileInfo:y}=this.rasterInfo.storageInfo,g=n/d,x=h/f;return Math.ceil(n/y.size[0])*Math.ceil(h/y.size[1])>=256*Math.max(1,(d+f)/1024)||g>8||x>8}_updateSourceDataInfo(n,h){h.srcWidth=0,h.srcHeight=0;const{rasterInfo:d}=this,f=d.spatialReference,{srcResolution:y,datumTransformation:g}=h,{pyramidLevel:x,pyramidResolution:v,excessiveReading:w}=Ft(y,d,this.ioConfig.sampling);if(w)return;let b=h.srcExtent||Ot(n,f,g);if(null==b)return;const R=d.transform;R&&(b=R.inverseTransform(b)),h.srcExtent=b;const{x:T,y:C}=d.storageInfo.origin,M=Math.floor((b.xmin-T)/v.x+.1),O=Math.floor((C-b.ymax)/v.y+.1),B=Math.floor((b.xmax-T)/v.x-.1),D=Math.floor((C-b.ymin)/v.y-.1),N=b.width<.1*v.x?0:B-M+1,E=b.height<.1*v.y?0:D-O+1;h.pyramidLevel=x,h.pyramidResolution=v,h.srcWidth=N,h.srcHeight=E,h.ul={x:M,y:O}}_getRequestOptionsWithSliceId(n){return null!=this.rasterInfo.multidimensionalInfo&&null==n.sliceId&&(n={...n,sliceId:this.getSliceIndex(n.multidimensionalDefinition)}),n}_processIdentifyResult(n,h){const{srcLocation:d,position:f,pyramidLevel:y,useTransposedTile:g}=h,x=n.pixels[0].length/n.width/n.height;if(n.mask&&!n.mask[f])return{location:d,value:null};const{multidimensionalInfo:v}=this.rasterInfo;if(null==v||!g){const h=n.pixels.map((n=>n[f])),g={location:d,value:h,pyramidLevel:y},x=this._computeMagDirValues(h.map((n=>[n])));return(null==x?void 0:x.length)&&(g.magdirValue=x.map((n=>n[0]))),g}let w=n.pixels.map((n=>n.slice(f*x,f*x+x))),b=this._computeMagDirValues(w);const{requestSomeSlices:R,identifyOptions:T}=h;let C=Te(v,T.transposedVariableName);if(R){const n=_e(C,T.multidimensionalDefinition,T.timeExtent);w=w.map((h=>n.map((n=>h[n])))),b=null==b?void 0:b.map((h=>n.map((n=>h[n])))),C=n.map((n=>C[n]))}const M=n.noDataValues||this.rasterInfo.noDataValue,O={pixels:w,pixelType:n.pixelType};let B;return null!=M&&(tt(O,M),B=O.mask),{location:d,value:null,dataSeries:C.map(((n,h)=>{const d={value:0===(null==B?void 0:B[h])?null:w.map((n=>n[h])),multidimensionalDefinition:n.multidimensionalDefinition.map((n=>new ke({...n,isSlice:!0})))};return(null==b?void 0:b.length)&&(d.magdirValue=[b[0][h],b[1][h]]),d})),pyramidLevel:y}}};M([O()],Wt.prototype,"_rasterTileAlignmentInfo",void 0),M([O()],Wt.prototype,"_tileFetchQueue",void 0),M([O({readOnly:!0})],Wt.prototype,"_isGlobalWrappableSource",null),M([O({readOnly:!0})],Wt.prototype,"_hasNoneOrGCSShiftTransform",null),M([O()],Wt.prototype,"rasterJobHandler",null),M([O({readOnly:!0})],Wt.prototype,"rasterId",null),M([O(B)],Wt.prototype,"url",null),M([O({type:String,json:{write:!0}})],Wt.prototype,"datasetName",void 0),M([O({type:String,json:{write:!0}})],Wt.prototype,"datasetFormat",void 0),M([O()],Wt.prototype,"hasUniqueSourceStorageInfo",void 0),M([O()],Wt.prototype,"rasterInfo",void 0),M([O()],Wt.prototype,"ioConfig",void 0),M([O()],Wt.prototype,"sourceJSON",void 0),Wt=M([D("esri.layers.support.rasterDatasets.BaseRaster")],Wt);const Gt=Wt;async function a(n,h,d){if("extent"===d.type)return function o$2(n,h,d){const{width:f,height:y}=n,g=new Uint8Array(f*y),x=h.width/f,v=h.height/y;if(d.width/x<.5||d.height/v<.5)return new it({pixelType:n.pixelType,width:f,height:y,mask:g,pixels:[...n.pixels]});const{xmin:w,xmax:b,ymin:R,ymax:T}=h,{xmin:C,xmax:M,ymin:O,ymax:B}=d,D=Math.max(w,C),N=Math.min(b,M),E=Math.max(R,O),J=Math.min(T,B),A=.5*x,L=.5*v;if(N-D<A||J-E<L||N<w+A||D>b-A||E>T-L||J<R+L)return new it({pixelType:n.pixelType,width:f,height:y,mask:g,pixels:[...n.pixels]});const z=Math.max(0,(D-w)/x),H=Math.min(f,Math.max(0,(N-w)/x)),$=Math.max(0,(T-J)/v),W=Math.min(y,Math.max(0,(T-E)/v)),j=Math.round(z),q=Math.round(H)-1,U=Math.round($),Y=Math.round(W)-1;if(j===q&&z%1>.5&&H%1<.5||U===Y&&$%1>.5&&W%1<.5)return new it({pixelType:n.pixelType,width:f,height:y,mask:g,pixels:[...n.pixels]});if(0===j&&0===U&&q===f&&Y===y)return n;const K=n.mask;for(let Q=U;Q<=Y;Q++)for(let n=j;n<=q;n++){const h=Q*f+n;g[h]=K?K[h]:255}return new it({pixelType:n.pixelType,width:f,height:y,mask:g,pixels:[...n.pixels]})}(n,h,d);const{width:f,height:y}=n,g=new Uint8Array(f*y),{contains:x,intersects:v}=await E((async()=>{const{contains:n,intersects:h}=await import("./geometryEngine-Bp1TD6MM.js");return{contains:n,intersects:h}}),__vite__mapDeps([0,1,2,3,4]));return v(h,d)?"polyline"===d.type?function r$2(n,h,d){const{width:f,height:y}=n,g=new Uint8Array(f*y),x=h.width/f,v=h.height/y,{xmin:w,ymax:b}=h,{paths:R}=d,T=n.mask;for(let C=0;C<R.length;C++){const n=R[C];for(let h=0;h<n.length-1;h++){const[d,R]=n[h],[C,M]=n[h+1];let O=Math.floor((b-R)/v),B=Math.floor((b-M)/v);if(B<O){const n=O;O=B,B=n}O=Math.max(0,O),B=Math.min(y-1,B);const D=(C-d)/(M-R);for(let n=O;n<=B;n++){const h=n===O?Math.max(R,M):(y+1-n)*v,b=n===B?Math.min(R,M):h-v;let N=M===R?Math.floor((d-w)/x):Math.floor((D*(h-R)+d-w)/x),E=M===R?Math.floor((C-w)/x):Math.floor((D*(b-R)+d-w)/x);if(E<N){const n=N;N=E,E=n}const J=n*f;N=Math.max(0,N),E=Math.min(f-1,E);for(let n=J+N;n<=J+E;n++)g[n]=T?T[n]:255}}}return new it({pixelType:n.pixelType,width:f,height:y,mask:g,pixels:[...n.pixels]})}(n,h,d):x(d,h)?n:function h$3(n,h,d){if(!n)return n;const{width:f,height:y}=n,g=h.width/f,x=h.height/y,{xmin:v,ymax:w}=h;let b;if("extent"===d.type){const n=(d.xmin-v)/g,h=(d.xmax-v)/g,f=(w-d.ymax)/x,y=(w-d.ymin)/x;b=[[[n,f],[n,y],[h,y],[h,f],[n,f]]]}else b=d.rings.map((n=>n.map((([n,h])=>[(n-v)/g,(w-h)/x]))));const R=document.createElement("canvas");R.width=f,R.height=y;const T=R.getContext("2d");T.fillStyle="#f00",T.beginPath(),b.forEach((n=>{T.moveTo(n[0][0],n[0][1]);for(let h=0;h<n.length;h++)T.lineTo(n[h][0],n[h][1]);T.closePath()})),T.fill();const C=T.getImageData(0,0,f,y).data,M=n.mask,O=f*y,B=new Uint8Array(O);for(let D=0;D<O;D++)M&&!M[D]||(B[D]=C[4*D+3]>127?255:0);return new it({pixelType:n.pixelType,width:f,height:y,mask:B,maskIsAlpha:!1,pixels:[...n.pixels]})}(n,h,d):new it({pixelType:n.pixelType,width:f,height:y,mask:g,maskIsAlpha:!1,pixels:[...n.pixels]})}function x$1(n,h,d,f=!0){const{spatialReference:y}=n,{x:g,y:x}=function n$2(n,h){if(n.spatialReference.equals(h))return n;const d=J(n.spatialReference),f=J(h);if(d===f)return n;const y=d/f;return{x:n.x*y,y:n.y*y}}(d,y);let v,b,R;const T="extent"===h.type?h:h.extent;let{xmin:C,xmax:M,ymax:O,ymin:B}=T;const{xmin:D,ymax:N}=n.extent;return f?(C=D+(C>D?g*Math.round((C-D)/g):0),O=N-(O<N?x*Math.round((N-O)/x):0),M=D+(M>D?g*Math.round((M-D)/g):0),B=N-(B<N?x*Math.round((N-B)/x):0),v=new w({xmin:C,ymax:O,xmax:M,ymin:B,spatialReference:y}),b=Math.round(v.width/g),R=Math.round(v.height/x)):(b=Math.floor((M-C)/g+.8),R=Math.floor((O-B)/x+.8),C=D+(C>D?g*Math.floor((C-D)/g+.1):0),O=N-(O<N?x*Math.floor((N-O)/x+.1):0),M=C+b*g,B=O-R*x,v=new w({xmin:C,ymax:O,xmax:M,ymin:B,spatialReference:y})),{extent:v,width:b,height:R}}let jt=class m extends Gt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async open(n){var h,d,f,y;await this.init();const{rasterFunction:x}=this;(null==(d=null==(h=this.primaryRasters)?void 0:h.rasters)?void 0:d.length)?x.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=x.getPrimaryRasters(),this.rasterJobHandler&&(null==(f=this.primaryRasters.rasters)||f.forEach((n=>n.rasterJobHandler=this.rasterJobHandler))));const{rasters:v,rasterIds:w}=this.primaryRasters,b=v.map((h=>h.rasterInfo?void 0:h.open(n)));await Promise.all(b);const R=v.map((({rasterInfo:n})=>n)),T=x.bind({rasterInfos:R,rasterIds:w});if(x.rawSourceRasterInfos=R,!T.success||0===R.length)throw new g("raster-function:open",`cannot bind the function: ${T.error??""}`);const C="Table"===x.functionName?x:null==(y=x.functionArguments)?void 0:y.raster;"Table"===(null==C?void 0:C.functionName)&&(x.rasterInfo.attributeTable=A.fromJSON(C.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const M=R[0];this.hasUniqueSourceStorageInfo=1===R.length||R.slice(1).every((n=>function h$2(n,h){const{storageInfo:d,pixelSize:f,spatialReference:y,extent:g}=n,{storageInfo:x,pixelSize:v,spatialReference:w,extent:b}=h;return f.x===v.x&&f.y===v.y&&y.equals(w)&&g.equals(b)&&d.blockHeight===x.blockHeight&&d.blockWidth===x.blockWidth&&d.maximumPyramidLevel===x.maximumPyramidLevel}(n,M))),this.set("sourceJSON",v[0].sourceJSON),this.set("rasterInfo",x.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var n;return null==(n=this.rasterJobHandler)?void 0:n.updateRasterFunction(this.rasterFunction)}async fetchPixels(n,h,d,f={}){var y,g;const{rasters:x,rasterIds:v}=this.primaryRasters;let w=!1;const{interpolation:b}=f,R=null==(y=this.rasterFunction.flatWebGLFunctionChain)?void 0:y.hasFocalFunction;!f.requestRawData&&R&&(w=1===x.length&&!f.skipRasterFunction,f={...f,interpolation:"bilinear",requestRawData:w});const T=x.map((y=>y.fetchPixels(n,h,d,f))),C=await Promise.all(T),M=C.map((n=>n.pixelBlock)),O=w||f.requestRawData?C.map((n=>n.srcTilePixelSize)):null;if(f.skipRasterFunction||M.every((n=>null==n)))return C[0];const B=(null==(g=C.find((n=>null!=n.pixelBlock)))?void 0:g.extent)??n;let D=this.rasterJobHandler?await this.rasterJobHandler.process({extent:B,primaryPixelBlocks:M,primaryPixelSizes:O,primaryRasterIds:v}):this.rasterFunction.process({extent:B,primaryPixelBlocks:M,primaryPixelSizes:O,primaryRasterIds:v});const{transformGrid:N}=C[0];if(!w||null==D||null==N){const n=f.noClip?null:this.getClippingGeometry(B.spatialReference);return f.noClip||f.requestRawData||null==D||!n||(D=await a(D,B,n)),{...C[0],pixelBlock:D}}const E={rows:N.spacing[0],cols:N.spacing[1]};let J;J=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[D],srcMosaicSize:{width:D.width,height:D.height},destDimension:{width:h,height:d},coefs:N.coefficients,sampleSpacing:E,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:b,alignmentInfo:void 0,blockWidths:null},f)).pixelBlock:Ke(D,{width:h,height:d},N.coefficients,E,b);const A=f.noClip?null:this.getClippingGeometry(n.spatialReference);return f.noClip||f.requestRawData||null==J||null==A||(J=await a(J,n,A)),{extent:n,srcExtent:C[0].srcExtent,pixelBlock:J}}getClippingGeometry(n){const h=this._clippingGeometry.get("0");if(!n||!h)return h;const d=function f$2(n){return String(n.wkid??n.wkt??n.wkt2)}(n);let f=this._clippingGeometry.get(d);return null!=f||(f=n.equals(h.spatialReference)?h:Nt(h,n),this._clippingGeometry.set(d,f)),f}async _updateClipGeometry(){const n=this.rasterFunction.getClippingGeometries()[0];let h=null==n?void 0:n.clippingGeometry;if(h&&"inside"===n.clippingType){const{extent:n}=this.rasterInfo,{difference:d,densify:f}=await E((async()=>{const{difference:n,densify:h}=await import("./geometryEngine-Bp1TD6MM.js");return{difference:n,densify:h}}),__vite__mapDeps([0,1,2,3,4]));let y=f(L.fromExtent(n),2*(n.width+n.height)/40);y=Nt(y,h.spatialReference),h=d(y,h)}this._clippingGeometry.clear(),h&&this._clippingGeometry.set("0",h)}};M([O({type:String,json:{write:!0}})],jt.prototype,"datasetFormat",void 0),M([O()],jt.prototype,"tileType",void 0),M([O()],jt.prototype,"rasterFunction",void 0),M([O()],jt.prototype,"primaryRasters",void 0),jt=M([D("esri.layers.support.rasterDatasets.FunctionRaster")],jt);const qt=jt;const V=n=>{let h=class extends n{constructor(...n){var h,d;super(...n),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===(null==(d=null==(h=n[0])?void 0:h.raster)?void 0:d.datasetFormat)}get fullExtent(){var n;return null==(n=this.serviceRasterInfo)?void 0:n.extent}set multidimensionalDefinition(n){this._set("multidimensionalDefinition",n),this.updateRenderer()}set rasterFunction(n){var h;"none"===(null==(h=null==n?void 0:n.functionName)?void 0:h.toLowerCase())&&(n=void 0),this._set("rasterFunction",n),this.updateRasterFunction()}get rasterInfo(){return H(y.getLogger(this),"rasterInfo",{replacement:"serviceRasterInfo",version:"4.29",warnOnce:!0}),this._get("serviceRasterInfo")}set url(n){this._set("url",f(n,y.getLogger(this)))}set renderer(n){null==n&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",n),this.updateRenderer())}readRenderer(n,h,d){var f,y;const g=null==(y=null==(f=null==h?void 0:h.layerDefinition)?void 0:f.drawingInfo)?void 0:y.renderer;return Pe(g,d)||void 0}async convertVectorFieldData(n,h){const{serviceRasterInfo:d}=this;if(null==n||!d)return null;const f=this._rasterJobHandler.instance,y=d.dataType;return f?f.convertVectorFieldData({pixelBlock:n,dataType:y},h):nt(n,y)}async computeStatisticsHistograms(n,h){await this.load(h),n=x(Be,n).clone();const{serviceRasterInfo:d}=this;if(null==d)throw new g("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:f}=n;if(null==f)throw new g("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let y=f;const{spatialReference:w}=d;f.spatialReference.equals(w)||(await Tt(),y="extent"===f.type?Ot(f,w):Nt(f,w));const b=n.pixelSize??new v({x:d.pixelSize.x,y:d.pixelSize.y,spatialReference:w}),{extent:R,width:T,height:C}=x$1(d,y,b),M=await this.fetchPixels(R,T,C,{...h,interpolation:"nearest"});if(null==M.pixelBlock)throw new g("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const O=await a(M.pixelBlock,R,y),B=this._rasterJobHandler.instance;return B?B.computeStatisticsHistograms({pixelBlock:O},h):st(O)}async createFlowMesh(n,h){const d=this._rasterJobHandler.instance;return d?d.createFlowMesh(n,h):rt(n.meshType,n.simulationSettings,n.flowData,null!=h.signal?h.signal:(new AbortController).signal)}normalizeRasterFetchOptions(n){var h,d;const{multidimensionalInfo:f}=this.serviceRasterInfo??{};if(null==f)return n;let y=n.multidimensionalDefinition||this.multidimensionalDefinition;(null==y?void 0:y.length)||(y=De(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const g=n.timeExtent||this.timeExtent;if(null!=y&&null!=g&&(null!=g.start||null!=g.end)){y=y.map((n=>n.clone()));const x=null==(d=null==(h=f.variables.find((({name:n})=>n===y[0].variableName)))?void 0:h.dimensions)?void 0:d.find((({name:n})=>"StdTime"===n)),v=y.find((({dimensionName:n})=>"StdTime"===n));if(!x||!v)return{...n,multidimensionalDefinition:null};const{start:w,end:b}=g,R=null==w?null:w.getTime(),T=null==b?null:b.getTime(),C=R??T,M=T??R;if(null!=x.values){const n=x.values.filter((n=>{if(Array.isArray(n)){if(C===M)return n[0]<=C&&n[1]>=C;const h=n[0]<=C&&n[1]>C||n[0]<M&&n[1]>=M,d=n[0]>=C&&n[1]<=M||n[0]<C&&n[1]>M;return h||d}return C===M?n===C:n>=C&&n<=M}));if(n.length){const h=n.sort(((n,h)=>{const d=Array.isArray(n)?n[0]:n,f=Array.isArray(n)?n[1]:n,y=Array.isArray(h)?h[0]:h,g=Array.isArray(h)?h[1]:h;return C===M?d-y:Math.abs(f-M)-Math.abs(g-M)}))[0];v.values=[h]}else y=null}else if(x.hasRegularIntervals&&x.extent){const[n,h]=x.extent;C>h||M<n?y=null:v.values=C===M?[C]:[Math.max(n,C),Math.min(h,M)]}}return null!=y&&Ne(y,this.multidimensionalSubset)?{...n,multidimensionalDefinition:null}:{...n,multidimensionalDefinition:y}}async updateRasterFunction(){var n,h,d;if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const h=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&h&&this._set("rasterFunction",Ce.fromJSON(h)),void(this._cachedRasterFunctionJson=null==(n=this.rasterFunction)?void 0:n.toJSON())}let f,y=this.raster,g=!1;"Function"===y.datasetFormat?(f=y.primaryRasters.rasters,y=f[0],g=!0):f=[y];const{rasterFunction:x}=this;if(x){const n={raster:y};f.length>1&&f.forEach((h=>n[h.url]=h));const g=Et((null==(h=x.functionDefinition)?void 0:h.toJSON())??x.toJSON(),n),v=new qt({rasterFunction:g});v.rasterJobHandler=this._rasterJobHandler.instance,await v.open(),this._cachedRasterFunctionJson=null==(d=this.rasterFunction)?void 0:d.toJSON(),this.raster=v}else this.raster=y,this._cachedRasterFunctionJson=null,await y.when();if(this._cachedRendererJson=null,!g&&!x)return;const{bandIds:v}=this,{bandCount:w}=this.raster.rasterInfo,b=(null==v?void 0:v.length)?v.some((n=>n>=w)):w>=3;v&&(b||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:n,symbolizer:h}=this;if(!n||!h||!this.renderer)return;const{rasterInfo:d}=this.raster,f=Ee(d,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),y=null==f?void 0:f.name,g=Je({...this.renderer.toJSON(),variableName:y});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(g))return;const x=this._rasterJobHandler.instance;x&&(h.rasterInfo=Ae(d,y),h.rendererJSON=g,h.bind(),await x.updateSymbolizer(h),this._cachedRendererJson=g)}async applyRenderer(n,h){const d=null==n?void 0:n.pixelBlock;if(!(null!=d&&d.pixels&&d.pixels.length>0))return null;let f;await this.updateRenderer();const y=this._rasterJobHandler.instance,g=this.bandIds??[];return f=y?await y.symbolize({...n,simpleStretchParams:h,bandIds:g}):this.symbolizer.symbolize({...n,simpleStretchParams:h,bandIds:g}),f}getTileUrl(n,h,d){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${n}/${h}/${d}`:""}getCompatibleTileInfo(n,h,f=!1){if(!this.loaded||null==h)return null;if(f&&n.equals(this.spatialReference))return this.tileInfo;const y=$(n);return d.create({size:256,spatialReference:n,origin:y?{x:y.origin[0],y:y.origin[1]}:{x:h.xmin,y:h.ymax}})}getCompatibleFullExtent(n){var h;return this.loaded?((null==(h=this._compatibleFullExtent)?void 0:h.spatialReference.equals(n))||(this._compatibleFullExtent=this.raster.computeExtent(n)),this._compatibleFullExtent):null}async fetchTile(n,h,d,f={}){var y;if(G(this),f.requestAsImageElement){const y=this.getTileUrl(n,h,d);return b(y,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:f.signal}).then((n=>n.data))}const{serviceRasterInfo:g}=this;if(null!=g.multidimensionalInfo&&null==(f=this.normalizeRasterFetchOptions(f)).multidimensionalDefinition){const y=f.tileInfo||g.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(n,h,d,y),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===(null==(y=this.renderer)?void 0:y.type)&&(f={...f,buffer:{cols:1,rows:1}}),this.raster.fetchTile(n,h,d,f)}async fetchPixels(n,h,d,f={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(f=this.normalizeRasterFetchOptions(f)).multidimensionalDefinition?{extent:n,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),h=Math.round(h),d=Math.round(d),this.raster.fetchPixels(n,h,d,f))}async identify(n,h={}){var d;await this.load();const{raster:f,serviceRasterInfo:y}=this;if(null!=(null==y?void 0:y.multidimensionalInfo)&&!(y.hasMultidimensionalTranspose&&(Re(h.multidimensionalDefinition)||h.transposedVariableName||h.timeExtent)||null!=(h=this.normalizeRasterFetchOptions(h)).multidimensionalDefinition))return{location:n,value:null};const x=null==(d=this.multidimensionalSubset)?void 0:d.areaOfInterest;if(x&&!x.contains(n))throw new g("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return f.identify(n,h)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var n,h,d;const f=null==(n=this.serviceRasterInfo)?void 0:n.multidimensionalInfo;if(null==f||"standard-time"!==(null==(h=this.serviceRasterInfo)?void 0:h.dataType))return!1;const y=this.multidimensionalDefinition,g=null==(d=null==y?void 0:y[0])?void 0:d.variableName;return f.variables.some((n=>n.name===g&&(!(null==y?void 0:y[0].dimensionName)||n.dimensions.some((n=>"StdTime"===n.name)))))}getStandardTimeValue(n){return new Date(24*(n-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(n){var h;const d=n??(null==(h=this.serviceRasterInfo)?void 0:h.multidimensionalInfo);return Le(this.multidimensionalSubset,d)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=De(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const n=new Ge;return this._rasterJobHandler.connectionPromise=n.initialize().then((async()=>{G(this),this._rasterJobHandler.instance=n,this.raster.rasterJobHandler=n,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){var n;if(null==this.interpolation){G(this);const{raster:h}=this,d=ze(h.rasterInfo,h.tileType,null==(n=this.sourceJSON)?void 0:n.defaultResamplingMethod);this._set("interpolation",d)}}_configDefaultRenderer(n="no"){var h,d;G(this);const{rasterInfo:f}=this.raster;!this.bandIds&&f.bandCount>1&&(this.bandIds=He(f));const g=Ee(f,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),x=null==g?void 0:g.name,v=$e(this.raster);if(!this.renderer||"override"===n){const n=We(f,{bandIds:this.bandIds,variableName:x,rasterFunctionColorRamp:v}),h=f.statistics,d=h&&h.length>0?h[0]:null,y=(null==d?void 0:d.max)??0,g=(null==d?void 0:d.min)??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===n.type&&(y>1e24||g<-1e24)&&(n.dynamicRangeAdjustment=!0,n.statistics=null,"none"===n.stretchType&&(n.stretchType="min-max")),this.renderer=n}const w=Je({...this.renderer.toJSON(),variableName:x}),b=Ae(f,x);this.symbolizer?(this.symbolizer.rendererJSON=w,this.symbolizer.rasterInfo=b):this.symbolizer=new at({rendererJSON:w,rasterInfo:b});const R=this.symbolizer.bind();if(R.success){if("auto"===n){const{colormap:n}=this.raster.rasterInfo,f=this.renderer;if(null!=n&&"raster-colormap"===f.type){const n=We(this.raster.rasterInfo);JSON.stringify(n)!==JSON.stringify(f)&&this._configDefaultRenderer("override")}else if("raster-stretch"===f.type){const n=null==(h=this.bandIds)?void 0:h.length,y=null==(d=f.statistics)?void 0:d.length;!f.dynamicRangeAdjustment&&y&&n&&y!==n&&this._configDefaultRenderer("override")}}}else y.getLogger(this).warn("imagery-tile-mixin",R.error||"The given renderer is not supported by the layer."),"auto"===n&&this._configDefaultRenderer("override")}};function G(n){if(!n.raster||!n.serviceRasterInfo)throw new g("imagery-tile","no raster")}return M([O({clonable:!1})],h.prototype,"_cachedRendererJson",void 0),M([O({clonable:!1})],h.prototype,"_cachedRasterFunctionJson",void 0),M([O({clonable:!1})],h.prototype,"_compatibleFullExtent",void 0),M([O({clonable:!1})],h.prototype,"_isConstructedFromFunctionRaster",void 0),M([O({clonable:!1})],h.prototype,"_rasterJobHandler",void 0),M([O()],h.prototype,"bandIds",void 0),M([O({json:{origins:{service:{read:{source:"copyrightText"}}}}})],h.prototype,"copyright",void 0),M([O({json:{read:!1}})],h.prototype,"fullExtent",null),M([O()],h.prototype,"interpolation",void 0),M([O()],h.prototype,"ioConfig",void 0),M([O({type:[ke],json:{write:!0}})],h.prototype,"multidimensionalDefinition",null),M([O({type:Fe,json:{write:!0}})],h.prototype,"multidimensionalSubset",void 0),M([O()],h.prototype,"raster",void 0),M([O({type:Ce,json:{name:"renderingRule",write:!0}})],h.prototype,"rasterFunction",null),M([O({readOnly:!0})],h.prototype,"rasterInfo",null),M([O()],h.prototype,"serviceRasterInfo",void 0),M([O()],h.prototype,"sourceJSON",void 0),M([O({readOnly:!0,type:T,json:{read:!1}})],h.prototype,"spatialReference",void 0),M([O({type:d})],h.prototype,"tileInfo",void 0),M([O(B)],h.prototype,"url",null),M([O({types:Me,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const h="raster-stretch"===(null==(n=this.renderer)?void 0:n.type)&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!h}}},origins:{"web-scene":{types:Oe,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:n=>({enabled:n&&"vector-field"!==n.type&&"flow"!==n.type})}}}}})],h.prototype,"renderer",null),M([z("renderer")],h.prototype,"readRenderer",null),M([O({clonable:!1})],h.prototype,"symbolizer",void 0),h=M([D("esri.layers.mixins.ImageryTileMixin")],h),h};function i$1(n){return["x","e","east","long","longitude"].includes(n.toLowerCase())}function r$1(n){return["y","n","west","lat","latitude"].includes(n.toLowerCase())}function u$3(n){const h=j();return h?n[h]??Object.values(n)[0]:Object.values(n)[0]}function m$2(){return Math.round(255*Math.random())}function d$2(n){let h=Number.MAX_VALUE,d=-Number.MAX_VALUE;for(let f=0;f<n.length;f++){const y=n[f];null!=y&&(y<h&&(h=y),y>d&&(d=y))}return ot(h,d)}function f$1(n,h,d){const f=n.map(((n,d)=>({name:n,count:h[d]}))).sort(((n,h)=>n.name>h.name?-1:1)),y=(g=1,n=>g*=n.count);var g;const x=[...f.slice(1),{name:"",count:1}].reverse().map(y).reverse();let v=0;for(let w=n.length-1;w>=0;w--)v+=x[f.findIndex((({name:h})=>h===n[w]))]*(d%h[w]),d=Math.floor(d/h[w]);return v}function p$1(n){var h;const{width:d,height:f,extent:y,dimensions:g}=function o$1(n){const{axes:h}=n.domain,d=Object.keys(h),f=[],y=[];let g=-1,x=-1,v=[];for(let w=0;w<d.length;w++){const n=d[w];i$1(n)?g=w:r$1(n)&&(x=w);const b=h[n],R=[];if("values"in b){b.values.forEach((n=>R.push("string"==typeof n?new Date(n).getTime():n)));const n=R[1]-R[0];f.push([R[0]-.5*n,R[R.length-1]+.5*n]),y.push(n)}else{const{start:n,stop:h,num:d}=b,g=(h-n)/(d-1);f.push([n-.5*g,h+.5*g]),y.push(g);for(let f=0;f<d;f++)R.push(n+g*f)}v.push({name:n,values:R,extent:[R[0],R[R.length-1]]})}g>-1&&-1===x?x=0===g?1:0:x>-1&&-1===g?g=0===x?1:0:-1===x&&-1===g&&(g=0,x=1),v=v.filter(((n,h)=>!(h===g||h===x)));const{referencing:b}=n.domain,R=b.find((n=>n.coordinates.includes(d[g]))).system.id,C=null==R?void 0:R.slice(R.lastIndexOf("/")+1),M=null==C||"CRS84"===C?4326:Number(C),O=new T({wkid:M}),[B,D]=f[g],[N,E]=f[x],J=new w({xmin:B,xmax:D,ymin:N,ymax:E,spatialReference:O});return{width:Math.round(J.width/y[g]),height:Math.round(J.height/y[x]),extent:J,dimensions:v}}(n),{ranges:x}=n,v=Object.keys(x).sort(((n,h)=>n<h?-1:1)),b=[];for(let w=0;w<v.length;w++){const n=v[w];(null==g?void 0:g.length)&&b.push({name:n,dimensions:g})}const R=function c$1(n){var h,d;const f={},{parameters:y}=n;if(!y)return f;for(const[g,x]of Object.entries(y)){const{type:n,description:y,unit:v,categoryEncoding:w,observedProperty:b}=x;if("Parameter"===n&&(f[g]={},y&&(f[g].description=u$3(y)),v&&(f[g].unit=v.label?u$3(v.label):null,f[g].symbol=null==(h=v.symbol)?void 0:h.value),w)){const n=Object.entries(w).map(((n,h)=>({OID:h,Value:Number(n[1]),ClassName:n[0].slice(n[0].lastIndexOf("/")+1),Count:1})));let h=!1;(null==(d=null==b?void 0:b.categories)?void 0:d.length)&&(b.categories.forEach((d=>{if(!d.id)return;const f=d.id.slice(d.id.lastIndexOf("/")+1),y=n.find((n=>n.ClassName===f));if(!y)return;const g=d.label?u$3(d.label):null;if(y.Label=g,d.preferredColor){const n=W.fromHex(d.preferredColor);n&&(h=!0,y.Red=n.r,y.Green=n.g,y.Blue=n.b)}})),h&&n.forEach((n=>{null==n.Red&&(n.Red=m$2(),n.Green=m$2(),n.Blue=m$2())})));const y={objectIdFieldName:"",fields:[{name:"OID",type:"esriFieldTypeOID",alias:"OID",domain:null},{name:"Value",type:"esriFieldTypeInteger",alias:"Value",domain:null},{name:"Count",type:"esriFieldTypeDouble",alias:"Count",domain:null},{name:"ClassName",type:"esriFieldTypeString",alias:"ClassName",domain:null,length:50},{name:"Label",type:"esriFieldTypeString",alias:"Label",domain:null,length:50}],features:n.map((n=>({attributes:n})))};h&&y.fields.push({name:"Red",type:"esriFieldTypeInteger",alias:"Red",domain:null},{name:"Green",type:"esriFieldTypeInteger",alias:"Green",domain:null},{name:"Blue",type:"esriFieldTypeInteger",alias:"Blue",domain:null}),f[g].attributeTable=y}}return f}(n);b.forEach((n=>R[n.name]&&Object.assign(n,R[n.name])));const C=b.length?{variables:b}:void 0,M=[];for(let w=0;w<v.length;w++){const n=v[w],{values:h,dataType:y,axisNames:b,shape:R}=x[n],T=R.length>2?w*R.slice(0,-2).reduce(((n,h)=>n*h)):0,C=b.slice(0,-2),O=R.slice(0,-2),B="float"===y?"f32":d$2(h),D=d*f,N=h.length/D;for(let x=0;x<N;x++){const n=it.createEmptyBand(B,D),y=new Uint8Array(D).fill(255);let v=!1;const b=x*D;for(let d=0;d<D;d++){const f=h[b+d];null==f?(y[d]=0,v=!0):n[d]=f}if(0===w||(null==g?void 0:g.length)){const h=new it({width:d,height:f,mask:v?y:null,pixels:[n],pixelType:B});h.updateStatistics(),(null==g?void 0:g.length)?M[f$1(C,O,x)+T]=h:M.push(h)}else{const h=M[x];h.pixels.push(n),v?h.mask&&(h.mask=it.combineBandMasks([h.mask,y])):h.mask=v?y:null}}}return{extent:y,pixelBlocks:M,multidimensionalInfo:C,attributeTable:null==(h=Object.values(R).find((n=>n.attributeTable)))?void 0:h.attributeTable,bandNames:C?void 0:v}}let Ut=class extends Gt{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.source=null}get url(){return""}async open(n){await this.init();const h=this.source,{pixelBlocks:d,attributeTable:f,statistics:y,histograms:g,name:x,nativeExtent:v,transform:b}=h,R=d[0],{width:C,height:M,pixelType:O}=R,B=h.extent??new w({xmin:-.5,ymin:.5,xmax:C-.5,ymax:M-.5,spatialReference:new T({wkid:3857})}),D=h.isPseudoSpatialReference??!h.extent,N={x:B.width/C,y:B.height/M},E={...h.keyProperties};f&&(E.DataType="Thematic");const J=new lt({width:C,height:M,pixelType:O,extent:B,nativeExtent:v,attributeTable:f,transform:b,pixelSize:N,spatialReference:B.spatialReference,bandCount:R.pixels.length,keyProperties:E,multidimensionalInfo:h.multidimensionalInfo,statistics:y,isPseudoSpatialReference:D,histograms:g});this.ioConfig.skipMapInfo&&this.updateImageSpaceRasterInfo(J),this.createRemoteDatasetStorageInfo(J,512,512),this._set("rasterInfo",J),this.updateTileInfo(),J.multidimensionalInfo?await this._buildMDimStats(h.pixelBlocks,J.multidimensionalInfo):await this._buildInMemoryRaster(R,{width:512,height:512},n),J.multidimensionalInfo||(this.source=null),this.datasetName=x}fetchRawTile(n,h,d,f={}){if(!this._pixelBlockTiles){const{rasterInfo:y}=this,[g,x]=y.storageInfo.tileInfo.size,{sliceId:v}=f,{pixelBlocks:w}=this.source,b={pixelBlock:null==v?w[0]:w[v],useBilinear:"thematic"!==y.dataType,tileSize:{width:g,height:x},level:n,row:h,col:d},R=this.rasterJobHandler?this.rasterJobHandler.clipTile(b,f):ct(b);return Promise.resolve(R)}const y=this._pixelBlockTiles.get(`${n}/${h}/${d}`);return Promise.resolve(y)}async _buildInMemoryRaster(n,h,d){var f,y;const{rasterInfo:x}=this,v=x.storageInfo.maximumPyramidLevel??0,w="thematic"!==x.dataType,b=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:n,tileSize:h,maximumPyramidLevel:v,useBilinear:w},d):Promise.resolve(ut(n,h,v,w)),R=null!=x.statistics,T=null!=x.histograms,C=this.ioConfig.skipStatistics||R?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:n},d):Promise.resolve(ht(n)),M=await q([b,C]);if(!M[0].value&&M[1].value)throw new g("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=M[0].value,R||(x.statistics=null==(f=M[1].value)?void 0:f.statistics),T||(x.histograms=null==(y=M[1].value)?void 0:y.histograms)}async _buildMDimStats(n,h,d){for(let f=0;f<h.variables.length;f++){const y=h.variables[f];if(y.statistics)continue;const g=y.dimensions.map((n=>{var h,d;return new ke({variableName:y.name,dimensionName:n.name,values:[(null==(h=n.values)?void 0:h[0])??(null==(d=n.extent)?void 0:d[0])],isSlice:!0})})),x=Se(g,h),v=null==x?null:n[x];if(null==v)continue;const w=this.rasterJobHandler?await this.rasterJobHandler.computeStatisticsHistograms({pixelBlock:v},d):st(v);y.statistics=w.statistics,y.histograms||(y.histograms=w.histograms)}}};M([O({type:String,json:{write:!0}})],Ut.prototype,"datasetFormat",void 0),M([O()],Ut.prototype,"source",void 0),M([O()],Ut.prototype,"url",null),Ut=M([D("esri.layers.support.rasterDatasets.InMemoryRaster")],Ut);const Vt=Ut;let Yt=class m2 extends Gt{constructor(){super(...arguments),this.datasetFormat="CovJSON"}async open(n){await this.init();const{extent:h,pixelBlocks:d,multidimensionalInfo:f,attributeTable:y,bandNames:g}=await this._fetchData(n),{statistics:x,histograms:v}=st(d[0]),w={DataType:y?"Thematic":f?"Scientific":"Generic",BandProperties:null==g?void 0:g.map((n=>({BandName:n})))},b=new Vt({source:{extent:h,pixelBlocks:d,attributeTable:y?A.fromJSON(y):null,multidimensionalInfo:f,statistics:x,histograms:v,keyProperties:w,isPseudoSpatialReference:!1}});await b.open(),this._inMemoryRaster=b;const R=this.source?"":this.url.slice(this.url.lastIndexOf("/")+1);this._set("datasetName",R.slice(0,R.indexOf("."))),this._set("rasterInfo",b.rasterInfo)}fetchRawTile(n,h,d,f={}){return this._inMemoryRaster.fetchRawTile(n,h,d,f)}async _fetchData(n){var h,d,f,y;const x=this.source??(await this.request(this.url,{signal:null==n?void 0:n.signal})).data,v="imagery-tile-layer:open-coverage-json";if("coverage"!==(null==(h=x.type)?void 0:h.toLowerCase())||"grid"!==(null==(f=null==(d=x.domain)?void 0:d.domainType)?void 0:f.toLowerCase()))throw new g(v,"Only coverage with Grid domain type is supported");if(!x.ranges)throw new g(v,"Missing ranges in the grid coverage data");if(!(null==(y=x.domain.referencing)?void 0:y.length))throw new g(v,"Missing domain referencing in the grid coverage data");const w=Object.values(x.ranges);for(let b=0;b<w.length;b++){const{axisNames:n,shape:h,type:d,values:f}=w[b];if(!("ndarray"===d.toLowerCase()&&(null==f?void 0:f.length)&&(null==n?void 0:n.length)&&(null==h?void 0:h.length)))throw new g(v,"Only ranges with valid NdArray, axisNames, shape, and inline values are supported");if(!i$1(n[n.length-1])||!r$1(n[n.length-2]))throw new g(v,"Only row-major ordered pixel values are supported. X axis must be the last axis.")}return p$1(x)}};M([O({type:String,json:{write:!0}})],Yt.prototype,"datasetFormat",void 0),M([O({constructOnly:!0})],Yt.prototype,"source",void 0),Yt=M([D("esri.layers.support.rasterDatasets.CovJSONRaster")],Yt);const Xt=Yt;function n$1(n,h){if(!n||!h)return[];let d=h;h.includes("/")?(d=h.slice(0,h.indexOf("/")),h=h.slice(h.indexOf("/")+1)):h="";const f=[];if(h){const y=n$1(n,d);for(let n=0;n<y.length;n++)n$1(y[n],h).forEach((n=>f.push(n)));return f}const y=n.getElementsByTagNameNS("*",d);if(!y||0===y.length)return[];for(let g=0;g<y.length;g++)f.push(y[g]||y.item(g));return f}function e(n,h){if(!n||!h)return null;let d=h;h.includes("/")?(d=h.slice(0,h.indexOf("/")),h=h.slice(h.indexOf("/")+1)):h="";const f=n$1(n,d);return f.length>0?h?e(f[0],h):f[0]:null}function t$1(n,h=null){const d=h?e(n,h):n;let f;return d?(f=d.textContent||d.nodeValue,f?f.trim():null):null}function u$2(n,h){return function l(n,h){const d=n$1(n,h),f=[];let y;for(let g=0;g<d.length;g++)y=d[g].textContent||d[g].nodeValue,y&&(y=y.trim(),""!==y&&f.push(y));return f}(n,h).map((n=>Number(n)))}function o(n,h){const d=t$1(n,h);return Number(d)}function i(n,h){var d;const f=null==(d=null==n?void 0:n.nodeName)?void 0:d.toLowerCase(),y=h.toLowerCase();return f.slice(f.lastIndexOf(":")+1)===y}function u$1(n,h){if(!n||!h)return null;const d=[];for(let f=0;f<n.length;f++)d.push(n[f]),d.push(h[f]);return d}function d$1(n){if(!n)return null;let h=Number(n);if(!isNaN(h)&&0!==h)return new T({wkid:h});if(n=String(n).trim(),U(n))return new T({wkt2:n});const d=n.toUpperCase();if(d.startsWith("COMPD_CS")){if(!d.includes("VERTCS")||!d.includes("GEOGCS")&&!d.startsWith("PROJCS"))return null;const f=d.indexOf("VERTCS"),y=d.indexOf("PROJCS"),g=y>-1?y:d.indexOf("GEOGCS");if(-1===g)return null;const x=n.slice(g,n.lastIndexOf("]",f)+1).trim(),v=n.slice(f,n.lastIndexOf("]")).trim();h=p(x);const w=new T(h?{wkid:h}:{wkt:x}),b=p(v);return b&&(w.vcsWkid=b),w}return d.startsWith("GEOGCS")||d.startsWith("PROJCS")?(h=p(n),new T(0!==h?{wkid:h}:{wkt:n})):null}function p(n){var h;const d=n.replaceAll("]","[").replaceAll('"',"").split("[").map((n=>n.trim())).filter((n=>""!==n)),f=d[d.length-1].split(","),y=null==(h=f[0])?void 0:h.toLowerCase();if(("epsg"===y||"esri"===y)&&n.endsWith('"]]')){const n=Number(f[1]);if(!isNaN(n)&&0!==n)return n}return 0}function S$1(n){var h;if("pamdataset"!==(null==(h=null==n?void 0:n.documentElement.tagName)?void 0:h.toLowerCase()))return{};const d={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};n.documentElement.childNodes.forEach((n=>{if(1===n.nodeType)if(i(n,"SRS")){if(!d.spatialReference){const h=t$1(n);d.spatialReference=d$1(h)}}else if(i(n,"Metadata"))if("xml:ESRI"===n.getAttribute("domain")){const{spatialReference:h,transform:f}=function c(n){const h=e(n,"GeodataXform"),d=d$1(o(h,"SpatialReference/WKID")||t$1(h,"SpatialReference/WKT"));if("typens:PolynomialXform"!==h.getAttribute("xsi:type"))return{spatialReference:d,transform:null};const f=o(h,"PolynomialOrder")??1,y=u$2(h,"CoeffX/Double"),g=u$2(h,"CoeffY/Double"),x=u$2(h,"InverseCoeffX/Double"),v=u$2(h,"InverseCoeffY/Double"),w=u$1(y,g),b=u$1(x,v);return{spatialReference:d,transform:w&&b&&w.length&&b.length?new Jt({spatialReference:d,polynomialOrder:f,forwardCoefficients:w,inverseCoefficients:b}):null}}(n);d.transform=f,d.spatialReference||(d.spatialReference=h)}else n$1(n,"MDI").forEach((n=>d.metadata[n.getAttribute("key")]=t$1(n)));else if(i(n,"PAMRasterBand")){const h=function m3(n){var h;const d=o(n,"NoDataValue"),f=e(n,"Histograms/HistItem"),y=o(f,"HistMin"),g=o(f,"HistMax"),x=o(f,"BucketCount"),v=null==(h=t$1(f,"HistCounts"))?void 0:h.split("|").map((n=>Number(n)));let w,b,R,T;n$1(n,"Metadata/MDI").forEach((n=>{const h=Number(n.textContent??n.nodeValue);switch(n.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":w=h;break;case"STATISTICS_MAXIMUM":b=h;break;case"STATISTICS_MEAN":R=h;break;case"STATISTICS_STDDEV":T=h}}));const C=o(n,"Metadata/SourceBandIndex");return{noDataValue:d,histogram:(null==v?void 0:v.length)&&null!=y&&null!=g?{min:y,max:g,size:x||v.length,counts:v}:null,sourceBandIndex:C,statistics:null!=w&&null!=b?{min:w,max:b,avg:R,stddev:T}:null}}(n);null!=h.sourceBandIndex&&null==d.rasterBands[h.sourceBandIndex]?d.rasterBands[h.sourceBandIndex]=h:d.rasterBands.push(h)}}));const f=d.rasterBands;if(f.length){const n=!!f[0].statistics;d.statistics=n?f.map((n=>n.statistics)).filter(Y):null;const h=!!f[0].histogram;d.histograms=h?f.map((n=>n.histogram)).filter(Y):null}return d}let Kt=class extends Gt{async open(n){await this.init();const h=await this._fetchData(n);let{spatialReference:d,statistics:f,histograms:y,transform:g}=await this._fetchAuxiliaryData(n);const x=!d;x&&(d=new T({wkid:3857})),(null==y?void 0:y.length)&&null==f&&(f=dt(y));const{width:v,height:b}=h;let R=new w({xmin:-.5,ymin:.5-b,xmax:v-.5,ymax:.5,spatialReference:d});const C=g?g.forwardTransform(R):R;let M=!0;if(g){const n=g.forwardCoefficients;M=n&&0===n[1]&&0===n[2],M&&(g=null,R=C)}const O=new Vt({source:{extent:C,nativeExtent:R,transform:g,pixelBlocks:[h],statistics:f,histograms:y,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:x},ioConfig:{sampling:"closest",skipStatistics:!0}});this.ioConfig.skipMapInfo&&(O.ioConfig.skipMapInfo=!0),await O.open(),O.source=null,this._set("rasterInfo",O.rasterInfo),this._inMemoryRaster=O}fetchRawTile(n,h,d,f={}){return this._inMemoryRaster.fetchRawTile(n,h,d,f)}async _fetchData(n){const{data:h}=await this.request(this.url,{responseType:"array-buffer",signal:null==n?void 0:n.signal}),d=ft(h).toUpperCase();if("JPG"!==d&&"PNG"!==d&&"GIF"!==d&&"BMP"!==d)throw new g("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",d);const f=d.toLowerCase(),y="gif"===f||"bmp"===f||!K("ios"),x=await this.decodePixelBlock(h,{format:f,useCanvas:y,hasNoZlibMask:!0});if(null==x)throw new g("image-aux-raster:open","the data cannot be decoded");return x}async _fetchAuxiliaryData(n){var h;const d=null==n?void 0:n.signal,{skipExtensions:f=[],skipMapInfo:y}=this.ioConfig,g=y||f.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:d}),x=this.datasetFormat,v="JPG"===x?"jgw":"PNG"===x?"pgw":"BMP"===x?"bpw":null,w=v&&f.includes(v)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+v,{responseType:"text",signal:d}),b=await q([g,w]);if(null==d?void 0:d.aborted)throw Q();const R=S$1(null==(h=b[0].value)?void 0:h.data);if(!R.transform){const n=b[1].value?b[1].value.data.split("\n").slice(0,6).map((n=>Number(n))):null;R.transform=6===(null==n?void 0:n.length)?new Jt({forwardCoefficients:[n[4],n[5],n[0],-n[1],n[2],-n[3]]}):null}return R}};M([O({type:String,json:{write:!0}})],Kt.prototype,"datasetFormat",void 0),Kt=M([D("esri.layers.support.rasterDatasets.ImageAuxRaster")],Kt);const Qt=Kt;let Zt=class extends Gt{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(n){var h,f;await this.init();const y=null==n?void 0:n.signal,x=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:y});x.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const v=x.data;if(this.sourceJSON=v,!v)throw new g("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!v.tileInfo)throw new g("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();this.tileType=v.cacheType,null==this.tileType&&(["jpg","jpeg","png","png8","png24","png32","mixed"].includes(v.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===v.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=(null==(h=v.name)?void 0:h.slice(v.name.indexOf("/")+1))??"";const w=await this._fetchRasterInfo({signal:y});if(null==w)throw new g("image-server-raster:open","cannot initialize image service");je(w,v);const b="Map"===this.tileType?function v$1(n,h){if(!n)return null;const{minScale:f,maxScale:y,minLOD:g,maxLOD:x}=h;if(null!=g&&null!=x)return d.fromJSON({...n,lods:n.lods.filter((({level:n})=>null!=n&&n>=g&&n<=x))});if(0!==f&&0!==y){const t4=n=>Math.round(1e4*n)/1e4,h=f?t4(f):1/0,g=y?t4(y):-1/0;return d.fromJSON({...n,lods:n.lods.filter((n=>{const d=t4(n.scale);return d<=h&&d>=g}))})}return d.fromJSON(n)}(v.tileInfo,v):d.fromJSON(v.tileInfo);Z(b);const[R,T]=this._computeMinMaxLOD(w,b),{extent:C,pixelSize:M}=w,O=.5/w.width*M.x,B=Math.max(M.x,M.y),{lods:D}=b;("Map"!==this.tileType&&0!==v.maxScale||Math.abs(M.x-M.y)>O||!D.some((n=>Math.abs(n.resolution-B)<O)))&&(M.x=M.y=R.resolution,w.width=Math.ceil((C.xmax-C.xmin)/M.x-.1),w.height=Math.ceil((C.ymax-C.ymin)/M.y-.1));const N=R.level-T.level,[E,J]=b.size,A=[],L=[];D.forEach(((n,h)=>{n.level>=T.level&&n.level<=R.level&&A.push({x:n.resolution,y:n.resolution}),h<D.length-1&&L.push(Math.round(10*n.resolution/D[h+1].resolution)/10)})),A.sort(((n,h)=>n.x-h.x));const z=this.computeBlockBoundary(C,E,J,b.origin,A,N),H=A.length>1?A.slice(1):null;let $;v.transposeInfo&&($={tileSize:[v.transposeInfo.rows,v.transposeInfo.cols],packetSize:(null==(f=w.keyProperties)?void 0:f._yxs.PacketSize)??0});const W=L.length<=1||L.length>=3&&L.slice(0,-1).every((n=>n===L[0]))?L[0]??2:Math.round(10/(T.resolution/R.resolution)**(-1/N))/10;if(w.storageInfo=new Xe({blockWidth:b.size[0],blockHeight:b.size[1],pyramidBlockWidth:b.size[0],pyramidBlockHeight:b.size[1],pyramidResolutions:H,pyramidScalingFactor:W,compression:b.format,origin:b.origin,firstPyramidLevel:1,maximumPyramidLevel:N,tileInfo:b,transposeInfo:$,blockBoundary:z}),function S(n){const{extent:h,spatialReference:d}=n;h.xmin>-1&&h.xmax>181&&(null==d?void 0:d.wkid)&&d.isGeographic&&(n.nativeExtent=n.extent,n.transform=new At,n.extent=n.transform.forwardTransform(h))}(w),this._set("rasterInfo",w),v.capabilities.toLowerCase().includes("tilemap")){const n={tileInfo:w.storageInfo.tileInfo,parsedUrl:ee(this.url),url:this.url,tileServers:[]};this._tilemapCache=new te({layer:n})}}async fetchRawTile(n,h,d,f={}){const{storageInfo:y,extent:g}=this.rasterInfo,{transposeInfo:x}=y,v=null!=x&&!!f.transposedVariableName;if(this._slices&&!v&&null==f.sliceId)return null;const w=v?0:y.maximumPyramidLevel-n+this._levelOffset,b=`${this.url}/tile/${w}/${h}/${d}`,R=this._slices?v?{variable:f.transposedVariableName}:{sliceId:f.sliceId||0}:null,{data:T}=await this.request(b,{query:R,responseType:"array-buffer",signal:f.signal});if(!T)return null;const C=v?x.tileSize:y.tileInfo.size,M=await this.decodePixelBlock(T,{width:C[0],height:C[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:v,noDataValue:this.rasterInfo.noDataValue});if(null==M)return null;const O=y.blockBoundary[n];if("jpg"!==y.compression||d>O.minCol&&d<O.maxCol&&h>O.minRow&&h<O.maxRow)return M;const{origin:B,blockWidth:D,blockHeight:N}=y,{x:E,y:J}=this.getPyramidPixelSize(n),A=Math.round((g.xmin-B.x)/E)%D,L=Math.round((g.xmax-B.x)/E)%D||D,z=Math.round((B.y-g.ymax)/J)%N,H=Math.round((B.y-g.ymin)/J)%N||N,$=d===O.minCol?A:0,W=h===O.minRow?z:0,j=d===O.maxCol?L:D,q=h===O.maxRow?H:N;return mt(M,{x:$,y:W},{width:j-$,height:q-W}),M}getSliceIndex(n){if(!this._slices||null==n||0===n.length)return null;const h=n;for(let d=0;d<this._slices.length;d++){const n=this._slices[d].multidimensionalDefinition;if(n.length===h.length&&!n.some((n=>{const d=h.find((h=>n.variableName===h.variableName&&h.dimensionName===n.dimensionName));return!d||(Array.isArray(n.values[0])?`${n.values[0][0]}-${n.values[0][1]}`:n.values[0])!==(Array.isArray(d.values[0])?`${d.values[0][0]}-${d.values[0][1]}`:d.values[0])})))return d}return null}async fetchVariableStatisticsHistograms(n,h){var d,f,y;const g=this.request(this.url+"/statistics",{query:{variable:n,f:"json"},signal:h}).then((n=>{var h;return null==(h=n.data)?void 0:h.statistics})),x=this.request(this.url+"/histograms",{query:{variable:n,f:"json"},signal:h}).then((n=>{var h;return null==(h=n.data)?void 0:h.histograms})),v=await Promise.all([g,x]);return v[0]&&v[0].forEach((n=>{n.avg=n.mean,n.stddev=n.standardDeviation})),(null==(y=null==(f=null==(d=v[1])?void 0:d[0])?void 0:f.counts)?void 0:y.length)||(v[1]=null),{statistics:v[0]||null,histograms:v[1]||null}}async computeBestPyramidLevelForLocation(n,h={}){if(!this._tilemapCache)return 0;let d=this.identifyPixelLocation(n,0,h.datumTransformation);if(null===d)return null;let f=0;const{maximumPyramidLevel:y}=this.rasterInfo.storageInfo;let g=y-f+this._levelOffset;const x=d.srcLocation;for(;g>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(g,d.row,d.col,h))break}catch{}if(g--,f++,d=this.identifyPixelLocation(x,f,h.datumTransformation),null===d)return null}return-1===g||null==d?null:f}async _fetchRasterInfo(n){const h=this.sourceJSON;if("Map"===this.tileType){const n=h.fullExtent||h.extent,d=Math.ceil((n.xmax-n.xmin)/h.pixelSizeX-.1),f=Math.ceil((n.ymax-n.ymin)/h.pixelSizeY-.1),y=T.fromJSON(h.spatialReference||n.spatialReference),g=new v({x:h.pixelSizeX,y:h.pixelSizeY,spatialReference:y});return new lt({width:d,height:f,bandCount:3,extent:w.fromJSON(n),spatialReference:y,pixelSize:g,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:d}=n,f=qe(this.url,this.sourceJSON,{signal:d,query:this.ioConfig.customFetchParameters}),y=h.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:d}).then((n=>{var h;return null==(h=n.data)?void 0:h.slices})).catch((()=>null)):null,g=await Promise.all([f,y]);return this._slices=g[1],g[0]}_fixScaleInServiceInfo(){const{sourceJSON:n}=this;n.minScale&&n.minScale<0&&(n.minScale=0),n.maxScale&&n.maxScale<0&&(n.maxScale=0)}_computeMinMaxLOD(n,h){const{pixelSize:d}=n,f=.5/n.width*d.x,{lods:y}=h,g=h.lodAt(Math.max.apply(null,y.map((n=>n.level)))),x=h.lodAt(Math.min.apply(null,y.map((n=>n.level)))),{tileType:v}=this;if("Map"===v)return this._levelOffset=y[0].level,[g,x];if("Raster"===v)return[y.find((n=>n.resolution===d.x))??g,x];const{minScale:w,maxScale:b}=this.sourceJSON;let R=g;b>0&&(R=y.find((n=>Math.abs(n.scale-b)<f)),R||(R=y.filter((n=>n.scale>b)).sort(((n,h)=>n.scale>h.scale?1:-1))[0]??g));let T=x;return w>0&&(T=y.find((n=>Math.abs(n.scale-w)<f))??x,this._levelOffset=T.level-x.level),[R,T]}};M([O({type:String,json:{write:!0}})],Zt.prototype,"datasetFormat",void 0),M([O()],Zt.prototype,"tileType",void 0),Zt=M([D("esri.layers.support.rasterDatasets.ImageServerRaster")],Zt);const ei=Zt,ti=new Map;ti.set("Int8","s8"),ti.set("UInt8","u8"),ti.set("Int16","s16"),ti.set("UInt16","u16"),ti.set("Int32","s32"),ti.set("UInt32","u32"),ti.set("Float32","f32"),ti.set("Float64","f32"),ti.set("Double64","f32");const ii=new Map;ii.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),ii.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),ii.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),ii.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let ni=class extends Gt{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(n){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const h=n?n.signal:null,d=await this.request(this.url,{responseType:"xml",signal:h}),{rasterInfo:f,files:y}=this._parseHeader(d.data),{skipMapInfo:g,skipExtensions:x=[]}=this.ioConfig;if(!x.includes("aux.xml")&&!g){const h=await this._fetchAuxiliaryData(n);null!=h&&(f.statistics=h.statistics??f.statistics,f.histograms=h.histograms,h.histograms&&null==f.statistics&&(f.statistics=dt(h.histograms)))}g&&this.updateImageSpaceRasterInfo(f),this._set("rasterInfo",f),this._files=y;const v=await this.request(y.index,{responseType:"array-buffer",signal:h});this._storageIndex=function I(n){if(n.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let h,d,f,y,g,x;if(pt){for(d=new Uint8Array(n),y=new ArrayBuffer(n.byteLength),f=new Uint8Array(y),g=0;g<n.byteLength/4;g++)for(x=0;x<4;x++)f[4*g+x]=d[4*g+3-x];h=new Uint32Array(y)}else h=new Uint32Array(n);return h}(v.data);const{blockWidth:w,blockHeight:b}=this.rasterInfo.storageInfo,R=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:T,height:C}=this.rasterInfo,M=[],O=this._getBandSegmentCount();let B=0,D=-1;for(;B<this._storageIndex.length;){D++;const n=Math.ceil(T/w/R**D)-1,h=Math.ceil(C/b/R**D)-1;B+=(n+1)*(h+1)*O*4,M.push({maxRow:h,maxCol:n,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=M,D>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=D),this.updateTileInfo()}async fetchRawTile(n,h,d,f={}){const{blockWidth:y,blockHeight:g,blockBoundary:x}=this.rasterInfo.storageInfo,v=x[n];if(!v||v.maxRow<h||v.maxCol<d||v.minRow>h||v.minCol>d)return null;const{bandCount:w,pixelType:b}=this.rasterInfo,{ranges:R,actualTileWidth:T,actualTileHeight:C}=this._getTileLocation(n,h,d);if(!R||0===R.length)return null;if(0===R[0].from&&0===R[0].to){const n=new Uint8Array(y*g);return new it({width:y,height:g,pixels:void 0,mask:n,validPixelCount:0})}const{bandIds:M}=this.ioConfig,O=this._getBandSegmentCount(),B=[];let D=0;for(D=0;D<O;D++)M&&!M.includes(D)||B.push(this.request(this._files.data,{range:{from:R[D].from,to:R[D].to},responseType:"array-buffer",signal:f.signal}));const N=await Promise.all(B),E=N.map((n=>n.data.byteLength)).reduce(((n,h)=>n+h)),J=new Uint8Array(E),A=[];let L=0;for(D=0;D<O;D++)A.push(L),J.set(new Uint8Array(N[D].data),L),L+=N[D].data.byteLength;const z=ii.get(this.rasterInfo.storageInfo.compression).decoderFormat,H=await this.decodePixelBlock(J.buffer,{width:y,height:g,format:z,planes:(null==M?void 0:M.length)||w,offsets:A,pixelType:b});if(null==H)return null;let{noDataValue:$}=this.rasterInfo;if(null!=$&&"lerc"!==z&&!H.mask&&($=$[0],null!=$)){const n=H.width*H.height,h=new Uint8Array(n);if(Math.abs($)>1e24)for(D=0;D<n;D++)Math.abs((H.pixels[0][D]-$)/$)>1e-6&&(h[D]=1);else for(D=0;D<n;D++)H.pixels[0][D]!==$&&(h[D]=1);H.mask=h}let W=0,j=0;if(T!==y||C!==g){let n=H.mask;if(n)for(D=0;D<g;D++)if(j=D*y,D<C)for(W=T;W<y;W++)n[j+W]=0;else for(W=0;W<y;W++)n[j+W]=0;else for(n=new Uint8Array(y*g),H.mask=n,D=0;D<C;D++)for(j=D*y,W=0;W<T;W++)n[j+W]=1}return H}_getBandSegmentCount(){return ii.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(n,h,d){const{blockWidth:f,blockHeight:y,pyramidScalingFactor:g}=this.rasterInfo.storageInfo,{width:x,height:v}=this.rasterInfo,w=this._getBandSegmentCount();let b,R,T,C=0,M=0;for(T=0;T<n;T++)M=g**T,b=Math.ceil(x/f/M),R=Math.ceil(v/y/M),C+=b*R;M=g**n,b=Math.ceil(x/f/M),R=Math.ceil(v/y/M),C+=h*b+d,C*=4*w;const O=this._storageIndex.subarray(C,C+4*w);let B=0,D=0;const N=[];for(let E=0;E<w;E++)B=O[4*E]*2**32+O[4*E+1],D=B+O[4*E+2]*2**32+O[4*E+3],N.push({from:B,to:D});return{ranges:N,actualTileWidth:d<b-1?f:Math.ceil(x/M)-f*(b-1),actualTileHeight:h<R-1?y:Math.ceil(v/M)-y*(R-1)}}_parseHeader(n){const h=e(n,"MRF_META/Raster");if(!h)throw new g("mrf:open","not a valid MRF format");const d=e(h,"Size"),f=parseInt(d.getAttribute("x"),10),y=parseInt(d.getAttribute("y"),10),x=parseInt(d.getAttribute("c"),10),b=(t$1(h,"Compression")||"none").toLowerCase();if(!ii.has(b))throw new g("mrf:open","currently does not support compression "+b);const R=t$1(h,"DataType")||"UInt8",C=ti.get(R);if(null==C)throw new g("mrf:open","currently does not support pixel type "+R);const M=e(h,"PageSize"),O=parseInt(M.getAttribute("x"),10),B=parseInt(M.getAttribute("y"),10),D=e(h,"DataValues");let N,E;if(D&&(E=D.getAttribute("NoData"),null!=E&&(N=E.trim().split(" ").map((n=>parseFloat(n))))),e(n,"MRF_META/CachedSource"))throw new g("mrf:open","currently does not support MRF referencing other data files");const J=e(n,"MRF_META/GeoTags"),A=e(J,"BoundingBox");let L,z=!1;if(null!=A){const n=parseFloat(A.getAttribute("minx")),h=parseFloat(A.getAttribute("miny")),d=parseFloat(A.getAttribute("maxx")),f=parseFloat(A.getAttribute("maxy")),y=t$1(J,"Projection")||"";let g=T.WGS84;if("LOCAL_CS[]"!==y)if(y.toLowerCase().startsWith("epsg:")){const n=Number(y.slice(5));isNaN(n)||0===n||(g=new T({wkid:n}))}else g=d$1(y)??T.WGS84;else z=!0,g=new T({wkid:3857});L=new w(n,h,d,f),L.spatialReference=g}else z=!0,L=new w({xmin:-.5,ymin:.5-y,xmax:f-.5,ymax:.5,spatialReference:new T({wkid:3857})});const H=e(n,"MRF_META/Rsets"),$=parseInt((null==H?void 0:H.getAttribute("scale"))||"2",10),W=L.spatialReference,j=new Xe({origin:new v({x:L.xmin,y:L.ymax,spatialReference:W}),blockWidth:O,blockHeight:B,pyramidBlockWidth:O,pyramidBlockHeight:B,compression:b,pyramidScalingFactor:$}),q=new v({x:L.width/f,y:L.height/y,spatialReference:W}),U=new lt({width:f,height:y,extent:L,isPseudoSpatialReference:z,spatialReference:W,bandCount:x,pixelType:C,pixelSize:q,noDataValue:N,storageInfo:j}),Y=t$1(n,"datafile"),K=t$1(n,"IndexFile");return{rasterInfo:U,files:{mrf:this.url,index:K||this.url.replace(".mrf",".idx"),data:Y||this.url.replace(".mrf",ii.get(b).blobExtension)}}}async _fetchAuxiliaryData(n){try{const{data:h}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==n?void 0:n.signal});return S$1(h)}catch{return null}}};M([O()],ni.prototype,"_files",void 0),M([O()],ni.prototype,"_storageIndex",void 0),M([O({type:String,json:{write:!0}})],ni.prototype,"datasetFormat",void 0),ni=M([D("esri.layers.support.rasterDatasets.MRFRaster")],ni);const si=ni;function t2(n){const h=n.fields,d=n.records,f=h.some((n=>"oid"===n.name.toLowerCase()))?"OBJECTID":"OID",y=[{name:f,type:"esriFieldTypeOID",alias:"OID"}].concat(h.map((n=>({name:n.name,type:"esriFieldType"+n.typeName,alias:n.name})))),g=y.map((n=>n.name)),x=[];let v=0,w=0;return d.forEach((n=>{const h={};for(h[f]=v++,w=1;w<g.length;w++)h[g[w]]=n[w-1];x.push({attributes:h})})),{displayFieldName:"",fields:y,features:x}}class r{static get supportedVersions(){return[5]}static parse(n){const h=new DataView(n),d=3&h.getUint8(0);if(3!==d)return{header:{version:d},recordSet:null};const f=h.getUint32(4,!0),y=h.getUint16(8,!0),g=h.getUint16(10,!0),x={version:d,recordCount:f,headerByteCount:y,recordByteCount:g};let v=32;const w=[],b=[];let R;if(3===d){for(;13!==h.getUint8(v);)R=String.fromCharCode(h.getUint8(v+11)).trim(),w.push({name:yt(new Uint8Array(n,v,11)),type:R,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(R)],length:h.getUint8(v+16)}),v+=32;if(v+=1,w.length>0)for(;b.length<f&&n.byteLength-v>g;){const d=[];32===h.getUint8(v)?(v+=1,w.forEach((h=>{if("C"===h.type)d.push(yt(new Uint8Array(n,v,h.length)).trim());else if("N"===h.type)d.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(n,v,h.length)).trim(),10));else if("F"===h.type)d.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(n,v,h.length)).trim()));else if("D"===h.type){const f=String.fromCharCode.apply(null,new Uint8Array(n,v,h.length)).trim();d.push(new Date(parseInt(f.substring(0,4),10),parseInt(f.substring(4,6),10)-1,parseInt(f.substring(6,8),10)))}v+=h.length})),b.push(d)):v+=g}}return{header:x,fields:w,records:b,recordSet:t2({fields:w,records:b})}}}const _=(n,h)=>{var d;return null==(d=n.get(h))?void 0:d.values},F=(n,h)=>{var d,f;return null==(f=null==(d=n.get(h))?void 0:d.values)?void 0:f[0]};let ri=class extends Gt{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(n){var h,d,f,x;await this.init();const b=n?n.signal:null,{data:R}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:b});if(!R)throw new g("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:C,firstIFDPos:M,isBigTiff:O}=gt(R),B=[];await this._readIFDs(B,R,C,M,0,O?8:4,b);const{imageInfo:D,rasterInfo:N}=function k(n){var h,d;const f=St(n),{width:y,height:g,tileWidth:x,tileHeight:b,planes:R,pixelType:C,compression:M,firstPyramidLevel:O,maximumPyramidLevel:B,pyramidBlockWidth:D,pyramidBlockHeight:N,pyramidResolutions:E,tileBoundary:J,affine:A,metadata:L}=f,z=(null==(h=f.extent.spatialReference)?void 0:h.wkt)||(null==(d=f.extent.spatialReference)?void 0:d.wkid);let H=d$1(z),$=!!f.isPseudoGeographic;null==H&&($=!0,H=new T({wkid:3857}));const W=new w({...f.extent,spatialReference:H}),j=new v(W?{x:W.xmin,y:W.ymax,spatialReference:H}:{x:0,y:0}),q=new Xe({blockWidth:x,blockHeight:b,pyramidBlockWidth:D,pyramidBlockHeight:N,compression:M,origin:j,firstPyramidLevel:O,maximumPyramidLevel:B,pyramidResolutions:E,blockBoundary:J}),U=new v({x:(W.xmax-W.xmin)/y,y:(W.ymax-W.ymin)/g,spatialReference:H}),Y=L?{BandProperties:L.bandProperties,DataType:L.dataType}:{};let K=null;const Q=F(n[0],"PHOTOMETRICINTERPRETATION"),Z=_(n[0],"COLORMAP");if(Q<=3&&(null==Z?void 0:Z.length)>3&&Z.length%3==0){K=[];const n=Z.length/3;for(let h=0;h<n;h++)K.push([h,Z[h]>>>8,Z[h+n]>>>8,Z[h+2*n]>>>8])}const ee=new lt({width:y,height:g,bandCount:R,pixelType:C,pixelSize:U,storageInfo:q,spatialReference:H,isPseudoSpatialReference:$,keyProperties:Y,extent:W,colormap:K,statistics:L?L.statistics:null});if((null==A?void 0:A.length)&&(ee.nativeExtent=new w({xmin:-.5,ymin:.5-g,xmax:y-.5,ymax:.5,spatialReference:H}),ee.transform=new Jt({polynomialOrder:1,forwardCoefficients:[A[2]+A[0]/2,A[5]-A[3]/2,A[0],A[3],-A[1],-A[4]]}),ee.extent=ee.transform.forwardTransform(ee.nativeExtent),ee.pixelSize=new v({x:(W.xmax-W.xmin)/y,y:(W.ymax-W.ymin)/g,spatialReference:H}),q.origin.x=-.5,q.origin.y=.5),E){const{x:n,y:h}=ee.pixelSize;E.forEach((d=>{d.x*=n,d.y*=h}))}return{imageInfo:f,rasterInfo:ee}}(B),E=xt(B),J=vt(B);if(this._headerInfo={littleEndian:C,isBigTiff:O,ifds:B,pyramidIFDs:E,maskIFDs:J,...D},this._set("rasterInfo",N),!D.isSupported)throw new g("tiffraster:open","this tiff is not supported: "+D.message);if(!D.tileWidth)throw new g("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");N.isPseudoSpatialReference&&y.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const A=null==(d=null==(h=B[0].get("PREDICTOR"))?void 0:h.values)?void 0:d[0];if(3===(null==(x=null==(f=B[0].get("SAMPLEFORMAT"))?void 0:f.values)?void 0:x[0])&&2===A)throw new g("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:L,skipExtensions:z=[]}=this.ioConfig;if(!z.includes("aux.xml")&&!L){const h=await this._fetchAuxiliaryMetaData(n);null!=h&&function P(n,h){if(h.statistics=n.statistics??h.statistics,h.histograms=n.histograms,n.histograms&&null==h.statistics&&(h.statistics=dt(n.histograms)),n.transform&&null==h.transform){h.transform=n.transform,h.nativeExtent=h.extent;const d=h.transform.forwardTransform(h.nativeExtent);h.pixelSize=new v({x:(d.xmax-d.xmin)/h.width,y:(d.ymax-d.ymin)/h.height,spatialReference:h.spatialReference}),h.extent=d}h.isPseudoSpatialReference&&n.spatialReference&&(h.spatialReference=n.spatialReference,h.extent.spatialReference=h.nativeExtent.spatialReference=h.storageInfo.origin.spatialReference=h.spatialReference)}(h,N)}z.includes("vat.dbf")||1!==N.bandCount||"u8"!==N.pixelType||L||(N.attributeTable=await this._fetchAuxiliaryTable(n),null!=N.attributeTable&&(N.keyProperties.DataType="thematic")),L&&this.updateImageSpaceRasterInfo(N),this.updateTileInfo()}async fetchRawTile(n,h,d,f={}){var y;if(!(null==(y=this._headerInfo)?void 0:y.isSupported)||this.isBlockOutside(n,h,d))return null;const g=await this._fetchRawTiffTile(n,h,d,!1,f);if(null!=g&&this._headerInfo.hasMaskBand){const y=await this._fetchRawTiffTile(n,h,d,!0,f);null!=y&&y.pixels[0]instanceof Uint8Array&&(g.mask=y.pixels[0])}return g}async _readIFDs(n,h,d,f,y,g=4,x){if(!f)return null;(f>=h.byteLength||f<0)&&(h=(await this.request(this.url,{range:{from:f+y,to:f+y+this._bufferSize},responseType:"array-buffer",signal:x})).data,y=f+y,f=0);const v=await this._readIFD(h,d,f,y,wt.tiffTags,g,x);if(n.push(v.ifd),!v.nextIFD)return null;await this._readIFDs(n,h,d,v.nextIFD-y,y,g,x)}async _readIFD(n,h,d,f,y=wt.tiffTags,g=4,x){var v,w;if(!n)return null;const b=It(n,h,d,f,y,g);if(b.success){const d=[];if(null==(v=b.ifd)||v.forEach((n=>{n.values||d.push(n)})),d.length>0){const y=d.map((n=>n.offlineOffsetSize)).filter(Y),g=Math.min.apply(null,y.map((n=>n[0])));if(Math.min.apply(null,y.map((n=>n[0]+n[1])))-g<=this._bufferSize){const{data:y}=await this.request(this.url,{range:{from:g,to:g+this._bufferSize},responseType:"array-buffer",signal:x});n=y,f=g,d.forEach((d=>bt(n,h,d,f)))}}if(null==(w=b.ifd)?void 0:w.has("GEOKEYDIRECTORY")){const d=b.ifd.get("GEOKEYDIRECTORY"),y=null==d?void 0:d.values;if(y&&y.length>4){const g=y[0]+"."+y[1]+"."+y[2],v=await this._readIFD(n,h,d.valueOffset+6-f,f,wt.geoKeys,2,x);d.data=v.ifd,d.data&&d.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[g]})}}return b}if(b.requiredBufferSize&&b.requiredBufferSize!==n.byteLength){const d=await this.request(this.url,{range:{from:f,to:f+b.requiredBufferSize+4},responseType:"array-buffer",signal:x});return(n=d.data).byteLength<b.requiredBufferSize?null:this._readIFD(n,h,0,f,wt.tiffTags,4,x)}}async _fetchRawTiffTile(n,h,d,f,y={}){const g=this._getTileLocation(n,h,d,f);if(!g)return null;const{ranges:x,actualTileWidth:v,actualTileHeight:w,ifd:b}=g,R=x.map((n=>this.request(this.url,{range:n,responseType:"array-buffer",signal:y.signal}))),T=await Promise.all(R),C=T.map((n=>n.data.byteLength)).reduce(((n,h)=>n+h)),M=1===T.length?T[0].data:new ArrayBuffer(C),O=[0],B=[0];if(T.length>1){const n=new Uint8Array(M);for(let h=0,d=0;h<T.length;h++){const f=T[h].data;n.set(new Uint8Array(f),d),O[h]=d,d+=f.byteLength,B[h]=f.byteLength}}const{blockWidth:D,blockHeight:N}=this.getBlockWidthHeight(n),E=await this.decodePixelBlock(M,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:b,offsets:O,sizes:B},width:D,height:N,planes:null,pixelType:null});if(null==E)return null;let J,A,L;if(v!==D||w!==N){let n=E.mask;if(n)for(J=0;J<N;J++)if(L=J*D,J<w)for(A=v;A<D;A++)n[L+A]=0;else for(A=0;A<D;A++)n[L+A]=0;else for(n=new Uint8Array(D*N),E.mask=n,J=0;J<w;J++)for(L=J*D,A=0;A<v;A++)n[L+A]=1}return E}_getTileLocation(n,h,d,f=!1){const{firstPyramidLevel:y,blockBoundary:g}=this.rasterInfo.storageInfo,x=0===n?0:n-(y-1),{_headerInfo:v}=this;if(!v)return null;const w=f?v.maskIFDs[x]:0===x?null==v?void 0:v.ifds[0]:null==v?void 0:v.pyramidIFDs[x-1];if(!w)return null;const b=Rt(w,v),R=_(w,"TILEOFFSETS");if(void 0===R)return null;const T=_(w,"TILEBYTECOUNTS"),{minRow:C,minCol:M,maxRow:O,maxCol:B}=g[x];if(h>O||d>B||h<C||d<M)return null;const D=F(w,"IMAGEWIDTH"),N=F(w,"IMAGELENGTH"),E=F(w,"TILEWIDTH"),J=F(w,"TILELENGTH"),A=[];if(b){const{bandCount:n}=this.rasterInfo;for(let f=0;f<n;f++){const n=f*(O+1)*(B+1)+h*(B+1)+d;A[f]={from:R[n],to:R[n]+T[n]-1}}}else{const n=h*(B+1)+d;A.push({from:R[n],to:R[n]+T[n]-1})}for(let L=0;L<A.length;L++)if(null==A[L].from||!A[L].to||A[L].to<0)return null;return{ranges:A,ifd:w,actualTileWidth:d===B&&D%E||E,actualTileHeight:h===O&&N%J||J}}async _fetchAuxiliaryMetaData(n){try{const{data:h}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==n?void 0:n.signal});return S$1(h)}catch{return null}}async _fetchAuxiliaryTable(n){try{const{data:h}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:null==n?void 0:n.signal}),d=r.parse(h);return(null==d?void 0:d.recordSet)?A.fromJSON(d.recordSet):null}catch{return null}}};M([O()],ri.prototype,"_files",void 0),M([O()],ri.prototype,"_headerInfo",void 0),M([O()],ri.prototype,"_bufferSize",void 0),M([O({type:String,json:{write:!0}})],ri.prototype,"datasetFormat",void 0),ri=M([D("esri.layers.support.rasterDatasets.TIFFRaster")],ri);const ai=ri,oi=new Map;oi.set("MRF",{desc:"Meta Raster Format",constructor:si}),oi.set("TIFF",{desc:"GeoTIFF",constructor:ai}),oi.set("RasterTileServer",{desc:"Raster Tile Server",constructor:ei}),oi.set("JPG",{desc:"JPG Raster Format",constructor:Qt}),oi.set("PNG",{desc:"PNG Raster Format",constructor:Qt}),oi.set("GIF",{desc:"GIF Raster Format",constructor:Qt}),oi.set("BMP",{desc:"BMP Raster Format",constructor:Qt}),oi.set("CovJSON",{desc:"COVJSON Raster Format",constructor:Xt}),oi.set("MEMORY",{desc:"In Memory Raster Format",constructor:Vt});class u{static get supportedFormats(){const n=new Set;return oi.forEach(((h,d)=>n.add(d))),n}static async open(n){var h;const{url:d,ioConfig:f,source:y,sourceJSON:x}=n;let v=n.datasetFormat??(null==f?void 0:f.datasetFormat);null==v&&(d.includes(".")?v=d.slice(d.lastIndexOf(".")+1).toUpperCase():"coverage"===(null==(h=null==y?void 0:y.type)?void 0:h.toLowerCase())?v="CovJSON":(null==y?void 0:y.extent)&&y.pixelblocks&&(v="MEMORY")),"OVR"===v||"TIF"===v?v="TIFF":"JPG"===v||"JPEG"===v||"JFIF"===v?v="JPG":"COVJSON"===v&&(v="CovJSON"),d.toLowerCase().includes("/imageserver")&&!d.toLowerCase().includes("/wcsserver")&&(v="RasterTileServer");const w={url:d,source:y,sourceJSON:x,datasetFormat:v,ioConfig:f??{bandIds:null,sampling:null}};if(Object.keys(w).forEach((n=>{null==w[n]&&delete w[n]})),v){if(!this.supportedFormats.has(v))throw new g("rasterfactory:open","not a supported format "+v);if("CRF"===v)throw new g("rasterfactory:open",`cannot open raster: ${d}`);const h=new(oi.get(v).constructor)(w);return await h.open({signal:n.signal}),h}const b=Array.from(oi.keys()).filter((n=>"CovJSON"!==n&&"Memory"!==n));let R=0;const m4=()=>{if(v=b[R++],!v)return null;if("CRF"===v)return null;const h=new(oi.get(v).constructor)(w);return h.open({signal:n.signal}).then((()=>h)).catch((()=>m4()))};return m4()}static register(n,h,d){oi.has(n.toUpperCase())||oi.set(n.toUpperCase(),{desc:h,constructor:d})}}let li=class extends(ie(ne(se(re(ae(V(oe(le(ce(ue(he(be)))))))))))){constructor(...n){super(...n),this._primaryRasters=[],this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this.source=void 0,this._debouncedSaveOperations=de((async(n,h,d)=>{const{save:f,saveAs:y}=await E((()=>import("./imageryUtils-BKfCadHR.js")),__vite__mapDeps([5,6,2,3]));switch(n){case ye.SAVE:return f(this,h);case ye.SAVE_AS:return y(this,d,h)}}))}normalizeCtorArgs(n,h){return"string"==typeof n?{url:n,...h}:n}load(n){const h=null!=n?n.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},n).catch(fe).then((()=>this._openRaster(h)))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){var n,h;const d=[new me({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"}),new me({name:"Raster.ServicePixelValue.Raw",alias:"Raw Pixel Value",domain:null,editable:!1,length:50,type:"string"})],f=(null==(n=this.raster)?void 0:n.rasterInfo)??this.serviceRasterInfo,y=null==f?void 0:f.attributeTable,g=null!=y?y.fields:null;if(g){const n=g.filter((n=>"oid"!==n.type&&"value"!==n.name.toLowerCase())).map((n=>{const h=n.clone();return h.name="Raster."+n.name,h}));d.push(...n)}const x=null==f?void 0:f.dataType,v=null==f?void 0:f.multidimensionalInfo;if(("vector-magdir"===x||"vector-uv"===x)&&null!=v){const n=null==(h=v.variables[0].unit)?void 0:h.trim(),f="Magnitude"+(n?` (${n})`:"");d.push(new me({name:"Raster.Magnitude",alias:f,domain:null,editable:!1,type:"double"})),d.push(new me({name:"Raster.Direction",alias:"Direction (°)",domain:null,editable:!1,type:"double"}))}return d}createPopupTemplate(n){const{rasterFields:h}=this,d=new Set(h.map((({name:n})=>n)).filter((n=>"raster.servicepixelvalue.raw"!==n.toLowerCase())));return pe({fields:h,title:this.title},{...n,visibleFieldNames:d})}async generateRasterInfo(n,h){var d;if(n=x(Ce,n),await this.load(),!n||"none"===(null==(d=n.functionName)?void 0:d.toLowerCase()))return this.serviceRasterInfo;try{const{rasterInfo:d}=await this._openFunctionRaster(n,h);return d}catch(f){if(f instanceof g)throw f;throw new g("imagery-tile-layer","the given raster function is not supported")}}async save(n){return this._debouncedSaveOperations(ye.SAVE,n)}async saveAs(n,h){return this._debouncedSaveOperations(ye.SAVE_AS,h,n)}write(n,h){const d=this._primaryRasters[0]??this.raster;if(this.loaded?"RasterTileServer"===d.datasetFormat&&("Raster"===d.tileType||"Map"===d.tileType):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(n,h);if(null==h?void 0:h.messages){const n=`${h.origin}/${h.layerContainerType||"operational-layers"}`;h.messages.push(new g("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${n}'`,{layer:this}))}return null}async _openRaster(n){var h;let d=!1;if(this.raster)await this._openFromRaster(this.raster,n),d="Function"===this.raster.datasetFormat;else{const{url:h,rasterFunction:d,source:f}=this;if(!h&&!f)throw new g("imagery-tile-layer:open","missing url or source parameter");f?await this._openFromSource(f,n):d?await this._openFromUrlWithRasterFunction(h,d,n):await this._openFromUrl(h,n)}const f=this.raster.rasterInfo;if(!f)throw new g("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("serviceRasterInfo",d?f:this._primaryRasters[0].rasterInfo),this._set("spatialReference",f.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,null!=this.sourceJSON){const n="Map"===this.raster.tileType&&null!=this.sourceJSON.minLOD&&null!=this.sourceJSON.maxLOD?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(n,{origin:"service"})}else this.read({tileInfo:null==(h=this.serviceRasterInfo)?void 0:h.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),"Map"===this.raster.tileType&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles(ge((()=>this.customParameters),(n=>{this.raster&&(this.raster.ioConfig.customFetchParameters=n)})))}async _openFromRaster(n,h){n.rasterInfo||await n.open({signal:h}),this._primaryRasters="Function"===n.datasetFormat?n.primaryRasters.rasters:[n],this.url||(this.url=this._primaryRasters[0].url)}async _openFromUrlWithRasterFunction(n,h,d){const f=[n];h&&Lt(h.toJSON(),f);const y=await Promise.all(f.map((n=>u.open({url:n,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:d})))),x=y.findIndex((n=>null==n));if(x>-1)throw new g("imagery-tile-layer:open",`cannot open raster: ${f[x]}`);return this._primaryRasters=y,this._initializeWithFunctionRaster(h)}async _openFromUrl(n,h){const d=await u.open({url:n,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:h});if(null==d)throw new g("imagery-tile-layer:open",`cannot open raster: ${n}`);this._primaryRasters=[d],this.raster=d}async _openFromSource(n,h){var d;const f="the tiled imagery data source is not supported",y="coverage"===(null==(d=n.type)?void 0:d.toLowerCase())?"CovJSON":n.extent&&n.pixelBlock?"MEMORY":null;if(!y)throw new g("imagery-tile-layer:open",f);"MEMORY"===y&&(n={extent:n.extent,pixelBlocks:[n.pixelBlock]});const x=await u.open({url:"",source:n,datasetFormat:y,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:h});if(null==x)throw new g("imagery-tile-layer:open",f);this._primaryRasters=[x],this.rasterFunction?await this._initializeWithFunctionRaster(this.rasterFunction):this.raster=x}async _openFunctionRaster(n,h){var d;const f={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach((n=>f[n.url]=n));const y=Et((null==(d=n.functionDefinition)?void 0:d.toJSON())??n.toJSON(),f),g=new qt({rasterFunction:y});return await g.open(h),g}async _initializeWithFunctionRaster(n,h){try{this.raster=await this._openFunctionRaster(n,h)}catch(d){d instanceof g&&y.getLogger(this).error("imagery-tile-layer:open",d.message),y.getLogger(this).warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=this._primaryRasters[0]}}};M([O({clonable:!1})],li.prototype,"_primaryRasters",void 0),M([O({type:[xe],json:{write:{overridePolicy(){var n;return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==(null==(n=this.bandIds)?void 0:n.join(","))}}}}})],li.prototype,"bandIds",void 0),M([O({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),ve(Ue)],li.prototype,"interpolation",void 0),M([O(we)],li.prototype,"legendEnabled",void 0),M([O({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],li.prototype,"isReference",void 0),M([O({type:["show","hide"]})],li.prototype,"listMode",void 0),M([O({json:{read:!0,write:!0}})],li.prototype,"blendMode",void 0),M([O()],li.prototype,"sourceJSON",void 0),M([O({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],li.prototype,"version",void 0),M([O({readOnly:!0,json:{read:!1}})],li.prototype,"type",void 0),M([O({type:["ArcGISTiledImageServiceLayer"]})],li.prototype,"operationalLayerType",void 0),M([O({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(n,h)=>!h.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}},writer(n,h,d){h[d]=!n}}}})],li.prototype,"popupEnabled",void 0),M([O({type:Ie,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}}}}})],li.prototype,"popupTemplate",void 0),M([O({readOnly:!0})],li.prototype,"defaultPopupTemplate",null),M([O({readOnly:!0,type:[me]})],li.prototype,"fields",void 0),M([O({readOnly:!0,type:[me]})],li.prototype,"rasterFields",null),M([O({constructOnly:!0})],li.prototype,"source",void 0),li=M([D("esri.layers.ImageryTileLayer")],li);const ci=li;export{ci as default};
