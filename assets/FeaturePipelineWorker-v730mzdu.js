const __vite__fileDeps=["assets/geometryEngineJSON-CrXS8d22.js","assets/geometryEngineBase-9EI9fooq.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/json-omtrO2vq.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{tb as $,t9 as k,vg as E,vh as D,vi as L,vj as V,mG as U,vk as X,vl as Q,mH as J,hD as et,vm as st,vn as ut,vo as ht,sZ as _t,vp as vt,b as Et,m0 as Pt,m1 as Ot,m5 as zt,n as Dt,kw as Nt,rJ as Lt,rE as Vt,fr as qt,vq as Ut,vr as Yt,vs as Qt,vt as te,vu as re,_ as ie,pk as ne,m as oe,ak as ae,vv as ce,im as le,vw as ue,io as he,vx as de,vy as pe,c5 as fe,vz as _e,il as me,vA as ye,pU as ge,e as xe,vB as be,aB as ve,y as we,a as Ie,S as Se,vC as $e,vD as Te,vE as Me,vF as ke,vG as Fe,aM as Ee,vH as Ce,vI as Pe,vJ as Ae,vK as Oe,pu as ze,fj as Re,tt as De,kg as Be,cX as Ne,d1 as Le,vL as je,c_ as Ge,vM as Ve,vN as qe,cD as Ue,bn as We,su as Ye,bc as Xe,cC as He,cF as Ze,vO as Ke,vP as Qe,vQ as Je,nH as ts,vR as es,cG as ss,a2 as rs,cR as is,fe as ns,I as os,hX as as,ic as cs,gM as ls,ub as us,vS as hs,vT as ds,fq as ps,fl as fs,nr as _s,k9 as ms,vU as ys,fm as gs,vV as xs,vW as bs,pt as vs,d9 as ws,vX as Is,j as Ss,az as $s,pG as Ts,ge as Ms,hd as ks,vY as Fs,vZ as Es,U as Cs,v_ as Ps,v$ as As,mO as Os,u as zs,b3 as Rs,cJ as Ds,gG as Bs,gs as Ns,g as Ls,pz as js,w0 as Gs,w1 as Vs,cU as qs,hm as Us,c as Ws,tm as Ys,h as Xs,kN as Hs,h6 as Zs,w2 as Ks,w3 as Qs,bZ as Js,rx as tr,w4 as er,gE as sr,s_ as rr,tO as ir,eX as nr}from"./index-DSIPxOWi.js";import{a as or,i as ar,c as cr}from"./TurboLine-C4MsOSzA.js";import{t as lr}from"./constants-D5zmR9t2.js";import{t as ur}from"./Rect-3ZUgN72u.js";import{$ as hr,a as dr,v as pr,t as fr,x as _r,j as mr}from"./QueryEngine-DAD9skS_.js";import{o as yr,n as gr}from"./optimizedFeatureQueryEngineAdapter--U1rvwBV.js";import{m as xr,n as br,a as vr}from"./TimeOnly-C5lZbbIX.js";import{f as wr}from"./quickselect-D9ta8ndX.js";import{d as Ir,c as Sr,S as $r}from"./query-C2USZ63O.js";import{$ as Tr}from"./ogcFeatureUtils-BnWXFknr.js";import{n as Mr}from"./pbf-B53Txr8m.js";import{b as kr,h as Fr}from"./pbfQueryUtils-DUjEbwA9.js";import{o as Er}from"./StreamFeatureManager-BCRzo0LN.js";import{createConnection as Cr}from"./createConnection-BF5tMznP.js";import"./normalizeUtils-BrH-PrZy.js";import"./normalizeUtilsCommon-BU8xfl77.js";import"./WhereClause-DYd7Xwn9.js";import"./json-omtrO2vq.js";import"./QueryEngineCapabilities-CTDe3LlQ.js";import"./utils-B-uQJqPz.js";import"./utils-DEUXBrCj.js";import"./utils-1_4Re7um.js";import"./ClassBreaksDefinition-Dt1HCCB7.js";import"./geojson-CFL0cZN1.js";import"./date-Do_V47iR.js";import"./clientSideDefaults-Cn_svm8L.js";import"./sourceUtils-BFIlJ45V.js";let Pr=class i{constructor(E,D,L,V){this.computedX=0,this.computedY=0,this.center=$(E,D),this.centerT=k(),this.halfWidth=L/2,this.halfHeight=V/2,this.width=L,this.height=V}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x($){this.center[0]=$}set y($){this.center[1]=$}clone(){return new i(this.x,this.y,this.width,this.height)}serialize($){return $.writeF32(this.center[0]),$.writeF32(this.center[1]),$.push(this.width),$.push(this.height),$}findCollisionDelta($,k=4){const E=Math.abs($.centerT[0]-this.centerT[0]),D=Math.abs($.centerT[1]-this.centerT[1]),L=($.halfWidth+this.halfWidth+k)/E,V=($.halfHeight+this.halfHeight+k)/D,U=Math.min(L,V);return Math.log2(U)}extend($){const k=Math.min(this.xmin,$.xmin),E=Math.min(this.ymin,$.ymin),D=Math.max(this.xmax,$.xmax)-k,L=Math.max(this.ymax,$.ymax)-E,V=k+D/2,U=E+L/2;this.width=D,this.height=L,this.halfWidth=D/2,this.halfHeight=L/2,this.x=V,this.y=U}static deserialize($){const k=$.readF32(),E=$.readF32(),D=$.readInt32(),L=$.readInt32();return new i(k,E,D,L)}};const Ar=4,Or=22+Ar,zr=Math.PI/180;let Rr=class M{constructor($,k,E,D){this._rotationT=V(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const L=E.rect,U=new Float32Array(8);$*=D,k*=D;const X=E.code?L.width*D:E.metrics.width,Q=E.code?L.height*D:E.metrics.height;this.width=X,this.height=Q,U[0]=$,U[1]=k,U[2]=$+X,U[3]=k,U[4]=$,U[5]=k+Q,U[6]=$+X,U[7]=k+Q,this._data=U,this._setTextureCoords(L),this._scale=D,this._mosaic=E,this.x=$,this.y=k,this.maxOffset=Math.max($+X,k+Q)}get mosaic(){return this._mosaic}set angle($){this._angle=$,U(this._rotationT,-$),this._setOffsets()}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:$,width:k}=this._mosaic.metrics,E=k*this._scale,D=Math.abs($)*this._scale,L=new Float32Array(8);L[0]=this.x,L[1]=this.y,L[2]=this.x+E,L[3]=this.y,L[4]=this.x,L[5]=this.y+D,L[6]=this.x+E,L[7]=this.y+D;const U=X(V(),this._rotationT,this._transform);Q(L,L,U);let J=1/0,et=1/0,st=0,ut=0;for(let V=0;V<4;V++){const $=L[2*V],k=L[2*V+1];J=Math.min(J,$),et=Math.min(et,k),st=Math.max(st,$),ut=Math.max(ut,k)}const ht=st-J,_t=ut-et,vt=J+ht/2,Et=et+_t/2;this._bounds=new Pr(vt,Et,ht,_t)}return this._bounds}setTransform($){this._transform=$,this._offsets=null}_setOffsets(){this._offsets||(this._offsets={topLeft:[0,0],topRight:[0,0],bottomLeft:[0,0],bottomRight:[0,0]});const $=X(V(),this._rotationT,this._transform);this._offsets.topLeft[0]=this._data[0],this._offsets.topLeft[1]=this._data[1],this._offsets.topRight[0]=this._data[2],this._offsets.topRight[1]=this._data[3],this._offsets.bottomLeft[0]=this._data[4],this._offsets.bottomLeft[1]=this._data[5],this._offsets.bottomRight[0]=this._data[6],this._offsets.bottomRight[1]=this._data[7],J(this._offsets.topLeft,this._offsets.topLeft,$),J(this._offsets.topRight,this._offsets.topRight,$),J(this._offsets.bottomLeft,this._offsets.bottomLeft,$),J(this._offsets.bottomRight,this._offsets.bottomRight,$)}_setTextureCoords({x:$,y:k,width:E,height:D}){this._texcoords={topLeft:[$,k],topRight:[$+E,k],bottomLeft:[$,k+D],bottomRight:[$+E,k+D]}}};const L$4=($,k)=>({code:0,page:0,sdf:!0,rect:new ur(0,0,11,8),textureBinding:k,metrics:{advance:0,height:4,width:$,left:0,top:0}});function R$6($,k){return $.forEach(($=>J($,$,k))),{topLeft:$[0],topRight:$[1],bottomLeft:$[2],bottomRight:$[3]}}let Dr=class B{constructor($,k,E){this._rotation=0,this._decorate($,k,E),this.glyphs=$,this.bounds=this._createBounds($),this.isMultiline=k.length>1,this._hasRotation=0!==E.angle,this._transform=this._createGlyphTransform(this.bounds,E),this._borderLineSizePx=E.borderLineSizePx,(E.borderLineSizePx||E.hasBackground)&&([this.bounds,this.textBox]=this.shapeBackground(this._transform));for(const D of $)D.setTransform(this._transform)}setRotation($){if(0===$&&0===this._rotation)return;this._rotation=$;const k=this._transform,E=U(V(),$);X(k,E,k);for(const D of this.glyphs)D.setTransform(this._transform)}_decorate($,k,E){if(!E.decoration||"none"===E.decoration||!$.length)return;const D=E.scale,L="underline"===E.decoration?Or:16,V=$[0].textureBinding;for(const U of k){const k=U.startX*D,E=U.startY*D,X=(U.width+U.glyphWidthEnd)*D;$.push(new Rr(k,E+L*D,L$4(X,V),1))}}shapeBackground($){const k=(1.5+(this._borderLineSizePx||0))/2,E=this._borderLineSizePx?k:0,{xmin:D,ymin:L,xmax:V,ymax:U,x:X,y:Q,width:J,height:et}=this.bounds,st=[D-8,L-8],ut=[V+8,L-8],ht=[D-8,U+8],_t=[V+8,U+8],vt=R$6([[st[0]-k,st[1]-k],[ut[0]+k,ut[1]-k],[st[0]+E,st[1]+E],[ut[0]-E,ut[1]+E]],$),Et=R$6([[ht[0]+E,ht[1]-E],[_t[0]-E,_t[1]-E],[ht[0]-k,ht[1]+k],[_t[0]+k,_t[1]+k]],$),Pt=R$6([[st[0]-k,st[1]-k],[st[0]+E,st[1]+E],[ht[0]-k,ht[1]+k],[ht[0]+E,ht[1]-E]],$),Ot=R$6([[ut[0]-E,ut[1]+E],[ut[0]+k,ut[1]-k],[_t[0]-E,_t[1]-E],[_t[0]+k,_t[1]+k]],$),zt={main:R$6([st,ut,ht,_t],$),top:vt,bot:Et,left:Pt,right:Ot};return[new Pr(X,Q,J+2*k,et+2*k),zt]}get boundsT(){const $=this.bounds,E=et(k(),$.x,$.y);if(J(E,E,this._transform),this._hasRotation){const k=Math.max($.width,$.height);return new Pr(E[0],E[1],k,k)}return new Pr(E[0],E[1],$.width,$.height)}_createBounds($){let k=1/0,E=1/0,D=0,L=0;for(const X of $)k=Math.min(k,X.xTopLeft),E=Math.min(E,X.yTopLeft),D=Math.max(D,X.xBottomRight),L=Math.max(L,X.yBottomRight);const V=D-k,U=L-E;return new Pr(k+V/2,E+U/2,V,U)}_createGlyphTransform($,E){const D=zr*E.angle,L=V(),U=k();return st(L,L,et(U,E.xOffset,-E.yOffset)),E.useCIMAngleBehavior?ut(L,L,D):(st(L,L,et(U,$.x,$.y)),ut(L,L,D),st(L,L,et(U,-$.x,-$.y))),L}},Br=class T{constructor($,k,E,D,L,V){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(k,E)),this.end=Math.max(0,Math.max(k,E)),this.end<$.length&&(this.glyphWidthEnd=$[this.end].metrics.width),this.width=D,this.yMin=L,this.yMax=V}};const v$6=$=>10===$,j$8=$=>32===$;function O$2($,k){const V=k.scale,U=new Array,{glyphs:X,isRightToLeft:Q}=$,J=function A$9($,k,E){const D=new Array,L=1/E.scale,V=E.maxLineWidth*L,U=k?$.length-1:0,X=k?-1:$.length,Q=k?-1:1;let J=U,et=0,st=0,ut=J,ht=ut,_t=0,vt=1/0,Et=0;for(;J!==X;){const{code:k,metrics:E}=$[J],L=Math.abs(E.top);if(v$6(k)||j$8(k)||(vt=Math.min(vt,L),Et=Math.max(Et,L+E.height)),v$6(k))J!==U&&(D.push(new Br($,ut,J-Q,et,vt===1/0?0:vt,Et)),vt=1/0,Et=0),et=0,ut=J+Q,ht=J+Q,st=0;else if(j$8(k))ht=J+Q,st=0,_t=E.advance,et+=E.advance;else if(et>V){if(ht!==ut){const k=ht-2*Q;et-=_t,D.push(new Br($,ut,k,et-st,vt,Et)),vt=1/0,Et=0,ut=ht,et=st}else D.push(new Br($,ut,J-Q,et,vt,Et)),vt=1/0,Et=0,ut=J,ht=J,et=0;et+=E.advance,st+=E.advance}else et+=E.advance,st+=E.advance;J+=Q}const Pt=new Br($,ut,J-Q,et,vt,Et);return Pt.start>=0&&Pt.end<$.length&&D.push(Pt),D}(X,Q,k),et=J.length?function z$6($,k){let E=0;for(let V=0;V<$.length;V++){const{width:k}=$[V];E=Math.max(k,E)}const D="underline"===k.decoration?Ar:0,L=$[0].yMin;return{x:0,y:L,height:$[$.length-1].yMax+k.lineHeight*($.length-1)+D-L,width:E}}(J,k):{x:0,y:0,height:0,width:0},st=E(k.horizontalAlignment),ut=D(k.verticalAlignment),ht=ut===L.Baseline?1:0,_t=ht?0:ut-1,vt=(1-ht)*-et.y+_t*(et.height/2)+-22*(ht?1:0);for(let E=0;E<J.length;E++){const{start:$,end:D,width:L}=J[E];let Q=-1*(st+1)*(L/2)-3;const et=E*k.lineHeight+vt-3;J[E].startX=Q,J[E].startY=et;for(let k=$;k<=D;k++){const $=X[k];if(v$6($.code))continue;const E=new Rr(Q+$.metrics.left,et-$.metrics.top,$,V);Q+=$.metrics.advance,U.push(E)}}return new Dr(U,J,k)}let Nr=class t{constructor($){this._client=$,this.layerView=this._client.createInvokeProxy(""),this.container=this._client.createInvokeProxy("container"),this._eventLog=this._client.createInvokeProxy("eventLog")}onEvent($){ht(this._eventLog.onEvent($))}},Lr=class t2{constructor($,k,E,D,L,V,U){this.instanceId=$,this.textureKey=k,this.indexStart=E,this.indexCount=D,this.vertexStart=L,this.vertexCount=V,this.overlaps=U}updateBaseOffsets($){this.vertexStart+=$.vertexFrom,this.indexStart+=$.indexFrom}clone(){return new t2(this.instanceId,this.textureKey,this.indexStart,this.indexCount,this.vertexStart,this.vertexCount,this.overlaps)}static write($,k,E,D,L,V,U,X){$.push(k),$.push(E),$.push(D),$.push(L),$.push(V),$.push(U),$.push(X)}serialize($){return $.push(this.instanceId),$.push(this.textureKey),$.push(this.indexStart),$.push(this.indexCount),$.push(this.vertexStart),$.push(this.vertexCount),$.push(this.overlaps),$}static deserialize($){const k=$.readInt32(),E=$.readInt32(),D=$.readInt32(),L=$.readInt32(),V=$.readInt32(),U=$.readInt32(),X=$.readInt32();return new t2(k,E,D,L,V,U,X)}};function e$k($,k){if(null!==k){$.push(k.length);for(const E of k)E.serialize($);return $}$.push(0)}function n$w($,k,E){const D=$.readInt32(),L=new Array(D);for(let V=0;V<L.length;V++)L[V]=k.deserialize($,E);return L}Lr.byteSizeHint=7*Uint32Array.BYTES_PER_ELEMENT;let jr=class s{constructor($,k){this.id=$,this.sortKey=k,this.records=[]}serialize($){return $.push(this.id),$.writeF32(this.sortKey),e$k($,this.records),$}static deserialize($){const k=$.readInt32(),E=$.readF32(),D=new s(k,E);return D.records=n$w($,Lr)??[],D}};jr.byteSizeHint=2*Uint32Array.BYTES_PER_ELEMENT+Lr.byteSizeHint;let Gr=class r{get length(){return this._pos}constructor($,k){this._pos=0;const E=k?this._roundToNearest(k,$.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(E),this._buffer=new $(this._array),this._ctor=$,this._i16View=new Int16Array(this._array)}_roundToNearest($,k){const E=Math.round($);return 1===k?E:E+(k-E%k)}_ensureSize($){if(this._pos+$>=this._buffer.length){const k=this._roundToNearest(1.25*(this._array.byteLength+$*this._buffer.BYTES_PER_ELEMENT),this._buffer.BYTES_PER_ELEMENT),E=new ArrayBuffer(k),D=new this._ctor(E);D.set(this._buffer,0),this._array=E,this._buffer=D,this._i16View=new Int16Array(this._array)}}ensureSize($){this._ensureSize($)}writeF32($){this._ensureSize(1);const k=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=$,this._pos++,k}push($){this._ensureSize(1);const k=this._pos;return this._buffer[this._pos++]=$,k}writeFixed($){this._buffer[this._pos++]=$}setValue($,k){this._buffer[$]=k}i1616Add($,k,E){this._i16View[2*$]+=k,this._i16View[2*$+1]+=E}getValue($){return this._buffer[$]}getValueF32($){return new Float32Array(this._array,4*$,1)[0]}incr($){if(this._buffer.length<$)throw new Error("Increment index overflows the target buffer");this._buffer[$]++}decr($){this._buffer[$]--}writeRegion($){this._ensureSize($.length);const k=this._pos;return this._buffer.set($,this._pos),this._pos+=$.length,k}writeManyFrom($,k,E){this._ensureSize(E-k);for(let D=k;D!==E;D++)this.writeFixed($._buffer[D])}buffer(){const $=this._array.slice(0,4*this._pos);return this.destroy(),$}toArray(){return[...this._buffer]}seek($){this._pos=$}destroy(){this._array=null,this._buffer=null}};let Vr=class r2{constructor($,k,E=0){const D=6*E*Uint32Array.BYTES_PER_ELEMENT,L=4*E*k.stride,V=k.stride/4,U=k.attributes.find(($=>"pos"===$.name||"position"===$.name));if(!U)throw new Error("InternalError: Unable to find position attribute");this.layout={...k,position:U},this._indices=new Gr(Uint32Array,D),this._vertices=new Gr(Uint32Array,L),this._metrics=new Gr(Uint32Array,0),this._metricCountOffset=this._metrics.push(0),this._strideInt=V,this._instanceId=$}serialize($){const k=this._indices.buffer(),E=this._vertices.buffer(),D=this._metrics.length?this._metrics.buffer():null;return $.push(k,E),{instanceId:this._instanceId,layout:this.layout,indices:k,vertices:E,metrics:D}}get strideInt(){return this._strideInt}get vertexCount(){return this._vertices.length/this._strideInt}get indexCount(){return this._indices.length}get indexWriter(){return this._indices}get vertexWriter(){return this._vertices}get metricWriter(){return this._metrics}vertexEnsureSize($){this._vertices.ensureSize($)}indexEnsureSize($){this._indices.ensureSize($)}writeIndex($){this._indices.push($)}writeVertex($){this._vertices.push($)}writeVertexRegion($){this._vertices.writeRegion($)}writeVertexF32($){this._vertices.writeF32($)}writeMetric($){this._metrics.incr(this._metricCountOffset),$.serialize(this._metrics)}},qr=class n{constructor($,k=0){this._id=$,this._sizeHint=k,this._entityRecordCountOffset=0,this._entityCountOffset=0,this._entityIdIndex=0,this._entitySortKeyIndex=0,this._instanceIdToVertexData=new Map,this._recordIndexStart=0,this._recordIndexCount=0,this._recordVertexStart=0,this._recordVertexCount=0,this._current={metric:null,writer:null,start:0,sortKey:0,instanceId:0,layoutHash:0,indexStart:0,vertexStart:0,textureKey:0,metricBoxLenPointer:0},this._entities=new Gr(Uint32Array,this._sizeHint*jr.byteSizeHint),this._entityCountOffset=this._entities.push(0)}get id(){return this._id}serialize(){const $=new Array,k=[],E=this._entities.buffer();for(const D of this._instanceIdToVertexData.values())k.push(D.serialize($));return{message:{data:k,entities:E},transferList:$}}vertexCount(){var $;return(null==($=this._current.writer)?void 0:$.vertexCount)??0}indexCount(){var $;return(null==($=this._current.writer)?void 0:$.indexCount)??0}vertexEnsureSize($){this._current.writer.vertexEnsureSize($)}indexEnsureSize($){this._current.writer.indexEnsureSize($)}vertexWrite($){this._current.writer.writeVertex($)}vertexWriteRegion($){this._current.writer.writeVertexRegion($)}vertexWriteF32($){this._current.writer.writeVertexF32($)}recordBounds($,k,E,D){}indexWrite($){this._current.writer.writeIndex($)}metricStart($){this._current.metric=$}metricEnd(){const $=this._current.writer;this._current.metric.bounds.length&&$.writeMetric(this._current.metric)}metricBoxWrite($){this._current.metric.bounds.push($)}entityStart($,k=$){this._entityIdIndex=this._entities.push($),this._entitySortKeyIndex=this._entities.writeF32(k),this._entityRecordCountOffset=this._entities.push(0)}entityRecordCount(){return this._entities.getValue(this._entityRecordCountOffset)}entityEnd(){0===this.entityRecordCount()?this._entities.seek(this._entityIdIndex):this._entities.incr(this._entityCountOffset)}recordCount(){return this._entities.getValue(this._entityRecordCountOffset)}recordStart($,k,E=0){this._current.writer=this._getVertexWriter($,k),this._current.indexStart=this._current.writer.indexCount,this._current.vertexStart=this._current.writer.vertexCount,this._current.instanceId=$,this._current.layoutHash=k.hash,this._current.textureKey=E}recordEnd($=0){const k=this._current.vertexStart,E=this._current.writer.vertexCount-k;if(!E)return!1;const D=this._current.indexStart,L=this._current.writer.indexCount-D;return this._recordIndexStart=D,this._recordIndexCount=L,this._recordVertexStart=k,this._recordVertexCount=E,this._entities.incr(this._entityRecordCountOffset),Lr.write(this._entities,this._current.instanceId,this._current.textureKey,D,L,k,E,$),!0}copyLast($,k){const E=this._recordVertexStart+this._recordVertexCount;this._entities.incr(this._entityRecordCountOffset),Lr.write(this._entities,this._current.instanceId,this._current.textureKey,this._recordIndexStart+this._recordIndexCount,this._recordIndexCount,E,this._recordVertexCount,0);const D=this._current.writer.indexWriter,L=this._current.writer.vertexWriter,V=this._recordIndexStart+this._recordIndexCount,U=this._recordVertexCount;for(let vt=this._recordIndexStart;vt!==V;vt++){const $=D.getValue(vt);D.push($+U)}const X=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,Q=this._recordVertexStart*X,J=(this._recordVertexStart+this._recordVertexCount)*X;for(let vt=Q;vt!==J;vt++){const $=L.getValue(vt);L.push($)}const et=this._current.writer.layout.position,st=et.packPrecisionFactor??1,ut=et.offset/Uint32Array.BYTES_PER_ELEMENT,ht=$*st,_t=k*st;for(let vt=E*X;vt<=L.length;vt+=X)L.i1616Add(vt+ut,ht,_t)}copyLastFrom($,k,E){const D=$._entities.getValue($._entityIdIndex);if(D!==this._entities.getValue(this._entityIdIndex)){const k=$._entities.getValueF32($._entitySortKeyIndex);this.entityStart(D,k)}this.recordStart($._current.instanceId,$._current.writer.layout,$._current.textureKey);const L=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,V=this._current.vertexStart,U=$._current.vertexStart-V,X=this._current.writer.indexWriter,Q=this._current.writer.vertexWriter,J=$._current.writer.indexWriter,et=$._current.writer.vertexWriter;for(let Et=$._current.indexStart;Et!==J.length;Et++){const $=J.getValue(Et);X.push($-U)}for(let Et=$._current.vertexStart*L;Et!==et.length;Et++){const $=et.getValue(Et);Q.push($)}const st=this._current.writer.layout.position,ut=st.packPrecisionFactor??1,ht=st.offset/Uint32Array.BYTES_PER_ELEMENT,_t=k*ut,vt=E*ut;for(let Et=V*L;Et<=Q.length;Et+=L)Q.i1616Add(Et+ht,_t,vt);this.recordEnd()}_getVertexWriter($,k){const E=this._instanceIdToVertexData;return E.has($)||E.set($,new Vr($,k,this._sizeHint)),E.get($)}};const Ur=128;function u$e($){switch($){case 1:case 8:case 32:return-1;case 2:case 64:return 0;case 4:case 16:case Ur:return 1}}function m$j($){switch($){case 1:case 2:case 4:return-1;case 8:case 16:return 0;case 32:case 64:case Ur:return 1}}let Wr=class g{constructor($,k,E,D=0){this.tileKey=$,this._bufferingEnabled=k,this._sizeHint=D,this._meshes={self:new qr(this.id,this._sizeHint),neighbors:new Array},this._currentRecordOverlaps=0,this._currentEntityOverlaps=0,this._copyBufferedDataIntoSelf=E&&this._bufferingEnabled&&0===$.level}get id(){return this.tileKey.id}vertexCount(){return this._meshes.self.vertexCount()}indexCount(){return this._meshes.self.indexCount()}indexEnsureSize($){this._meshes.self.indexEnsureSize($)}entityStart($,k=$){this._currentEntityOverlaps=0,this._meshes.self.entityStart($,k)}entityRecordCount(){return this._meshes.self.entityRecordCount()}entityEnd(){if(this._meshes.self.entityEnd(),this._bufferingEnabled){if(this._copyBufferedDataIntoSelf)return;for(let $=0;$<8;$++){const k=1<<$;this._currentEntityOverlaps&k&&this._meshes.neighbors[$].entityEnd()}}}recordStart($,k,E){this._currentRecordOverlaps=0,this._meshes.self.recordStart($,k,E)}recordEnd($=0){const k=this._meshes.self.recordEnd(this._currentRecordOverlaps);return k&&0!==this._currentRecordOverlaps?(this._copyIntoNeighbors(),this._currentEntityOverlaps|=this._currentRecordOverlaps,!0):k}recordBounds($,k,E,D){this._bufferingEnabled&&this._addOverlap($,k,E,D)}recordCount(){return this._meshes.self.recordCount()}metricStart($){this._meshes.self.metricStart($)}metricBoxWrite($){this._meshes.self.metricBoxWrite($)}metricEnd(){this._meshes.self.metricEnd()}vertexWrite($){this._meshes.self.vertexWrite($)}vertexWriteF32($){this._meshes.self.vertexWriteF32($)}vertexWriteRegion($){this._meshes.self.vertexWriteRegion($)}indexWrite($){this._meshes.self.indexWrite($)}serialize($){const k={message:[],transferList:[]},E=this._meshes.self.serialize();return k.message.push({tileId:this.tileKey.id,...E.message}),k.transferList.push(...E.transferList),this._meshes.neighbors.forEach(((E,D)=>{const L=E.serialize(),V=1<<D,U=u$e(V),X=m$j(V),Q=function o$p($,k,E,D){const L=$.clone(),V=1<<L.level,U=L.col+k,X=L.row+E;return D&&U<0?(L.col=U+V,L.world-=1):U>=V?(L.col=U-V,L.world+=1):L.col=U,L.row=X,L}(new _t(this.tileKey),U,X,$);k.message.push({tileId:Q.id,...L.message}),k.transferList.push(...L.transferList)})),k}_addOverlap($,k,E,D){const L=Math.min(vt/2,E),V=Math.min(vt/2,D),U=255^(($<0+L?148:$>=vt-L?41:189)|(k<0+V?224:k>=vt-V?7:231));this._currentRecordOverlaps|=U}_copyIntoNeighbors(){for(let $=0;$<8;$++){const k=1<<$;if(this._currentRecordOverlaps&k){if(this._copyBufferedDataIntoSelf){const $=-u$e(k)*vt,E=-m$j(k)*vt;if(0!==E)continue;this._meshes.self.copyLast($,E);continue}if(!this._meshes.neighbors[$]){const E=Math.floor(this._sizeHint/16);this._meshes.neighbors[$]=new qr(k,E)}const E=this._meshes.neighbors[$],D=-u$e(k)*vt,L=-m$j(k)*vt;E.copyLastFrom(this._meshes.self,D,L)}}}},Yr=class s2{},Xr=class t3{constructor(){this._defaultResult=null,this._backgroundFillResult=null}static async from($,k){const E=new t3;return E.setDefault(await $.createMeshWriters(k.meshes)),E}size(){return 1}getDefault(){return this._defaultResult}setDefault($){this._defaultResult=$}getBackgroundFill(){return this._backgroundFillResult}setBackgroundFill($){this._backgroundFillResult=$}match($,k){const E=this.doMatch($,k)||this.getDefault();if(E&&E.length>0){const $=this.getBackgroundFill();if($)return[...$,...E]}return E}getSortKey($,k){return 0}doMatch($,k){return null}async fetchResources($,k){}},Hr=class e extends Xr{static async fromDictionaryRenderer($,k){return new e($,k)}constructor($,k){super(),this._context=$,this._schema=k,this._hashToGroup=new Map}get fieldMap(){return this._schema.fieldMap}async fetchResources($,k){const E=k.getCursor(),D=[];for(;E.next();)D.push(this._updateMeshWriterGroup($,E));await Promise.all(D)}match($,k){const E=$.getAttributeHash();return this._hashToGroup.get(E)}async _updateMeshWriterGroup($,k){const E=k.readLegacyFeatureForDisplay(),D=k.getAttributeHash();if(this._hashToGroup.has(D))return;this._hashToGroup.set(D,null);const L=await $.fetchDictionaryResourceImmediate({type:"dictionary-request",feature:E});if(!L)return;const V=await this._context.createMeshWriters(L.meshes);this._hashToGroup.set(D,V)}},Zr=class e2 extends Xr{constructor($,k){super(),this._intervals=[],this._isMaxInclusive=k,this._field=$}static async fromIntervalSchema($,k){const E=await $.storage.createComputedField(k),D=new e2(E,k.isMaxInclusive);await Promise.all(k.intervals.map((async k=>{const E=await $.createMeshWriters(k.meshes);D.add(k,E)})));const L=await $.createMeshWriters(k.defaultSymbol);D.setDefault(L);const V=await $.createMeshWriters(k.backgroundFill);return D.setBackgroundFill(V),D}add($,k){this._intervals.push({interval:$,result:k}),this._intervals.sort((($,k)=>$.interval.min-k.interval.min))}size(){return super.size()+this._intervals.length}doMatch($,k){var E;const D=null==(E=this._field)?void 0:E.read($,k);if(null==D||isNaN(D)||D===1/0||D===-1/0)return null;for(let L=0;L<this._intervals.length;L++){const{interval:$,result:k}=this._intervals[L],E=D>=$.min,V=this._isMaxInclusive?D<=$.max:D<$.max;if(E&&V)return k}return null}},Kr=class a extends Xr{static async fromLabelSchema($,k){const E=k.classes.map((async k=>{const E=await $.createMeshWriters(k.meshes);return{minScale:k.minScale,maxScale:k.maxScale,meshes:E,expression:null,where:await $.storage.createWhereClause(k.where)}})),D=await Promise.all(E);return new a(D)}constructor($){super(),this._labels=$}match($,k){if(!this._labels.length)return null;const E=this._getLabels(k.$view.scale),D=[];for(const L of E)L.where&&!L.where($)||D.push(...L.meshes);return D}_getLabels($){return this._labels.filter((k=>this._validForTileScale(k,$)))}_validForTileScale($,k){const E=k-k/4,D=k+k/2;return(!$.minScale||$.minScale>=E)&&(!$.maxScale||$.maxScale<=D)}},Qr=class t4 extends Xr{constructor($,k){super(),this._defaultSymbolSortKey=0,this._nullResult=null,this._resultsMap=new Map,this._fields=[],this._fields=$,this._separator=k||""}static async fromMatcherSchema($,k){const E=k.expression?[$.storage.createComputedField({expression:k.expression})]:[k.field?$.storage.createComputedField({field:k.field}):null,k.field2?$.storage.createComputedField({field:k.field2}):null,k.field3?$.storage.createComputedField({field:k.field3}):null],D=(await Promise.all(E)).filter(($=>!!$)),L=new t4(D,k.fieldDelimiter),V=await $.createMeshWriters(k.defaultSymbol);L.setDefault(V);const U=await $.createMeshWriters(k.backgroundFill);return L.setBackgroundFill(U),await Promise.all(k.map.map((async(k,E)=>{const D=await $.createMeshWriters(k.symbol);"<Null>"===k.value?L.setNullResult(D):L.add(k.value,D,E+1)}))),L}setNullResult($){this._nullResult=$}getSortKey($,k){const E=this._getValueFromFields($,k);if(null==E||""===E||"<Null>"===E)return 0;const D=this._resultsMap.get(E.toString());return D?D.sortKey:this._defaultSymbolSortKey}add($,k,E){this._resultsMap.set($.toString(),{meshWriters:k,sortKey:E}),this._defaultSymbolSortKey=Math.max(this._defaultSymbolSortKey,E+1)}size(){return super.size()+this._resultsMap.size}doMatch($,k){var E;const D=this._getValueFromFields($,k);if(null!==this._nullResult&&(null==D||""===D||"<Null>"===D))return this._nullResult;if(null==D)return null;const L=D.toString();return null==(E=this._resultsMap.get(L))?void 0:E.meshWriters}_getValueFromFields($,k){const E=[];for(const D of this._fields){const L=D.read($,k);null==L||""===L?E.push("<Null>"):E.push(L)}return E.join(this._separator)}};async function c$i($,k){switch(k.type){case"simple":case"heatmap":case"dot-density":case"pie-chart":return Xr.from($,k);case"interval":return Zr.fromIntervalSchema($,k);case"dictionary":return Hr.fromDictionaryRenderer($,k);case"label":return Kr.fromLabelSchema($,k);case"map":return Qr.fromMatcherSchema($,k);case"subtype":return Jr.fromSubtypes($,k);case"cluster":return ti.fromClusterSchema($,k);default:throw new Error("Impl")}}let Jr=class n2 extends Xr{constructor($,k){super(),this._subMatchers=$,this._subtypeField=k}static async fromSubtypes($,k){const E=new Map,D=[];for(const L in k.renderers){const V=parseInt(L,10),U=c$i($,k.renderers[L]).then(($=>E.set(V,$)));D.push(U)}return await Promise.all(D),new n2(E,k.subtypeField)}match($,k){const E=$.readAttribute(this._subtypeField),D=this._subMatchers.get(E);return D?D.match($,k):null}},ti=class o extends Xr{static async fromClusterSchema($,k){const[E,D]=await Promise.all([c$i($,k.feature),c$i($,k.cluster)]);return new o(E,D)}constructor($,k){super(),this._featureMatcher=$,this._clusterMatcher=k}match($,k){return 1===$.readAttribute("cluster_count")?this._featureMatcher.match($,k):this._clusterMatcher.match($,k)}},ei=class s3 extends Yr{static async create($,k){const E=await c$i($,k.symbology),D=k.labels?await c$i($,k.labels):null;return new s3(E,D)}constructor($,k){super(),this._symbology=$,this._labels=k}destroy(){}async enqueueMatcherRequests($,k){var E;await Promise.all([this._symbology.fetchResources($,k),null==(E=this._labels)?void 0:E.fetchResources($,k)])}enqueueWriterRequests($,k,E){const D=this._symbology.match(k,E);if(D){for(const L of D)L.enqueueRequest($,k,E);if(this._labels){const D=this._labels.match(k,E);if(!D)return;for(const L of D)L.enqueueRequest($,k,E)}}}write($,k,E,D,L){const V=this._symbology.match(E,D);if(V){for(const U of V)U.write($,k,E,D,L);if($.entityRecordCount()>=1&&this._labels){const U=this._labels.match(E,D);if(!U)return;for(const X of U)X.setReferences(V),X.write($,k,E,D,L)}}}getSortKey($,k){return this._symbology.getSortKey($,k)}};function d$g($){switch($){case Pt.UNSIGNED_BYTE:return Uint8Array;case Pt.UNSIGNED_SHORT_4_4_4_4:return Uint16Array;case Pt.FLOAT:return Float32Array;default:return void Dt.getLogger("esri.views.2d.engine.webgl.Utils").error(new Et("webgl-utils",`Unable to handle type ${$}`))}}function T$5($,k,E){const D=new Ot(k.width,k.height);return D.dataType=k.dataType,k.depth&&(D.depth=k.depth),k.flipped&&(D.flipped=k.flipped),k.hasMipmap&&(D.hasMipmap=k.hasMipmap),D.internalFormat=k.internalFormat,k.isImmutable&&(D.isImmutable=k.isImmutable),k.isOpaque&&(D.isOpaque=k.isOpaque),k.maxAnisotropy&&(D.maxAnisotropy=k.maxAnisotropy),D.pixelFormat=k.pixelFormat,k.preMultiplyAlpha&&(D.preMultiplyAlpha=k.preMultiplyAlpha),k.samplingMode&&(D.samplingMode=k.samplingMode),k.target&&(D.target=k.target),D.uniform=k.uniform,k.unpackAlignment&&(D.unpackAlignment=k.unpackAlignment),k.wrapMode&&(D.wrapMode=k.wrapMode),new zt($,D,E)}let si=class s4{},ri=class s5 extends si{constructor($){super(),this._fetcher=$,this._controller=new AbortController,this._pendingIds=new Set,this._pendingRequests=[],this._resourceIdToResource=new Map}destroy(){this._controller.abort()}get _abortOptions(){return{signal:this._controller.signal}}enqueueRequest($){const k=function M$6($){return"url"in $&&"urlHash"in $?{...$,url:""}:$}($.resource),E=Nt(JSON.stringify(k));return this._pendingIds.has(E)||(this._pendingIds.add(E),this._pendingRequests.push({...$,resourceId:E})),E}async fetchEnqueuedResources(){const $=this._pendingRequests;this._pendingIds.clear(),this._pendingRequests=[];const k=await this._fetcher.fetch($,this._abortOptions);for(let E=0;E<k.length;E++){const D=$[E].resourceId;this._resourceIdToResource.set(D,k[E])}}async fetchResourceImmediate($){const k=await this._fetcher.fetch([$],this._abortOptions);if(1!==k.length)throw new Error("FeaturePipelineResourceProxy: failed to fetch resources");return k[0]}async fetchDictionaryResourceImmediate($){const k=await this._fetcher.fetchDictionary([$],this._abortOptions);if(1!==k.length)throw new Error("FeaturePipelineResourceProxy: failed to fetch dictionary resources");return k[0]}getResource($){return this._resourceIdToResource.get($)}};var ii,ni;function e$f($,k,E,D,L,V,U){ci=0;const X=(D-E)*V,Q=L&&L.length,J=Q?(L[0]-E)*V:X;let et,st,ut,ht,_t,vt=n$s(k,E,D,0,J,V,!0);if(vt&&vt.next!==vt.prev){if(Q&&(vt=function f$f($,k,E,D,L,V){const U=new Array;for(let X=0,Q=D.length;X<Q;X++){const L=n$s($,k,E,D[X]*V,X<Q-1?D[X+1]*V:E*V,V,!1);L===L.next&&(L.steiner=!0),U.push(l$l(L))}U.sort(m$i);for(const X of U)L=y$8(X,L);return L}(k,E,D,L,vt,V)),X>80*V){et=ut=k[0+E*V],st=ht=k[1+E*V];for(let $=V;$<J;$+=V){const D=k[$+E*V],L=k[$+1+E*V];et=Math.min(et,D),st=Math.min(st,L),ut=Math.max(ut,D),ht=Math.max(ht,L)}_t=Math.max(ut-et,ht-st),_t=0!==_t?1/_t:0}x$8(vt,$,V,et,st,_t,U,0)}}function n$s($,k,E,D,L,V,U){let X;if(U===function Z$2($,k,E,D,L,V){let U=0;for(let X=D,Q=L-V;X<L;X+=V)U+=($[Q+k*V]-$[X+k*V])*($[X+1+k*V]+$[Q+1+k*V]),Q=X;return U}($,k,0,D,L,V)>0)for(let Q=D;Q<L;Q+=V)X=u$c(Q+k*V,$[Q+k*V],$[Q+1+k*V],X);else for(let Q=L-V;Q>=D;Q-=V)X=u$c(Q+k*V,$[Q+k*V],$[Q+1+k*V],X);return X&&M$5(X,X.next)&&(o$m(X),X=X.next),X}function t$l($,k=$){if(!$)return $;let E,D=$;do{if(E=!1,D.steiner||!M$5(D,D.next)&&0!==s$n(D.prev,D,D.next))D=D.next;else{if(o$m(D),D=k=D.prev,D===D.next)break;E=!0}}while(E||D!==k);return k}function x$8($,k,E,D,L,V,U,X){if(!$)return;!X&&V&&($=c$h($,D,L,V));let Q=$;for(;$.prev!==$.next;){const J=$.prev,et=$.next;if(V?i$j($,D,L,V):r$j($))k.push(J.index/E+U),k.push($.index/E+U),k.push(et.index/E+U),o$m($),$=et.next,Q=et.next;else if(($=et)===Q){X?1===X?x$8($=b$8($,k,E,U),k,E,D,L,V,U,2):2===X&&g$c($,k,E,D,L,V,U):x$8(t$l($),k,E,D,L,V,U,1);break}}}function r$j($){const k=$.prev,E=$,D=$.next;if(s$n(k,E,D)>=0)return!1;let L=$.next.next;const V=L;let U=0;for(;L!==$.prev&&(0===U||L!==V);){if(U++,a$j(k.x,k.y,E.x,E.y,D.x,D.y,L.x,L.y)&&s$n(L.prev,L,L.next)>=0)return!1;L=L.next}return!0}function i$j($,k,E,D){const L=$.prev,V=$,U=$.next;if(s$n(L,V,U)>=0)return!1;const X=L.x<V.x?L.x<U.x?L.x:U.x:V.x<U.x?V.x:U.x,Q=L.y<V.y?L.y<U.y?L.y:U.y:V.y<U.y?V.y:U.y,J=L.x>V.x?L.x>U.x?L.x:U.x:V.x>U.x?V.x:U.x,et=L.y>V.y?L.y>U.y?L.y:U.y:V.y>U.y?V.y:U.y,st=z$5(X,Q,k,E,D),ut=z$5(J,et,k,E,D);let ht=$.prevZ,_t=$.nextZ;for(;ht&&ht.z>=st&&_t&&_t.z<=ut;){if(ht!==$.prev&&ht!==$.next&&a$j(L.x,L.y,V.x,V.y,U.x,U.y,ht.x,ht.y)&&s$n(ht.prev,ht,ht.next)>=0)return!1;if(ht=ht.prevZ,_t!==$.prev&&_t!==$.next&&a$j(L.x,L.y,V.x,V.y,U.x,U.y,_t.x,_t.y)&&s$n(_t.prev,_t,_t.next)>=0)return!1;_t=_t.nextZ}for(;ht&&ht.z>=st;){if(ht!==$.prev&&ht!==$.next&&a$j(L.x,L.y,V.x,V.y,U.x,U.y,ht.x,ht.y)&&s$n(ht.prev,ht,ht.next)>=0)return!1;ht=ht.prevZ}for(;_t&&_t.z<=ut;){if(_t!==$.prev&&_t!==$.next&&a$j(L.x,L.y,V.x,V.y,U.x,U.y,_t.x,_t.y)&&s$n(_t.prev,_t,_t.next)>=0)return!1;_t=_t.nextZ}return!0}function u$c($,k,E,D){const L=oi.create($,k,E);return D?(L.next=D.next,L.prev=D,D.next.prev=L,D.next=L):(L.prev=L,L.next=L),L}function o$m($){$.next.prev=$.prev,$.prev.next=$.next,$.prevZ&&($.prevZ.nextZ=$.nextZ),$.nextZ&&($.nextZ.prevZ=$.prevZ)}function l$l($){let k=$,E=$;do{(k.x<E.x||k.x===E.x&&k.y<E.y)&&(E=k),k=k.next}while(k!==$);return E}function y$8($,k){const E=function p$g($,k){let E=k;const D=$.x,L=$.y;let V,U=-1/0;do{if(L<=E.y&&L>=E.next.y&&E.next.y!==E.y){const $=E.x+(L-E.y)*(E.next.x-E.x)/(E.next.y-E.y);if($<=D&&$>U){if(U=$,$===D){if(L===E.y)return E;if(L===E.next.y)return E.next}V=E.x<E.next.x?E:E.next}}E=E.next}while(E!==k);if(!V)return null;if(D===U)return V.prev;const X=V,Q=V.x,J=V.y;let et,st=1/0;for(E=V.next;E!==X;)D>=E.x&&E.x>=Q&&D!==E.x&&a$j(L<J?D:U,L,Q,J,L<J?U:D,L,E.x,E.y)&&(et=Math.abs(L-E.y)/(D-E.x),(et<st||et===st&&E.x>V.x)&&w$5(E,$)&&(V=E,st=et)),E=E.next;return V}($,k);if(!E)return k;const D=j$7(E,$);return t$l(D,D.next),t$l(E,E.next)}function c$h($,k,E,D){let L;for(;L!==$;L=L.next){if(L=L||$,null===L.z&&(L.z=z$5(L.x,L.y,k,E,D)),L.prev.next!==L||L.next.prev!==L)return L.prev.next=L,L.next.prev=L,c$h($,k,E,D);L.prevZ=L.prev,L.nextZ=L.next}return $.prevZ.nextZ=null,$.prevZ=null,function v$5($){let k,E=1;for(;;){let D,L=$;$=null,k=null;let V=0;for(;L;){V++,D=L;let U=0;for(;U<E&&D;U++)D=D.nextZ;let X=E;for(;U>0||X>0&&D;){let E;0===U?(E=D,D=D.nextZ,X--):0!==X&&D?L.z<=D.z?(E=L,L=L.nextZ,U--):(E=D,D=D.nextZ,X--):(E=L,L=L.nextZ,U--),k?k.nextZ=E:$=E,E.prevZ=k,k=E}L=D}if(k.nextZ=null,E*=2,V<2)return $}}($)}function s$n($,k,E){return(k.y-$.y)*(E.x-k.x)-(k.x-$.x)*(E.y-k.y)}function h$h($,k,E,D){return!!(M$5($,k)&&M$5(E,D)||M$5($,D)&&M$5(E,k))||s$n($,k,E)>0!=s$n($,k,D)>0&&s$n(E,D,$)>0!=s$n(E,D,k)>0}function a$j($,k,E,D,L,V,U,X){return(L-U)*(k-X)-($-U)*(V-X)>=0&&($-U)*(D-X)-(E-U)*(k-X)>=0&&(E-U)*(V-X)-(L-U)*(D-X)>=0}function w$5($,k){return s$n($.prev,$,$.next)<0?s$n($,k,$.next)>=0&&s$n($,$.prev,k)>=0:s$n($,k,$.prev)<0||s$n($,$.next,k)<0}function z$5($,k,E,D,L){return($=1431655765&(($=858993459&(($=252645135&(($=16711935&(($=32767*($-E)*L)|$<<8))|$<<4))|$<<2))|$<<1))|(k=1431655765&((k=858993459&((k=252645135&((k=16711935&((k=32767*(k-D)*L)|k<<8))|k<<4))|k<<2))|k<<1))<<1}function M$5($,k){return $.x===k.x&&$.y===k.y}function m$i($,k){return $.x-k.x}function b$8($,k,E,D){let L=$;do{const V=L.prev,U=L.next.next;!M$5(V,U)&&h$h(V,L,L.next,U)&&w$5(V,U)&&w$5(U,V)&&(k.push(V.index/E+D),k.push(L.index/E+D),k.push(U.index/E+D),o$m(L),o$m(L.next),L=$=U),L=L.next}while(L!==$);return L}function g$c($,k,E,D,L,V,U){let X=$;do{let $=X.next.next;for(;$!==X.prev;){if(X.index!==$.index&&k$5(X,$)){let Q=j$7(X,$);return X=t$l(X,X.next),Q=t$l(Q,Q.next),x$8(X,k,E,D,L,V,U,0),void x$8(Q,k,E,D,L,V,U,0)}$=$.next}X=X.next}while(X!==$)}function k$5($,k){return $.next.index!==k.index&&$.prev.index!==k.index&&!function d$f($,k){let E=$;do{if(E.index!==$.index&&E.next.index!==$.index&&E.index!==k.index&&E.next.index!==k.index&&h$h(E,E.next,$,k))return!0;E=E.next}while(E!==$);return!1}($,k)&&w$5($,k)&&w$5(k,$)&&function A$8($,k){let E=$,D=!1;const L=($.x+k.x)/2,V=($.y+k.y)/2;do{E.y>V!=E.next.y>V&&E.next.y!==E.y&&L<(E.next.x-E.x)*(V-E.y)/(E.next.y-E.y)+E.x&&(D=!D),E=E.next}while(E!==$);return D}($,k)}function j$7($,k){const E=oi.create($.index,$.x,$.y),D=oi.create(k.index,k.x,k.y),L=$.next,V=k.prev;return $.next=k,k.prev=$,E.next=L,L.prev=E,D.next=E,E.prev=D,V.next=D,D.prev=V,D}(ni=ii||(ii={}))[ni.Fill=0]="Fill",ni[ni.PatternFill=1]="PatternFill",ni[ni.ComplexFill=2]="ComplexFill",ni[ni.OutlineFill=3]="OutlineFill",ni[ni.PatternOutlineFill=4]="PatternOutlineFill",ni[ni.ComplexOutlineFill=5]="ComplexOutlineFill",ni[ni.Marker=6]="Marker",ni[ni.PieChart=7]="PieChart",ni[ni.Line=8]="Line",ni[ni.TexturedLine=9]="TexturedLine",ni[ni.Text=10]="Text",ni[ni.Label=11]="Label",ni[ni.Heatmap=12]="Heatmap",ni[ni.DotDensity=13]="DotDensity",ni[ni.Test=14]="Test";let oi=class q{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create($,k,E){const D=ci<ai.length?ai[ci++]:new q;return D.index=$,D.x=k,D.y=E,D.prev=null,D.next=null,D.z=null,D.prevZ=null,D.nextZ=null,D.steiner=!1,D}};const ai=[];let ci=0;for(let Sl=0;Sl<8096;Sl++)ai.push(new oi);const li=new Lt(0,0,0,1,0),ui=new Lt(0,0,0,1,0);function u$b($,k,E){let D=0;for(let L=1;L<E;L++){const E=$[2*(k+L-1)],V=$[2*(k+L-1)+1];D+=($[2*(k+L)]-E)*($[2*(k+L)+1]+V)}return D}function h$g($,k,E,D,L){let V=0;for(let U=E;U<D;U+=3){const E=2*($[U]-L),D=2*($[U+1]-L),X=2*($[U+2]-L);V+=Math.abs((k[E]-k[X])*(k[D+1]-k[E+1])-(k[E]-k[D])*(k[X+1]-k[E+1]))}return V}function d$e($,k){if(null==$)return null;if(!function m$h($,k,E){let D=0;for(let L=0;L<$.lengths.length;L++){const V=$.lengths[L];for(let L=0;L<V;L++){const V=$.coords[2*(L+D)],U=$.coords[2*(L+D)+1];if(V<k||V>E||U<k||U>E)return!0}D+=V}return!1}($,-128,vt+128))return $;li.setPixelMargin(k),li.reset(Vt.Polygon);let E=0;for(let U=0;U<$.lengths.length;U++){const k=$.lengths[U];let D=$.coords[2*(0+E)],L=$.coords[2*(0+E)+1];li.moveTo(D,L);for(let V=1;V<k;V++)D=$.coords[2*(V+E)],L=$.coords[2*(V+E)+1],li.lineTo(D,L);li.close(),E+=k}const D=li.result(!1);if(!D)return null;const L=[],V=[];for(const U of D){let $=0;for(const k of U)V.push(k.x),V.push(k.y),$++;L.push($)}return new qt(L,V)}li.setExtent(vt),ui.setExtent(vt);const hi=96/72;let di=class l{static executeEffects($,k,E,D){const L=hi,V=Ut($);let U=new Qt(k);for(const X of $){const $=Yt(X);$&&(U=$.execute(U,X,L,E,D,V))}return U}static applyEffects($,k,E){if(!$)return k;const D=Ut($);let L,V=new Qt(te.fromJSONCIM(k));for(const Q of $){const $=Yt(Q);$&&(V=$.execute(V,Q,1,null,E,D))}const U=[];let X=null;for(;L=V.next();)U.push(...re(L)),X=L.geometryType;return 0===U.length||null===X?null:"esriGeometryPolygon"===X?{rings:U}:{paths:U}}},pi=null;function t$k(){return pi}const fi=new Float32Array(1),_i=new Uint32Array(fi.buffer);function y$7($){const k=function a$h($){return fi[0]=$,_i[0]}($),E=k>>>31;let D=k>>>23&255,L=8388607&k;return D-=127,D>15?E<<15|31744:D<-25?0:(D<-14&&(L+=8388608,L/=2**(-14-D),D=-15),D+=15,L/=8192,L=function A$7($,k){const E=Math.floor($),D=$-E;return E<k&&(D>.5||.5===D&&E%2==1)?E+1:E}(L,1023),E<<15|D<<10|L)}function o$l($,k,E,D,L,V,U){if($.primitiveName===k)for(const X in $)if(X===E){let k=null==D?void 0:D.readWithDefault(L,V,$[X]&&U);return"text"===$.type&&(k=k.toString()),void($[X]=k)}if("type"in $&&null!=$.type)switch($.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if($.symbolLayers)for(const X of $.symbolLayers)o$l(X,k,E,D,L,V,U);break;case"CIMHatchFill":$.lineSymbol&&o$l($.lineSymbol,k,E,D,L,V,U);break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if("CIMVectorMarker"===$.type&&$.markerGraphics)for(const X of $.markerGraphics)o$l(X,k,E,D,L,V,U),o$l(X.symbol,k,E,D,L,V,U)}}function i$h($){const k=$.width;return null!=$.effects?400:Math.max(1.25*k,8)}function e$d($){switch($){case ne.BYTE:case ne.UNSIGNED_BYTE:return 1;case ne.SHORT:case ne.UNSIGNED_SHORT:case ne.HALF_FLOAT:return 2;case ne.FLOAT:case ne.INT:case ne.UNSIGNED_INT:return 4}}let mi=class n3{static fromVertexSpec($,k){const{attributes:E,optionalAttributes:D}=$;let L,V,U;const X=[];for(const _t in E){const $=E[_t];"position"===$.pack?L={...$,name:_t,offset:0}:"id"===$.pack?V={...$,name:_t,offset:4}:"bitset"===_t?U={...$,name:_t,offset:7}:X.push({...$,name:_t})}for(const _t in D)if(!0===k[_t]){const $=D[_t];X.push({...$,name:_t})}const Q=function o$k($){const k=[],E=[],D=[];for(const L of $){const $=e$d(L.type)*L.count;switch($%2||$%4||4){case 4:k.push(L);continue;case 2:E.push(L);continue;case 1:D.push(L);continue;default:throw new Error("Found unexpected dataType byte count")}}return k.push(...E),k.push(...D),k}(X),J=[];let et=8,st=1;for(const _t of Q)J.push({..._t,offset:et}),et+=e$d(_t.type)*_t.count,_t.packAlternating&&(st=Math.max(_t.packAlternating.count,st));const ut=Uint32Array.BYTES_PER_ELEMENT,ht=et%ut;return new n3(L,V,U,J,et+(ht?ut-ht:0),st)}constructor($,k,E,D,L,V){this.position=$,this.id=k,this.bitset=E,this.standardAttributes=D,this.stride=L,this.packVertexCount=V,D.push(E),this._attributes=[$,k,E,...D]}get attributeLayout(){if(!this._attributeLayout){const $=function t$i($){const k=$.map((({name:$,count:k,type:E})=>`${$}.${k}.${E}`)).join(",");return Nt(k)}(this._attributes),k=this._attributes.map(($=>({name:$.name,count:$.count,offset:$.offset,type:$.type,packPrecisionFactor:$.packPrecisionFactor,normalized:$.normalized??!1})));this._attributeLayout={attributes:k,hash:$,stride:this.stride}}return this._attributeLayout}};let yi=class i2{static fromVertexSpec($,k){const E=mi.fromVertexSpec($,k);return new i2(E)}constructor($){this._spec=$,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex($,k,E,D,L,V){var U;for(let X=0;X<this._spec.packVertexCount;X++){const $=X*this._spec.stride;this._packPosition(E,D,$),this._packId(k,$);const Q=this._spec.bitset;if(V){if(Q.packTessellation){const k=Q.packTessellation(V,L);this._pack(k,Q,$)}for(const k of this._spec.standardAttributes)if(null!=k.packTessellation){const E=k.packTessellation(V,L);this._pack(E,k,$)}else if(null==(U=k.packAlternating)?void 0:U.packTessellation){const $=k.packAlternating.packTessellation(V,L);for(let E=0;E<this._spec.packVertexCount;E++){const D=$[E];this._pack(D,k,E*this._spec.stride)}}}}$.vertexWriteRegion(this._packedU32View)}pack($,k){var E;for(const D of this._spec.standardAttributes)if(D.pack&&"string"!=typeof D.pack){const E=D.pack($,k);for(let $=0;$<this._spec.packVertexCount;$++)this._pack(E,D,$*this._spec.stride)}else if(null==(E=D.packAlternating)?void 0:E.pack){const E=D.packAlternating.pack($,k);for(let $=0;$<this._spec.packVertexCount;$++){const k=E[$];this._pack(k,D,$*this._spec.stride)}}}_packPosition($,k,E){const{offset:D}=this._spec.position,L=this._spec.position.packPrecisionFactor??1,V=function s$m($,k){return 65535&$|k<<16}($*L,k*L);this._dataView.setUint32(E+D,V,!0)}_packId($,k){const E=$*(this._spec.id.packPrecisionFactor??1),D=4278190080&this._dataView.getUint32(k+this._spec.id.offset,!0);this._dataView.setUint32(k+this._spec.id.offset,E|D,!0)}_pack($,k,E){!function o$j($,k,E,D){const L=E.packPrecisionFactor??1;switch(E.type){case ne.BYTE:if(1===E.count)$.setInt8(D+E.offset,k*L);else for(let V=0;V<E.count;V++){const U=V*Int8Array.BYTES_PER_ELEMENT;$.setInt8(D+E.offset+U,k[V]*L)}break;case ne.UNSIGNED_BYTE:if(1===E.count)$.setUint8(D+E.offset,k*L);else for(let V=0;V<E.count;V++){const U=V*Uint8Array.BYTES_PER_ELEMENT;$.setUint8(D+E.offset+U,k[V]*L)}break;case ne.SHORT:if(1===E.count)$.setInt16(D+E.offset,k*L,!0);else for(let V=0;V<E.count;V++){const U=V*Int16Array.BYTES_PER_ELEMENT;$.setInt16(D+E.offset+U,k[V]*L,!0)}break;case ne.UNSIGNED_SHORT:if(1===E.count)$.setUint16(D+E.offset,k*L,!0);else for(let V=0;V<E.count;V++){const U=V*Uint16Array.BYTES_PER_ELEMENT;$.setUint16(D+E.offset+U,k[V]*L,!0)}break;case ne.INT:if(1===E.count)$.setInt32(D+E.offset,k*L,!0);else for(let V=0;V<E.count;V++){const U=V*Int32Array.BYTES_PER_ELEMENT;$.setInt32(D+E.offset+U,k[V]*L,!0)}break;case ne.UNSIGNED_INT:if(1===E.count)$.setUint32(D+E.offset,k*L,!0);else for(let V=0;V<E.count;V++){const U=V*Uint32Array.BYTES_PER_ELEMENT;$.setUint32(D+E.offset+U,k[V]*L,!0)}break;case ne.FLOAT:if(1===E.count)$.setFloat32(D+E.offset,k*L,!0);else for(let V=0;V<E.count;V++){const U=V*Float32Array.BYTES_PER_ELEMENT;$.setFloat32(D+E.offset+U,k[V]*L,!0)}break;case ne.HALF_FLOAT:if(1===E.count)$.setUint16(D+E.offset,y$7(k*L),!0);else for(let V=0;V<E.count;V++){const U=V*Uint16Array.BYTES_PER_ELEMENT;$.setUint16(D+E.offset+U,y$7(k[V]*L),!0)}}}(this._dataView,$,k,E)}};let gi=class c{constructor($,k,E,D){this._instanceId=$,this._evaluator=k,this._enabledOptionalAttributes=E,this._viewParams=D,this._evaluator.evaluator=$=>this.vertexSpec.createComputedParams($)}get _vertexPack(){if(!this._cachedVertexPack){const $=yi.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||$.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=$}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}setReferences($){this._references=$}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){var $;(function i$f($){if(!$)return!1;for(const k of $)switch(k.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1})(null==($=this._evaluator.inputMeshParams.effects)?void 0:$.effectInfos)&&await async function e$e(){pi=await ie((()=>import("./geometryEngineJSON-CrXS8d22.js").then(($=>$.g))),__vite__mapDeps([0,1,2,3,4]))}()}enqueueRequest($,k,E){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest($,k,E)}write($,k,E,D,L){var V;this.ensurePacked(k,E,D);const U=this.evaluatedMeshParams.effects;if(!U||0===U.length)return void this._write($,E,void 0,L);const X=null==(V=E.readGeometryForDisplay())?void 0:V.clone();if(!X)return;const Q=te.fromOptimizedCIM(X,E.geometryType),J=t$k();Q.invertY();const et=$.id||"",st=di.executeEffects(U,Q,et,J);let ut;for(;ut=st.next();)ut.invertY(),this._write($,E,ut,L)}ensurePacked($,k,E){if(!this._evaluator.hasDynamicProperties)return;const D=this._evaluator.evaluateMeshParams($,k,E);this._vertexPack.pack(D,this._viewParams)}_writeVertex($,k,E,D,L){const V=this.evaluatedMeshParams;this._vertexPack.writeVertex($,k,E,D,V,L)}};const xi=oe("featurelayer-fast-triangulation-enabled");let bi=class a2 extends gi{async loadDependencies(){await Promise.all([super.loadDependencies(),ar()])}_write($,k,E){const D=(null==E?void 0:E.asOptimized())??k.readGeometryForDisplay(),L=this._clip(D);L&&($.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry($,k,L),$.recordEnd())}_clip($){if(!$)return null;return d$e($,this.hasEffects?256:8)}_writeGeometry($,k,E){const D=E.maxLength>100,L=[],V=this.createTesselationParams(k);if(!D&&xi&&function a$i($,k){const{coords:E,lengths:D,hasIndeterminateRingOrder:L}=k,V=$;if(L)return!1;let U=0;for(let X=0;X<D.length;){let $=X,k=D[X],L=u$b(E,U,k);const Q=[];for(;++$<D.length;){const V=D[$],X=u$b(E,U+k,V);if(!(X>0))break;L+=X,Q.push(U+k),k+=V}const J=V.length;e$f(V,E,U,U+k,Q,2,0);const et=h$g(V,E,J,V.length,0),st=Math.abs(L);if(Math.abs((et-st)/Math.max(1e-7,st))>1e-5)return V.length=0,!1;X=$,U+=k}return!0}(L,E))return void(L.length&&this._writeVertices($,k,E.coords,V,L));const U=function p$f($){const{coords:k,lengths:E}=$,{buffer:D}=or(k,E);return D}(E);this._writeVertices($,k,U,V)}_writeVertices($,k,E,D,L){const V=k.getDisplayId(),U=$.vertexCount(),X=this.hasEffects;let Q=0;if(L)for(const J of L){const k=E[2*J],L=E[2*J+1];X&&$.recordBounds(k,L,0,0),this._writeVertex($,V,k,L,D),Q++}else for(let J=0;J<E.length;J+=2){const k=Math.round(E[J]),L=Math.round(E[J+1]);X&&$.recordBounds(k,L,0,0),this._writeVertex($,V,k,L,D),Q++}$.indexEnsureSize(Q);for(let J=0;J<Q;J++)$.indexWrite(J+U)}};const vi={createComputedParams:$=>$,optionalAttributes:{},attributes:{id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:ne.UNSIGNED_BYTE,count:1},pos:{type:ne.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:ne.FLOAT,count:1,packTessellation:({inverseArea:$})=>$}}};let wi=class s6 extends bi{constructor(){super(...arguments),this.vertexSpec=vi}createTesselationParams($){return{inverseArea:1/$.readGeometryArea()}}};function m$g($,k){return[!!(null==$?void 0:$.minScale)&&k.scaleToZoom($.minScale)||0,!!(null==$?void 0:$.maxScale)&&k.scaleToZoom($.maxScale)||100]}function f$d($){return 1<<$}function l$j($){let k=0;for(const[E,D]of $)D&&(k|=1<<E);return k}function g$b($){let k;if(!$)return[0,0,0,0];if("string"==typeof $){const E=ae.fromString($);if(!E)return Dt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils").errorOnce(new Et("mapview:mesh-processing","Unable to parse string into color",{color:$})),[0,0,0,0];k=E.toArray()}else k=$;const[E,D,L,V]=k;return[E*(V/255),D*(V/255),L*(V/255),V]}function d$d($,k){return Math.round(Math.min(Math.sqrt($*k),255))}function S$b($,k){return Math.round($*k)/k}const Ii={createComputedParams:$=>$,optionalAttributes:{zoomRange:{type:ne.SHORT,count:2,packPrecisionFactor:de,pack:({scaleInfo:$},{tileInfo:k})=>m$g($,k)}},attributes:{id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:ne.UNSIGNED_BYTE,count:1},pos:{type:ne.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:$})=>g$b($)}}};let Si=class c2 extends bi{constructor(){super(...arguments),this.vertexSpec=Ii}createTesselationParams($){return null}};const $i={createComputedParams:$=>$,optionalAttributes:Ii.optionalAttributes,attributes:{...Ii.attributes,tlbr:{count:4,type:ne.UNSIGNED_SHORT,pack:({sprite:$})=>{const{rect:k,width:E,height:D}=$,L=k.x+pe,V=k.y+pe;return[L,V,L+E,V+D]}},inverseRasterizationScale:{count:1,type:ne.BYTE,packPrecisionFactor:16,pack:({sprite:$})=>1/$.rasterizationScale}}};let Ti=class o2 extends Si{constructor(){super(...arguments),this.vertexSpec=$i}_write($,k,E){var D;const L=(null==E?void 0:E.asOptimized())??k.readGeometryForDisplay(),V=this._clip(L);if(!V)return;const U=null==(D=this.evaluatedMeshParams.sprite)?void 0:D.textureBinding;$.recordStart(this.instanceId,this.attributeLayout,U),this._writeGeometry($,k,V),$.recordEnd()}};var Mi,ki;(ki=Mi||(Mi={}))[ki.Geographic=0]="Geographic",ki[ki.Arithmatic=1]="Arithmatic";const Fi=1.1,Ei=1,Ci=1e-5,Pi=.05,Ai=1e-30,Oi=2;function p$d($){const{sprite:k,aspectRatio:E,scaleProportionally:D}=$,L=fe($.height),V=L>0?L:k.height;let U=L*E;return U<=0?U=k.width:D&&(U*=k.width/k.height),{width:U,height:V}}function n$l($){const{applyRandomOffset:k,sampleAlphaOnly:E}=$;return l$j([[Oi,k],[4,E]])}const zi={createComputedParams:$=>$,optionalAttributes:$i.optionalAttributes,attributes:{...$i.attributes,bitset:{count:1,type:ne.UNSIGNED_BYTE,pack:n$l},width:{count:1,type:ne.HALF_FLOAT,pack:$=>p$d($).width},height:{count:1,type:ne.HALF_FLOAT,pack:$=>p$d($).height},offset:{count:2,type:ne.HALF_FLOAT,pack:({offsetX:$,offsetY:k})=>[fe($),-fe(k)]},scale:{count:2,type:ne.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:$,scaleY:k})=>[$,k]},angle:{count:1,type:ne.UNSIGNED_BYTE,pack:({angle:$})=>_e($)}}};let Ri=class h extends Ti{constructor(){super(...arguments),this.vertexSpec=zi}},Di=class d{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}};const Bi={createComputedParams:$=>$,optionalAttributes:{zoomRange:{type:ne.SHORT,count:2,packPrecisionFactor:de,pack:({scaleInfo:$},{tileInfo:k})=>m$g($,k)}},attributes:{id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:ne.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:ne.UNSIGNED_BYTE,count:1},color:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:$})=>g$b($)},offset:{type:ne.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:$,extrusionOffsetY:k})=>[S$b($,16),S$b(k,16)]},normal:{type:ne.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:$,normalY:k})=>[S$b($,16),S$b(k,16)]},halfWidth:{type:ne.HALF_FLOAT,count:1,pack:({width:$})=>fe(.5*$)},referenceHalfWidth:{type:ne.HALF_FLOAT,count:1,pack:({referenceWidth:$})=>fe(.5*$)}}};let Ni=class _{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}};let Li=class T2 extends gi{constructor($,k,E,D){super($,k,E,D),this.vertexSpec=Bi,this._currentWrite=new Ni,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:65535,textured:!1},this._tessParams=new Di,this._initializeTessellator()}writeLineVertices($,k,E){const D=this._getLines(k);null!=D&&this._writeVertices($,E,D)}_initializeTessellator(){this._lineTessellator=new cr(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write($,k,E){const D=E??te.fromFeatureSetReaderCIM(k);D&&this._writeGeometry($,k,D)}_writeGeometry($,k,E,D){$.recordStart(this.instanceId,this.attributeLayout,D),this.writeLineVertices($,E,k),$.recordEnd()}_getLines($){return function x$7($,k){ui.setPixelMargin(k);const E=ui,D=-k,L=vt+k;let V=[],U=!1;if(!$.nextPath())return null;let X=!0;for(;X;){$.seekPathStart();const k=[];if(!$.pathSize)return null;E.reset(Vt.LineString),$.nextPoint();let Q=$.x,J=$.y;if(U)E.moveTo(Q,J);else{if(Q<D||Q>L||J<D||J>L){U=!0;continue}k.push({x:Q,y:J})}let et=!1;for(;$.nextPoint();)if(Q=$.x,J=$.y,U)E.lineTo(Q,J);else{if(Q<D||Q>L||J<D||J>L){et=!0;break}k.push({x:Q,y:J})}if(et)U=!0;else{if(U){const $=E.resultWithStarts();if($)for(const k of $)V.push(k)}else V.push({line:k,start:0});X=$.nextPath(),U=!1}}return V=V.filter(($=>$.line.length>1)),0===V.length?null:V}($,i$h(this.evaluatedMeshParams))}_writeVertices($,k,E){const{_currentWrite:D,_tessellationOptions:L,evaluatedMeshParams:V}=this,{width:U,capType:X,joinType:Q,miterLimit:J,hasSizeVV:et}=V,st=fe(.5*U);L.halfWidth=st,L.capType=function h$f($){switch($){case"butt":case ce.Butt:return le.BUTT;case"round":case ce.Round:return le.ROUND;case"square":case ce.Square:return le.SQUARE}}(X),L.joinType=function p$e($){switch($){case"bevel":case ue.Bevel:return he.BEVEL;case"miter":case ue.Miter:return he.MITER;case"round":case ue.Round:return he.ROUND}}(Q),L.miterLimit=J;const ut=!et;D.out=$,D.id=k.getDisplayId(),D.vertexCount=0,D.indexCount=0,D.vertexFrom=$.vertexCount(),D.vertexBounds=ut&&st<me?0:1;for(const{line:ht,start:_t}of E)L.initialDistance=_t%65535,this._lineTessellator.tessellate(ht,L,ut)}_writeTesselatedVertex($,k,E,D,L,V,U,X,Q,J,et){const{out:st,id:ut,vertexBounds:ht}=this._currentWrite;return this.hasEffects&&st.recordBounds($,k,ht,ht),this._tessParams.extrusionOffsetX=U,this._tessParams.extrusionOffsetY=X,this._tessParams.normalX=Q,this._tessParams.normalY=J,this._tessParams.directionX=L,this._tessParams.directionY=V,this._tessParams.distance=et,this._writeVertex(st,ut,$,k,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle($,k,E){const{out:D}=this._currentWrite;D.indexEnsureSize(3),D.indexWrite($),D.indexWrite(k),D.indexWrite(E),this._currentWrite.indexCount+=3}};const ji={createComputedParams:$=>$,optionalAttributes:Bi.optionalAttributes,attributes:{...Bi.attributes,bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:$=>0},color:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:$})=>g$b($)}}},Gi={createComputedParams:$=>$,optionalAttributes:Bi.optionalAttributes,attributes:{...Bi.attributes,bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:$=>l$j([[0,!0]])},color:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:$})=>g$b($)}}};let Vi=class m extends Li{constructor(){super(...arguments),this.vertexSpec=Gi}},qi=class h2 extends Si{constructor($,k,E,D){super($,k,E,D),this.vertexSpec=ji,this._lineMeshWriter=this._createOutlineWriter($,k,E,D)}_createOutlineWriter($,k,E,D){return new Vi($,k,E,D)}_write($,k,E){const D=(null==E?void 0:E.asOptimized())??k.readGeometryForDisplay(),L=this._clip(D);L&&($.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry($,k,L),this._lineMeshWriter.writeLineVertices($,te.fromOptimizedCIM(L,"esriGeometryPolyline"),k),$.recordEnd())}_clip($){return $?d$e($,i$h(this.evaluatedMeshParams)):null}ensurePacked($,k,E){super.ensurePacked($,k,E),this._lineMeshWriter.ensurePacked($,k,E)}enqueueRequest($,k,E){super.enqueueRequest($,k,E),this._lineMeshWriter.enqueueRequest($,k,E)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};let Ui=class i3{constructor(){this._includedModules=new Map}include($,k){this._includedModules.has($)?this._includedModules.get($):(this._includedModules.set($,k),$(this.builder,k))}},Wi=class o3 extends Ui{constructor(){super(...arguments),this.vertex=new Hi,this.fragment=new Hi,this.attributes=new Zi,this.varyings=new Ki,this.extensions=new Qi,this.constants=new Ji}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate($,k=!0){const E=this.extensions.generateSource($),D=this.attributes.generateSource($),L=this.varyings.generateSource($),V="vertex"===$?this.vertex:this.fragment,U=V.uniforms.generateSource(),X=V.code.generateSource(),Q="vertex"===$?en:function _$a($=!0){return`#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif\n${$?"out vec4 fragColor;":""}\n`}(k),J=this.constants.generateSource().concat(V.constants.generateSource());return`${k?"#version 300 es":""}\n${E.join("\n")}\n${Q}\n${J.join("\n")}\n${U.join("\n")}\n${D.join("\n")}\n${L.join("\n")}\n${X.join("\n")}`}generateBindPass($){const k=new Map;this.vertex.uniforms.entries.forEach(($=>{const E=$.bind[ye.Pass];E&&k.set($.name,E)})),this.fragment.uniforms.entries.forEach(($=>{const E=$.bind[ye.Pass];E&&k.set($.name,E)}));const E=Array.from(k.values()),D=E.length;return(k,L)=>{for(let V=0;V<D;++V)E[V]($,k,L)}}generateBindDraw($){const k=new Map;this.vertex.uniforms.entries.forEach(($=>{const E=$.bind[ye.Draw];E&&k.set($.name,E)})),this.fragment.uniforms.entries.forEach(($=>{const E=$.bind[ye.Draw];E&&k.set($.name,E)}));const E=Array.from(k.values()),D=E.length;return(k,L,V)=>{for(let U=0;U<D;++U)E[U]($,k,L,V)}}},Yi=class a3{constructor(){this._entries=new Map}add(...$){for(const k of $)this._add(k)}get($){return this._entries.get($)}_add($){if(null!=$){if(this._entries.has($.name)&&!this._entries.get($.name).equals($))throw new Et(`Duplicate uniform name ${$.name} for different uniform type`);this._entries.set($.name,$)}else Dt.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder").error(`Trying to add null Uniform from ${(new Error).stack}.`)}generateSource(){return Array.from(this._entries.values()).map(($=>null!=$.arraySize?`uniform ${$.type} ${$.name}[${$.arraySize}];`:`uniform ${$.type} ${$.name};`))}get entries(){return Array.from(this._entries.values())}},Xi=class c3{constructor(){this._entries=new Array}add($){this._entries.push($)}generateSource(){return this._entries}},Hi=class u extends Ui{constructor(){super(...arguments),this.uniforms=new Yi,this.code=new Xi,this.constants=new Ji}get builder(){return this}},Zi=class m2{constructor(){this._entries=new Array}add($,k){this._entries.push([$,k])}generateSource($){return"fragment"===$?[]:this._entries.map(($=>`in ${$[1]} ${$[0]};`))}},Ki=class h3{constructor(){this._entries=new Map}add($,k){this._entries.has($)&&ge(this._entries.get($)===k),this._entries.set($,k)}generateSource($){const k=new Array;return this._entries.forEach(((E,D)=>k.push("vertex"===$?`out ${E} ${D};`:`in ${E} ${D};`))),k}},Qi=class l2{constructor(){this._entries=new Set}add($){this._entries.add($)}generateSource($){const k="vertex"===$?l2.ALLOWLIST_VERTEX:l2.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter(($=>k.includes($))).map(($=>`#extension ${$} : enable`))}};Qi.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],Qi.ALLOWLIST_VERTEX=[];let Ji=class d2{constructor(){this._entries=new Set}add($,k,E){let D="ERROR_CONSTRUCTOR_STRING";switch(k){case"float":D=d2._numberToFloatStr(E);break;case"int":D=d2._numberToIntStr(E);break;case"bool":D=E.toString();break;case"vec2":D=`vec2(${d2._numberToFloatStr(E[0])},                            ${d2._numberToFloatStr(E[1])})`;break;case"vec3":D=`vec3(${d2._numberToFloatStr(E[0])},                            ${d2._numberToFloatStr(E[1])},                            ${d2._numberToFloatStr(E[2])})`;break;case"vec4":D=`vec4(${d2._numberToFloatStr(E[0])},                            ${d2._numberToFloatStr(E[1])},                            ${d2._numberToFloatStr(E[2])},                            ${d2._numberToFloatStr(E[3])})`;break;case"ivec2":D=`ivec2(${d2._numberToIntStr(E[0])},                             ${d2._numberToIntStr(E[1])})`;break;case"ivec3":D=`ivec3(${d2._numberToIntStr(E[0])},                             ${d2._numberToIntStr(E[1])},                             ${d2._numberToIntStr(E[2])})`;break;case"ivec4":D=`ivec4(${d2._numberToIntStr(E[0])},                             ${d2._numberToIntStr(E[1])},                             ${d2._numberToIntStr(E[2])},                             ${d2._numberToIntStr(E[3])})`;break;case"mat2":case"mat3":case"mat4":D=`${k}(${Array.prototype.map.call(E,($=>d2._numberToFloatStr($))).join(", ")})`}return this._entries.add(`const ${k} ${$} = ${D};`),this}static _numberToIntStr($){return $.toFixed(0)}static _numberToFloatStr($){return Number.isInteger($)?$.toFixed(1):$.toString()}generateSource(){return Array.from(this._entries)}};const en="precision highp float;\nprecision highp sampler2D;";function e$c($,k){const E=[];for(E.push(k);E.length;){const k=E.pop();if("object"==typeof k&&!$.has(k.uid)){$.add(k.uid);for(const $ of k.children)E.push($)}}}let rn=class s7{constructor(){this.uid=s7.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName($){return $=function t$h($){return $.split(" ").map((($,k)=>k>0?$.charAt(0).toUpperCase()+$.slice(1):$)).join("")}($),this._debugName=$,this.isImplicit&&this.children[0]instanceof s7&&this.children[0].setDebugName($),this}get debugInfo(){return{name:this._debugName??""}}cloneInto($){$._debugName=this._debugName,$._isMutable=this._isMutable,$.isImplicit=this.isImplicit,$.uid=this.uid}};function i$a($){return"object"==typeof $?$.clone():$}rn.NodeCount=0;let nn=class r3 extends rn{constructor(){super(...arguments),this.shaderType="primitive-node"}},on=class n4 extends rn{constructor($){super(),this.child=$,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const $=new n4(i$a(this.child));return this.cloneInto($),$}},an=class o4 extends rn{constructor($,k,E){super(),this.property=$,this.target=k,this.returnType=E,this.shaderType="property-access-node"}get children(){const $=[this.target];return"string"!=typeof this.property&&$.push(this.property),$}clone(){const $=new o4(this.property,i$a(this.target),this.returnType);return this.cloneInto($),$}},cn=class c4 extends rn{constructor($,k,E){super(),this.condition=$,this.ifTrue=k,this.ifFalse=E,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const $=i$a(this.ifTrue),k=this.ifFalse?i$a(this.ifFalse):null,E=new c4(this.condition,$,k);return this.cloneInto(E),E}},un=class u2 extends rn{constructor($,k,E,D){super(),this.captureList=$,this.returnType=k,this.generator=D,this.shaderType="block-node",E&&(this.subgraph=new on(E))}get children(){return Object.keys(this.captureList).map(($=>this.captureList[$])).concat(this.subgraph??[])}clone(){const $={};for(const E in this.captureList)$[E]=i$a(this.captureList[E]);const k=new u2($,this.returnType,this.subgraph?i$a(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(k),k}},hn=class p extends rn{constructor($,k,E,D,L,V=!1){super(),this.token=$,this._children=k,this.isInfix=E,this.isPropertyAccess=D,this.returnType=L,this.isTernary=V,this.shaderType="function-node"}get children(){return this._children}clone(){const $=new p(this.token,this._children.map(i$a),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto($),$}};var dn,pn,fn,_n,mn,yn,gn,xn,wn,In,$n,Tn,Mn,Fn;function D$3($){return new Proxy($,{get(k,E){if("constructor"===E)return new Proxy(k.constructor,{construct:($,k,E)=>D$3(new $(...k))});if(E in k)return k[E];if("string"==typeof E){const k=function z$4($){const k=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const E of k)if(E.includes($))return E.map(($=>eo[$]));throw new Error("Unable to find type family")}($.type);return ft($,E,k[E.length-1])}}})}function N$1($){return new Proxy($,{construct:($,k,E)=>D$3(new $(...k))})}let En=class B2 extends Error{},Cn=dn=class extends nn{constructor($,k){super(),this.elementType=$,this.size=k,this.children=[],this.type="array"}clone(){const $=new dn(this.elementType,this.size);return super.cloneInto($),$}get($){if("number"==typeof $){const k=new Kn($);return k.isImplicit=!0,ft(this,k,this.elementType.constructor)}return ft(this,$,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex($,k,E){return function bt($,k,E=0,D=$.size){const L=new Kn(E).setMutable().setDebugName("FindIndexIterator"),V=k($.get(L)).setDebugName("FindIndexPredicate"),U=mt({iter:L},Kn,V,(({out:$,iter:k,subgraph:E})=>`\n${$} = -1;\n\nfor (; ${k} < ${D}; ${k}++) {\n\n${E.body}\n\n  if (${E.varName}) {\n    ${$} = ${k};\n    break;\n  }\n\n}\n`)).setDebugName("FindIndexBlock");return U}(this,$,k,E)}glslFindIndex($,k,E){return function It($,k,E=0,D=$.size){const L=mt({array:$},Kn,null,(({out:$,array:L})=>`\n${$} = -1;\nfor (int i = ${E}; i < ${D}; i++) {\n  bool condition;\n  ${k({array:L,i:"i",out:"condition"})}\n  if (condition) {\n    ${$} = i;\n    break;\n  }\n}\n`)).setDebugName("GlslFindIndexBlock");return L}(this,$,k,E)}static ofType($,k){const E={construct:(E,D)=>new dn(new $,k)};return new Proxy(dn,E)}};Cn.type="array",Cn=dn=xe([function q$4($){return new Proxy($,{construct:($,k,E)=>function P$4($){return new Proxy($,{get(k,E){if(E in k)return k[E];if("string"==typeof E){const k=parseInt(E,10);if(!isNaN(k))return ft($,`[${k}]`,$.elementType.constructor)}}})}(new $(...k))})}],Cn);let Pn=class S extends nn{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const $=new S;return $.children=this.children.map(i$a),super.cloneInto($),$}};Pn.type="sampler2D";let An=class j extends nn{constructor($){super(),this.type="float",this.children=[$]}clone(){const $=new j(i$a(this.children[0]));return super.cloneInto($),$}multiply($){return Tt(this,"number"==typeof $?K$1($,j):$)}divide($){return $t(this,"number"==typeof $?K$1($,j):$)}add($){return Ft(this,"number"==typeof $?K$1($,j):$)}subtract($){return kt(this,"number"==typeof $?K$1($,j):$)}};An.type="float";let On=pn=class extends nn{constructor($,k){super(),this.type="vec2",this.children=[$,k].filter(($=>null!=$))}clone(){const $=new pn(i$a(this.children[0]),i$a(this.children[1]));return super.cloneInto($),$}get 0(){return ft(this,"[0]",An)}get 1(){return ft(this,"[1]",An)}get 2(){throw new En}get 3(){throw new En}multiply($){return Tt(this,"number"==typeof $?K$1($,An):$)}divide($){return $t(this,"number"==typeof $?K$1($,An):$)}add($){return Ft(this,"number"==typeof $?K$1($,An):$)}subtract($){return kt(this,"number"==typeof $?K$1($,An):$)}};On.type="vec2",On=pn=xe([N$1],On);let zn=fn=class extends nn{constructor($,k,E){super(),this.type="vec3",this.children=[$,k,E].filter(($=>null!=$))}get 0(){return ft(this,"[0]",An)}get 1(){return ft(this,"[1]",An)}get 2(){return ft(this,"[2]",An)}get 3(){throw new En}clone(){const $=new fn(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]));return super.cloneInto($),$}multiply($){return Tt(this,"number"==typeof $?K$1($,An):$)}divide($){return $t(this,"number"==typeof $?K$1($,An):$)}add($){return Ft(this,"number"==typeof $?K$1($,An):$)}subtract($){return kt(this,"number"==typeof $?K$1($,An):$)}};zn.type="vec3",zn=fn=xe([N$1],zn);let Rn=_n=class extends nn{constructor($,k,E,D){super(),this.type="vec4",this.children=[$,k,E,D].filter(($=>null!=$))}clone(){const $=new _n(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]));return super.cloneInto($),$}get 0(){return ft(this,"[0]",An)}get 1(){return ft(this,"[1]",An)}get 2(){return ft(this,"[2]",An)}get 3(){return ft(this,"[3]",An)}multiply($){return Tt(this,"number"==typeof $?K$1($,An):$)}divide($){return $t(this,"number"==typeof $?K$1($,An):$)}add($){return Ft(this,"number"==typeof $?K$1($,An):$)}subtract($){return kt(this,"number"==typeof $?K$1($,An):$)}};Rn.type="vec4",Rn=_n=xe([N$1],Rn);let Dn=mn=class extends nn{constructor($){super(),this.type="uint",this.children=[$]}clone(){const $=new mn(i$a(this.children[0]));return super.cloneInto($),$}};Dn.type="uint",Dn=mn=xe([N$1],Dn);let Nn=yn=class extends nn{constructor($,k){super(),this.type="uvec2",this.children=[$,k].filter(($=>null!=$))}clone(){const $=new yn(i$a(this.children[0]),i$a(this.children[1]));return super.cloneInto($),$}};Nn.type="uvec2",Nn=yn=xe([N$1],Nn);let Ln=gn=class extends nn{constructor($,k,E){super(),this.type="uvec3",this.children=[$,k,E].filter(($=>null!=$))}clone(){const $=new gn(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]));return super.cloneInto($),$}};Ln.type="uvec3",Ln=gn=xe([N$1],Ln);let Vn=xn=class extends nn{constructor($,k,E,D){super(),this.type="uvec4",this.children=[$,k,E,D].filter(($=>null!=$))}clone(){const $=new xn(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]));return super.cloneInto($),$}};Vn.type="uvec4",Vn=xn=xe([N$1],Vn);let qn=class Y extends nn{constructor($){super(),this.type="bool",this.children=[$]}and($){return Rt(this,$)}or($){return Ht(this,$)}clone(){const $=new Y(i$a(this.children[0]));return super.cloneInto($),$}};qn.type="bool";let Yn=wn=class extends nn{constructor($,k){super(),this.type="bvec2",this.children=[$,k].filter(($=>null!=$))}all(){return Jt(this)}any(){return Kt(this)}clone(){const $=new wn(i$a(this.children[0]),i$a(this.children[1]));return super.cloneInto($),$}};Yn.type="bvec2",Yn=wn=xe([N$1],Yn);let Xn=In=class extends nn{constructor($,k,E){super(),this.type="bvec3",this.children=[$,k,E].filter(($=>null!=$))}all(){return Jt(this)}any(){return Kt(this)}clone(){const $=new In(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]));return super.cloneInto($),$}};function K$1($,k){return"number"==typeof $?new k($):$}Xn.type="bvec3",Xn=In=xe([N$1],Xn);let Zn=$n=class extends nn{constructor($,k,E,D){super(),this.type="bvec4",this.children=[$,k,E,D].filter(($=>null!=$))}all(){return Jt(this)}any(){return Kt(this)}clone(){const $=new $n(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]));return super.cloneInto($),$}};Zn.type="bvec4",Zn=$n=xe([N$1],Zn);let Kn=class O extends nn{constructor($){super(),this.type="int",this.children=[$]}multiply($){return Tt(this,K$1($,O))}add($){return Ft(this,K$1($,O))}subtract($){return kt(this,K$1($,O))}divide($){return $t(this,K$1($,O))}clone(){const $=new O(i$a(this.children[0]));return super.cloneInto($),$}};Kn.type="int";let Qn=Tn=class extends nn{constructor($,k){super(),this.type="ivec2",this.children=[$,k].filter(($=>null!=$))}clone(){const $=new Tn(i$a(this.children[0]),i$a(this.children[1]));return super.cloneInto($),$}};Qn.type="ivec2",Qn=Tn=xe([N$1],Qn);let Jn=Mn=class extends nn{constructor($,k,E){super(),this.type="ivec3",this.children=[$,k,E].filter(($=>null!=$))}clone(){const $=new Mn(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]));return super.cloneInto($),$}};Jn.type="ivec3",Jn=Mn=xe([N$1],Jn);let to=Fn=class extends nn{constructor($,k,E,D){super(),this.type="ivec4",this.children=[$,k,E,D].filter(($=>null!=$))}clone(){const $=new Fn(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]));return super.cloneInto($),$}};to.type="ivec4",to=Fn=xe([N$1],to);(class Z extends nn{constructor($,k,E,D){super(),this.type="mat2",this.children=[$,k,E,D]}clone(){const $=new Z(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]));return super.cloneInto($),$}}).type="mat2";class tt extends nn{static identity(){return new tt(1,0,0,0,1,0,0,0,1)}static fromRotation($){const k=Wn($),E=tn($);return new tt(E,k,0,yt(k),E,0,0,0,1)}constructor($,k,E,D,L,V,U,X,Q){super(),this.type="mat3",this.children=[$,k,E,D,L,V,U,X,Q]}add($){return Ft(this,$)}multiply($){return Tt(this,$)}clone(){const $=new tt(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]),i$a(this.children[4]),i$a(this.children[5]),i$a(this.children[6]),i$a(this.children[7]),i$a(this.children[8]));return super.cloneInto($),$}}tt.type="mat3";class nt extends nn{static identity(){return new nt(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor($,k,E,D,L,V,U,X,Q,J,et,st,ut,ht,_t,vt){super(),this.type="mat4",this.children=[$,k,E,D,L,V,U,X,Q,J,et,st,ut,ht,_t,vt]}static fromColumns($,k,E,D){return new nt($.x,$.y,$.z,$.w,k.x,k.y,k.z,k.w,E.x,E.y,E.z,E.w,D.x,D.y,D.z,D.w)}multiply($){return Tt(this,$)}clone(){const $=new nt(i$a(this.children[0]),i$a(this.children[1]),i$a(this.children[2]),i$a(this.children[3]),i$a(this.children[4]),i$a(this.children[5]),i$a(this.children[6]),i$a(this.children[7]),i$a(this.children[8]),i$a(this.children[9]),i$a(this.children[10]),i$a(this.children[11]),i$a(this.children[12]),i$a(this.children[13]),i$a(this.children[14]),i$a(this.children[15]));return super.cloneInto($),$}}nt.type="mat4";const eo={float:An,vec2:On,vec3:zn,vec4:Rn,int:Kn,ivec2:Qn,ivec3:Jn,ivec4:to,uint:Dn,uvec2:Nn,uvec3:Ln,uvec4:Vn,bool:qn,bvec2:Yn,bvec3:Xn,bvec4:Zn},rt=(...$)=>new Kn(...$),ct=(...$)=>new An(...$),it=(...$)=>new On(...$),ot=(...$)=>new Rn(...$),lt=(...$)=>new tt(...$);function ft($,k,E){const D=new E(new an(k,$,E));return D.isImplicit=!0,D}function at($,k,E,D=null){if(D){const L=new D,V=new D(new hn($,[k,E],!0,!1,L));return V.isImplicit=!0,V}if("float"===k.type||"int"===k.type){const D=new E.constructor(new hn($,[k,E],!0,!1,E.constructor));return D.isImplicit=!0,D}if(("mat2"===k.type||"mat3"===k.type||"mat4"===k.type)&&"float"!==E.type){const D=new E.constructor(new hn($,[k,E],!0,!1,E.constructor));return D.isImplicit=!0,D}const L=new k.constructor(new hn($,[k,E],!0,!1,k.constructor));return L.isImplicit=!0,L}function pt($,k,E=k.constructor){const D=new E(new hn($,[k],!1,!1,E));return D.isImplicit=!0,D}function dt($,k,E,D=k.constructor){const L=new D(new hn($,[k,E],!1,!1,D));return L.isImplicit=!0,L}function wt($,k,E,D,L=k.constructor){const V=new L(new hn($,[k,E,D],!1,!1,L));return V.isImplicit=!0,V}function yt($){return Tt($,ct(-1))}function mt($,k,E,D){return new k(new un($,k,E,D))}function xt($,k,E){const D="function"==typeof k?k():k,L="function"==typeof E?E():E,V=new D.constructor(new cn($,D,L));return V.isImplicit=!0,V}function gt(...$){const k=$.map((([$,k])=>"function"==typeof k?[$,k()]:[$,k])),E=k[0][1].constructor,D=k.findIndex(($=>!0===$[0]));if(-1===D)throw new Error("A cond must have a fallthrough case with `true`/; ");const L=k.slice(0,D),V=k[D][1],U=new E(L.reduceRight((($,k)=>xt(k[0],k[1],$)),V));return U.isImplicit=!0,U}function Tt($,k){return at("*",$,k)}function $t($,k){return at("/",$,k)}function Ft($,k){return at("+",$,k)}function kt($,k){return at("-",$,k)}function Bt($,k){return at("==",$,k,qn)}function jt($,k){return at("<=",$,k,qn)}function Ct($,k){return at(">",$,k,qn)}function Gt($,k){return at(">=",$,k,qn)}function Ht(...$){return $.length<=1?$[0]:$.slice(1).reduce((($,k)=>function Mt($,k){return at("||",$,k,qn)}($,k)),$[0])}function Rt(...$){return $.length<=1?$[0]:$.slice(1).reduce((($,k)=>function At($,k){return at("&&",$,k,qn)}($,k)),$[0])}function Jt($){return pt("all",$,qn)}function Kt($){return pt("any",$,qn)}function Zt($,k,E){return wt("clamp",$,k,E,$.constructor)}function tn($){return pt("cos",$)}function ln($,k){return dt("dot",$,k,An)}function bn($){return pt("fract",$)}function kn($){return pt("length",$,An)}function Bn($,k){return dt("max",$,k)}function Un($,k){return dt("min",$,k)}function Sn($,k,E){return wt("mix",$,k,E)}function jn($,k){return dt("mod",$,k)}function Hn($){return"bool"===$.type?pt("!",$):pt("not",$)}function Wn($){return pt("sin",$)}function ee($,k){return dt("step",$,k,k.constructor)}function se($,k){return dt("texture2D",$,k,Rn)}function t$g($,k,E){const D=k.split("\n");for(const L of D)if(L.trim().length){{let k="";null!=E&&(k+=`/*id:${E??"000"}*/   `),$.body+=k.padEnd(14)}$.body+=" ".repeat($.indent)+L+"\n"}}let so=class r4{write($){for(const k of $.rootOutputNodes())$.shouldPruneOutputNode(k)||(k.variableName=this._write($,k.node));return $}_createVarName($,k){let E="";return"boolean"!=typeof k&&"number"!=typeof k&&k.debugInfo.name&&(E=`${k.debugInfo.name}_`),`${E}v${$.varCount++}`}_write($,k,E=!1){if("number"==typeof k)return k.toString();if("boolean"==typeof k)return k.toString();let D=$.getEmit(k);if(D)return D;switch(k.shaderType){case"scope-node":D=this._writeScopeNode($,k);break;case"primitive-node":D=this._writePrimitiveNode($,k,E);break;case"function-node":D=this._writeFunctionNode($,k);break;case"property-access-node":D=this._writePropertyAccessNode($,k);break;case"text-node":D=k.text;break;case"block-node":D=this._writeBlockNode($,k);break;case"condition-node":D=this._writeConditionNode($,k)}return $.setEmit(k,D),D}_writeScopeNode($,k){const E=new k.child.constructor;E.setDebugName(k.debugInfo.name);const D=this._write($,E,!0);return t$g($,`{ /*ScopeStart: ${k.uid} ${k.debugInfo.name}*/`),$.indent+=2,t$g($,`${D} = ${this._write($,k.child)};`),$.indent-=2,t$g($,`} /*ScopeEnd: ${k.uid} ${k.debugInfo.name}*/`),D}_writeConditionNode($,k){const E=new k.ifTrue.constructor,D=this._write($,E,!0);t$g($,`if (${this._write($,k.condition)}) {`),$.indent+=2;const L=$.createSubgraphContext(),V=this._write(L,k.ifTrue);if($.body+=L.body,V&&t$g($,`${D} = ${V};`),$.indent-=2,t$g($,"}"),k.ifFalse){t$g($,"else {"),$.indent+=2;const E=$.createSubgraphContext(),L=this._write(E,k.ifFalse);$.body+=E.body,L&&t$g($,`${D} = ${L};`),$.indent-=2,t$g($,"}")}return D}_writeBlockNode($,k){const{captureList:E,generator:D,returnType:L}=k,V={};for(const J in E){if(!E[J])continue;const k=this._write($,E[J]);V[J]=k}const U=new L,X=this._write($,U,!0);if(V.out=X,k.subgraph){const E=$.createSubgraphContext(),D=this._write(E,k.subgraph.child),L=E.body;V.subgraph={varName:D,body:L}}const Q=D(V);return t$g($,"{\n"),$.indent+=2,t$g($,Q),$.indent-=2,t$g($,"}\n"),X}_writePropertyAccessNode($,k){const E=this._write($,k.target);return"string"==typeof k.property&&k.property.includes("[")?`${E}${k.property}`:"string"!=typeof k.property?`${E}[${this._write($,k.property)}]`:`${E}.${k.property}`}_writeFunctionNode($,k){const E=k.returnType.type;if(k.isInfix){const[D,L]=k.children.map((k=>this._write($,k))),V=this._createVarName($,k);return t$g($,`${E.padEnd(5)} ${V} = ${D} ${k.token} ${L};`,k.uid),V}const D=k.children.map((k=>this._write($,k))).join(", "),L=this._createVarName($,k);return t$g($,`${E.padEnd(5)} ${L} = ${k.token}(${D});`,k.uid),L}_writePrimitiveNode($,k,E=!1){var D;const L=$.getInput(k);if(L)return L.isUsed=!0,L.variableName;const V=1===k.children.length&&(null==(D=k.children[0])?void 0:D.type)===k.type;if(k.isImplicit||V)return this._write($,k.children[0]);const U=this._createVarName($,k);if(E)return t$g($,`${k.type.padEnd(5)} ${U};`,k.uid),U;const X=!k.debugInfo.name&&!k.isMutable;if(X&&"float"===k.type&&"number"==typeof k.children[0])return Number.isInteger(k.children[0])?k.children[0].toFixed(1):k.children[0].toString();if(X&&"int"===k.type&&"number"==typeof k.children[0]&&Number.isInteger(k.children[0]))return k.children[0].toString();const Q=k.children.map((k=>this._write($,k))).join(", ");return"array"===k.type?(t$g($,`${k.type.padEnd(5)} ${U} = [${Q}];`,k.uid),U):X?`${k.type}(${Q})`:(t$g($,`${k.type.padEnd(5)} ${U} = ${k.type}(${Q});`,k.uid),U)}},ro=class t5{constructor($,k,E){this.variableName=$,this.variableInputType=k,this.node=E,this.type="shader-input",this.isUsed=!1}clone(){return new t5(this.variableName,this.variableInputType,i$a(this.node))}},io=class n5{constructor($,k,E){this.outVariableName=$,this.outVariableType=k,this.node=E,this.type="shader-output"}clone(){const $=new n5(this.outVariableName,this.outVariableType,i$a(this.node));return $.variableName=this.variableName,$}},no=class o5{static createVertex($,k,E,D,L,V){const U=[];for(const Q in $){const k=$[Q],D=E.get(Q);D?U.push(new ro(D,"builtin",k)):U.push(new ro("a_"+Q,"attribute",k))}for(const Q of D){const $=Q.uniformHydrated;U.push(new ro(Q.uniformName,"uniform",$))}const X=[];for(const Q in k){const $=k[Q];"glPosition"===Q?X.push(new io("gl_Position","builtin",$)):"glPointSize"===Q?X.push(new io("gl_PointSize","builtin",$)):X.push(new io("v_"+Q,"varying",$))}return new o5(U,X,L,V)}static createFragment($,k,E,D,L,V){const U=[],X=Array.from(L.rootOutputNodes());for(const J in $){const k=$[J],D=E.get(J);if(D){U.push(new ro(D,"builtin",k));continue}const L=X.find(($=>$.node===k));L&&U.push(new ro(L.outVariableName,L.outVariableType,k))}for(const J of D){const $=J.uniformHydrated;U.push(new ro(J.uniformName,"uniform",$))}const Q=[];for(const J in k){const $=k[J],D=E.get(J);if("discard"===J)Q.push(new io(null,"discard",$));else{if(!D)throw new Error(`Member ${J} in shader fragment output shoule be tagged as builtin`);Q.push(new io(D,"builtin",$))}}return new o5(U,Q,V)}constructor($,k,E,D){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const L of $)this._inputShaderTypesByNodeUid.set(L.node.uid,L);this._outputShaderTypes=k,this._transformFeedbackBindings=E,this._transformFeedbackNames=new Set(E.map(($=>"v_"+$.propertyKey))),this._usedInFragmentShader=D}shouldPruneOutputNode($){return!!this._usedInFragmentShader&&"builtin"!==$.outVariableType&&!this._transformFeedbackNames.has($.outVariableName)&&!this._usedInFragmentShader.has($.node.uid)}setEmit($,k){this._nodeEmitMap.set($.uid,k)}getEmit($){return this._nodeEmitMap.get($.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput($){return this._inputShaderTypesByNodeUid.get($.uid)}*rootOutputNodes(){for(const $ of this._outputShaderTypes)yield $}*nodes(){const $=[];for(const k of this._outputShaderTypes.values())$.push(k.node);for(;$.length;){const k=$.pop();"number"!=typeof k&&"boolean"!=typeof k&&$.push(...k.children.filter(Boolean)),yield k}}*nodesOfTypeOrFunction(){for(const $ of this.nodes())"number"!=typeof $&&"boolean"!=typeof $&&(yield $)}createSubgraphContext(){const $=this.clone();return $.body="",$.indent=this.indent+2,$._nodeEmitMap=new Map(this._nodeEmitMap),$}clone(){const $=new o5([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return $._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,$.indent=this.indent,$.body=this.body,$.varCount=this.varCount,$._nodeEmitMap=this._nodeEmitMap,$}insertVertexShader($){$.vertex.code.add(""),this._insertInputs($,"vertex"),$.vertex.code.add(""),$.vertex.code.add("// OUTPUTS: "),$.vertex.code.add("// --------------------------------------------------------- ");for(const k of this.rootOutputNodes()){const E="builtin"===k.outVariableType;this.shouldPruneOutputNode(k)||(E?$.vertex.code.add(`// ${k.outVariableType.padEnd(7)} ${k.node.type.padEnd(9)} ${k.outVariableName};`):$.vertex.code.add(`${k.outVariableType.padEnd(10)} ${k.node.type.padEnd(9)} ${k.outVariableName};`))}$.vertex.code.add(""),$.vertex.code.add("void main() {"),$.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const k of this.rootOutputNodes())this.shouldPruneOutputNode(k)||$.vertex.code.add(`  ${k.outVariableName} = ${k.variableName};`);$.vertex.code.add("}")}insertFragmentShader($){this._insertInputs($,"fragment"),$.fragment.code.add(""),$.fragment.code.add("void main() {"),$.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const k of this.rootOutputNodes())"discard"===k.outVariableType?($.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),$.fragment.code.add(`  if (${k.variableName}) {`),$.fragment.code.add("    discard;"),$.fragment.code.add("  }"),$.fragment.code.add("  ")):$.fragment.code.add(`  ${k.outVariableName} = ${k.variableName};`);$.fragment.code.add("}")}_insertInputs($,k){$[k].code.add("// INPUTS: "),$[k].code.add("// --------------------------------------------------------- ");for(const E of this.inputs())E.isUsed&&"builtin"!==E.variableInputType&&("array"===E.node.type?$[k].code.add(`${E.variableInputType.padEnd(10)} ${E.node.elementType.type.padEnd(9)} ${E.variableName}[${E.node.size}];`):$[k].code.add(`${E.variableInputType.padEnd(10)} ${E.node.type.padEnd(9)} ${E.variableName};`))}};function n$i($,k,E){const D=k.length;if(D!==E){const L=new Et("Invalid Uniform",`Invalid length, expected ${E} but got ${D}`,{uniformName:$,values:k});Dt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram").errorOnce(L)}}let oo=class a4{constructor($,k,E,D,L,V){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=$,this.fragmentShader=k,this._locations=E,this._locationInfo=D,this._uniformBindings=L,this._transformFeedbackBindings=V}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms($){this._uniforms=$}cleanupTemporaryTextures(){for(const $ of this._temporaryTextures)$.dispose();this._temporaryTextures=[]}bind($){const k=this._uniforms;if(!this._program){const k=new Map;for(const[$,D]of this._locations)k.set($,D);const E=[];for(const $ of this._transformFeedbackBindings??[]){const{index:k,propertyKey:D}=$;E[k]=`v_${D}`}this._program=new be($,this.vertexShader,this.fragmentShader,k,new Map,E)}const E=this._program;$.useProgram(E);for(const D of this._uniformBindings){const{shaderModulePath:L,uniformName:V,uniformType:U,uniformArrayLength:X}=D,Q=ve(L,k);if(null==Q){if("sampler2D"===U)continue;throw new Error(`Failed to find uniform value for ${L}`)}switch("array"===U?D.uniformArrayElementType:U){case"sampler2D":{const{unit:k,texture:D}=Q;if(E.setUniform1i(V,k),"type"in D)$.bindTexture(D,k);else{const E=T$5($,D.descriptor,D.data);$.bindTexture(E,k)}break}case"int":if(!X){E.setUniform1i(V,Q);break}n$i(D.uniformName,Q,X),E.setUniform1iv(V,Q);break;case"float":if(!X){E.setUniform1f(V,Q);break}n$i(D.uniformName,Q,X),E.setUniform1fv(V,Q);break;case"vec2":if(!X){E.setUniform2f(V,Q[0],Q[1]);break}n$i(D.uniformName,Q,X),E.setUniform2fv(V,Q.flat());break;case"vec3":if(!X){E.setUniform3f(V,Q[0],Q[1],Q[2]);break}n$i(D.uniformName,Q,X),E.setUniform3fv(V,Q.flat());break;case"vec4":if(!X){E.setUniform4f(V,Q[0],Q[1],Q[2],Q[3]);break}n$i(D.uniformName,Q,X),E.setUniform4fv(V,Q.flat());break;case"mat3":E.setUniformMatrix3fv(V,Q.flat());break;case"mat4":E.setUniformMatrix4fv(V,Q.flat());break;default:throw new Error(`Unable to set uniform for type ${U}`)}}}};function d$9($){return new $}function f$a($,k,E){const D=$.constructor[k]??[];$.constructor.hasOwnProperty(k)||Object.defineProperty($.constructor,k,{value:D.slice()}),$.constructor[k].push(E)}function h$9($,k){return(E,D)=>{f$a(E,"locations",{typeCtor:k,propertyKey:D,parameterIndex:null,index:$})}}const m$c=$=>(k,E,D)=>{f$a(k,"inputs",{inputCtor:$,propertyKey:E,parameterIndex:D})},g$9=$=>(k,E)=>{f$a(k,"uniforms",{typeCtor:$,propertyKey:E})},_$8=$=>(k,E)=>{f$a(k,"options",{typeCtor:$,propertyKey:E})},K=($,k)=>{f$a($,"defines",{propertyKey:k})},C$2=($,k)=>(E,D)=>{E.constructor.builtins.push({builtin:$,propertyKey:D,typeCtor:k})};let ao=class b{};ao.builtins=[],xe([C$2("gl_VertexID",Kn)],ao.prototype,"glVertexID",void 0);let co=class I{},lo=class v{};lo.builtins=[],xe([C$2("gl_FragCoord",Rn)],lo.prototype,"glFragCoord",void 0),xe([C$2("gl_PointCoord",On)],lo.prototype,"glPointCoord",void 0);let uo=class w{};var ho;xe([(ho="gl_FragColor",($,k)=>{f$a($,"builtins",{builtin:ho,propertyKey:k})})],uo.prototype,"glFragColor",void 0);let po=class P{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},fo=class j2{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const $=this._shaderModuleClass.inputs.findLast(($=>"vertex"===$.propertyKey&&0===$.parameterIndex));if(!$)throw new Error("Unable to find vertex input parameter");return $}get computeInput(){return this._shaderModuleClass.inputs.findLast(($=>"vertex"===$.propertyKey&&1===$.parameterIndex))}get fragmentInput(){const $=this._shaderModuleClass.inputs.findLast(($=>"fragment"===$.propertyKey));if(!$)throw new Error("Unable to find fragment input parameter");return $}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){var $;return[...this.vertexInput.inputCtor.locations,...(null==($=this.computeInput)?void 0:$.inputCtor.locations)??[]]}get locationsMap(){const $=new Map,k=new Set;for(const E of this.locations)k.has(E.index)?Dt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${E.propertyKey} to ${E.index}. Index already in use`,{locationsMap:$}):($.set(E.propertyKey,E.index),k.add(E.index));return $}get locationInfo(){if(!this._locationInfo){const $=this.locationsMap,k=Array.from($.entries()).map((([$,k])=>`${$}.${k}`)).join("."),E=Nt(k),D=this.computeAttributes;this._locationInfo={hash:E,locations:$,computeAttributeMap:D}}return this._locationInfo}get renamedLocationsMap(){const $=new Map;for(const k of this.locations)$.set("a_"+k.propertyKey,k.index);return $}get optionPropertyKeys(){if(!this._optionPropertyKeys){const $=new Set;for(const k of this._options)$.add(k.propertyKey);this._optionPropertyKeys=$}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram($,k,E,D){try{const{vertex:L,fragment:V,uniformBindings:U}=this._generateShaders($,k,E,D);return new oo(L,V,this.renamedLocationsMap,this.locationInfo,U,this.transformFeedbackBindings)}catch(L){return new oo("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo($){const k=this._options.find((k=>k.propertyKey===$));if(k)return{type:"option",className:k.typeCtor};const E=this._uniforms.find((k=>k.propertyKey===$));if(!E)throw new Error(`Unable to find uniform class type for property: ${$}`);return{type:"required",className:E.typeCtor}}getShaderKey($,k,E,D){const L=Object.keys($).map((k=>`${k}.${$[k]}`)).join("."),V=Object.keys(E).map(($=>`${$}.${E[$]}`)).join("."),U=Object.keys(D).map(($=>`${$}.${D[$]}`)).join("."),X=Object.keys(k).filter(($=>this.optionPropertyKeys.has($)&&k[$])).join(".");return`${this.constructor.name}.${L}.${V}.${U}.${X}`}_generateShaders($,k,E,D){const L=[];this._setDefines(E),this._setOptionalUniforms(L,k),this._setRequiredUniforms(L);const V=this._hydrateVertexInput(D),U=this._injectPackPrecisionFactor(V,$),X=this._hydrateComputeInput(),Q=X&&this._injectComputePackPrecisionFactor(X,$),J=this.vertex(U,Q),et=this._hydrateFragmentInput(J),st=this.fragment(et),ut=new Set;for(const Dt in st){e$c(ut,st[Dt])}const ht=this._getVertexInputBuiltins(),_t=no.createVertex({...V,...X},J,ht,L,this.transformFeedbackBindings,ut);(new so).write(_t);const vt=this._getFragmentInputBuiltins(st);vt.set("glPointCoord","gl_PointCoord");const Et=no.createFragment(et,st,vt,L,_t,this.transformFeedbackBindings);(new so).write(Et);const Pt=this._createShaderBuilder(_t,Et),Ot=Pt.generate("vertex",!1),zt=Pt.generate("fragment",!1);return this.logShader,{vertex:Ot,fragment:zt,uniformBindings:L}}_setDefines($){for(const k in $)this[k]=$[k]}_setOptionalUniforms($,k){for(const E of this._options)k[E.propertyKey]?this[E.propertyKey]=this._hydrateUniformGroup($,E):this[E.propertyKey]=null}_setRequiredUniforms($){for(const k of this._uniforms)this[k.propertyKey]=this._hydrateUniformGroup($,k)}_hydrateUniformGroup($,k){const E=new k.typeCtor;for(const D of E._uniforms??[]){const L=d$9(D.typeCtor),V=`u_${k.propertyKey}_${D.propertyKey}`,U=L.type,X=[k.propertyKey,D.propertyKey].join(".");if("type"in D.typeCtor&&"array"===D.typeCtor.type){const k=L;$.push({shaderModulePath:X,uniformName:V,uniformType:U,uniformArrayLength:k.size,uniformArrayElementType:k.elementType.type,uniformHydrated:L})}else $.push({shaderModulePath:X,uniformName:V,uniformType:U,uniformHydrated:L});E[D.propertyKey]=L}return E}_hydrateVertexInput($){const k=this.vertexInput.inputCtor,E=k.locations.reduce(((k,E)=>!1===$[E.propertyKey]?k:{...k,[E.propertyKey]:d$9(E.typeCtor)}),{});for(const{propertyKey:D,typeCtor:L}of k.builtins){const $=d$9(L);E[D]=$}return E}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce((($,k)=>({...$,[k.propertyKey]:d$9(k.typeCtor)})),{})}_injectPackPrecisionFactor($,k){const E={};for(const D in $){const L=$[D],V=k[D];if(V){if("float"!==L.type&&"vec2"!==L.type&&"vec3"!==L.type&&"vec4"!==L.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${L.type}`);E[D]=L.divide(new An(V))}else E[D]=L}return E}_injectComputePackPrecisionFactor($,k){const E={},D=new Map;for(const L in this.computeAttributes)for(const $ of this.computeAttributes[L]??[])D.set($,L);for(const L in $){const V=$[L],U=D.get(L);if(!U)continue;const X=k[U];if(X){if("float"!==V.type&&"vec2"!==V.type&&"vec3"!==V.type&&"vec4"!==V.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${V.type}`);E[L]=V.divide(new An(X))}else E[L]=V}return E}_hydrateFragmentInput($){const k={};for(const E in $)k[E]=$[E];for(const{propertyKey:E,typeCtor:D}of lo.builtins){const $=d$9(D);k[E]=$}return k}_getVertexInputBuiltins(){const $=this.vertexInput.inputCtor,k=new Map;for(const{builtin:E,propertyKey:D}of $.builtins)k.set(D,E);return k}_getFragmentInputBuiltins($){const k=$.constructor,E=new Map;for(const D of k.builtins??[])E.set(D.propertyKey,D.builtin);return E}_createShaderBuilder($,k){const E=new Wi;return this._insertDebugInfo(E),$.insertVertexShader(E),k.insertFragmentShader(E),E}_insertDebugInfo($){$.vertex.code.add("// DEFINES: "),$.vertex.code.add("// --------------------------------------------------------- ");for(const k of this._defines)this[k.propertyKey]?$.vertex.code.add(`//   ${k.propertyKey}: true`):$.vertex.code.add(`//   ${k.propertyKey}: false`);$.vertex.code.add(""),$.vertex.code.add("// OPTIONS: "),$.vertex.code.add("// --------------------------------------------------------- ");for(const k of this._options)this[k.propertyKey]?$.vertex.code.add(`//   ${k.propertyKey}: true`):$.vertex.code.add(`//   ${k.propertyKey}: false`)}},_o=class l3 extends Se{constructor(){super(...arguments),this.color=new ae([0,255,255]),this.haloOpacity=1,this.fillOpacity=.25,this.multiHighlightEnabled=!1}equals($){return this.color.equals($.color)&&(this.haloColor||this.color).equals($.haloColor||$.color)&&this.haloOpacity===$.haloOpacity&&this.fillOpacity===$.fillOpacity&&this.multiHighlightEnabled===$.multiHighlightEnabled}};xe([we({type:ae})],_o.prototype,"color",void 0),xe([we({type:ae})],_o.prototype,"haloColor",void 0),xe([we()],_o.prototype,"haloOpacity",void 0),xe([we()],_o.prototype,"fillOpacity",void 0),xe([we()],_o.prototype,"multiHighlightEnabled",void 0),_o=xe([Ie("esri.views.2d.support.HighlightOptions")],_o);const mo=_o,yo={selection:$=>new mo({color:new ae([$.color.r/2,$.color.g/2,$.color.b/2,$.color.a])}),highlight:$=>$,popup:$=>new mo({color:new ae([$.color.g,$.color.b,$.color.r,$.color.a])})},go=Object.keys(yo);function g$8($){const k=ct(12.9898),E=ct(78.233),D=ct(43758.5453);return bn(Wn(jn(ln($,it(k,E)),ct(3.14))).multiply(D))}function h$8($){return Bt($,ct(Ai))}function j$4($,k){const E=ct(2**k);return jn(function vn($){return pt("floor",$)}($.divide(E)),ct(2))}function v$2($,k){return j$4($,k+go.length)}function R$4($){const k=j$4($.z,7),E=ct(1).subtract(k),D=$.xyz.subtract(((...$)=>new zn(...$))(0,0,ct(128)));return E.multiply($).add(k.multiply(D))}let xo=class p2 extends po{getVisualVariableData($){if(!this._vvData){const k=this.getAttributeDataCoords($);this._vvData=se(this.visualVariableData,k).setDebugName("storage2")}return this._vvData}getAttributeDataCoords($){if(!this._uv){const k=R$4($),E=this.size,D=rt(k.x),L=rt(k.y).multiply(rt(256)),V=rt(k.z).multiply(rt(256)).multiply(rt(256)),U=ct(D.add(L).add(V)),X=jn(U,E),Q=U.subtract(X).divide(E);this._uv=new On(X,Q).add(.5).divide(E)}return this._uv}getFilterData($){const k=this.getAttributeDataCoords($);return se(this.filterFlags,k).setDebugName("storage0")}getAnimationData($){const k=this.getAttributeDataCoords($);return se(this.animation,k).setDebugName("storage1")}getVVData($){return this.getVisualVariableData($)}getDataDrivenData0($){const k=this.getAttributeDataCoords($);return se(this.dataDriven0,k).setDebugName("storage30")}getDataDrivenData1($){const k=this.getAttributeDataCoords($);return se(this.dataDriven1,k).setDebugName("storage31")}getDataDrivenData2($){const k=this.getAttributeDataCoords($);return se(this.dataDriven2,k).setDebugName("storage32")}getGPGPUData($){const k=this.getAttributeDataCoords($);return se(this.gpgpu,k).setDebugName("storage4")}getFilterFlags($){return oe("webgl-ignores-sampler-precision")?function Wt($){return pt("ceil",$)}(this.getFilterData($).x.multiply(ct(255))):this.getFilterData($).x.multiply(ct(255))}getAnimationValue($){return this.getAnimationData($).x}getSizeValue($){return this.getVisualVariableData($).x}getColorValue($){return this.getVisualVariableData($).y}getOpacityValue($){return this.getVisualVariableData($).z}getRotationValue($){return this.getVisualVariableData($).w}};xe([g$9(Pn)],xo.prototype,"filterFlags",void 0),xe([g$9(Pn)],xo.prototype,"animation",void 0),xe([g$9(Pn)],xo.prototype,"gpgpu",void 0),xe([g$9(Pn)],xo.prototype,"visualVariableData",void 0),xe([g$9(Pn)],xo.prototype,"dataDriven0",void 0),xe([g$9(Pn)],xo.prototype,"dataDriven1",void 0),xe([g$9(Pn)],xo.prototype,"dataDriven2",void 0),xe([g$9(An)],xo.prototype,"size",void 0);let bo=class e3 extends po{};xe([g$9(An)],bo.prototype,"activeReasons",void 0),xe([g$9(An)],bo.prototype,"highlightAll",void 0);let vo=class e4 extends po{};xe([g$9(On)],vo.prototype,"position",void 0),xe([g$9(An)],vo.prototype,"distance",void 0),xe([g$9(An)],vo.prototype,"smallSymbolDistance",void 0),xe([g$9(An)],vo.prototype,"smallSymbolSizeThreshold",void 0);let wo=class d3 extends po{};xe([g$9(tt)],wo.prototype,"displayViewScreenMat3",void 0),xe([g$9(tt)],wo.prototype,"displayViewMat3",void 0),xe([g$9(tt)],wo.prototype,"displayMat3",void 0),xe([g$9(tt)],wo.prototype,"viewMat3",void 0),xe([g$9(tt)],wo.prototype,"tileMat3",void 0),xe([g$9(An)],wo.prototype,"displayZoomFactor",void 0),xe([g$9(An)],wo.prototype,"requiredZoomFactor",void 0),xe([g$9(On)],wo.prototype,"tileOffset",void 0),xe([g$9(An)],wo.prototype,"currentScale",void 0),xe([g$9(An)],wo.prototype,"currentZoom",void 0),xe([g$9(An)],wo.prototype,"metersPerSRUnit",void 0),xe([g$9(An)],wo.prototype,"rotation",void 0),xe([g$9(An)],wo.prototype,"pixelRatio",void 0);let Io=class S2 extends ao{};xe([h$9(0,zn)],Io.prototype,"id",void 0),xe([h$9(1,An)],Io.prototype,"bitset",void 0),xe([h$9(2,On)],Io.prototype,"pos",void 0);let So=class q2 extends co{};xe([h$9(14,On)],So.prototype,"nextPos1",void 0),xe([h$9(15,On)],So.prototype,"nextPos2",void 0);let $o=class F extends lo{},To=class P2 extends fo{clip($,k){let E=new An(0);const D=this.storage.getFilterFlags($);if(E=E.add(ct(2).multiply(ct(1).subtract(v$2(D,0)))),this.inside?E=E.add(ct(2).multiply(ct(1).subtract(v$2(D,1)))):this.outside?E=E.add(ct(2).multiply(v$2(D,1))):this.highlight&&(E=E.add(ct(2).multiply(ct(1).subtract(this._checkHighlight(D))))),null!=k){const $=new An(1).subtract(ee(k.x,this.view.currentZoom)),D=ee(k.y,this.view.currentZoom);E=E.add(new An(2).multiply($.add(D)))}return E}getFragmentOutput($,k,E=new An(1/255)){const D=new uo;return D.glFragColor=this._maybeWriteHittest(k)??this._maybeHighlight($,E)??$,D}_maybeHighlight($,k){return this.highlight?new Rn($.rgb,ee(k,$.a)):null}_checkHighlight($){let k=this._checkHighlightBit($,0);for(let E=1;E<go.length;E++)k=k.add(this._checkHighlightBit($,E));return ee(new An(.1),k.add(this.highlight.highlightAll))}_checkHighlightBit($,k){return function w$2($,k){return j$4($,k)}($,k).multiply(j$4(this.highlight.activeReasons,k))}maybeRunHittest($,k,E){if(null==this.hittestRequest)return null;let D=xt(Ct(this.hittest($,k,E),this.hittestRequest.distance),new An(2),new An(0));const L=function d$8($){return $.multiply(2).subtract(1)}(this.storage.getAttributeDataCoords($.id));D=D.add(this.clip($.id,$.zoomRange));const V=new Rn(new An(1/255),0,0,0);return{glPointSize:new An(1),glPosition:new Rn(L,D,1),color:V}}_maybeWriteHittest($){return null!=this.hittestRequest?$.color:null}};function v$1($,k){return ln($,function Gn($){return pt("normalize",$)}(k))}function j$3($,k,E){const D=E.subtract(k),L=Zt(v$1($.subtract(k),D).divide(kn(D)),new An(0),new An(1));return function sn($,k){return dt("distance",$,k,An)}($,k.add(L.multiply(E.subtract(k))))}function g$7($){const k=function Xt($){return pt("abs",$)}($);return ee(k.x.add(k.y).add(k.z),new An(1.05))}function M$3($,k,E,D){return Bt(g$7(function h$7($,k,E,D){const L=new tt(E.x.multiply(D.y).subtract(D.x.multiply(E.y)),D.x.multiply(k.y).subtract(k.x.multiply(D.y)),k.x.multiply(E.y).subtract(E.x.multiply(k.y)),E.y.subtract(D.y),D.y.subtract(k.y),k.y.subtract(E.y),D.x.subtract(E.x),k.x.subtract(D.x),E.x.subtract(k.x)),V=k.x.multiply(E.y.subtract(D.y)),U=E.x.multiply(D.y.subtract(k.y)),X=D.x.multiply(k.y.subtract(E.y)),Q=V.add(U).add(X);return new An(1).divide(Q).multiply(L.multiply(new zn(1,$)))}($,k,E,D)),new An(1))}function P$1($,k,E,D){const L=function b$5($,k){return $.x.multiply(k.y).subtract(k.x.multiply($.y))}(E.subtract(k),D.subtract(k)),V=Rt(function St($,k){return at("<",$,k,qn)}(L,new An(Pi)),Ct(L,new An(-Pi)));return gt([Rt(Hn(V),M$3($.xy,k,E,D)),new An(-1)],[!0,()=>{const L=j$3($,k,E),V=j$3($,E,D),U=j$3($,D,k);return Un(Un(L,V),U)}])}function q$2($){return $.distance.add(1)}function z$3($,k,E){const{viewMat3:D,tileMat3:L}=$.view,V=D.multiply(L),U=V.multiply(new zn(k.pos,1)),X=V.multiply(new zn(E.nextPos1,1)),Q=V.multiply(new zn(E.nextPos2,1));return P$1($.hittestRequest.position,U.xy,X.xy,Q.xy)}xe([K],To.prototype,"inside",void 0),xe([K],To.prototype,"outside",void 0),xe([_$8(bo)],To.prototype,"highlight",void 0),xe([g$9(xo)],To.prototype,"storage",void 0),xe([g$9(wo)],To.prototype,"view",void 0),xe([_$8(vo)],To.prototype,"hittestRequest",void 0);let Mo=class f extends po{getColor($,k,E){return gt([Ht(h$8($),E),k],[jt($,this.values.first()),this.colors.first()],[Gt($,this.values.last()),this.colors.last()],[!0,()=>{const k=this.values.findIndex((k=>Ct(k,$))),E=this.values.get(k),D=k.subtract(1),L=this.values.get(D),V=$.subtract(L).divide(E.subtract(L));return Sn(this.colors.get(D),this.colors.get(k),V)}])}};xe([g$9(Cn.ofType(Rn,8))],Mo.prototype,"colors",void 0),xe([g$9(Cn.ofType(An,8))],Mo.prototype,"values",void 0);let ko=class h4 extends po{getOpacity($){return gt([h$8($),new An(1)],[jt($,this.opacityValues.first()),this.opacities.first()],[Gt($,this.opacityValues.last()),this.opacities.last()],[!0,()=>{const k=this.opacityValues.findIndex((k=>Ct(k,$))),E=this.opacityValues.get(k),D=k.subtract(1),L=this.opacityValues.get(D),V=$.subtract(L).divide(E.subtract(L));return Sn(this.opacities.get(D),this.opacities.get(k),V)}])}};function l$c($){return null!=$.visualVariableSizeMinMaxValue||null!=$.visualVariableSizeScaleStops||null!=$.visualVariableSizeStops||null!=$.visualVariableSizeUnitValue}function r$e($,k,E,D=new qn(!1)){if(null==$.visualVariableColor)return E;const L=$.storage.getColorValue(k);return $.visualVariableColor.getColor(L,E,D)}function u$6($,k){if(null==$.visualVariableOpacity)return new An(1);const E=$.storage.getOpacityValue(k);return $.visualVariableOpacity.getOpacity(E)}xe([g$9(Cn.ofType(An,8))],ko.prototype,"opacities",void 0),xe([g$9(Cn.ofType(An,8))],ko.prototype,"opacityValues",void 0);let Fo=class g2 extends Io{};xe([h$9(3,Rn)],Fo.prototype,"color",void 0),xe([h$9(4,On)],Fo.prototype,"zoomRange",void 0);let Eo=class x extends To{constructor(){super(...arguments),this.computeAttributes={pos:["nextPos1","nextPos2"]}}vertex($,k){const E=u$6(this,$.id),D=r$e(this,$.id,$.color).multiply(E),L=this.view.displayViewScreenMat3.multiply(new zn($.pos.xy,1)),V=this.clip($.id,$.zoomRange);return{glPosition:new Rn(L.xy,V,1),color:D,...this.maybeRunHittest($,k,null)}}fragment($){return this.getFragmentOutput($.color,$,new An(0))}hittest($,k){return z$3(this,$,k)}};xe([_$8(Mo)],Eo.prototype,"visualVariableColor",void 0),xe([_$8(ko)],Eo.prototype,"visualVariableOpacity",void 0),xe([$e(0,m$c(Fo)),$e(1,m$c(So))],Eo.prototype,"vertex",null),xe([$e(0,m$c($o))],Eo.prototype,"fragment",null);let Co=class n6 extends po{getPatternOffsetAtTileOrigin($,k=new An(0),E=new An(1)){const D=new On(16777216).divide($);let L=$.multiply(bn(this.maxIntsToLocalOrigin.multiply(D))).add(this.tileOffsetFromLocalOrigin).subtract(new An(.5).multiply($));return L=new On(L.x.multiply(E).subtract(L.y.multiply(k)),L.x.multiply(k).add(L.y.multiply(E))),jn(L,$)}};xe([g$9(On)],Co.prototype,"tileOffsetFromLocalOrigin",void 0),xe([g$9(On)],Co.prototype,"maxIntsToLocalOrigin",void 0);let Po=class p3 extends po{};xe([g$9(On)],Po.prototype,"size",void 0),xe([g$9(Pn)],Po.prototype,"texture",void 0);let Ao=class q3 extends Fo{};xe([h$9(5,Rn)],Ao.prototype,"tlbr",void 0),xe([h$9(6,An)],Ao.prototype,"width",void 0),xe([h$9(7,An)],Ao.prototype,"height",void 0),xe([h$9(8,On)],Ao.prototype,"offset",void 0),xe([h$9(9,On)],Ao.prototype,"scale",void 0),xe([h$9(10,An)],Ao.prototype,"angle",void 0);function L$2($,k,E,D,L){const V=Bt(j$4(L,Oi),ct(1)),U=function k$3($){return ln($,ot(255/256,255/65536,255/16777216,255/4294967296))}(new Rn($,0));return xt(V,lt(D.divide(k.x),E.divide(k.y),0,yt(E.divide(k.x)),D.divide(k.y),0,g$8(it(U,0)),g$8(it(0,U)),1),lt(D.divide(k.x),E.divide(k.y),0,yt(E.divide(k.x)),D.divide(k.y),0,0,0,1))}function P3($,k){const E=$.view.requiredZoomFactor,D=new On(k.width,k.height),L=D.multiply(k.scale).multiply(E),V=k.angle.multiply(.024543692606171875),U=Wn(V),X=tn(V),Q=L$2(k.id,L,U,X,k.bitset),J=$.localTileOffset.getPatternOffsetAtTileOrigin(D,U,X),et=E.multiply(k.scale).multiply(k.offset.subtract(J)).divide(L),st=new zn(k.pos,1),ut=Q.multiply(st).xy.subtract(et),ht=k.tlbr.divide($.mosaicInfo.size.xyxy);let _t=j$4(k.bitset,4);return null!=$.visualVariableColor&&(_t=xt(h$8($.storage.getColorValue(k.id)),new An(0),_t)),{tileTextureCoord:ut,tlbr:ht,sampleAlphaOnly:_t}}function Z2($,k){const E=jn(k.tileTextureCoord,new An(1)),D=Sn(k.tlbr.xy,k.tlbr.zw,E);let L=se($.mosaicInfo.texture,D);return L=xt(Ct(k.sampleAlphaOnly,new An(.5)),L.aaaa,L),k.color.multiply(L)}let Oo=class _2 extends Eo{vertex($,k){return{...super.vertex($,k),...P3(this,$)}}fragment($){const k=Z2(this,$);return this.getFragmentOutput(k,$,new An(0))}};xe([g$9(Po)],Oo.prototype,"mosaicInfo",void 0),xe([g$9(Co)],Oo.prototype,"localTileOffset",void 0),xe([$e(0,m$c(Ao)),$e(1,m$c(So))],Oo.prototype,"vertex",null),xe([$e(0,m$c(class G extends $o{}))],Oo.prototype,"fragment",null);let zo=class m3 extends po{getSize($,k){const E=this.minMaxValueAndSize.xy,D=this.minMaxValueAndSize.zw;return xt(h$8($),k,(()=>{const k=Zt($.subtract(E.x).divide(E.y.subtract(E.x)),new An(0),new An(1));return D.x.add(k.multiply(D.y.subtract(D.x)))}))}};xe([g$9(Rn)],zo.prototype,"minMaxValueAndSize",void 0);let Ro=class p4 extends po{getSizeForViewScale($){return gt([jt($,this.values.first()),this.sizes.first()],[Gt($,this.values.last()),this.sizes.last()],[!0,()=>{const k=this.values.findIndex((k=>Ct(k,$))),E=this.values.get(k),D=k.subtract(1),L=this.values.get(D),V=$.subtract(L).divide(E.subtract(L));return Sn(this.sizes.get(D),this.sizes.get(k),V)}])}};xe([g$9(Cn.ofType(An,8))],Ro.prototype,"sizes",void 0),xe([g$9(Cn.ofType(An,8))],Ro.prototype,"values",void 0);let Do=class f2 extends po{getSize($,k){const E=gt([h$8($),k],[jt($,this.values.first()),this.sizes.first()],[Gt($,this.values.last()),this.sizes.last()],[!0,()=>{const k=this.values.findIndex((k=>Ct(k,$))),E=this.values.get(k),D=k.subtract(1),L=this.values.get(D),V=$.subtract(L).divide(E.subtract(L));return Sn(this.sizes.get(D),this.sizes.get(k),V)}]);return xt(h$8(E),k,E)}};xe([g$9(Cn.ofType(An,8))],Do.prototype,"sizes",void 0),xe([g$9(Cn.ofType(An,8))],Do.prototype,"values",void 0);let Bo=class l4 extends po{getSize($,k){return xt(h$8($),k,$.multiply(this.unitValueToPixelsRatio))}};xe([g$9(An)],Bo.prototype,"unitValueToPixelsRatio",void 0);class q4 extends Io{}xe([h$9(3,Rn)],q4.prototype,"color",void 0),xe([h$9(4,On)],q4.prototype,"offset",void 0),xe([h$9(5,On)],q4.prototype,"normal",void 0),xe([h$9(6,An)],q4.prototype,"halfWidth",void 0),xe([h$9(7,An)],q4.prototype,"referenceHalfWidth",void 0),xe([h$9(8,On)],q4.prototype,"zoomRange",void 0);let No=class A extends $o{},Lo=class F2 extends po{};function k$2($){return Bn(new An(Fi).multiply(ee($,new An(Ei))),new An(1))}function G$1($,k){const{id:E,halfWidth:D,referenceHalfWidth:L}=k;if(l$c($)){const k=function t$e($,k,E){var D,L,V,U;if(l$c($)){const X=$.storage.getSizeValue(k);return(null==(D=$.visualVariableSizeMinMaxValue)?void 0:D.getSize(X,E))??(null==(L=$.visualVariableSizeScaleStops)?void 0:L.getSizeForViewScale($.view.currentScale))??(null==(V=$.visualVariableSizeStops)?void 0:V.getSize(X,E))??(null==(U=$.visualVariableSizeUnitValue)?void 0:U.getSize(X,E))}return E}($,E,new An(2).multiply(L));return new An(.5).multiply(D.divide(Bn(L,new An(Ci)))).multiply(k)}return D}function T$3($,k){const{id:E,offset:D,pos:L,normal:V,zoomRange:U}=k,{displayViewScreenMat3:X,displayViewMat3:Q}=$.view,J=r$e($,E,k.color),et=u$6($,E),st=G$1($,k),ut=new An(.5).multiply($.antialiasingControls.antialiasing),ht=Bn(st.add(ut),new An(.45)).add(new An(.1).multiply(ut)),_t=k$2(ht).multiply(ht).multiply(D),vt=Q.multiply(new zn(_t,new An(0))),Et=X.multiply(new zn(L,new An(1))).add(vt),Pt=new An(2).multiply(ee(st,new An(0))).add($.clip(E,U)),Ot=new Rn(Et.xy,Pt,1);return{color:J,opacity:et,halfWidth:ht,normal:V,scaledOffset:_t,scaledHalfWidth:st,glPosition:new Rn(Ot.xy,Pt,1)}}function _$6($,k){const{opacity:E,color:D}=$,L=function D$2($,k){const{halfWidth:E,normal:D}=$,L=k$2(E),V=kn(D).multiply(E);return Zt(L.multiply(E.subtract(V)).divide(k.add(L).subtract(new An(1))),new An(0),new An(1))}($,k);return E.multiply(D).multiply(L)}xe([g$9(An)],Lo.prototype,"antialiasing",void 0),xe([g$9(An)],Lo.prototype,"blur",void 0);let jo=class B3 extends To{constructor(){super(...arguments),this.computeAttributes={pos:["nextPos1","nextPos2"]}}vertex($,k){const E=T$3(this,$);return{...E,...this.maybeRunHittest($,k,E.halfWidth)}}fragment($){const k=_$6($,this.antialiasingControls.blur);return this.getFragmentOutput(k,$)}hittest($,k,E){const{viewMat3:D,tileMat3:L}=this.view,V=D.multiply(L),U=V.multiply(new zn($.pos,1)),X=V.multiply(new zn(k.nextPos1,1)),Q=V.multiply(new zn(k.nextPos2,1)),{distance:J,smallSymbolDistance:et,smallSymbolSizeThreshold:st}=this.hittestRequest,ut=ee(E,st.multiply(.5)).multiply(J.subtract(et)),ht=this.hittestRequest.position;return Un(j$3(ht,U.xy,X.xy),j$3(ht,U.xy,Q.xy)).subtract(E).add(ut)}};xe([g$9(Lo)],jo.prototype,"antialiasingControls",void 0),xe([_$8(Mo)],jo.prototype,"visualVariableColor",void 0),xe([_$8(ko)],jo.prototype,"visualVariableOpacity",void 0),xe([_$8(zo)],jo.prototype,"visualVariableSizeMinMaxValue",void 0),xe([_$8(Ro)],jo.prototype,"visualVariableSizeScaleStops",void 0),xe([_$8(Do)],jo.prototype,"visualVariableSizeStops",void 0),xe([_$8(Bo)],jo.prototype,"visualVariableSizeUnitValue",void 0),xe([$e(0,m$c(q4)),$e(1,m$c(So))],jo.prototype,"vertex",null),xe([$e(0,m$c(No))],jo.prototype,"fragment",null);let Go=class W extends Io{};xe([h$9(3,On)],Go.prototype,"offset",void 0),xe([h$9(4,Rn)],Go.prototype,"color",void 0),xe([h$9(5,On)],Go.prototype,"normal",void 0),xe([h$9(6,An)],Go.prototype,"halfWidth",void 0),xe([h$9(7,An)],Go.prototype,"referenceHalfWidth",void 0),xe([h$9(8,On)],Go.prototype,"zoomRange",void 0);let Vo=class R extends No{};function A$4($,k,E){const{id:D,bitset:L}=k,V=j$4(L,0),U=Ct(V,new An(.5)),X=T$3($,k),Q=xt(U,X.halfWidth,new An(0)),J=u$6($,D),et=r$e($,D,k.color),st=xt(U,k.color,et.multiply(J)),ut=$.view.displayViewScreenMat3.multiply(new zn(k.pos.xy,1)),ht=$.clip(k.id),_t=new Rn(ut.xy,ht,1),vt=xt(U,X.glPosition,_t),Et=E&&$.maybeRunHittest(k,E,U);return{isOutline:V,color:st,opacity:new An(1),halfWidth:Q,normal:X.normal,glPosition:vt,...Et}}let qo=class F3 extends To{constructor(){super(...arguments),this.computeAttributes={pos:["nextPos1","nextPos2"]}}};xe([g$9(Lo)],qo.prototype,"antialiasingControls",void 0),xe([_$8(Mo)],qo.prototype,"visualVariableColor",void 0),xe([_$8(ko)],qo.prototype,"visualVariableOpacity",void 0),xe([_$8(zo)],qo.prototype,"visualVariableSizeMinMaxValue",void 0),xe([_$8(Ro)],qo.prototype,"visualVariableSizeScaleStops",void 0),xe([_$8(Do)],qo.prototype,"visualVariableSizeStops",void 0),xe([_$8(Bo)],qo.prototype,"visualVariableSizeUnitValue",void 0);class H extends qo{vertex($,k){return A$4(this,$,k)}fragment($){const{color:k,isOutline:E}=$,D=Ct(E,new An(.5)),L=xt(D,_$6($,this.antialiasingControls.blur),k),V=xt(D,new An(1/255),new An(0));return this.getFragmentOutput(L,$,V)}hittest($,k,E){return xt(E,q$2(this.hittestRequest),z$3(this,$,k))}}xe([$e(0,m$c(Go)),$e(1,m$c(So))],H.prototype,"vertex",null),xe([$e(0,m$c(Vo))],H.prototype,"fragment",null);let Uo=class h5 extends Fo{};xe([h$9(5,Rn)],Uo.prototype,"tlbr",void 0),xe([h$9(6,An)],Uo.prototype,"inverseRasterizationScale",void 0);function O2($,k){const E=k.tlbr.xy,D=k.tlbr.zw,L=D.x.subtract(E.x),V=E.y.subtract(D.y),U=new On(L,V).multiply(k.inverseRasterizationScale),X=U.multiply($.view.requiredZoomFactor),Q=function j$2($){const k=new An(1),E=new An(0);return new tt(k.divide($.x),E.divide($.y),0,yt(E.divide($.x)),k.divide($.y),0,0,0,1)}(X),J=$.localTileOffset.getPatternOffsetAtTileOrigin(U).divide(X),et=new zn(k.pos,1);return{tileTextureCoord:Q.multiply(et).xy.subtract(J),tlbr:k.tlbr.divide($.mosaicInfo.size.xyxy)}}function T$2($,k){const E=jn($.tileTextureCoord,new An(1)),D=Sn($.tlbr.xy,$.tlbr.zw,E),L=se(k.texture,D);return $.color.multiply(L)}let Wo=class z extends Eo{vertex($,k){return{...super.vertex($,k),...O2(this,$)}}fragment($){const k=T$2($,this.mosaicInfo);return this.getFragmentOutput(k,$,new An(0))}};xe([g$9(Po)],Wo.prototype,"mosaicInfo",void 0),xe([g$9(Co)],Wo.prototype,"localTileOffset",void 0),xe([$e(0,m$c(Uo)),$e(1,m$c(So))],Wo.prototype,"vertex",null),xe([$e(0,m$c(class g3 extends $o{}))],Wo.prototype,"fragment",null);let Yo=class x2 extends Go{};xe([h$9(9,Rn)],Yo.prototype,"tlbr",void 0),xe([h$9(10,An)],Yo.prototype,"inverseRasterizationScale",void 0);let Xo=class y extends Vo{},Ho=class S3 extends H{vertex($,k){return{...A$4(this,$,k),...O2(this,$)}}fragment($){const{isOutline:k}=$,E=Ct(k,new An(.5)),D=xt(E,_$6($,this.antialiasingControls.blur),T$2($,this.mosaicInfo)),L=xt(E,new An(1/255),new An(0));return this.getFragmentOutput(D,$,L)}};xe([g$9(Po)],Ho.prototype,"mosaicInfo",void 0),xe([g$9(Co)],Ho.prototype,"localTileOffset",void 0),xe([$e(0,m$c(Yo)),$e(1,m$c(So))],Ho.prototype,"vertex",null),xe([$e(0,m$c(Xo))],Ho.prototype,"fragment",null);const Zo=1/16;let Ko=class F4 extends Io{};xe([h$9(3,Rn)],Ko.prototype,"color",void 0),xe([h$9(4,Rn)],Ko.prototype,"tlbr",void 0),xe([h$9(5,An)],Ko.prototype,"angle",void 0),xe([h$9(6,An)],Ko.prototype,"aux1",void 0),xe([h$9(7,An)],Ko.prototype,"aux2",void 0),xe([h$9(8,On)],Ko.prototype,"aux3",void 0),xe([h$9(9,On)],Ko.prototype,"aux4",void 0),xe([h$9(10,On)],Ko.prototype,"zoomRange",void 0);let Qo=class C extends qo{vertex($,k){const{aux1:E,aux2:D,aux3:L,aux4:V}=$,U={...$,width:E,height:D,offset:L,scale:V.multiply(Zo)},X=A$4(this,{...$,halfWidth:E,referenceHalfWidth:D,offset:L,normal:V.subtract(128).multiply(Zo)}),Q=P3(this,U),J=Ct(X.isOutline,new An(.5));return{...X,...Q,...this.maybeRunHittest($,k,J)}}fragment($){const{isOutline:k}=$,E=Ct(k,new An(.5)),D=xt(E,_$6($,this.antialiasingControls.blur),Z2(this,$)),L=xt(E,new An(1/255),new An(0));return this.getFragmentOutput(D,$,L)}hittest($,k,E){return xt(E,q$2(this.hittestRequest),z$3(this,$,k))}};xe([g$9(Po)],Qo.prototype,"mosaicInfo",void 0),xe([g$9(Co)],Qo.prototype,"localTileOffset",void 0),xe([$e(0,m$c(Ko)),$e(1,m$c(So))],Qo.prototype,"vertex",null),xe([$e(0,m$c(class R2 extends Xo{}))],Qo.prototype,"fragment",null);const Jo=zi,ta=Gi,ea={createComputedParams:$=>$,optionalAttributes:Jo.optionalAttributes,attributes:{...Jo.attributes,bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:$=>n$l($)},aux1:{count:1,type:ne.HALF_FLOAT,pack:$=>p$d($).width},aux2:{count:1,type:ne.HALF_FLOAT,pack:$=>p$d($).height},aux3:{count:2,type:ne.HALF_FLOAT,pack:({offsetX:$,offsetY:k})=>[fe($),fe(k)]},aux4:{count:2,type:ne.UNSIGNED_BYTE,pack:({scaleX:$,scaleY:k})=>[16*$,16*k]}}},sa={createComputedParams:$=>$,optionalAttributes:Jo.optionalAttributes,attributes:{...Jo.attributes,color:ta.attributes.color,bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:$=>l$j([[0,!0]])},aux1:{count:1,type:ne.HALF_FLOAT,pack:$=>fe(.5*$.width)},aux2:{count:1,type:ne.HALF_FLOAT,pack:$=>fe(.5*$.referenceWidth)},aux3:{count:2,type:ne.HALF_FLOAT,packTessellation:({extrusionOffsetX:$,extrusionOffsetY:k})=>[$,k]},aux4:{count:2,type:ne.UNSIGNED_BYTE,packTessellation:({normalX:$,normalY:k})=>[16*$+128,16*k+128]}}};let ra=class x3 extends Vi{constructor(){super(...arguments),this.vertexSpec=sa}},ia=class _3 extends qi{constructor(){super(...arguments),this.vertexSpec=ea}_createOutlineWriter($,k,E,D){return new ra($,k,E,D)}_write($,k,E){var D;const L=(null==E?void 0:E.asOptimized())??k.readGeometryForDisplay(),V=this._clip(L);if(!V)return;const U=null==(D=this.evaluatedMeshParams.sprite)?void 0:D.textureBinding;$.recordStart(this.instanceId,this.attributeLayout,U),this._writeGeometry($,k,V),this._lineMeshWriter.writeLineVertices($,te.fromOptimizedCIM(V,"esriGeometryPolyline"),k),$.recordEnd()}ensurePacked($,k,E){super.ensurePacked($,k,E),this._lineMeshWriter.ensurePacked($,k,E)}enqueueRequest($,k,E){super.enqueueRequest($,k,E),this._lineMeshWriter.enqueueRequest($,k,E)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const na={optionalAttributes:$i.optionalAttributes,createComputedParams:$=>$,attributes:{...$i.attributes,...ji.attributes}},oa={optionalAttributes:$i.optionalAttributes,createComputedParams:$=>$,attributes:{...$i.attributes,...Gi.attributes}};let aa=class u3 extends Vi{constructor(){super(...arguments),this.vertexSpec=oa}},ca=class c5 extends qi{constructor(){super(...arguments),this.vertexSpec=na}_createOutlineWriter($,k,E,D){return new aa($,k,E,D)}_write($,k,E){var D;const L=(null==E?void 0:E.asOptimized())??k.readGeometryForDisplay(),V=this._clip(L);if(!V)return;const U=null==(D=this.evaluatedMeshParams.sprite)?void 0:D.textureBinding;$.recordStart(this.instanceId,this.attributeLayout,U),this._writeGeometry($,k,V),this._lineMeshWriter.writeLineVertices($,te.fromOptimizedCIM(V,"esriGeometryPolyline"),k),$.recordEnd()}ensurePacked($,k,E){super.ensurePacked($,k,E),this._lineMeshWriter.ensurePacked($,k,E)}enqueueRequest($,k,E){super.enqueueRequest($,k,E),this._lineMeshWriter.enqueueRequest($,k,E)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const la={createComputedParams:$=>$,optionalAttributes:{},attributes:{pos:{type:ne.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:ne.UNSIGNED_BYTE,count:1},offset:{type:ne.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let ua=class i4 extends gi{constructor(){super(...arguments),this.vertexSpec=la}_write($,k){$.recordStart(this.instanceId,this.attributeLayout);const E=k.getDisplayId();if("esriGeometryPoint"===k.geometryType){const D=k.readXForDisplay(),L=k.readYForDisplay();this._writeQuad($,E,D,L)}else if("esriGeometryMultipoint"===k.geometryType){const D=k.readGeometryForDisplay();null==D||D.forEachVertex(((k,D)=>{k>=0&&k<=512&&D>=0&&D<=512&&this._writeQuad($,E,k,D)}))}$.recordEnd()}_writeQuad($,k,E,D){const L=$.vertexCount();this._writeVertex($,k,E,D),$.indexWrite(L+0),$.indexWrite(L+1),$.indexWrite(L+2),$.indexWrite(L+1),$.indexWrite(L+3),$.indexWrite(L+2)}};const ha=8388607,f$6=$=>$&ha;let da=class r5{constructor($,k,E,D,L,V,U,X,Q=[]){this.entityTexel=$,this.anchorX=k,this.anchorY=E,this.directionX=D,this.directionY=L,this.maxScale=V,this.minScale=U,this.referenceBounds=X,this.bounds=Q}serialize($){$.push(this.entityTexel),$.writeF32(this.anchorX),$.writeF32(this.anchorY),$.writeF32(this.directionX),$.writeF32(this.directionY),$.writeF32(this.maxScale),$.writeF32(this.minScale),null===this.referenceBounds?($.writeF32(0),$.writeF32(0),$.writeF32(0)):($.writeF32(this.referenceBounds.size),$.writeF32(this.referenceBounds.offsetX),$.writeF32(this.referenceBounds.offsetY)),e$k($,this.bounds)}static deserialize($){const k=$.readInt32(),E=$.readF32(),D=$.readF32(),L=$.readF32(),V=$.readF32(),U=$.readF32(),X=$.readF32(),Q=$.readF32(),J=$.readF32(),et=$.readF32(),st=n$w($,Pr)??[];return new r5(k,E,D,L,V,U,X,{size:Q,offsetX:J,offsetY:et},st)}};function e$8($,k,E){return $[0]=k[0]-E[0],$[1]=k[1]-E[1],$}function n$e($,k){return Math.sqrt($*$+k*k)}function s$d($){const k=n$e($[0],$[1]);$[0]/=k,$[1]/=k}function i$8($,k){return n$e($[0]-k[0],$[1]-k[1])}function h$3($){return $.length-1}function c$7($,k,E=1){let[D,L]=function r$b($,k){return $[k+1]}($,k);return[D,L]=[Math.round(D),Math.round(L)],Math.sqrt(D*D+L*L)*E}let pa=class u4{constructor($,k,E,D,L){this._segments=$,this._index=k,this._distance=E,this._xStart=D,this._yStart=L,this._done=!1}static create($){return new u4($,0,0,$[0][0],$[0][1])}clone(){return new u4(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals($){return this._index===$._index||$._index===this._index-1&&(0===this._distance||1===$._distance)||$._index===this._index+1&&(1===this._distance||0===$._distance)}leq($){return this._index<$._index||this._index===$._index&&this._distance<=$._distance}geq($){return this._index>$._index||this._index===$._index&&this._distance>=$._distance}get _segment(){return this._segments[this._index+1]}get angle(){const $=this.dy,k=(0*$+-1*-this.dx)/(1*this.length);let E=Math.acos(k);return $>0&&(E=2*Math.PI-E),E}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:$,dy:k}=this;return Math.sqrt($*$+k*k)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<h$3(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards($,k){const E=this.backwardLength;if($<=E)return this._distance=(E-$)/this.length,this;let D=this.backwardLength;for(;this.prev();){if(D+this.length>$)return this._seekBackwards($-D);D+=this.length}return this._distance=0,k?this:null}seek($,k=!1){if($<0)return this._seekBackwards(Math.abs($),k);if($<=this.remainingLength)return this._distance=(this.backwardLength+$)/this.length,this;let E=this.remainingLength;for(;this.next();){if(E+this.length>$)return this.seek($-E,k);E+=this.length}return this._distance=1,k?this:null}};function d$5($,k,E,D=!0){const L=function a$b($){let k=0;for(let E=0;E<h$3($);E++)k+=c$7($,E);return k}($),V=pa.create($),U=L/2;if(!D)return V.seek(U),void(Math.abs(V.x)<lr&&Math.abs(V.y)<lr&&E(V.clone(),0,U+0*k,L));const X=Math.max((L-k)/2,0),Q=Math.floor(X/k),J=U-Q*k;V.seek(J);for(let et=-Q;et<=Q;et++)Math.abs(V.x)<lr&&Math.abs(V.y)<lr&&E(V.clone(),et,U+et*k,L),V.seek(k)}function l$a($,k){const E=k;for(let D=0;D<$.length;D++){let k=$[D];g$4(k,E);const L=[];L.push(k[0]);for(let $=1;$<k.length;$++){const[E,D]=k[$-1],[V,U]=k[$],X=V-E,Q=U-D;L.push([X,Q])}$[D]=L,k=L}return $}function g$4($,k){const E=1e-6;if(k<=0)return;const D=$.length;if(D<3)return;const L=[];let V=0;L.push(0);for(let st=1;st<D;st++)V+=i$8($[st],$[st-1]),L.push(V);k=Math.min(k,.2*V);const U=[];U.push($[0][0]),U.push($[0][1]);const X=$[D-1][0],Q=$[D-1][1],J=e$8([0,0],$[0],$[1]);s$d(J),$[0][0]+=k*J[0],$[0][1]+=k*J[1],e$8(J,$[D-1],$[D-2]),s$d(J),$[D-1][0]+=k*J[0],$[D-1][1]+=k*J[1];for(let st=1;st<D;st++)L[st]+=k;L[D-1]+=k;const et=.5*k;for(let st=1;st<D-1;st++){let V=0,X=0,Q=0;for(let D=st-1;D>=0&&!(L[D+1]<L[st]-et);D--){const U=et+L[D+1]-L[st],J=L[D+1]-L[D],ut=L[st]-L[D]<et?1:U/J;if(Math.abs(ut)<E)break;const ht=ut*ut,_t=ut*U-.5*ht*J,vt=ut*J/k,Et=$[D+1],Pt=$[D][0]-Et[0],Ot=$[D][1]-Et[1];V+=vt/_t*(Et[0]*ut*U+.5*ht*(U*Pt-J*Et[0])-ht*ut*J*Pt/3),X+=vt/_t*(Et[1]*ut*U+.5*ht*(U*Ot-J*Et[1])-ht*ut*J*Ot/3),Q+=vt}for(let U=st+1;U<D&&!(L[U-1]>L[st]+et);U++){const D=et-L[U-1]+L[st],J=L[U]-L[U-1],ut=L[U]-L[st]<et?1:D/J;if(Math.abs(ut)<E)break;const ht=ut*ut,_t=ut*D-.5*ht*J,vt=ut*J/k,Et=$[U-1],Pt=$[U][0]-Et[0],Ot=$[U][1]-Et[1];V+=vt/_t*(Et[0]*ut*D+.5*ht*(D*Pt-J*Et[0])-ht*ut*J*Pt/3),X+=vt/_t*(Et[1]*ut*D+.5*ht*(D*Ot-J*Et[1])-ht*ut*J*Ot/3),Q+=vt}U.push(V/Q),U.push(X/Q)}U.push(X),U.push(Q);for(let st=0,ut=0;st<D;st++)$[st][0]=U[ut++],$[st][1]=U[ut++]}let fa=class e5{static getPlacement($,k,E,D,L,V){const U=Te(E);return U?(-1===k&&$.invertY(),U.execute($,E,D,L,V)):null}};let _a=class o6{constructor($){const{offsetX:k,offsetY:E,postAngle:D,fontSize:L,scaleFactor:V,transforms:U}=$;if(this.offsetX=k,this.offsetY=E,this.postAngle=D,this.fontSize=Math.min(L,96),this.transforms=U,U&&U.infos.length>1){const $=Me(L,D,!1,k,E,U);this.fontSize=Math.min($.size,96),this.postAngle=$.rotation,this.offsetX=$.offsetX,this.offsetY=$.offsetY}V&&(this.fontSize*=V,this.offsetX*=V,this.offsetY*=V)}};const ma=[4,4],ya=[16,4],ga={topLeft:ya,topRight:ya,bottomLeft:ya,bottomRight:ya},xa=[4,2],ba=[4,6],va={topLeft:xa,topRight:xa,bottomLeft:ba,bottomRight:ba},wa={topLeft:xa,topRight:ba,bottomLeft:xa,bottomRight:ba},Ia={topLeft:ba,topRight:ba,bottomLeft:ma,bottomRight:ma},Sa={topLeft:ma,topRight:ma,bottomLeft:ba,bottomRight:ba},$a={topLeft:ba,topRight:ma,bottomLeft:ba,bottomRight:ma},Ta={topLeft:ma,topRight:ba,bottomLeft:ma,bottomRight:ba},Ma={createComputedParams:$=>$,optionalAttributes:{zoomRange:{type:ne.UNSIGNED_SHORT,count:2,packPrecisionFactor:de,packTessellation:({minZoom:$,maxZoom:k})=>[$||0,k||28]},clipAngle:{type:ne.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:$})=>A$3($||0)},referenceSymbol:{type:ne.BYTE,count:4,packPrecisionFactor:1,packTessellation:($,k)=>{if(!$.referenceBounds)return[0,0,0,0];const E=ke(k.horizontalAlignment),D=Fe(k.verticalAlignment),{offsetX:L,offsetY:V,size:U}=$.referenceBounds;return[fe(L),-fe(V),fe(U),E+1<<2|D+1]}}},attributes:{pos:{type:ne.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:ne.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:$,mapAligned:k})=>l$j([[0,$],[3,!!k]])},offset:{type:ne.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:$})=>{const{bottomLeft:k,bottomRight:E,topLeft:D,topRight:L}=$;return[D,L,k,E]}}},textureUV:{type:ne.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:$})=>{const{bottomLeft:k,bottomRight:E,topLeft:D,topRight:L}=$;return[D,L,k,E]}}},color:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:$})=>$},fontSize:{type:ne.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:$})=>fe($)},referenceSize:{type:ne.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:$},{referenceSize:k})=>fe(k??$)},haloColor:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:$})=>g$b($)},haloFontSize:{type:ne.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,pack:({haloFontSize:$})=>fe($)}}};class N extends gi{constructor(){super(...arguments),this.vertexSpec=Ma,this._textMeshParamsPropsInitialized=!1}ensurePacked($,k,E){super.ensurePacked($,k,E),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new _a(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write($,k,E){const D=this._getShaping();if(!D)return;const L=k.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers($,k,D,E);if(null==E?void 0:E.nextPath())return E.nextPoint(),this._writeGlyphs($,L,E.x,E.y,D,0);if("esriGeometryPolygon"===k.geometryType){const E=k.readCentroidForDisplay();if(!E)return;const[V,U]=E.coords;return this._writeGlyphs($,L,V,U,D,0)}if("esriGeometryMultipoint"===k.geometryType){const E=k.readGeometryForDisplay();return void(null==E||E.forEachVertex(((k,E)=>this._writeGlyphs($,L,k,E,D,0))))}const V=k.readXForDisplay(),U=k.readYForDisplay();return this._writeGlyphs($,L,V,U,D,0)}_writePlacedTextMarkers($,k,E,D){const L=D??te.fromFeatureSetReaderCIM(k);if(!L)return;const V=fa.getPlacement(L,-1,this.evaluatedMeshParams.placement,fe(1),$.id,t$k());if(!V)return;const U=k.getDisplayId();let X=V.next();for(;null!=X;){const k=X.tx,D=-X.ty,L=-X.getAngle();this._writeGlyphs($,U,k,D,E,L),X=V.next()}}_getShaping($){var k;const E=this._textMeshTransformProps,D=this.evaluatedMeshParams;if(!(null==(k=D.glyphs)?void 0:k.glyphs.length))return null;const L=Math.round(fe(E.fontSize)),V=fe(E.offsetX),U=fe(E.offsetY),X=Ee(fe(D.lineWidth),Pe,Ce),Q=Ae*Ee(D.lineHeightRatio,.25,4);return O$2(D.glyphs,{scale:L/Oe,angle:E.postAngle,xOffset:V,yOffset:U,horizontalAlignment:D.horizontalAlignment,verticalAlignment:$||D.verticalAlignment,maxLineWidth:X,lineHeight:Q,decoration:D.decoration,borderLineSizePx:fe(D.boxBorderLineSize),hasBackground:!!D.boxBackgroundColor,useCIMAngleBehavior:D.useCIMAngleBehavior})}_writeGlyphs($,k,E,D,L,V,U,X){const Q=this.evaluatedMeshParams,J=this._textMeshTransformProps,et=J.fontSize,st=fe(J.offsetX),ut=fe(J.offsetY),[ht,_t]=m$g(Q.scaleInfo,this.getTileInfo());0!==V&&L.setRotation(V);const vt=L.bounds,Et=E+vt.x+st,Pt=D+vt.y-ut,Ot=2*(Q.minPixelBuffer?Q.minPixelBuffer/et:1),zt=Math.max(vt.width,vt.height)*Ot;L.textBox&&($.recordStart(this.instanceId,this.attributeLayout,L.glyphs[0].textureBinding),$.recordBounds(Et,Pt,zt,zt),this._writeTextBox($,k,E,D,L.textBox,U,X),$.recordEnd());for(const Dt of L.glyphs){$.recordStart(this.instanceId,this.attributeLayout,Dt.textureBinding),$.recordBounds(Et,Pt,zt,zt);const{texcoords:L,offsets:V}=Dt;this._writeQuad($,k,E,D,{texcoords:L,offsets:V,fontSize:et,color:g$b(Q.color),isBackground:!1,referenceBounds:U,minZoom:ht,maxZoom:_t,...X}),$.recordEnd()}0!==V&&L.setRotation(-V)}_writeTextBox($,k,E,D,L,V,U){const X=this.evaluatedMeshParams,{fontSize:Q}=this._textMeshTransformProps,{boxBackgroundColor:J,boxBorderLineColor:et}=X,st={isBackground:!0,fontSize:Q,referenceBounds:V,...U};J&&(this._writeQuad($,k,E,D,{texcoords:ga,offsets:L.main,color:g$b(J),...st}),et||(this._writeQuad($,k,E,D,{texcoords:Ia,offsets:L.top,color:g$b(J),...st}),this._writeQuad($,k,E,D,{texcoords:Sa,offsets:L.bot,color:g$b(J),...st}),this._writeQuad($,k,E,D,{texcoords:$a,offsets:L.left,color:g$b(J),...st}),this._writeQuad($,k,E,D,{texcoords:Ta,offsets:L.right,color:g$b(J),...st}))),et&&(this._writeQuad($,k,E,D,{texcoords:va,offsets:L.top,color:g$b(et),...st}),this._writeQuad($,k,E,D,{texcoords:va,offsets:L.bot,color:g$b(et),...st}),this._writeQuad($,k,E,D,{texcoords:wa,offsets:L.left,color:g$b(et),...st}),this._writeQuad($,k,E,D,{texcoords:wa,offsets:L.right,color:g$b(et),...st}))}_writeQuad($,k,E,D,L){const V=$.vertexCount();this._writeVertex($,k,E,D,L),$.indexWrite(V+0),$.indexWrite(V+1),$.indexWrite(V+2),$.indexWrite(V+1),$.indexWrite(V+3),$.indexWrite(V+2)}}const A$3=$=>Math.round($*(254/360)),ka=je(($=>{let k=0;if(0===$)return 1/0;for(;!($%2);)k++,$/=2;return k}));class z2 extends N{constructor(){super(...arguments),this._zoomLevel=0}_write($,k,E,D){if(this._zoomLevel=D||0,null!=E)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(k.geometryType){case"esriGeometryPoint":{const E=k.readXForDisplay(),D=k.readYForDisplay();return this._writePoint($,E,D,k)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const E=k.readCentroidForDisplay();if(!E)return;const[D,L]=E.coords;return this._writePoint($,D,L,k)}case"esriGeometryPolyline":this._writeLines($,k)}}_writePoint($,k,L,V){var U,X;const Q=this._getShaping();if(!Q)return;let J=this._getPointReferenceBounds();J||(J={offsetX:0,offsetY:0,size:0});const et=Q.boundsT,st=E(this.evaluatedMeshParams.horizontalAlignment),ut=D(this.evaluatedMeshParams.verticalAlignment),ht=(null==(U=this.evaluatedMeshParams.scaleInfo)?void 0:U.maxScale)??0,_t=(null==(X=this.evaluatedMeshParams.scaleInfo)?void 0:X.minScale)??0,vt=f$6(V.getDisplayId());$.metricStart(new da(vt,k,L,st,ut,ht,_t,J)),$.metricBoxWrite(et),this._writeGlyphs($,V.getDisplayId(),k,L,Q,0,J),$.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const $ of this._references){const k=$.getBoundsInfo();if(k)return k}return null}_writeLines($,k){const{scaleInfo:E,verticalAlignment:D}=this.evaluatedMeshParams,L=this.evaluatedMeshParams.repeatLabelDistance||128,V=this._getShaping("middle");if(!V)return;const n14=($,k,E,D)=>this._placeSubdivGlyphs($,k,E,D),U=(V.bounds.width+L)/2;this._current={out:$,id:k.getDisplayId(),shaping:V,zoomRange:m$g(E,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===D?"above":"top"===D?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(k,n14,U):this._writeCenterAlong(k,n14,U)}_writeAboveAndBelowAlong($,k,E){const{repeatLabel:D,fontSize:L}=this.evaluatedMeshParams,{shaping:V}=this._current,U=fe(L),X=$.readGeometryForDisplay();if(!X)return;const Q=new qt;ze(Q,X,!1,!1,"esriGeometryPolyline",1);const J=D$1(new qt,Q,U),et=D$1(new qt,Q,-U),st=Re(et,"esriGeometryPolyline",!1,!1),ut=l$a(Re(J,"esriGeometryPolyline",!1,!1).paths,V.bounds.width),ht=l$a(st.paths,V.bounds.width);this._current.offsetDirection="above";for(const _t of ut)d$5(_t,E,k,!!D);this._current.offsetDirection="below";for(const _t of ht)d$5(_t,E,k,!!D)}_writeCenterAlong($,k,E){const{repeatLabel:D}=this.evaluatedMeshParams,{shaping:L}=this._current,V=l$a($.readLegacyGeometryForDisplay().paths,L.bounds.width);for(const U of V)d$5(U,E,k,!!D)}_placeSubdivGlyphs($,k,E,D){const{allowOverrun:L,labelPosition:V,repeatLabelDistance:U}=this.evaluatedMeshParams,X=this._current.zoomRange[0],Q=ka(k),J=this._current.shaping.bounds.width/2,et=Math.sqrt(U||128)/2,st=Math.min(E,D-E),ut=this._current.shaping.isMultiline?28:Math.log2(st/(et+J/2)),ht=0===k?ut:Math.min(Q,ut),_t=Math.max(X,this._zoomLevel+1-ht),vt=this._zoomLevel-_t,Et=this._current.shaping.bounds.width/2*2**vt;this._current.shaping.isMultiline?0===k&&this._placeStraight($,_t):L&&vt<0?this._placeStraightAlong($,X):"parallel"===V?this._placeStraightAlong($,_t):"curved"===V&&this._placeCurved($,_t,Et)}_placeStraight($,k){var E,D;const{out:L,id:V,shaping:U,referenceBounds:X}=this._current,{x:Q,y:J}=$,et=f$6(V),st=(null==(E=this.evaluatedMeshParams.scaleInfo)?void 0:E.maxScale)??0,ut=(null==(D=this.evaluatedMeshParams.scaleInfo)?void 0:D.minScale)??0;L.metricStart(new da(et,$.x,$.y,0,0,st,ut,null)),L.metricBoxWrite(U.boundsT);const ht=$.angle*(180/Math.PI)%360,_t=($.angle*(180/Math.PI)+180)%360;this._writeGlyphs(L,V,Q,J,U,0,X,{clipAngle:ht,mapAligned:!0,isLineLabel:!0,minZoom:k}),this._writeGlyphs(L,V,Q,J,U,0,X,{clipAngle:_t,mapAligned:!0,isLineLabel:!0,minZoom:k}),L.metricEnd()}_placeCurved($,k,E){var D,L;const{out:V,id:U}=this._current,X=$.clone(),Q=$.angle*(180/Math.PI)%360,J=($.angle*(180/Math.PI)+180)%360,et=f$6(U),st=(null==(D=this.evaluatedMeshParams.scaleInfo)?void 0:D.maxScale)??0,ut=(null==(L=this.evaluatedMeshParams.scaleInfo)?void 0:L.minScale)??0;V.metricStart(new da(et,$.x,$.y,0,0,st,ut,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(X,k,1,Q),this._placeBack($,X,k,E,1,Q),this._placeForward($,X,k,E,1,Q)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(X,k,0,J),this._placeBack($,X,k,E,0,J),this._placeForward($,X,k,E,0,J)),V.metricEnd()}_placeStraightAlong(k,E){var D,L;const{out:X,id:Q,shaping:J,zoomRange:et,referenceBounds:ut}=this._current,{boxBorderLineColor:ht,boxBackgroundColor:_t}=this.evaluatedMeshParams,vt=k.clone(),Et=k.angle*(180/Math.PI)%360,Pt=(k.angle*(180/Math.PI)+180)%360;if(J.glyphs.length>0&&(ht||_t)){const D=Math.max(E,et[0],0),L=Math.min(28,et[1]),ht=U(V(),-k.angle),_t={minZoom:D,maxZoom:L,clipAngle:Et,mapAligned:!0,isLineLabel:!0},vt=fe(this.evaluatedMeshParams.offsetX),Ot=fe(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const E=$(vt,-1*Ot),[D,L]=J.shapeBackground(st(V(),ht,E));X.recordStart(this.instanceId,this.attributeLayout,J.glyphs[0].textureBinding);const U=2*Math.max(D.width,D.height);X.recordBounds(k.x+D.x,k.y+D.y,U,U),this._writeTextBox(X,Q,k.x,k.y,L,ut,_t),X.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const E=$(vt,Ot),[D,L]=J.shapeBackground(st(V(),ht,E));_t.clipAngle=Pt,X.recordStart(this.instanceId,this.attributeLayout,J.glyphs[0].textureBinding);const U=2*Math.max(D.width,D.height);X.recordBounds(k.x+D.x,k.y+D.y,U,U),this._writeTextBox(X,Q,k.x,k.y,L,ut,_t),X.recordEnd()}}const Ot=f$6(Q),zt=(null==(D=this.evaluatedMeshParams.scaleInfo)?void 0:D.maxScale)??0,Dt=(null==(L=this.evaluatedMeshParams.scaleInfo)?void 0:L.minScale)??0;X.metricStart(new da(Ot,k.x,k.y,0,0,zt,Dt,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(vt,E,1,Et,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(vt,E,0,Pt,!0),X.metricEnd()}_placeBack($,k,E,D,L,V){const U=$.clone();let X=$.backwardLength+0;for(;U.prev()&&!(X>=D);)this._placeOnSegment(U,k,X,E,-1,L,V),X+=U.length+0}_placeForward($,k,E,D,L,V){const U=$.clone();let X=$.remainingLength+0;for(;U.next()&&!(X>=D);)this._placeOnSegment(U,k,X,E,1,L,V),X+=U.length+0}_placeFirst($,k,E,D,L=!1){const{out:V,id:U,shaping:X,zoomRange:Q,referenceBounds:J}=this._current,et=X.glyphs;for(const st of et){const et=st.x>X.bounds.x?E:1-E,ut=et*$.remainingLength+(1-et)*$.backwardLength,ht=Math.abs(st.x+st.width/2-X.bounds.x),_t=Math.max(0,this._zoomLevel+Math.log2(ht/(ut+0))),vt=Math.max(k,L?0:_t);st.maxZoom=Math.min(Q[1],28),st.angle=$.angle+(1-E)*Math.PI,st.minZoom=Math.max(Q[0],vt),this._writeLineGlyph(V,U,$.x,$.y,X.bounds,st,D,J,!0),E&&this._isVisible(st.minZoom,st.maxZoom)&&V.metricBoxWrite(st.bounds)}}_placeOnSegment($,k,E,D,L,V,U){const{out:X,id:Q,shaping:J,referenceBounds:et}=this._current,st=J.glyphs,ut=$.dx/$.length,ht=$.dy/$.length,_t={x:$.x+E*-L*ut,y:$.y+E*-L*ht};for(const vt of st){const st=vt.x>J.bounds.x?V:1-V;if(!(st&&1===L||!st&&-1===L))continue;const ut=Math.abs(vt.x+vt.width/2-J.bounds.x),ht=Math.max(0,this._zoomLevel+Math.log2(ut/E)-.1),Et=Math.max(D,this._zoomLevel+Math.log2(ut/(E+$.length+0)));if(0!==ht&&(vt.angle=$.angle+(1-V)*Math.PI,vt.minZoom=Et,vt.maxZoom=ht,this._writeLineGlyph(X,Q,_t.x,_t.y,J.bounds,vt,U,et,!0),V&&this._isVisible(vt.minZoom,vt.maxZoom))){const E=vt.bounds,D=$.x-k.x,L=$.y-k.y,V=new Pr(E.center[0]+D,E.center[1]+L,E.width,E.height);X.metricBoxWrite(V)}}}_writeLineGlyph($,k,E,D,L,V,U,X,Q){const J=E+L.x,et=D+L.y,st=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),ut=Math.max(L.width,L.height)*st;$.recordStart(this.instanceId,this.attributeLayout,V.textureBinding),$.recordBounds(J,et,ut,ut);const{texcoords:ht,offsets:_t}=V,vt=this._textMeshTransformProps.fontSize;this._writeQuad($,k,E,D,{texcoords:ht,offsets:_t,fontSize:vt,color:g$b(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:X,minZoom:Math.max(this._current.zoomRange[0],V.minZoom),maxZoom:Math.min(this._current.zoomRange[1],V.maxZoom),clipAngle:U,mapAligned:Q,isLineLabel:!0}),$.recordEnd()}_isVisible($,k){const E=this._zoomLevel;return $<=E&&E<=k}}function D$1($,k,E){const{coords:D,lengths:L}=k,V=Ge(),U=Ge(),X=Ge(),Q=Ge(),J=Ge(),st=Ge();let ut=0;for(let ht=0;ht<L.length;ht++){const k=L[ht];for(let L=0;L<k;L++){const ht=2*(L+ut-1),_t=2*(L+ut),vt=2*(L+ut+1);L>0?et(V,D[ht],D[ht+1]):et(V,0,0),et(U,D[_t],D[_t+1]),L<k-1?et(X,D[vt],D[vt+1]):et(X,0,0),0===L?et(Q,0,0):(De(Q,U,V),Be(Q,Q),et(Q,Q[1],-Q[0])),L===k-1?et(J,0,0):(De(J,X,U),Be(J,J),et(J,J[1],-J[0])),Ne(st,Q,J),Be(st,st);const Et=st[0]*J[0]+st[1]*J[1];0!==Et&&Le(st,st,Et),Le(st,st,E),$.coords.push(U[0]+st[0],U[1]+st[1])}$.lengths.push(k),ut+=k}return $}const Fa={createComputedParams:$=>$,optionalAttributes:Bi.optionalAttributes,attributes:{...Bi.attributes,bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:$,shouldScaleDash:k,isSDF:E})=>l$j([[4,$],[2,k],[3,E]])},tlbr:{type:ne.UNSIGNED_SHORT,count:4,pack:({sprite:$})=>{const{rect:k,width:E,height:D}=$,L=k.x+pe,V=k.y+pe;return[L,V,L+E,V+D]}},accumulatedDistance:{type:ne.UNSIGNED_SHORT,count:1,packTessellation:({distance:$})=>$},segmentDirection:{type:ne.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:$,directionY:k})=>[$,k]}}};let Ea=class m4 extends Li{constructor($,k,E,D){super($,k,E,D),this.vertexSpec=Fa,this._tessellationOptions.textured=!0}_write($,k,E){const D=E??te.fromFeatureSetReaderCIM(k);if(!D)return;const{sprite:L}=this.evaluatedMeshParams;this._writeGeometry($,k,D,null==L?void 0:L.textureBinding)}},Ca=class s8{static from($){return"width"in $?this.fromSimpleMeshParams($):this.fromComplexMeshParams($)}static fromSimpleMeshParams($){const k=new s8($.sprite,$.color,$.outlineColor,$.minPixelBuffer,$.placement,$.scaleInfo,$.effects),{type:E,width:D,height:L,angle:V,alignment:U,outlineSize:X,referenceSize:Q,sprite:J,overrideOutlineColor:et}=$;k.rawWidth=fe(D),k.rawHeight=fe(L),k.angle=V,k.alignment=U,k.outlineSize=fe(X),k.referenceSize=fe(Q),k.overrideOutlineColor=et,k.offsetX=fe($.offsetX),k.offsetY=fe($.offsetY),"simple"!==E||J.sdf||(k.rawWidth=J.width,k.rawHeight=J.height);return k.sizeRatio=J.sdf?2:1,k._computeSize($,!1),k}static fromComplexMeshParams($){const k=new s8($.sprite,$.color,$.outlineColor,$.minPixelBuffer,$.placement,$.scaleInfo,$.effects);let{alignment:E,transforms:D,size:L,scaleX:V,anchorX:U,anchorY:X,angle:Q,colorLocked:J,frameHeight:et,widthRatio:st,offsetX:ut,offsetY:ht,outlineSize:_t,referenceSize:vt,scaleFactor:Et,sizeRatio:Pt,isAbsoluteAnchorPoint:Ot,rotateClockwise:zt,scaleSymbolsProportionally:Dt,sprite:Nt}=$;if(D&&D.infos.length>0){const $=Me(L,Q,zt,ut,ht,D);L=$.size,Q=$.rotation,ut=$.offsetX,ht=$.offsetY,zt=!1}Et&&(L*=Et,ut*=Et,ht*=Et);const Lt=V*(Nt.width/Nt.height);k.alignment=E,k.rawHeight=fe(L),k.rawWidth=k.rawHeight*Lt,k.referenceSize=fe(vt),k.sizeRatio=Pt,k.angle=Q,k.rotateClockwise=zt,k.anchorX=U,k.anchorY=X,k.offsetX=fe(ut),k.offsetY=fe(ht),Ot&&L&&(Nt.sdf?k.anchorX=U/(L*st):k.anchorX=U/(L*Lt),k.anchorY=X/L);const Vt=Dt&&et?L/et:1;return k.outlineSize=0===_t||isNaN(_t)?0:fe(_t)*Vt,k.scaleSymbolsProportionally=Dt,k.colorLocked=J,k._computeSize($,!0),k}constructor($,k,E,D,L,V,U){this.sprite=$,this.color=k,this.outlineColor=E,this.minPixelBuffer=D,this.placement=L,this.scaleInfo=V,this.effects=U,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.alignment=Ve.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize($,k){const{sprite:E,hasSizeVV:D}=$,L=!!E.sdf,{rawWidth:V,rawHeight:U,sizeRatio:X,outlineSize:Q}=this,J=V*X,et=U*X;if(L&&!D){const $=k&&V>U?J:V,E=U,D=Q+2;this.computedWidth=Math.min($+D,J),this.computedHeight=Math.min(E+D,et)}else this.computedWidth=J,this.computedHeight=et;const st=L?Math.max(E.width,E.height)/Math.max(J,et):1,ut=.5*(J-this.computedWidth)*st,ht=.5*(et-this.computedHeight)*st,_t=E.rect.x+pe+ut,vt=E.rect.y+pe+ht,Et=_t+E.width-2*ut,Pt=vt+E.height-2*ht;this.texXmin=Math.floor(_t),this.texYmin=Math.floor(vt),this.texXmax=Math.ceil(Et),this.texYmax=Math.ceil(Pt),this.computedWidth*=(this.texXmax-this.texXmin)/(Et-_t),this.computedHeight*=(this.texYmax-this.texYmin)/(Pt-vt),this.anchorX*=J/this.computedWidth,this.anchorY*=et/this.computedHeight}};const Pa={isSDF:0,isMapAligned:1,scaleSymbolsProportionally:2,overrideOutlineColor:3,colorLocked:4},Aa=128/Math.PI;function S$4($){return function b$2($,k){return $%=k,Math.abs($>=0?$:$+k)}($*Aa,256)}const Oa={createComputedParams:$=>Ca.from($),optionalAttributes:{zoomRange:{type:ne.SHORT,count:2,packPrecisionFactor:de,pack:({scaleInfo:$},{tileInfo:k})=>m$g($,k)}},attributes:{pos:{type:ne.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:({sprite:$,alignment:k,scaleSymbolsProportionally:E,overrideOutlineColor:D,colorLocked:L})=>{let V=0;return $.sdf&&(V|=f$d(Pa.isSDF)),k===Ve.MAP&&(V|=f$d(Pa.isMapAligned)),E&&(V|=f$d(Pa.scaleSymbolsProportionally)),D&&(V|=f$d(Pa.overrideOutlineColor)),L&&(V|=f$d(Pa.colorLocked)),V}},offset:{type:ne.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:$,computedWidth:k,computedHeight:E,anchorX:D,anchorY:L,offsetX:U,offsetY:X,rotateClockwise:Q})=>{const et=function I$2($,k,E,D,L=!1){const U=V(),X=L?1:-1;return qe(U),(k||E)&&st(U,U,[k,-E]),D&&ut(U,U,.017453292519944444*X*-D),U}(0,U,X,-$,Q),ht=-(.5+D)*k,_t=-(.5-L)*E,vt=[ht,_t],Et=[ht+k,_t],Pt=[ht,_t+E],Ot=[ht+k,_t+E];return J(vt,vt,et),J(Et,Et,et),J(Pt,Pt,et),J(Ot,Ot,et),[vt,Et,Pt,Ot]}}},textureUV:{type:ne.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:$,texXmin:k,texYmax:E,texYmin:D})=>[[k,D],[$,D],[k,E],[$,E]]}},color:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:$})=>g$b($)},outlineColor:{type:ne.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:$})=>g$b($)},sizing:{type:ne.UNSIGNED_BYTE,count:4,pack:({rawWidth:$,rawHeight:k,outlineSize:E,referenceSize:D})=>[d$d(Math.max($,k),128),d$d(E,128),d$d(D,128),0]},placementAngle:{type:ne.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:$})=>S$4($)},sizeRatio:{type:ne.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sizeRatio:$})=>$}}};class v2 extends gi{constructor(){super(...arguments),this.vertexSpec=Oa}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write($,k,E){var D;const L=null==(D=this.evaluatedMeshParams.sprite)?void 0:D.textureBinding,V=k.getDisplayId();$.recordStart(this.instanceId,this.attributeLayout,L);const U=this.evaluatedMeshParams.minPixelBuffer,X=Math.max(this.evaluatedMeshParams.computedWidth,U),Q=Math.max(this.evaluatedMeshParams.computedHeight,U),J=this.evaluatedMeshParams.offsetX,et=-this.evaluatedMeshParams.offsetY;if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers($,k,E,X,Q);else if(null==E?void 0:E.nextPath()){E.nextPoint();const k=E.x,D=E.y;$.recordBounds(k+J,D+et,X,Q),this._writeQuad($,V,k,D)}else if("esriGeometryPolygon"===k.geometryType){const E=k.readCentroidForDisplay();if(!E)return;const[D,L]=E.coords;$.recordBounds(D+J,L+et,X,Q),this._writeQuad($,V,D,L)}else if("esriGeometryPoint"===k.geometryType){const E=k.readXForDisplay(),D=k.readYForDisplay();$.recordBounds(E+J,D+et,X,Q),this._writeQuad($,V,E,D)}else{const E=k.readGeometryForDisplay();null==E||E.forEachVertex(((k,E)=>{$.recordBounds(k+J,E+et,X,Q),Math.abs(k)>lr||Math.abs(E)>lr||this._writeQuad($,V,k,E)}))}$.recordEnd()}_writePlacedMarkers($,k,E,D,L){var V;const U=E??(null==(V=te.fromFeatureSetReaderCIM(k))?void 0:V.clone());if(!U)return;const X=fa.getPlacement(U,-1,this.evaluatedMeshParams.placement,fe(1),$.id,t$k());if(!X)return;const Q=k.getDisplayId();let J=X.next();const et=this.evaluatedMeshParams.offsetX,st=-this.evaluatedMeshParams.offsetY;for(;null!=J;){const k=J.tx,E=-J.ty;if(Math.abs(k)>lr||Math.abs(E)>lr){J=X.next();continue}const V=-J.getAngle();$.recordBounds(k+et,E+st,D,L),this._writeQuad($,Q,k,E,V),J=X.next()}}_writeQuad($,k,E,D,L){const V=$.vertexCount(),U=null==L?null:{placementAngle:L};this._writeVertex($,k,E,D,U),$.indexWrite(V+0),$.indexWrite(V+1),$.indexWrite(V+2),$.indexWrite(V+1),$.indexWrite(V+3),$.indexWrite(V+2)}}function o$a($){return Math.floor(function e$6($,k){let E;if("string"==typeof $)E=Nt($+`-seed(${k})`);else{let D=12;E=$^k;do{E=107*(E>>8^E)+D|0}while(0!=--D)}return(1+E/(1<<31))/2}($,za)*Ra)}const za=53290320,Ra=10;let Da=class s9{destroy(){}},Ba=class r6 extends Da{constructor($){super(),this._value=$}resize($){}read($,k){return this._value}readWithDefault($,k,E){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}};async function c$6($,k,E=!1){const{defaultValue:D,valueExpressionInfo:L,value:V}=k;if(L){const{expression:V}=L,U=await $.createComputedField({expression:V},E);return U?{...k,computed:U,defaultValue:D}:null}return{...k,computed:new Ba(V),defaultValue:D}}async function m$9($,k){const{defaultValue:E,valueExpressionInfo:D}=k,{expression:L}=D,V=await $.createComputedField({expression:L});return V?{...k,computed:V,defaultValue:E}:null}const p$4=$=>"boolean"!=typeof $&&"number"!=typeof $&&"valueExpressionInfo"in $,f$5=$=>$.some(($=>{for(const k in $){const E=$[k];if(p$4(E))return!0}return!1}));let Na=class l5{static async create($,k,E){const D={},L=new Map,V=new Map,U=new Map,X=new Map,Q=new Map;for(const J in E){const et=E[J];if(null!=et&&"object"==typeof et)if(Array.isArray(et)){if("object"==typeof et[0])throw new Error(`InternalError: Cannot handle ${J}. Nested array params are not supported`);D[J]=et}else if("valueExpressionInfo"in et){if(et.value){D[J]=et.value;continue}const k=await m$9($,et);if(!k){D[J]=et.defaultValue;continue}L.set(J,k),D[J]=null}else switch(et.type){case"cim-effect-infos":if(et.effectInfos.some(($=>$.overrides.length))){V.set(J,{effects:await Promise.all(et.effectInfos.map((async k=>{const E=k.overrides.map((k=>c$6($,k)));return{effect:k.effect,compiledOverrides:(await Promise.all(E)).filter(Ue)}})))});break}D[J]=et.effectInfos.map(($=>$.effect));break;case"cim-marker-placement-param":et.overrides.length&&U.set(J,{placementInfo:et,compiledOverrides:(await Promise.all(et.overrides.map((k=>c$6($,k))))).filter(Ue)}),D[J]=et.placement;break;case"text-rasterization-param":{if(et.overrides.length){const k=et.overrides.map((k=>c$6($,k,et.useLegacyLabelEvaluationRules)));X.set(J,{compiledOverrides:(await Promise.all(k)).filter(Ue),rasterizationParam:et,objectIdToResourceId:new Map});continue}const E={type:"cim-rasterization-info",resource:et.resource};D[J]=await k.fetchResourceImmediate(E)??null;break}case"sprite-rasterization-param":{if(et.overrides.length){const k=et.overrides.map((k=>c$6($,k)));X.set(J,{compiledOverrides:(await Promise.all(k)).filter(Ue),rasterizationParam:et,objectIdToResourceId:new Map});continue}if("animated"===et.resource.type){X.set(J,{compiledOverrides:[],rasterizationParam:et,objectIdToResourceId:new Map});continue}const E={type:"cim-rasterization-info",resource:et.resource};D[J]=await k.fetchResourceImmediate(E)??null;break}case"cim-marker-transform-param":{const{params:k}=et;if(f$5(k)){const E={compiledMarkerInfos:[]};await Promise.all(k.map((async k=>{const D={props:{}};for(const E in k)if(p$4(k[E])){const L=await m$9($,k[E]);D.compiledExpressionMap||(D.compiledExpressionMap=new Map);const V=D.compiledExpressionMap;L&&V.set(E,L)}else D.props[E]=k[E];E.compiledMarkerInfos.push(D)}))),Q.set(J,E)}else D[J]={type:"cim-marker-transform-info",infos:k};break}default:D[J]=et}else D[J]=et}return new l5(E,D,L,V,U,X,Q)}constructor($,k,E,D,L,V,U){this.inputMeshParams=$,this._resolvedMeshParams=k,this._dynamicProperties=E,this._dynamicEffectProperties=D,this._dynamicPlacementProperties=L,this._dynamicAsyncProperties=V,this._dynamicTransformProperties=U,this.evaluator=$=>$}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest($,k,E){for(const L of this._dynamicAsyncProperties.values()){const V=We(L.rasterizationParam.resource);"animated"===L.rasterizationParam.resource.type&&L.rasterizationParam.resource.randomizeStartTime&&(V.primitiveName="__RESERVED__PRIMITIVE__NAME__",V.startGroup=o$a(k.getObjectId()||0));for(const{primitiveName:$,propertyName:X,computed:Q,defaultValue:J,valueExpressionInfo:et}of L.compiledOverrides)try{o$l(V,"animated"===L.rasterizationParam.resource.type?V.primitiveName:$,X,Q,k,E,J)}catch(D){Dt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new Et("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${null==et?void 0:et.expression}' (primitive: '${$}', property: '${X}')`,D))}const U=$.enqueueRequest({type:"cim-rasterization-info",resource:V});L.objectIdToResourceId.set(k.getObjectId(),U)}}evaluateMeshParams($,k,E){for(const[D,L]of this._dynamicProperties.entries())this._resolvedMeshParams[D]=L.computed.readWithDefault(k,E,L.defaultValue);for(const[D,L]of this._dynamicPlacementProperties.entries())for(const{computed:$,defaultValue:V,propertyName:U}of L.compiledOverrides){const X=$.readWithDefault(k,E,V);L.placementInfo.placement[U]=X,this._resolvedMeshParams[D]=L.placementInfo.placement}for(const[D,L]of this._dynamicEffectProperties.entries())for(const $ of L.effects){for(const{computed:D,defaultValue:L,propertyName:V}of $.compiledOverrides){const U=D.readWithDefault(k,E,L);$.effect[V]=U}this._resolvedMeshParams[D]=L.effects.map(($=>$.effect))}for(const[D,L]of this._dynamicTransformProperties.entries()){const $={type:"cim-marker-transform-info",infos:[]};for(const D of L.compiledMarkerInfos){const L={...D.props};if(D.compiledExpressionMap)for(const[$,V]of D.compiledExpressionMap){const D=V.computed.readWithDefault(k,E,V.defaultValue);L[$]="number"==typeof D||"boolean"==typeof D?D:V.defaultValue}$.infos.push(L)}this._resolvedMeshParams[D]=$}for(const[D,L]of this._dynamicAsyncProperties.entries()){const E=L.objectIdToResourceId.get(k.getObjectId());if(null==E)continue;const V=$.getResource(E);this._resolvedMeshParams[D]=V}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}};const La={createComputedParams:$=>$,optionalAttributes:{},attributes:{pos:{type:ne.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:ne.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:ne.UNSIGNED_BYTE,count:1,pack:$=>0},offset:{type:ne.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:$})=>{const k=fe($),E=-k/2,D=-k/2;return[[E,D],[E+k,D],[E,D+k],[E+k,D+k]]}}},texCoords:{type:ne.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:ne.UNSIGNED_BYTE,count:2,pack:({size:$})=>[$,$]},referenceSize:{type:ne.UNSIGNED_BYTE,count:1,pack:({size:$})=>fe($)},zoomRange:{type:ne.UNSIGNED_BYTE,count:2,pack:({scaleInfo:$},{tileInfo:k})=>m$g($,k)}}};let ja=class s10 extends gi{constructor(){super(...arguments),this.vertexSpec=La}_write($,k){const E=k.getDisplayId(),D=this.evaluatedMeshParams.minPixelBuffer,L=Math.max(fe(this.evaluatedMeshParams.size),D);let V,U;if("esriGeometryPoint"===k.geometryType)V=k.readXForDisplay(),U=k.readYForDisplay();else{const $=k.readCentroidForDisplay();if(!$)return;V=null==$?void 0:$.coords[0],U=null==$?void 0:$.coords[1]}$.recordStart(this.instanceId,this.attributeLayout),$.recordBounds(V,U,L,L);const X=$.vertexCount();this._writeVertex($,E,V,U),$.indexWrite(X+0),$.indexWrite(X+1),$.indexWrite(X+2),$.indexWrite(X+1),$.indexWrite(X+3),$.indexWrite(X+2),$.recordEnd()}};class W2{async createMeshWriter($,k,E,D){const L=this._getMeshWriter(D.techniqueType),V=await Na.create($,k,D.inputParams),U=new L(D.id,V,D.optionalAttributes,E);return await U.loadDependencies(),U}_getMeshWriter($){switch($){case ii.Fill:return Si;case ii.DotDensity:return wi;case ii.ComplexFill:return Ri;case ii.PatternFill:return Ti;case ii.OutlineFill:return qi;case ii.PatternOutlineFill:return ca;case ii.ComplexOutlineFill:return ia;case ii.Marker:return v2;case ii.PieChart:return ja;case ii.Text:return N;case ii.Line:return Li;case ii.TexturedLine:return Ea;case ii.Heatmap:return ua;case ii.Label:return z2;case ii.Test:throw new Error("Internal Error: Found invalid mesh writer")}}}let Ga=class s11{constructor($,k,E,D){this.storage=$,this.proxy=k,this.viewParams=E,this.registry=D}async createMeshWriters($){const k=$.map(($=>this.registry.createMeshWriter(this.storage,this.proxy,this.viewParams,$)));return Promise.all(k)}},Va=class e6{constructor($){this._outstandingMessages=[],this._queue=new Ye({concurrency:$.concurrency,process:k=>$.process(k)})}async push($){if($.end)return await Promise.all(this._outstandingMessages),await this._queue.push($),void(this._outstandingMessages=[]);const k=this._queue.push($);return this._outstandingMessages.push(k),k}},qa=class s12{static async create($,k){var E;if("count"===k.statisticType){const $=new Ba(1);return new s12(k.name,k.alias,k.type,k.statisticType,$)}const D=await $.createComputedField({expression:null==(E=k.onStatisticExpression)?void 0:E.expression,field:k.onStatisticField});return new s12(k.name,k.alias,k.type,k.statisticType,D)}constructor($,k,E,D,L){this.name=$,this.alias=k,this.type=E,this.statisticType=D,this.computed=L}},Ua=class t6{constructor($){this.subscription=$,this.handledChunks=new Set}destroy(){}},Wa=class e7{constructor($,k){this._source=$,this._attributeStore=k,this._sendStates=new Map}destroy(){}get enablePixelBuffering(){return!0}onSubscribe($){const k=this.createState($);this._sendStates.set($.key.id,k),this.updateChunks()}onUnsubscribe($){var k;null==(k=this._sendStates.get($.key.id))||k.destroy(),this._sendStates.delete($.key.id)}invalidate(){const $=Array.from(this._sendStates.values());this._sendStates.clear();for(const k of $)k.destroy(),this.onSubscribe(k.subscription)}invalidateAttributeData(){}getFeatureObjectIdsForAggregate($){throw new Error("InternalError: AggregateId lookup not supported")}getDisplayIds($){return this.displayMap($,($=>$),($=>$))}getDisplayAndObjectIds($){return this.displayMap($,($=>$),(($,k,E)=>[$,E]))}afterUpdateChunks(){}},Ya=class i5 extends Wa{constructor($,k,E,D){super($,k),this.spatialReference=E,this.aggregateFields=D,this.events=new Xe,this.featureAdapter=yr}get aggregateQueryEngine(){return this._aggregateQueryEngine||(this._aggregateQueryEngine=new hr({featureStore:this,fieldsIndex:this._metadata.fieldsIndex,geometryType:this._metadata.geometryType,objectIdField:this._metadata.objectIdField,spatialReference:this.spatialReference})),this._aggregateQueryEngine}removeChunks($){}forEach($){return this.forEachAggregateWorldSpace($)}forEachInBounds($,k){}forEachBounds($,k){const E=He();for(const D of $){const $=Ze(E,D.geometry,!1,!1);$&&k($)}}},Xa=class e8{constructor($,k,E,D,L){this.subscription=$,this.reader=k,this.clear=E,this.end=D,this.debugInfo=L,this.type="append"}get id(){return this.subscription.tile.id}createMessage($,k,E){return{type:"append",clear:this.clear,id:this.id,append:$,end:this.end,debugInfo:this.debugInfo,subscriptionVesrion:this.subscription.version,version:k,attributeEpoch:E}}},Ha=class i6{constructor($,k,E,D,L){this.subscription=$,this.reader=k,this.remove=E,this.end=D,this.debugInfo=L,this.type="update"}get id(){return this.subscription.tile.id}createMessage($,k,E){return{type:"update",id:this.id,modify:$,debugInfo:this.debugInfo,remove:this.remove,version:k,subscriptionVesrion:this.subscription.version,end:this.end,attributeEpoch:E}}},Za=class r7 extends Da{constructor($){super(),this._field=$}resize($){throw new Error("Method not implemented.")}read($,k){return $.readAttribute(this._field)}readWithDefault($,k){return $.readAttribute(this._field)}referencesScale(){return!1}referencesGeometry(){return!1}};function r$7($,k,E){var D;if(null==$)return null;const L=k.readArcadeFeature();k.contextTimeZone=null==(D=E.$view)?void 0:D.timeZone;try{return $.evaluate({...E,$feature:L},$.services)}catch(V){return Dt.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",V),null}}function n$b($){return null==$||$===1/0||$===-1/0||"number"==typeof $&&isNaN($)}function t$b($,k,E,D){var L;if(null==$)return null!=D?D:null;const V=k.readArcadeFeature();k.contextTimeZone=null==(L=E.$view)?void 0:L.timeZone;const U=$.evaluate({...E,$feature:V},$.services);return n$b(U)?null!=D?D:null:U}let Ka=class c6 extends Da{static async create($,k){const E=await Ke($,k.spatialReference,k.fields),D=Nt($);return new c6(E,D)}constructor($,k){super(),this._compiled=$,this._cacheKey=k}resize($){}read($,k){return this.referencesScale()||"system"!==k.$view.timeZone?r$7(this._compiled,$,k):this._readCached($,k)}readWithDefault($,k,E){return this.referencesScale()||"system"!==k.$view.timeZone?t$b(this._compiled,$,k,E):this._readWithDefaultCached($,k,E)}referencesScale(){var $;return(null==($=this._compiled)?void 0:$.referencesScale())??!1}referencesGeometry(){var $;return(null==($=this._compiled)?void 0:$.referencesGeometry())??!1}_readCached($,k){if($.setCache(this._cacheKey),$.hasCachedValue())return $.getCachedValue();const E=r$7(this._compiled,$,k);return $.setCachedValue(E),E}_readWithDefaultCached($,k,E){if($.setCache(this._cacheKey),$.hasCachedValue())return $.getCachedValue();const D=t$b(this._compiled,$,k,E);return $.setCachedValue(D),D}},Qa=class a5 extends Da{static async create($,k){const E=Qe($);return new a5(($=>E.replaceAll(/{[^}]*}/g,(k=>{const E=k.slice(1,-1),D=$.metadata.fieldsIndex.get(E);if(null==D)return k;const L=$.readAttribute(E);return null==L?"":Je(L,D)}))))}constructor($){super(),this._evaluator=$}resize($){}read($,k){return this._evaluator($)}readWithDefault($,k,E){const D=this._evaluator($);return n$b(D)?E:D}referencesScale(){return!1}referencesGeometry(){return!1}},Ja=class r8 extends Da{constructor($,k){super(),this._field=$,this._normalizationInfo=k}resize($){throw new Error("Method not implemented.")}read($,k){return this._readNormalized($)}readWithDefault($,k){return this._readNormalized($)}referencesScale(){return!1}referencesGeometry(){return!1}_readNormalized($){const k=$.readAttribute(this._field);if(null==k)return null;const{normalizationField:E,normalizationTotal:D,normalizationType:L}=this._normalizationInfo,V=$.readAttribute(E);switch(L??"esriNormalizeByField"){case"esriNormalizeByField":return V?V?k/V:void 0:null;case"esriNormalizeByLog":return Math.log(k)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return D?k/D*100:null}}},tc=class t7{static fromBuffer($,k){return new t7($,k)}static create($,k=4294967295){const E=new Uint32Array(Math.ceil($/32));return new t7(E,k)}constructor($,k){this._mask=0,this._buf=$,this._mask=k}_getIndex($){return Math.floor($/32)}has($){const k=this._mask&$;return!!(this._buf[this._getIndex(k)]&1<<k%32)}hasRange($,k){let E=$,D=k;for(;E%32&&E!==D;){if(this.has(E))return!0;E++}for(;D%32&&E!==D;){if(this.has(E))return!0;D--}if(E===D)return!1;for(let L=E/32;L!==D/32;L++)if(this._buf[L])return!0;return!1}set($){const k=this._mask&$,E=this._getIndex(k),D=1<<k%32;this._buf[E]|=D}setRange($,k){let E=$,D=k;for(;E%32&&E!==D;)this.set(E++);for(;D%32&&E!==D;)this.set(D--);if(E!==D)for(let L=E/32;L!==D/32;L++)this._buf[L]=4294967295}unset($){const k=this._mask&$,E=this._getIndex(k),D=1<<k%32;this._buf[E]&=4294967295^D}resize($){const k=this._buf,E=new Uint32Array(Math.ceil($/32));E.set(k),this._buf=E}or($){for(let k=0;k<this._buf.length;k++)this._buf[k]|=$._buf[k];return this}and($){for(let k=0;k<this._buf.length;k++)this._buf[k]&=$._buf[k];return this}xor($){for(let k=0;k<this._buf.length;k++)this._buf[k]^=$._buf[k];return this}ior($){for(let k=0;k<this._buf.length;k++)this._buf[k]|=~$._buf[k];return this}iand($){for(let k=0;k<this._buf.length;k++)this._buf[k]&=~$._buf[k];return this}ixor($){for(let k=0;k<this._buf.length;k++)this._buf[k]^=~$._buf[k];return this}any(){for(let $=0;$<this._buf.length;$++)if(this._buf[$])return!0;return!1}copy($){for(let k=0;k<this._buf.length;k++)this._buf[k]=$._buf[k];return this}clone(){return new t7(this._buf.slice(),this._mask)}clear(){for(let $=0;$<this._buf.length;$++)this._buf[$]=0;return this}forEachSet($){for(let k=0;k<this._buf.length;k++){let E=this._buf[k],D=32*k;if(E)for(;E;)1&E&&$(D),E>>>=1,D++}}countSet(){let $=0;return this.forEachSet((k=>{$++})),$}};const a$9=()=>Dt.getLogger("esri.views.2d.layers.features.support.whereUtils"),ec={getAttribute:($,k)=>$.readAttribute(k)};async function o$8($,k){try{const E=await ts($,k);if(!E.isStandardized){const $=new Et("mapview - bad input","Unable to apply filter's definition expression, as expression is not standardized.",E);a$9().error($)}return k=>{const D=k.readArcadeFeature();try{return E.testFeature(D,ec)}catch(L){return a$9().warn("mapview-bad-where-clause","Encountered an error when evaluating where clause",$),!0}}}catch(E){return a$9().warn("mapview-bad-where-clause","Encountered an error when evaluating where clause",$),$=>!0}}const a$8=()=>Dt.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage"),sc=4294967295;function m$8($,k,E){if(!($.length>k))for(;$.length<=k;)$.push(E)}let rc=class p5{constructor($){this._numerics=[],this._strings=[],this._allocatedSize=256,this._bitsets=[],this._instanceIds=[],this._bounds=[],this._dirtyBitset=this.getBitset(this.createBitset()),this.compilationOptions=$}createBitset(){const $=this._bitsets.length;return this._bitsets.push(tc.create(this._allocatedSize,ha)),$+1}async createComputedField($,k=!1){if($.expression)try{if(!this.compilationOptions)throw new Error("InternalError: Compilation options not defined");return k?Qa.create($.expression,this.compilationOptions):await Ka.create($.expression,this.compilationOptions)}catch(D){const k=new Et("featurelayer","Failed to compile arcade expression",{error:D,expression:$.expression});return a$8().error(k),null}if($.normalizationType||$.normalizationField)return new Ja($.field,$);if($.field)return new Za($.field);const E=new Et("featurelayer","Unable to create computed field. No expression or field found",{info:$});return a$8().error(E),null}async createWhereClause($){return $?o$8($,this.compilationOptions.fields):null}getBitset($){return this._bitsets[$-1]}getComputedNumeric($,k){return this.getComputedNumericAtIndex($&ha,0)}setComputedNumeric($,k,E){return this.setComputedNumericAtIndex($&ha,E,0)}getComputedString($,k){return this.getComputedStringAtIndex($&ha,0)}setComputedString($,k,E){return this.setComputedStringAtIndex($&ha,0,E)}getComputedNumericAtIndex($,k){const E=$&ha;return this._ensureNumeric(k,E),this._numerics[k][E]}setComputedNumericAtIndex($,k,E){const D=$&ha;this._ensureNumeric(k,D),this._numerics[k][D]=E}getPackedChunkId($){const k=$&ha;return this._ensureInstanceId(k),this._instanceIds[k]}setPackedChunkId($,k){const E=$&ha;this._ensureInstanceId(E),this._instanceIds[E]=k}getComputedStringAtIndex($,k){const E=$&ha;return this._ensureString(k,E),this._strings[k][E]}setComputedStringAtIndex($,k,E){const D=$&ha;this._ensureString(k,D),this._strings[k][D]=E}getXMin($){return this._bounds[4*($&ha)]}getYMin($){return this._bounds[4*($&ha)+1]}getXMax($){return this._bounds[4*($&ha)+2]}getYMax($){return this._bounds[4*($&ha)+3]}setBounds($,k,E=!1){const D=$&ha;if(!E&&!this._dirtyBitset.has($))return this._bounds[4*D]!==sc;this._dirtyBitset.unset($);const L=k.readGeometryWorldSpace();if(m$8(this._bounds,4*D+4,0),!L||!L.coords.length)return this._bounds[4*D]=sc,this._bounds[4*D+1]=sc,this._bounds[4*D+2]=sc,this._bounds[4*D+3]=sc,!1;let V=1/0,U=1/0,X=-1/0,Q=-1/0;return L.forEachVertex((($,k)=>{V=Math.min(V,$),U=Math.min(U,k),X=Math.max(X,$),Q=Math.max(Q,k)})),this._bounds[4*D]=V,this._bounds[4*D+1]=U,this._bounds[4*D+2]=X,this._bounds[4*D+3]=Q,!0}getBounds($,k){const E=this.getXMin(k),D=this.getYMin(k),L=this.getXMax(k),V=this.getYMax(k);return es($,E,D,L,V),E!==sc}_ensureNumeric($,k){this._numerics[$]||(this._numerics[$]=[]),m$8(this._numerics[$],k,0)}_ensureInstanceId($){m$8(this._instanceIds,$,0)}_ensureString($,k){this._strings[$]||(this._strings[$]=[]),m$8(this._strings[$],k,null)}},ic=class t8{getObjectId($){return $.getObjectId()}getAttributes($){return $.readAttributes()}getAttribute($,k){return $.readAttribute(k)}getAttributeAsTimestamp($,k){return $.readAttributeAsTimestamp(k)}cloneWithGeometry($,k){return $}getGeometry($){return $.readGeometryWorldSpace()}getCentroid($,k){return $.readCentroidForDisplay()}};ic.Shared=new ic;let nc=class p6{constructor($){this._geometryBounds=ss(),this._idToVisibility=new Map,this._serviceInfo=$}static async create($){const k=new p6($);return await k.update($.filterJSON,$.spatialReference),k}get hash(){return this._hash}check($){return this._applyFilter($)}clear(){const $=this._resetAllHiddenIds();return this.update(),{show:$,hide:[]}}invalidate(){this._idToVisibility.forEach((($,k)=>{this._idToVisibility.set(k,0)}))}setKnownIds($){for(const k of $)this._idToVisibility.set(k,1)}setTrue($){const k=[],E=[],D=new Set($);return this._idToVisibility.forEach((($,L)=>{const V=!!(1&this._idToVisibility.get(L)),U=D.has(L);!V&&U?k.push(L):V&&!U&&E.push(L),this._idToVisibility.set(L,U?3:0)})),{show:k,hide:E}}createQuery(){const{geometry:$,spatialRel:k,where:E,timeExtent:D,objectIds:L}=this;return rs.fromJSON({geometry:$,spatialRel:k,where:E,timeExtent:D,objectIds:L})}async update($,k){this._hash=JSON.stringify($);const E=await dr($,null,k);await Promise.all([this._setGeometryFilter(E),this._setIdFilter(E),this._setAttributeFilter(E),this._setTimeFilter(E)])}async _setAttributeFilter($){if(!(null==$?void 0:$.where))return this._clause=null,void(this.where=null);this._clause=await o$8($.where,this._serviceInfo.fieldsIndex),this.where=$.where}_setIdFilter($){this._idsToShow=(null==$?void 0:$.objectIds)&&new Set($.objectIds),this._idsToHide=(null==$?void 0:$.hiddenIds)&&new Set($.hiddenIds),this.objectIds=null==$?void 0:$.objectIds}async _setGeometryFilter($){if(!(null==$?void 0:$.geometry))return this._spatialQueryOperator=null,this.geometry=null,void(this.spatialRel=null);const k=$.geometry,E=$.spatialRel||"esriSpatialRelIntersects",D=await pr(E,k,this._serviceInfo.geometryType,this._serviceInfo.hasZ,this._serviceInfo.hasM);is(this._geometryBounds,k),this._spatialQueryOperator=D,this.geometry=k,this.spatialRel=E}_setTimeFilter($){if(this.timeExtent=this._timeOperator=null,null==$?void 0:$.timeExtent)if(this._serviceInfo.timeInfo)this.timeExtent=$.timeExtent,this._timeOperator=fr(this._serviceInfo.timeInfo,$.timeExtent,ic.Shared);else{const k=new Et("feature-layer-view:time-filter-not-available","Unable to apply time filter, as layer doesn't have time metadata.",$.timeExtent);Dt.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(k)}}_applyFilter($){return this._filterByGeometry($)&&this._filterById($)&&this._filterByTime($)&&this._filterByExpression($)}_filterByExpression($){return!this.where||this._clause($)}_filterById($){var k,E;return(!(null==(k=this._idsToHide)?void 0:k.size)||!this._idsToHide.has($.getObjectId()))&&(!(null==(E=this._idsToShow)?void 0:E.size)||this._idsToShow.has($.getObjectId()))}_filterByGeometry($){if(!this.geometry)return!0;const k=$.readGeometryWorldSpace();return!!k&&this._spatialQueryOperator(k)}_filterByTime($){return null==this._timeOperator||this._timeOperator($)}_resetAllHiddenIds(){const $=[];return this._idToVisibility.forEach(((k,E)=>{1&k||(this._idToVisibility.set(E,1),$.push(E))})),$}},oc=class i7{static minimal($,k,E=[]){return new i7({geometryType:$,fields:E,objectIdField:k,subtypes:null,subtypeField:null,types:null,globalIdField:null,spatialReference:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null})}constructor($){this._options=$,this._fieldsIndex="fieldsIndex"in $?ns.fromJSON($.fieldsIndex):new ns($.fields),$.spatialReference&&(this._spatialReference=os.fromJSON($.spatialReference)),this._arcadeSchema={fields:this.fieldsIndex.fields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,objectIdField:this.objectIdField,globalIdField:this._options.globalIdField,spatialReference:this._spatialReference,timeInfo:this._options.timeInfo,typeIdField:this._options.typeIdField??void 0,types:this._options.types??void 0,subtypeField:this._options.subtypeField,subtypes:this._options.subtypes??void 0}}get fieldsIndex(){return this._fieldsIndex}get geometryType(){return this._options.geometryType}get subtypeField(){return this._options.subtypeField}get timeInfo(){return this._options.timeInfo}get objectIdField(){return this._options.objectIdField}get globalIdField(){return this._options.globalIdField}get arcadeSchema(){return this._arcadeSchema}get spatialReference(){return this._spatialReference}get timeReferenceUnknownClient(){return this._options.timeReferenceUnknownClient}},ac=class a6{constructor($){this._valid=tc.create($),this._data=new Array($)}has($){return this._valid.has($)}set($,k){this._valid.set($),this._data[$]=k}get($){return this._data[$]}};const cc=oe("featurelayer-simplify-thresholds")??[.5,.5,.5,.5],lc=cc[0],uc=cc[1],hc=cc[2],dc=cc[3],pc=oe("featurelayer-simplify-payload-size-factors")??[1,2,4],fc=pc[0],_c=pc[1],mc=pc[2],yc=oe("featurelayer-simplify-mobile-factor")??2,gc=oe("esri-mobile"),xc=4294967295;class M2{constructor($){this.metadata=$,this.type="FeatureSetReader",this._deleted=null,this._joined=[],this._objectIdToIndex=null,this._boundsBuffer=[],this._caches=new Map,this.arcadeDeclaredClass="esri.arcade.Feature",this._contextTimeZone=null}get isEmpty(){return null!=this._deleted&&this._deleted.countSet()===this.getSize()}getAreaSimplificationThreshold($,k){let E=1;const D=gc?yc:1;k>4e6?E=mc*D:k>1e6?E=_c*D:k>5e5?E=fc*D:k>1e5&&(E=D);let L=0;return $>4e3?L=dc*E:$>2e3?L=hc*E:$>100?L=uc:$>15&&(L=lc),L}parseTimestampOffset($){return $}getBounds($){if(function C2($,k,E){if(!($.length>k))for(;$.length<=k;)$.push(E)}(this._boundsBuffer,4*this.getIndex()+4,0),this.getBoundsXMin()===xc)return!1;if(0===this.getBoundsXMin()){const k=this.readGeometryWorldSpace();if(!k)return this.setBoundsXMin(xc),!1;let E=1/0,D=1/0,L=-1/0,V=-1/0;return k.forEachVertex((($,k)=>{E=Math.min(E,$),D=Math.min(D,k),L=Math.max(L,$),V=Math.max(V,k)})),this.setBoundsXMin(E),this.setBoundsYMin(D),this.setBoundsXMax(L),this.setBoundsYMax(V),es($,E,D,L,V),!0}const k=this.getBoundsXMin(),E=this.getBoundsYMin(),D=this.getBoundsXMax(),L=this.getBoundsYMax();return es($,k,E,D,L),!0}getBoundsXMin(){return this._boundsBuffer[4*this.getIndex()]}setBoundsXMin($){this._boundsBuffer[4*this.getIndex()]=$}getBoundsYMin(){return this._boundsBuffer[4*this.getIndex()+1]}setBoundsYMin($){this._boundsBuffer[4*this.getIndex()+1]=$}getBoundsXMax(){return this._boundsBuffer[4*this.getIndex()+2]}setBoundsXMax($){this._boundsBuffer[4*this.getIndex()+2]=$}getBoundsYMax(){return this._boundsBuffer[4*this.getIndex()+3]}setBoundsYMax($){this._boundsBuffer[4*this.getIndex()+3]=$}readAttributeAsTimestamp($){const k=this.readAttribute($);return"string"==typeof k?new Date(k).getTime():"number"==typeof k||null==k?k:null}readAttribute($,k=!1){const E=this._readAttribute($,k);if(void 0!==E)return E;for(const D of this._joined){D.setIndex(this.getIndex());const E=D._readAttribute($,k);if(void 0!==E)return E}}readAttributes(){const $=this._readAttributes();for(const k of this._joined){k.setIndex(this.getIndex());const E=k._readAttributes();for(const k of Object.keys(E))$[k]=E[k]}return $}joinAttributes($){this._joined.push($)}removeIds($){if(null==this._objectIdToIndex){const $=new Map,k=this.getCursor();for(;k.next();){const E=k.getObjectId();as(E),$.set(E,k.getIndex())}this._objectIdToIndex=$}const k=this._objectIdToIndex;for(const E of $.values())k.has(E)&&this._removeAtIndex(k.get(E))}readOptimizedFeatureWorldSpace(){const $=this.readGeometryWorldSpace(),k=this.readAttributes(),E=this.readCentroidWorldSpace(),D=new ps($,k,E);return D.objectId=this.getObjectId(),D.displayId=this.getDisplayId(),D}readLegacyFeatureForDisplay(){const $=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:($&&{x:$.coords[0],y:$.coords[1]})??null}}readLegacyFeatureWorldSpace(){const $=this.readCentroidWorldSpace();return{attributes:this.readAttributes(),geometry:this._readLegacyGeometryWorldSpace(),centroid:($&&{x:$.coords[0],y:$.coords[1]})??null}}readLegacyGeometryForDisplay(){const $=this.readGeometryForDisplay();return Re($,this.geometryType,!1,!1)}readXForDisplay(){return this._readX()}readYForDisplay(){return this._readY()}readXWorldSpace(){const $=this._readX(),k=this.getInTransform();return null==k?$:$*k.scale[0]+k.translate[0]}readYWorldSpace(){const $=this._readY(),k=this.getInTransform();return null==k?$:k.translate[1]-$*k.scale[1]}readGeometryForDisplay(){const $=this._readGeometryDeltaDecoded(!0);if(!$){const $=this._createGeometryFromServerCentroid();return $?$.deltaDecode():null}return $}readGeometryWorldSpace(){let $=this._readGeometry();if($||($=this._createGeometryFromServerCentroid()),!$)return null;const k=$.clone(),E=this.getInTransform();return null!=E&&cs(k,k,this.hasZ,this.hasM,E),k}readCentroidForDisplay(){const $=this.readGeometryForDisplay();return $?this._computeDisplayCentroid($):this._readServerCentroid()}readCentroidWorldSpace(){const $=this.readGeometryForDisplay(),k=$?this._computeDisplayCentroid($):this._readServerCentroid();if(!k)return null;const E=k.clone(),D=this.getInTransform();return null!=D&&cs(E,E,this.hasZ,this.hasM,D),E}setCache($){let k=this._caches.get($);null==k&&(k=new ac(this.getSize()),this._caches.set($,k)),this._activeCache=k}setCachedValue($){this._activeCache.set(this.getIndex(),$)}hasCachedValue(){return this._activeCache.has(this.getIndex())}getCachedValue(){return this._activeCache.get(this.getIndex())}_readGeometryDeltaDecoded($){const k=this._readGeometry($);return"esriGeometryPoint"!==this.geometryType&&k&&this.getInTransform()?k.deltaDecode():k}get contextTimeZone(){return this._contextTimeZone}set contextTimeZone($){this._contextTimeZone=$}readArcadeFeature(){return this}hasField($){return this.fields.has($)||this._joined.some((k=>k.hasField($)))}geometry(){const $=this.readGeometryWorldSpace(),k=Re($,this.geometryType,this.hasZ,this.hasM),E=ls(k);if(E){if(!this.metadata.spatialReference)throw new Error("InternalError: Expected spatial reference to be defined");E.spatialReference=this.metadata.spatialReference}return E}autocastArcadeDate($,k){return k&&k instanceof Date?this.isUnknownDateTimeField($)?xr.unknownDateJSToArcadeDate(k):xr.dateJSAndZoneToArcadeDate(k,this.contextTimeZone??us):k}isUnknownDateTimeField($){return this.metadata.fieldsIndex.getTimeZone($)===hs}field($){let k=this.fields.get($);if(k)switch(k.type){case"date-only":case"esriFieldTypeDateOnly":return vr.fromReader(this.readAttribute($,!1));case"time-only":case"esriFieldTypeTimeOnly":return br.fromReader(this.readAttribute($,!1));case"esriFieldTypeTimestampOffset":case"timestamp-offset":return xr.fromReaderAsTimeStampOffset(this.readAttribute($,!1));case"date":case"esriFieldTypeDate":return this.autocastArcadeDate($,this.readAttribute($,!0));default:return this.readAttribute($,!1)}for(const E of this._joined)if(E.setIndex(this.getIndex()),k=E.fields.get($),k)switch(k.type){case"date-only":case"esriFieldTypeDateOnly":return vr.fromReader(E._readAttribute($,!1));case"time-only":case"esriFieldTypeTimeOnly":return br.fromReader(E._readAttribute($,!1));case"esriFieldTypeTimestampOffset":case"timestamp-offset":return xr.fromReaderAsTimeStampOffset(E._readAttribute($,!1));case"date":case"esriFieldTypeDate":return this.autocastArcadeDate($,E._readAttribute($,!0));default:return this.readAttribute($,!1)}throw new Error(`Field ${$} does not exist`)}setField($,k){throw new Error("Unable to update feature attribute values, feature is readonly")}keys(){return this.fields.fields.map(($=>$.name))}castToText($=!1){if(!$)return JSON.stringify(this.readLegacyFeatureForDisplay());const k=this.readLegacyFeatureForDisplay();if(!k)return JSON.stringify(null);const E={geometry:k.geometry,attributes:{...k.attributes??{}}};for(const D in E.attributes){const $=E.attributes[D];$ instanceof Date&&(E.attributes[D]=$.getTime())}return JSON.stringify(E)}gdbVersion(){return null}fullSchema(){return this.metadata.arcadeSchema}castAsJson($=null){var k;return{attributes:this._readAttributes(),geometry:!0===(null==$?void 0:$.keepGeometryType)?this.geometry():(null==(k=this.geometry())?void 0:k.toJSON())??null}}castAsJsonAsync($=null,k=null){return Promise.resolve(this.castAsJson(k))}_getExists(){return null==this._deleted||!this._deleted.has(this.getIndex())}_computeDisplayCentroid($){if(null==this.getInTransform())return gr(new qt,$,this.hasM,this.hasZ);const k=te.fromOptimized($,this.geometryType);k.yFactor*=-1;const E=ds(k);return E?(E[1]*=-1,new qt([],E)):null}copyInto($){$._joined=this._joined,$._deleted=this._deleted,$._objectIdToIndex=this._objectIdToIndex,$._boundsBuffer=this._boundsBuffer,$._activeCache=this._activeCache,$._caches=this._caches,$._contextTimeZone=this._contextTimeZone}_readLegacyGeometryWorldSpace(){const $=this.readGeometryWorldSpace();return Re($,this.geometryType,!1,!1)}_createGeometryFromServerCentroid(){const $=this._readServerCentroid();if(!$)return null;const[k,E]=$.coords;return this._createQuantizedExtrudedGeometry(k,E)}_createQuantizedExtrudedGeometry($,k){return"esriGeometryPolyline"===this.geometryType?this._createQuantizedExtrudedLine($,k):this._createQuantizedExtrudedQuad($,k)}_createQuantizedExtrudedQuad($,k){return new qt([5],[$-1,k,1,-1,1,1,-1,1,-1,-1])}_createQuantizedExtrudedLine($,k){return new qt([2],[$-1,k+1,1,-1])}_removeAtIndex($){null==this._deleted&&(this._deleted=tc.create(this.getSize())),this._deleted.set($)}}let bc=class u5 extends M2{static fromFeatures($,k){const{objectIdField:E,geometryType:D}=k,L=fs([],$,D,!1,!1,E);for(let V=0;V<L.length;V++)L[V].displayId=$[V].displayId;return u5.fromOptimizedFeatures(L,k)}static fromFeatureSet($,k){const E=_s($,k.objectIdField);return u5.fromOptimizedFeatureSet(E,k)}static fromOptimizedFeatureSet($,k){const E=u5.fromOptimizedFeatures($.features,k);return E._exceededTransferLimit=$.exceededTransferLimit,E._transform=$.transform,E._fieldsIndex=new ns($.fields),E}static fromOptimizedFeatures($,k,E){const D=new u5($,k);return D._fieldsIndex=k.fieldsIndex,D._transform=E,D}static empty($){return new u5([],$)}constructor($,k){super(k),this._exceededTransferLimit=!1,this._featureIndex=-1,this._fieldsIndex=null,this._geometryType=k.geometryType,this._features=$}get fields(){return this._fieldsIndex}get geometryType(){return this._geometryType}get hasFeatures(){return!!this._features.length}get hasNext(){return this._featureIndex+1<this._features.length}get exceededTransferLimit(){return this._exceededTransferLimit}get hasZ(){return!1}get hasM(){return!1}get _current(){return this._features[this._featureIndex]}removeIds($){const k=new Set($);this._features=this._features.filter(($=>!(null!=$.objectId&&k.has($.objectId))))}getSize(){return this._features.length}getCursor(){return this.copy()}getInTransform(){return this._transform}getAttributeHash(){let $="";for(const k in this._current.attributes)$+=this._current.attributes[k];return $}getIndex(){return this._featureIndex}setIndex($){this._featureIndex=$}getObjectId(){var $;return null==($=this._current)?void 0:$.objectId}getDisplayId(){return this._current.displayId}setDisplayId($){this._current.displayId=$}copy(){const $=new u5(this._features,this.metadata);return this.copyInto($),$}next(){for(;++this._featureIndex<this._features.length&&!this._getExists(););return this._featureIndex<this._features.length}readGeometryArea(){return ms(this._current)?ys(this._current.geometry,2):0}_readX(){return ms(this._current)?this._current.geometry.coords[0]:0}_readY(){return ms(this._current)?this._current.geometry.coords[1]:0}_readGeometry(){return ms(this._current)?this._current.geometry??null:null}_readServerCentroid(){return this._current.centroid}_readAttribute($,k){var E;if(!this._fieldsIndex){const k=this._current.attributes[$];if(void 0!==k)return k;const E=$.toLowerCase();for(const $ in this._current.attributes)if($.toLowerCase()===E)return this._current.attributes[$];return}const D=this._fieldsIndex.get($);if(!D)return;let L=this._current.attributes[D.name];return null==L?L:("esriFieldTypeTimestampOffset"===(null==(E=this.fields.get($))?void 0:E.type)&&(L=this.parseTimestampOffset(L)),k&&this.fields.isDateField($)?new Date(L):L)}_readAttributes(){return this._current.attributes}copyInto($){super.copyInto($),$._featureIndex=this._featureIndex,$._transform=this._transform,$._fieldsIndex=this._fieldsIndex}},vc=class m5 extends Ua{constructor($,k){super($),this.bins=new Map,this.featureCache=new Map,this.done=!1,this._store=k}reset(){this.destroy(),this.done=!1}destroy(){const $=this.subscription.tile.key.level;for(const k of this.featureCache.keys())this._store.releaseDisplayIdForObjectId(`${k}.${$}`);this.bins.clear(),this.featureCache.clear(),this.handledChunks.clear()}get tile(){return this.subscription.tile}*featuresWorldSpace(){for(const $ of this.featureCache.values()){const k=$.clone();k.geometry&&cs(k.geometry,k.geometry,!1,!1,this.subscription.tile.transform),yield k}}},wc=class g4 extends Ya{static async create($,k,E,D,L){const V=new rc({spatialReference:k}),U=await Promise.all($.fields.map((async $=>qa.create(V,$)))),X=$.featureFilter?await nc.create({geometryType:E.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:E.metadata.timeInfo,fieldsIndex:E.metadata.fieldsIndex,spatialReference:k,filterJSON:$.featureFilter}):null;return"geohash"===$.index.type&&await _r(k,os.WGS84),new g4($,X,L,U,k,E,D)}constructor($,k,E,D,L,V,U){super(V,U,L,D),this._schema=$,this._featureFilter=k,this._timeZone=E,this._metadata=new oc({geometryType:"esriGeometryPolygon",objectIdField:"aggregateId",fields:$.fields,globalIdField:null,spatialReference:V.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}createState($){return new vc($,this._attributeStore)}async*applyLocalEdit($){for(const k of this._sendStates.values()){k.reset();const $=new Xa(k.subscription,bc.empty(this._source.metadata),!0,!1,{});yield $}}displayMap($,k,E){const D=new Map($.map(($=>[k($),$]))),L=[];for(const V of this._sendStates.values())for(const $ of V.featuresWorldSpace()){const{objectId:k,displayId:V}=$,U=D.get(k);if(null!=U){const $=E(V,U,k);L.push($),D.delete(k)}}return L}getDisplayFeatures($){const k=new Set($),E=new Set,D=[];for(const L of this._sendStates.values())for(const $ of L.featuresWorldSpace())k.has($.displayId)&&!E.has($.objectId)&&($.geometry&&D.push({...gs($,this._metadata.geometryType,!1,!1),displayId:$.displayId}),E.add($.objectId));return{features:[],aggregates:D}}getFeatureObjectIdsForAggregate($){for(const k of this._sendStates.values())for(const E of k.bins.values())if(E.id===$)return Array.from(E.containedObjectIds);return[]}async*updateChunks(){if(this._source.chunks().length)for(const $ of this._sendStates.values())yield*this._update($,this._source)}forEachAggregateWorldSpace($){for(const k of this._sendStates.values())for(const E of k.featuresWorldSpace())$(E)}_createIndexOptions($){switch(this._schema.index.type){case"geohash":return{type:"geohash",fields:this.aggregateFields,featureFilter:this._featureFilter,geohashLevel:this._schema.index.fixBinLevel,spatialReference:this.spatialReference,timeZone:this._timeZone,scale:$.scale};case"grid":{const k=this._schema.index.fixedBinLevel,E=null!=k?$.tileInfoView.getLODInfoAt(k).scale:$.scale;return{type:"grid",fields:this.aggregateFields,cellSize:this._schema.index.size,featureFilter:this._featureFilter,spatialReference:this.spatialReference,timeZone:this._timeZone,scale:E}}}}async*_update($,k){const{handledChunks:E,subscription:D,bins:L,featureCache:V}=$,U=D.tile;if($.done)return;for(const vt of k.chunks()){if(E.has(vt.chunkId))continue;E.add(vt.chunkId);const k=vt.queryInfo;if("tileId"in k){const $=new _t(k.tileId);if($.level!==U.level||$.world!==U.key.world)continue}vt.getAggregateIndex(this._createIndexOptions($.tile)).putBounded(L,$.tile.extent,$.tile.resolution)}const X=[],Q=D.tile.transform,J=D.tile.key.level;for(const _t of L.values()){let $=V.get(_t.id);if($)$.attributes=_t.getAttributes();else{const k=_t.getGeometry(this.spatialReference,Q);$=new ps(k,_t.getAttributes(),null),k||($.centroid=_t.getGeometricCentroid(this.spatialReference,Q)),$.objectId=_t.id,$.displayId=this._attributeStore.createDisplayIdForObjectId(`${$.objectId}.${J}`),V.set(_t.id,$)}X.push($)}this.events.emit("changed"),$.done=!k.updateTracking.updating;const et=bc.fromOptimizedFeatures(X,this._metadata,Q),st=et.getCursor(),ut=$.subscription.tile.createArcadeEvaluationOptions(this._timeZone);for(;st.next();)this._attributeStore.setAttributeData(st.getDisplayId(),st,ut);const ht=new Ha($.subscription,et,[],$.done,{});yield ht}},Ic=class t9{constructor($){this._statistics=$}get statistics(){return this._statistics}};const Sc=Math.PI/180;let $c=class s13{static create($){return new s13($.map(($=>function i$4($){switch($.statisticType){case"min":return new Mc($);case"max":return new kc($);case"avg":return new Ec($);case"avg_angle":return new Cc($);case"sum":case"count":return new Fc($);case"mode":return new Pc($)}}($))))}constructor($){this._statistics=$}values(){return this._statistics.values()}insert($,k){for(const E of this._statistics)E.insert($,k)}merge($){for(let k=0;k<this._statistics.length;k++){const E=this._statistics[k],D=$._statistics[k];if(E.field.name!==D.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");E.merge(D)}}clone(){return new s13(this._statistics.map(($=>$.clone())))}};let Tc=class n7{constructor($){this.field=$}insert($,k){if(!this.field.computed)return;const E=this.field.computed.read($,k);n$b(E)||this._insertValue(E)}},Mc=class r9 extends Tc{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue($){this.value=Math.min(this.value,$)}merge($){this.value=Math.min(this.value,$.value)}clone(){const $=new r9(this.field);return $.value=this.value,$}},kc=class u6 extends Tc{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue($){this.value=Math.max(this.value,$)}merge($){this.value=Math.max(this.value,$.value)}clone(){const $=new u6(this.field);return $.value=this.value,$}},Fc=class a7 extends Tc{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue($){this.value+=$}merge($){this.value+=$.value}clone(){const $=new a7(this.field);return $.value=this.value,$}},Ec=class c7 extends Tc{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue($){this._total+=$,this._count+=1}merge($){this._total+=$._total,this._count+=$._count}clone(){const $=new c7(this.field);return $._total=this._total,$._count=this._count,$}},Cc=class h6 extends Tc{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const $=this._x/this._count,k=this._y/this._count,E=180/Math.PI;return Math.atan2(k,$)*E}_insertValue($){this._x=this._x+Math.cos($*Sc),this._y=this._y+Math.sin($*Sc),this._count+=1}merge($){this._x+=$._x,this._y+=$._y,this._count+=$._count}clone(){const $=new h6(this.field);return $._x=this._x,$._y=this._y,$._count=this._count,$}},Pc=class o7 extends Tc{constructor(){super(...arguments),this._frequencies=new Map}get value(){let $,k=0;for(const[E,D]of this._frequencies.entries())D>k&&(k=D,$=E);return $}_insertValue($){const k=this._frequencies.get($);null!=k?this._frequencies.set($,k+1):this._frequencies.set($,1)}merge($){for(const[k,E]of $._frequencies.entries()){const $=this._frequencies.get(k);null!=$?this._frequencies.set(k,$+E):this._frequencies.set(k,E)}}clone(){const $=new o7(this.field);return $._frequencies=new Map(this._frequencies),$}},Ac=class l6 extends Ic{static createId($,k){return`${$}.${k}`}static create($,k,E,D){return new l6($,k,$c.create(E),D)}constructor($,k,E,D){super(E),this.gridX=$,this.gridY=k,this._worldUnitsPerCell=D,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._objectIds=new Set}get id(){return l6.createId(this.gridX,this.gridY)}get containedObjectIds(){return this._objectIds}get count(){return this._count}get firstObjectId(){return this._objectIds.values().next().value}get centroidXWorld(){return this._xWorldTotal/this._count}get centroidYWorld(){return this._yWorldTotal/this._count}clone(){const $=new l6(this.gridX,this.gridY,this._statistics.clone(),this._worldUnitsPerCell);return $._count=this._count,$._xWorldTotal=this._xWorldTotal,$._yWorldTotal=this._yWorldTotal,$._firstFeatureAttributes=this._firstFeatureAttributes,$._objectIds=new Set(this._objectIds),$}insert($,k,E,D){0===this._count?this._firstFeatureAttributes=$.readAttributes():this._firstFeatureAttributes=null,this._count+=1,this._xWorldTotal+=E,this._yWorldTotal+=D,this._statistics.insert($,k),this._objectIds.add($.getObjectId())}merge($){if(0!==$._count){this._count+=$._count,this._firstFeatureAttributes=$._firstFeatureAttributes,this._xWorldTotal+=$._xWorldTotal,this._yWorldTotal+=$._yWorldTotal,this._statistics.merge($._statistics);for(const k of $._objectIds.values())this._objectIds.add(k)}}getCentroidX($){return null==$?this.centroidXWorld:xs($,this.centroidXWorld)}getCentroidY($){return null==$?this.centroidYWorld:bs($,this.centroidYWorld)}getGeometry($,k){const E=this.gridX*this._worldUnitsPerCell,D=this.gridY*this._worldUnitsPerCell,L=new qt([4],[E,D,E+this._worldUnitsPerCell,D,E+this._worldUnitsPerCell,D+this._worldUnitsPerCell,E,D+this._worldUnitsPerCell]);if(null!=k){const $=new qt;return vs($,L,!1,!1,"esriGeometryPolygon",k)}return L}getCentroid($){const k=new qt([],[this.centroidXWorld,this.centroidYWorld]);if(null!=$){const E=new qt;return vs(E,k,!1,!1,"esriGeometryPoint",$)}return k}getGeometricCentroid($,k){const E=this.gridX*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,D=this.gridY*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,L=new qt([],[E,D]);if(null!=k){const $=new qt;return vs($,L,!1,!1,"esriGeometryPoint",k)}return L}getAttributes(){const $={aggregateId:this.id};for(const k of this._statistics.values())$[k.field.name]=k.value;return null!=this._firstFeatureAttributes?{...$,...this._firstFeatureAttributes}:$}},Oc=class t10{constructor($){this._options=$}insert($,k){const E=$.getCursor(),D={$view:{scale:this._options.scale,timeZone:this._options.timeZone}};for(;E.next();)this._insertFeature(E,D,k)}_insertFeature($,k,E){const{featureFilter:D}=this._options;if(null!==D&&!D.check($))return;let L=0,V=0;if("esriGeometryPoint"===$.geometryType)L=$.readXWorldSpace(),V=$.readYWorldSpace();else{if(E){const k=$.readCentroidForDisplay();if(null==k)return;const[E,D]=k.coords;if(E<0||E>vt||D<0||D>vt)return}const k=$.readCentroidWorldSpace();if(null==k)return;L=k.coords[0],V=k.coords[1]}this._insert($,L,V,k)}};function o$6($,k){return ws($)*Is*96/k}let zc=class n8 extends Oc{constructor($){super($),this._cells=new Map,this._pixelsPerMapUnit=o$6($.spatialReference,$.scale)}put($){for(const k of this._cells.values()){const E=$.get(k.id);E?E.merge(k):$.set(k.id,k.clone())}}putBounded($,k,E){const D=[k.xmin,k.ymin,k.xmax,k.ymax],[L,V,U,X]=D,Q=Math.floor(L*this._pixelsPerMapUnit/this._options.cellSize),J=Math.floor(V*this._pixelsPerMapUnit/this._options.cellSize),et=Math.ceil(U*this._pixelsPerMapUnit/this._options.cellSize),st=Math.ceil(X*this._pixelsPerMapUnit/this._options.cellSize);for(let ut=J;ut<=st;ut++)for(let k=Q;k<=et;k++){const E=`${k}.${ut}`,D=this._cells.get(E);if(!D)continue;const L=$.get(D.id);L?D&&!$.has(D.id)&&L.merge(D):$.set(D.id,D.clone())}}_insert($,k,E,D){const L=k*this._pixelsPerMapUnit,V=E*this._pixelsPerMapUnit,U=Math.floor(L/this._options.cellSize),X=Math.floor(V/this._options.cellSize);this._getCellOrCreate(U,X).insert($,D,k,E)}_getCellOrCreate($,k){const E=Ac.createId($,k);let D=this._cells.get(E);if(!D){const L=1*this._options.cellSize/this._pixelsPerMapUnit;D=Ac.create($,k,this._options.fields,L),this._cells.set(E,D)}return D}},Rc=class s14{constructor($,k){this.inner=$,this.displayId=k}};const Dc=128;let Bc=class m6 extends Ua{constructor($){super($),this.didSend=!1,this.done=!1}},Nc=class y2{constructor($,k,E,D,L){this._level=$,this._scale=k,this._indexOptions=E,this._clusterRadius=D,this._store=L,this._cells=new Map,this._handledChunks=new Set,this._statistics=new Map,this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const $ of this._clusters.values())this._store.releaseDisplayIdForObjectId($.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const $ of this._clusters.values()){const k=$.inner.getCentroid(null),E=new ps(k,$.inner.getAttributes(),null);E.objectId=$.inner.id,E.displayId=$.displayId,yield E}}clusters(){return this._clusters.values()}updateChunks($,k){let E=!1;for(const U of $){const $=U.queryInfo;"tileId"in $&&new _t($.tileId).level!==this._level||(this._handledChunks.has(U.normalizedChunkId)||(this._handledChunks.add(U.normalizedChunkId),E=!0,U.getAggregateIndex({...this._indexOptions,scale:this._scale}).put(this._cells)))}const D={xMin:1/0,yMin:1/0,xMax:-1/0,yMax:-1/0},L=o$6(this._indexOptions.spatialReference,this._scale),V=this._indexOptions.cellSize;for(const{subscription:U}of k){const $=U.tile.bounds,k=Math.floor($[0]*L/V),E=Math.floor($[1]*L/V),X=Math.ceil($[2]*L/V),Q=Math.ceil($[3]*L/V);D.xMin=Math.min(D.xMin,k),D.yMin=Math.min(D.yMin,E),D.xMax=Math.max(D.xMax,X),D.yMax=Math.max(D.yMax,Q)}return null!=this._lastCellBounds&&D.xMin===this._lastCellBounds.xMin&&D.yMin===this._lastCellBounds.yMin&&D.yMin===this._lastCellBounds.yMin&&D.yMax===this._lastCellBounds.yMax||(E=!0,this._lastCellBounds=D),E&&this._clusterCells(D),E}async updateStatistics($){let k=!1;for(const E of this._clusters.values())E.inner.count>1&&(k=this._updateAggregateStatistics(this._statistics,E.inner)||k);if(k){const k=Array.from(this._statistics.entries()).map((([$,k])=>({fieldName:$,minValue:k.minValue,maxValue:k.maxValue})));await $.container.updateStatistics(this._level,k)}}createAggregateFeatures($,k){const E=$.subscription,D=[],L=E.tile.transform;for(const V of this._clusters.values()){let $=V.inner.getCentroidX(L);const k=V.inner.getCentroidY(L),U=E.tile.lod,X=U.wrap?U.worldSize[0]:null,Q=1===V.inner.count?V.inner.firstObjectId:V.inner.id,J=V.displayId;if(null!=X)if(1===X){const E=new qt([],[$,k]),L=new ps(E,V.inner.getAttributes(),null);L.geometry.coords[0]-=vt,L.objectId=Q,L.displayId=J,D.push(L);const U=new qt([],[$,k]),X=new ps(U,V.inner.getAttributes(),null);X.geometry.coords[0]+=vt,X.objectId=Q,X.displayId=J,D.push(X)}else $>vt+vt/2?$-=X*vt:$<-vt/2&&($+=X*vt);if($<vt+Dc&&$>=-128&&k<vt+Dc&&k>=-128){const E=new qt([],[$,k]),L=new ps(E,V.inner.getAttributes(),null);L.objectId=Q,L.displayId=J,D.push(L)}}return bc.fromOptimizedFeatures(D,k,E.tile.transform)}_clusterCells($){let k=Array.from(this._cells.values());k=k.sort((($,k)=>k.count-$.count));const E=[];for(const U of this._clusters.values())E.push(U.inner.id);this._clusters.clear();const D=this._clusterRadius*(1/o$6(this._indexOptions.spatialReference,this._scale)),L=1+this._clusterRadius/this._indexOptions.cellSize,V=new Set;for(const U of k){if(V.has(U.id))continue;if(U.gridX<$.xMin||U.gridX>$.xMax||U.gridY<$.yMin||U.gridY>$.yMax)continue;const k=this._store.createDisplayIdForObjectId(U.id),E=new Rc(U.clone(),k);V.add(U.id),this._clusters.set(U.id,E);const X=U.centroidXWorld,Q=U.centroidYWorld;for(let $=U.gridY-L;$<=U.gridY+L;$++)for(let k=U.gridX-L;k<=U.gridX+L;k++){if($===U.gridY&&k===U.gridX)continue;const L=this._cells.get(Ac.createId(k,$));if(!L||V.has(L.id))continue;const J=Math.abs(L.centroidXWorld-X),et=Math.abs(L.centroidYWorld-Q);J<D&&et<D&&(E.inner.merge(L),V.add(L.id))}}for(const U of E)this._store.releaseDisplayIdForObjectId(U)}_updateAggregateStatistics($,k){let E=!1;for(const D of k.statistics.values()){if("esriFieldTypeString"===D.field.type)continue;const k=D.value,L=D.field,V=$.get(L.name);if(V){const{minValue:$,maxValue:D}=V,L=Math.min(V.minValue,k),U=Math.max(V.maxValue,k);$===L&&D===U||(V.minValue=L,V.maxValue=U,E=!0)}else $.set(L.name,{minValue:k,maxValue:k}),E=!0}return E}},Lc=class S4 extends Ya{static async create($,k,E,D,L,V){const U=new rc({spatialReference:E}),X={type:"grid",fields:await Promise.all(k.fields.map((async $=>qa.create(U,$)))),spatialReference:E,featureFilter:k.featureFilter?await nc.create({geometryType:D.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:D.metadata.timeInfo,fieldsIndex:D.metadata.fieldsIndex,spatialReference:E,filterJSON:k.featureFilter}):null,cellSize:k.clusterRadius/4,timeZone:V};return new S4($,k.clusterRadius,X,k.fields,D,L)}constructor($,k,E,D,L,V){super(L,V,E.spatialReference,E.fields),this._connection=$,this._clusterRadius=k,this._indexOptions=E,this._cellsPerScale=new Map,this._metadata=new oc({geometryType:"esriGeometryPoint",objectIdField:"aggregateId",fields:[...D,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],globalIdField:null,spatialReference:L.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const $ of this._cellsPerScale.values())$.destroy();this._cellsPerScale.clear()}onSubscribe($){super.onSubscribe($),this._requiredLevel=$.tile.level,this._requiredScale=$.tile.scale}createState($){return new Bc($)}async*applyLocalEdit($){for(const k of this._cellsPerScale.values())k.destroy();this._cellsPerScale.clear();for(const k of this._sendStates.values())k.done=!1}displayMap($,k,E){const D=new Map($.map(($=>[k($),$]))),L=[],V=this._getClusterState(this._requiredLevel,this._requiredScale);for(const U of V.clusters()){const $=D.get(U.inner.id);if(null==$){if(1===U.inner.count){const $=D.get(U.inner.firstObjectId);if(null!=$){const k=E(U.displayId,$,U.inner.firstObjectId);L.push(k),D.delete(U.inner.firstObjectId)}}}else{const k=E(U.displayId,$,U.inner.id);L.push(k),D.delete(U.inner.id)}}return L}getDisplayFeatures($){const k=new Set($),E=new Set,D=[],L=[],V=this._getClusterState(this._requiredLevel,this._requiredScale);for(const U of V.aggregatesWorldSpace())if(k.has(U.displayId)&&!E.has(U.displayId)){const $=gs(U,this._metadata.geometryType,!1,!1);if(E.add(U.displayId),1===$.attributes.cluster_count){D.push({...$,displayId:U.displayId});continue}L.push({...$,displayId:U.displayId})}return{features:D,aggregates:L}}getFeatureObjectIdsForAggregate($){const k=this._getClusterState(this._requiredLevel,this._requiredScale);for(const E of k.clusters())if(E.inner.id===$)return Array.from(E.inner.containedObjectIds);return[]}async*updateChunks(){const $=this._source.chunks();if(!$.length)return;const k=this._getClusterState(this._requiredLevel,this._requiredScale),E=Array.from(this._sendStates.values()).filter(($=>$.subscription.tile.level===this._requiredLevel));if(k.updateChunks($,E)||!this._source.updateTracking.updating)for(const V of E)V.subscription.tile.level===this._requiredLevel&&(V.didSend=!1,V.done=!1);const D=Array.from(this._sendStates.values()).filter(($=>$.done)).map(($=>$.subscription.tile.key)),L=new Set(D);for(const V of this._sendStates.values()){if(this._source.updateTracking.updating){if(D.some(($=>$.containsChild(V.subscription.tile.key))))continue;if(V.subscription.tile.key.getChildKeys().every(($=>L.has($))))continue}V.didSend||V.subscription.tile.level!==this._requiredLevel||(V.didSend=!0,yield*this._update(V,k,this._source))}await k.updateStatistics(this._connection)}forEachAggregateWorldSpace($){if(null==this._requiredLevel||null==this._requiredScale)return;const k=this._getClusterState(this._requiredLevel,this._requiredScale);for(const E of k.aggregatesWorldSpace())$(E)}_getClusterState($,k){if(null==$||null==k)throw new Error("InternalError: Level and scale must be defined");let E=this._cellsPerScale.get(k);return E||(E=new Nc($,k,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(k,E)),E}async*_update($,k,E){if($.done)return;const D=k.createAggregateFeatures($,this._metadata);this.events.emit("changed"),$.done=!E.updateTracking.updating;const L=D.getCursor(),V=$.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);for(;L.next();)this._attributeStore.setAttributeData(L.getDisplayId(),L,V);const U=new Xa($.subscription,D,!0,$.done,{});yield U}};function i$3($,k){if(!(this instanceof i$3))return new i$3($,k);this._maxEntries=Math.max(4,$||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),k&&("function"==typeof k?this.toBBox=k:this._initFormat(k)),this.clear()}function n$7($,k,E){if(!E)return k.indexOf($);for(var D=0;D<k.length;D++)if(E($,k[D]))return D;return-1}function h$1($,k){a$5($,0,$.children.length,k,$)}function a$5($,k,E,D,L){L||(L=x4(null)),L.minX=1/0,L.minY=1/0,L.maxX=-1/0,L.maxY=-1/0;for(var V,U=k;U<E;U++)V=$.children[U],r$4(L,$.leaf?D(V):V);return L}function r$4($,k){return $.minX=Math.min($.minX,k.minX),$.minY=Math.min($.minY,k.minY),$.maxX=Math.max($.maxX,k.maxX),$.maxY=Math.max($.maxY,k.maxY),$}function e$1($,k){return $.minX-k.minX}function o$5($,k){return $.minY-k.minY}function s$4($){return($.maxX-$.minX)*($.maxY-$.minY)}function l$6($){return $.maxX-$.minX+($.maxY-$.minY)}function m$4($,k){return(Math.max(k.maxX,$.maxX)-Math.min(k.minX,$.minX))*(Math.max(k.maxY,$.maxY)-Math.min(k.minY,$.minY))}function c$2($,k){var E=Math.max($.minX,k.minX),D=Math.max($.minY,k.minY),L=Math.min($.maxX,k.maxX),V=Math.min($.maxY,k.maxY);return Math.max(0,L-E)*Math.max(0,V-D)}function u$1($,k){return $.minX<=k.minX&&$.minY<=k.minY&&k.maxX<=$.maxX&&k.maxY<=$.maxY}function f$4($,k){return k.minX<=$.maxX&&k.minY<=$.maxY&&k.maxX>=$.minX&&k.maxY>=$.minY}function x4($){return{children:$,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d$3($,k,E,D,L){for(var V,U=[k,E];U.length;)(E=U.pop())-(k=U.pop())<=D||(V=k+Math.ceil((E-k)/D/2)*D,wr($,V,k,E,L),U.push(k,V,V,E))}i$3.prototype={all:function(){return this._all(this.data,[])},search:function($){var k=this.data,E=[],D=this.toBBox;if(!f$4($,k))return E;for(var L,V,U,X,Q=[];k;){for(L=0,V=k.children.length;L<V;L++)U=k.children[L],f$4($,X=k.leaf?D(U):U)&&(k.leaf?E.push(U):u$1($,X)?this._all(U,E):Q.push(U));k=Q.pop()}return E},collides:function($){var k=this.data,E=this.toBBox;if(!f$4($,k))return!1;for(var D,L,V,U,X=[];k;){for(D=0,L=k.children.length;D<L;D++)if(V=k.children[D],f$4($,U=k.leaf?E(V):V)){if(k.leaf||u$1($,U))return!0;X.push(V)}k=X.pop()}return!1},load:function($){if(!$||!$.length)return this;if($.length<this._minEntries){for(var k=0,E=$.length;k<E;k++)this.insert($[k]);return this}var D=this._build($.slice(),0,$.length-1,0);if(this.data.children.length)if(this.data.height===D.height)this._splitRoot(this.data,D);else{if(this.data.height<D.height){var L=this.data;this.data=D,D=L}this._insert(D,this.data.height-D.height-1,!0)}else this.data=D;return this},insert:function($){return null!=$&&this._insert($,this.data.height-1),this},clear:function(){return this.data=x4([]),this},remove:function($,k){if(null==$)return this;for(var E,D,L,V,U=this.data,X=this.toBBox($),Q=[],J=[];U||Q.length;){if(U||(U=Q.pop(),D=Q[Q.length-1],E=J.pop(),V=!0),U.leaf&&-1!==(L=n$7($,U.children,k)))return U.children.splice(L,1),Q.push(U),this._condense(Q),this;V||U.leaf||!u$1(U,X)?D?(E++,U=D.children[E],V=!1):U=null:(Q.push(U),J.push(E),E=0,D=U,U=U.children[0])}return this},toBBox:function($){return $},compareMinX:e$1,compareMinY:o$5,toJSON:function(){return this.data},fromJSON:function($){return this.data=$,this},_all:function($,k){for(var E=[];$;)$.leaf?k.push.apply(k,$.children):E.push.apply(E,$.children),$=E.pop();return k},_build:function($,k,E,D){var L,V=E-k+1,U=this._maxEntries;if(V<=U)return h$1(L=x4($.slice(k,E+1)),this.toBBox),L;D||(D=Math.ceil(Math.log(V)/Math.log(U)),U=Math.ceil(V/Math.pow(U,D-1))),(L=x4([])).leaf=!1,L.height=D;var X,Q,J,et,st=Math.ceil(V/U),ut=st*Math.ceil(Math.sqrt(U));for(d$3($,k,E,ut,this.compareMinX),X=k;X<=E;X+=ut)for(d$3($,X,J=Math.min(X+ut-1,E),st,this.compareMinY),Q=X;Q<=J;Q+=st)et=Math.min(Q+st-1,J),L.children.push(this._build($,Q,et,D-1));return h$1(L,this.toBBox),L},_chooseSubtree:function($,k,E,D){for(var L,V,U,X,Q,J,et,st;D.push(k),!k.leaf&&D.length-1!==E;){for(et=st=1/0,L=0,V=k.children.length;L<V;L++)Q=s$4(U=k.children[L]),(J=m$4($,U)-Q)<st?(st=J,et=Q<et?Q:et,X=U):J===st&&Q<et&&(et=Q,X=U);k=X||k.children[0]}return k},_insert:function($,k,E){var D=this.toBBox,L=E?$:D($),V=[],U=this._chooseSubtree(L,this.data,k,V);for(U.children.push($),r$4(U,L);k>=0&&V[k].children.length>this._maxEntries;)this._split(V,k),k--;this._adjustParentBBoxes(L,V,k)},_split:function($,k){var E=$[k],D=E.children.length,L=this._minEntries;this._chooseSplitAxis(E,L,D);var V=this._chooseSplitIndex(E,L,D),U=x4(E.children.splice(V,E.children.length-V));U.height=E.height,U.leaf=E.leaf,h$1(E,this.toBBox),h$1(U,this.toBBox),k?$[k-1].children.push(U):this._splitRoot(E,U)},_splitRoot:function($,k){this.data=x4([$,k]),this.data.height=$.height+1,this.data.leaf=!1,h$1(this.data,this.toBBox)},_chooseSplitIndex:function($,k,E){var D,L,V,U,X,Q,J,et;for(Q=J=1/0,D=k;D<=E-k;D++)U=c$2(L=a$5($,0,D,this.toBBox),V=a$5($,D,E,this.toBBox)),X=s$4(L)+s$4(V),U<Q?(Q=U,et=D,J=X<J?X:J):U===Q&&X<J&&(J=X,et=D);return et},_chooseSplitAxis:function($,k,E){var D=$.leaf?this.compareMinX:e$1,L=$.leaf?this.compareMinY:o$5;this._allDistMargin($,k,E,D)<this._allDistMargin($,k,E,L)&&$.children.sort(D)},_allDistMargin:function($,k,E,D){$.children.sort(D);var L,V,U=this.toBBox,X=a$5($,0,k,U),Q=a$5($,E-k,E,U),J=l$6(X)+l$6(Q);for(L=k;L<E-k;L++)V=$.children[L],r$4(X,$.leaf?U(V):V),J+=l$6(X);for(L=E-k-1;L>=k;L--)V=$.children[L],r$4(Q,$.leaf?U(V):V),J+=l$6(Q);return J},_adjustParentBBoxes:function($,k,E){for(var D=E;D>=0;D--)r$4(k[D],$)},_condense:function($){for(var k,E=$.length-1;E>=0;E--)0===$[E].children.length?E>0?(k=$[E-1].children).splice(k.indexOf($[E]),1):this.clear():h$1($[E],this.toBBox)},_initFormat:function($){var k=["return a"," - b",";"];this.compareMinX=new Function("a","b",k.join($[0])),this.compareMinY=new Function("a","b",k.join($[1])),this.toBBox=new Function("a","return {minX: a"+$[0]+", minY: a"+$[1]+", maxX: a"+$[2]+", maxY: a"+$[3]+"};")}};let jc=class t11{static fromReader($){const k=[],E=$.copy(),D=He();for(;E.next();)E.getBounds(D)&&k.push(E.getIndex());const L=i$3(9,($=>(E.setIndex($),{minX:E.getBoundsXMin(),minY:E.getBoundsYMin(),maxX:E.getBoundsXMax(),maxY:E.getBoundsYMax()})));return L.load(k),new t11(L)}constructor($){this._index=$}search($){const k={minX:$[0],minY:$[1],maxX:$[2],maxY:$[3]};return this._index.search(k)}};function A2($,k,E,D){if(D.isWebMercator){const D=Ms($/ks.radius),L=D-360*Math.floor((D+180)/360),V=[0,0];return Y2(V,0,Ms(Math.PI/2-2*Math.atan(Math.exp(-k/ks.radius))),L,E),V}const L=mr({x:$,y:k},D,os.WGS84);if(!L)return null;const V=[0,0];return Y2(V,0,L.y,L.x,E),V}function Y2($,k,E,D,L){L%2&&(L+=1);let V=0,U=0,X=-90,Q=90,J=-180,et=180;for(let st=0;st<L/2;st++){for(let $=0;$<5;$++){const k=(J+et)/2,E=D>k?1:0;V|=E<<29-($+5*st),J=(1-E)*J+E*k,et=(1-E)*k+E*et}for(let $=0;$<5;$++){const k=(X+Q)/2,D=E>k?1:0;U|=D<<29-($+5*st),X=(1-D)*X+D*k,Q=(1-D)*k+D*Q}}$[2*k]=V,$[2*k+1]=U}let Gc=class l7 extends Ic{static create($,k,E,D){const L=$c.create($),V=new Array(32);for(let U=0;U<V.length;U++)V[U]=null;return new l7(L,k,E,D,V)}constructor($,k,E,D,L){super($),this.xNode=k,this.yNode=E,this.depth=D,this.children=L,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}get id(){return`${this.xNode}.${this.yNode}`}get containedObjectIds(){return this._objectIds}get count(){return this._count}clone(){const $=new l7(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return $._count=this._count,$._xWorldTotal=this._xWorldTotal,$._yWorldTotal=this._yWorldTotal,$._xGeohashTotal=this._xGeohashTotal,$._yGeohashTotal=this._yGeohashTotal,$.next=this.next,$._objectIds=new Set(this._objectIds),$}insert($,k,E,D,L,V){this._count+=1,this._xWorldTotal+=k,this._yWorldTotal+=E,this._xGeohashTotal+=D,this._yGeohashTotal+=L,this._statistics.insert($,V),this._objectIds.add($.getObjectId())}merge($){if(0!==$._count){this._count+=$._count,this._xWorldTotal+=$._xWorldTotal,this._yWorldTotal+=$._yWorldTotal,this._xGeohashTotal+=$._xWorldTotal,this._yGeohashTotal+=$._yWorldTotal,this._statistics.merge($._statistics);for(const k of $._objectIds.values())this._objectIds.add(k)}}getCentroid($){throw new Error("getCentroid not supported for GeohashNode")}getGeometry($,k){const E=this._getLngLatBounds(),[D,L,V,U]=E,X=mr({rings:[[[D,L],[D,U],[V,U],[V,L],[D,L]]]},os.WGS84,$),Q=Ts(new qt,X,!1,!1);return null!=k?vs(new qt,Q,!1,!1,"esriGeometryPolygon",k,!1,!1):Q}getGeometricCentroid($,k){const E=this._getLngLatBounds(),[D,L,V,U]=E,X=mr({x:(D+V)/2,y:(L+U)/2},os.WGS84,$),Q=Fs(new qt,X);return null!=k?vs(new qt,Q,!1,!1,"esriGeometryPoint",k,!1,!1):Q}getAttributes(){const $={aggregateId:this.id};for(const k of this._statistics.values())$[k.field.name]=k.value;return $.aggregateCount=this._count,$}find($,k,E,D,L,V){if(D>=E)return this;const U=1-D%2,X=3*U+2*(1-U),Q=2*U+3*(1-U),J=30-L-X,et=30-V-Q,st=(($&7*U+3*(1-U)<<J)>>J)+((k&3*U+7*(1-U)<<et)>>et)*(8*U+4*(1-U)),ut=this.children[st];return null==ut?null:ut.find($,k,E,D+1,L+X,V+Q)}_getLngLatBounds(){const $=this.depth,k=Math.ceil($/2),E=Math.floor($/2),D=30-(3*k+2*E),L=30-(2*k+3*E);return function R3($,k){let E=-90,D=90,L=-180,V=180;for(let U=0;U<k;U++){const k=Math.ceil((U+1)/2),X=Math.floor((U+1)/2),Q=1-U%2,J=30-(3*k+2*X),et=30-(2*k+3*X),st=3*Q+2*(1-Q),ut=2*Q+3*(1-Q),ht=3*Q+7*(1-Q)<<et,_t=(7*Q+3*(1-Q)<<J&$.geohashX)>>J,vt=(ht&$.geohashY)>>et;for(let $=st-1;$>=0;$--){const k=(L+V)/2,E=_t&1<<$?1:0;L=(1-E)*L+E*k,V=(1-E)*k+E*V}for(let $=ut-1;$>=0;$--){const k=(E+D)/2,L=vt&1<<$?1:0;E=(1-L)*E+L*k,D=(1-L)*k+L*D}}return[L,E,V,D]}({geohashX:this.xNode<<D,geohashY:this.yNode<<L},this.depth)}};class e9{constructor($){this._fields=$,this._size=0,this._depth=0,this._root=Gc.create(this._fields,0,0,0)}destroy(){}get size(){return this._size}get depth(){return this._depth}find($,k,E){return this._root.find($,k,E,0,0,0)}insert($,k,E,D,L,V,U){let X=this._root,Q=0,J=0,et=0;for(;null!==X;){if(X.insert($,k,E,D,L,U),Q>=V)return;const st=Math.ceil((Q+1)/2),ut=Math.floor((Q+1)/2),ht=1-Q%2,_t=30-(3*st+2*ut),vt=30-(2*st+3*ut),Et=(D&7*ht+3*(1-ht)<<_t)>>_t,Pt=(L&3*ht+7*(1-ht)<<vt)>>vt,Ot=Et+Pt*(8*ht+4*(1-ht));J=J<<3*ht+2*(1-ht)|Et,et=et<<2*ht+3*(1-ht)|Pt,null==X.children[Ot]&&(X.children[Ot]=Gc.create(this._fields,J,et,Q+1),this._depth=Math.max(this._depth,Q+1),this._size+=1),Q+=1,X=X.children[Ot]}}putBins($,k){for(const E of this.getNodes(k)){const k=$.get(E.id);k?k.merge(E):$.set(E.id,E.clone())}}getNodes($){const k=[],{geohashBounds:E,level:D}=$;let L=this._root;for(;null!==L;){const $=L.depth,V=L.xNode,U=L.yNode;if($>=D){k.push(L),L=L.next;continue}const X=Math.ceil(($+1)/2),Q=Math.floor(($+1)/2),J=1-$%2,et=30-(3*X+2*Q),st=30-(2*X+3*Q),ut=~((1<<et)-1),ht=~((1<<st)-1),_t=(E.xLL&ut)>>et,vt=(E.yLL&ht)>>st,Et=(E.xTR&ut)>>et,Pt=(E.yTR&ht)>>st,Ot=V<<3*J+2*(1-J),zt=U<<2*J+3*(1-J),Dt=Ot+8*J+4*(1-J),Nt=zt+4*J+8*(1-J),Lt=Math.max(Ot,_t),Vt=Math.max(zt,vt),qt=Math.min(Dt,Et),Ut=Math.min(Nt,Pt);let Yt=null,Qt=null;for(let k=Vt;k<=Ut;k++)for(let $=Lt;$<=qt;$++){const E=$-Ot+(k-zt)*(8*J+4*(1-J)),D=L.children[E];D&&(Yt||(Yt=D,Yt.next=L.next),Qt&&(Qt.next=D),Qt=D,D.next=L.next)}L=Yt||L.next}return k}}let Vc=class r10 extends Oc{constructor($){super($),this._tree=new e9(this._options.fields)}put($){throw new Error("Geohash tree does not support put")}putBounded($,k,E){const{geohashLevel:D,spatialReference:L}=this._options,V=function S$1($,k,E,D){const L=[$.xmin,$.ymin,$.xmax,$.ymax],V=Ss.fromExtent($s.fromBounds(L,D)),U=mr(V,D,os.WGS84,{densificationStep:64*k});if(!U)return null;const X=Ts(new qt,U,!1,!1),Q=X.coords.filter((($,k)=>!(k%2))),J=X.coords.filter((($,k)=>k%2)),et=Math.min(...Q),st=Math.min(...J),ut=Math.max(...Q),ht=Math.max(...J),_t=A2(et,st,E,os.WGS84),vt=A2(ut,ht,E,os.WGS84);return _t&&vt?{bounds:L,geohashBounds:{xLL:_t[0],yLL:_t[1],xTR:vt[0],yTR:vt[1]},level:E}:null}(k,E,D,L);null!=V&&this._tree.putBins($,V)}_insert($,k,E,D){const{geohashLevel:L,spatialReference:V}=this._options,U=A2(k,E,L,V);U&&this._tree.insert($,k,E,U[0],U[1],L,D)}},qc=class a8 extends M2{static from($,k){return new a8($.copy(),k)}constructor($,k){super($.metadata),this._currentIndex=-1,this._displayTranslationX=0,this._displayTranslationY=0,this._displayScaleX=1,this._displayScaleY=1,this._reader=$,this._indices=k,this._isPoint="esriGeometryPoint"===$.geometryType}setTransformForDisplay($){const k=this._reader.getInTransform();if(null==k){const[k,E]=$.scale,[D,L]=$.translate;return this._displayTranslationX=-D/k,this._displayScaleX=1/k,this._displayTranslationY=L/E,this._displayScaleY=1/-E,void(this._displayTransform=$)}const[E,D]=k.scale,[L,V]=k.translate,[U,X]=$.scale,[Q,J]=$.translate;if(this._displayScaleX=E/U,this._displayTranslationX=(L-Q)/U,this._displayScaleY=D/X,this._displayTranslationY=(-V+J)/X,!this._isPoint&&k)throw new Error("InternalError: Relative transformations not supported for non-point features");this._displayTransform=$}getInTransform(){return this._reader.getInTransform()}get fields(){return this._reader.fields}get hasNext(){return this._currentIndex+1<this._indices.length}getSize(){return this._indices.length}getCursor(){return this.copy()}copy(){const $=new a8(this._reader.copy(),this._indices);return $._currentIndex=this._currentIndex,$._displayTransform=this._displayTransform,$._displayTranslationX=this._displayTranslationX,$._displayTranslationY=this._displayTranslationY,$._displayScaleX=this._displayScaleX,$._displayScaleY=this._displayScaleY,$}get contextTimeZone(){return this._reader.contextTimeZone}set contextTimeZone($){this._reader.contextTimeZone=$}_nextIndex(){return++this._currentIndex<this._indices.length&&(this._reader.setIndex(this._indices[this._currentIndex]),!0)}next(){for(;this._nextIndex()&&!this._reader._getExists(););return this._currentIndex<this._indices.length}readXForDisplay(){return this._reader.readXForDisplay()*this._displayScaleX+this._displayTranslationX}readYForDisplay(){return this._reader.readYForDisplay()*this._displayScaleY+this._displayTranslationY}readGeometryForDisplay(){const $=this._reader.readGeometryForDisplay();if(!this._displayTransform)return $;const k=new qt;return vs(k,$,this.hasZ,this.hasM,this.geometryType,this._displayTransform),k.deltaDecode()}readCentroidForDisplay(){var $;const k=null==($=this._reader.readCentroidForDisplay())?void 0:$.clone();if(k){const[$,E]=k.coords;k.coords[0]=$*this._displayScaleX+this._displayTranslationX,k.coords[1]=E*this._displayScaleY+this._displayTranslationY}return k}get geometryType(){return this._reader.geometryType}get hasFeatures(){return this._reader.hasFeatures}get exceededTransferLimit(){return this._reader.exceededTransferLimit}get hasZ(){return this._reader.hasZ}get hasM(){return this._reader.hasM}readAttribute($,k=!1){return this._reader.readAttribute($,k)}readAttributes(){return this._reader.readAttributes()}joinAttributes($){return this._reader.joinAttributes($)}getBounds($){return this._reader.getBounds($)}getAttributeHash(){return this._reader.getAttributeHash()}getObjectId(){return this._reader.getObjectId()}getDisplayId(){return this._reader.getDisplayId()}setDisplayId($){return this._reader.setDisplayId($)}setIndex($){return this._reader.setIndex($)}getIndex(){return this._reader.getIndex()}readXWorldSpace(){return this._reader.readXWorldSpace()}readYWorldSpace(){return this._reader.readYWorldSpace()}_readX(){return this._reader.readXForDisplay()}_readY(){return this._reader.readYForDisplay()}_readServerCentroid(){return this._reader._readServerCentroid()}readLegacyFeatureForDisplay(){const $=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:($&&{x:$.coords[0],y:$.coords[1]})??null}}readLegacyGeometryForDisplay(){const $=this.readGeometryForDisplay();return Re($,this.geometryType,!1,!1)}readGeometryArea(){return this._reader.readGeometryArea()}readGeometryWorldSpace(){return this._reader.readGeometryWorldSpace()}_readGeometry(){return this._reader._readGeometry()}_readAttribute($,k){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}_readAttributes(){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}readArcadeFeature(){return this._reader.readArcadeFeature()}geometry(){return this._reader.geometry()}field($){return this._reader.field($)}hasField($){return this._reader.hasField($)}setField($,k){return this._reader.setField($,k)}keys(){return this._reader.keys()}castToText($=!1){return this._reader.castToText($)}},Uc=class i8{size(){return this.reader.getSize()}get fields(){return this.reader.fields}invalidate(){this._aggregateIndex=null,this._aggregateIndexHash=null,this._spatialIndex=null}queryFeaturesInBounds($){const k=this._getSpatialIndex().search($);return qc.from(this.reader,k)}getAggregateIndex($){const k=JSON.stringify($);if(k!==this._aggregateIndexHash){switch(this._aggregateIndexHash=k,$.type){case"grid":this._aggregateIndex=new zc($);break;case"geohash":this._aggregateIndex=new Vc($)}this._aggregateIndex.insert(this.reader,this.isTiled)}return this._aggregateIndex}_getSpatialIndex(){return this._spatialIndex||(this._spatialIndex=jc.fromReader(this.reader)),this._spatialIndex}},Wc=class r11 extends Uc{constructor($,k){super(),this.metadata=$,this.removed=new Set,this.overriddenIds=new Set,this._features=[],this.chunkId=k,this.normalizedChunkId=k}get reader(){return bc.fromOptimizedFeatures(this._features,this.metadata)}get queryInfo(){return{}}get first(){return!1}get end(){return!1}get isTiled(){return!1}applyOverrides($){super.invalidate();const{reader:k,removed:E}=$,D=[],L=new Set,V=k.getCursor(),U=new Set(E);for(this.overriddenIds.clear();V.next();){const $=V.readOptimizedFeatureWorldSpace(),k=$.objectId;D.push($),L.add(k),this.overriddenIds.add(k),this.removed.delete(k)}for(const X of this._features){const $=X.objectId;U.has($)||L.has($)||(D.push(X),this.overriddenIds.add($))}this._features=D;for(const X of L.values())this.removed.delete(X);for(const X of E)this.removed.add(X),this.overriddenIds.add(X)}removeOverrides($){const k=$.reader.getCursor(),E=new Set;for(;k.next();){const $=k.getObjectId();this.overriddenIds.has($)&&(E.add($),this.overriddenIds.delete($))}this._features=this._features.filter(($=>!E.has($.objectId)))}getTileReader($){if(!this._features.length)return null;const k=this.queryFeaturesInBounds($.bounds);return k.setTransformForDisplay($.transform),k}},Yc=class n9 extends Ua{},Xc=class o8 extends Wa{constructor($,k,E){super($,k),this._timeZone=E,this.handledChunks=new Set,this.handledChunksForIdCreation=new Set,this.handledChunksForAttributeData=new Set,this._streamLayerDeferredObjectIdsToRemove=[]}destroy(){super.destroy();for(const $ of this._source.chunks())this._cleanupChunkIds($)}invalidateAttributeData(){this.handledChunksForAttributeData.clear()}onSubscribe($){super.onSubscribe($),this._evalOptions=$.tile.createArcadeEvaluationOptions(this._timeZone)}createState($){return new Yc($)}get aggregateQueryEngine(){return null}displayMap($,k,E){const D=new Map($.map(($=>[k($),$]))),L=[];for(const V of this._source.chunks()){const $=V.reader.getCursor();for(;$.next();){const k=$.getObjectId(),V=$.getDisplayId(),U=D.get(k);if(null!=U){const $=E(V,U,k);L.push($),D.delete(k)}}}return L}getDisplayFeatures($){const k=new Set($),E=new Set,D=[];for(const L of this._source.chunks()){const $=L.reader.getCursor();for(;$.next();){const L=$.getObjectId(),V=$.getDisplayId();k.has(V)&&!E.has(L)&&(D.push({...$.readLegacyFeatureWorldSpace(),displayId:V}),E.add(L))}}return{features:D,aggregates:[]}}async*applyLocalEdit($){const k=[],E=$.reader.getCursor();for(;E.next();){const $=E.getObjectId();k.push($);const D=this._attributeStore.createDisplayIdForObjectId($);E.setDisplayId(D),this._attributeStore.setAttributeData(D,E,this._evalOptions)}const D=this.getDisplayIds(k),L=this.getDisplayIds($.removed),V=new Wc(this._source.metadata,"localEdit");V.applyOverrides($),this.handledChunks.add(V.chunkId),this.handledChunksForAttributeData.add(V.chunkId),this.handledChunksForIdCreation.add(V.chunkId);for(const U of this._sendStates.values())U.handledChunks.add(V.chunkId),yield new Ha(U.subscription,null,D,!1,V.queryInfo);for(const U of this._sendStates.values()){const $=V.getTileReader(U.subscription.tile);yield new Ha(U.subscription,$,L,!1,V.queryInfo)}for(const U of $.removed)this._attributeStore.releaseDisplayIdForObjectId(U)}async*updateChunks(){if(this._source.chunks().length){await this._updateAttributeData();for(const $ of this._sendStates.values())yield*this._update($)}}removeChunks($){for(const k of $)this.handledChunks.delete(k.chunkId),this.handledChunksForAttributeData.delete(k.chunkId),this._cleanupChunkIds(k)}afterUpdateChunks(){for(const $ of this._streamLayerDeferredObjectIdsToRemove)this._attributeStore.releaseDisplayIdForObjectId($);this._streamLayerDeferredObjectIdsToRemove=[]}_cleanupChunkIds($){if(this.handledChunksForIdCreation.has($.chunkId)){const k=$.reader.getCursor();for(;k.next();){const $=k.getObjectId();this._source.isStream?this._streamLayerDeferredObjectIdsToRemove.push($):this._attributeStore.releaseDisplayIdForObjectId($)}this.handledChunksForIdCreation.delete($.chunkId)}}async _updateAttributeData(){for(const $ of this._source.chunks()){const{chunkId:k,reader:E}=$;if(!this.handledChunksForIdCreation.has(k)){this.handledChunksForIdCreation.add(k);const $=E.getCursor();for(;$.next();){const k=this._attributeStore.createDisplayIdForObjectId($.getObjectId());$.setDisplayId(k)}}}for(const $ of this._source.chunks())if(!this.handledChunksForAttributeData.has($.chunkId)){this.handledChunksForAttributeData.add($.chunkId);const k=$.reader.getCursor();for(;k.next();){const $=k.getDisplayId();this._attributeStore.setAttributeData($,k,this._evalOptions)}}}*_update($){const{subscription:k,handledChunks:E}=$;for(const D of this._source.chunks()){const{chunkId:L}=D;if(E.has(L))continue;E.add(L);const V=D.getTileReader(k.tile);V&&(yield new Xa($.subscription,V,!1,D.end,D.queryInfo))}}};let Hc=class t12{constructor($){this.data=$,this._referenceCount=0}increment(){this._referenceCount+=1}decrement(){this._referenceCount-=1}empty(){return 0===this._referenceCount}},Zc=class s15{constructor(){this._freeIdsGenerationA=[],this._freeIdsGenerationB=[],this._idCounter=1,this._freeIds=this._freeIdsGenerationA,this._objectIdToDisplayId=new Map}createIdForObjectId($){let k=this._objectIdToDisplayId.get($);return k?k.increment():(k=new Hc(function s$e($,k){return((k?8388608:0)|$)>>>0}(this._getFreeId(),!1)),k.increment(),this._objectIdToDisplayId.set($,k)),k.data}releaseIdForObjectId($){const k=this._objectIdToDisplayId.get($);k&&(k.decrement(),k.empty()&&(this._objectIdToDisplayId.delete($),this._freeIds.push(k.data)))}releaseAll(){for(const $ of this._objectIdToDisplayId.values())this._freeIds.push($.data);this._objectIdToDisplayId.clear()}incrementGeneration(){this._freeIds=this._freeIds===this._freeIdsGenerationA?this._freeIdsGenerationB:this._freeIdsGenerationA}_getFreeId(){return this._freeIds.length?this._freeIds.pop():this._idCounter++}};const f$3=()=>Dt.getLogger("esri.views.layers.2d.features.support.AttributeStore"),Kc=(f$3(),()=>null);oe("esri-shared-array-buffer"),oe("esri-atomics");let Qc=class m7{constructor($,k,E){this.size=0,this.texelSize=4,this.dirtyStart=0,this.dirtyEnd=0;const{pixelType:D,layout:L,textureOnly:V}=k;this.textureOnly=V||!1,this.pixelType=D,this.layout=L,this._resetRange(),this.size=$,this.isLocal=E,V||(this.data=this._initData(D,$))}get buffer(){var $;return null==($=this.data)?void 0:$.buffer}unsetComponentAllTexels($,k){const E=this.data;for(let D=0;D<this.size*this.size;D++)E[D*this.texelSize+$]&=~k;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponentAllTexels($,k){const E=this.data;for(let D=0;D<this.size*this.size;D++)E[D*this.texelSize+$]|=255&k;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponent($,k,E){const D=this.data;for(const L of E)D[L*this.texelSize+$]|=k,this.dirtyStart=Math.min(this.dirtyStart,L),this.dirtyEnd=Math.max(this.dirtyEnd,L)}setComponentTexel($,k,E){this.data[E*this.texelSize+$]|=k,this.dirtyStart=Math.min(this.dirtyStart,E),this.dirtyEnd=Math.max(this.dirtyEnd,E)}unsetComponentTexel($,k,E){this.data[E*this.texelSize+$]&=~k,this.dirtyStart=Math.min(this.dirtyStart,E),this.dirtyEnd=Math.max(this.dirtyEnd,E)}getData($,k){const E=f$6($);return this.data[E*this.texelSize+k]}setData($,k,E){const D=f$6($),L=1<<k;this.layout&L?null!=this.data&&(this.data[D*this.texelSize+k]=E,this.dirtyStart=Math.min(this.dirtyStart,D),this.dirtyEnd=Math.max(this.dirtyEnd,D)):f$3().error("mapview-attributes-store","Tried to set a value for a texel's readonly component")}expand($){if(this.size=$,!this.textureOnly){const k=this._initData(this.pixelType,$),E=this.data;k.set(E),this.data=k}}toMessage(){const $=this.dirtyStart,k=this.dirtyEnd,E=this.texelSize;if($>k)return null;this._resetRange();const D=!this.isLocal,L=this.pixelType,V=this.layout,U=this.data;return{start:$,end:k,data:D&&U.slice($*E,(k+1)*E)||null,pixelType:L,layout:V}}_initData($,k){const E=ArrayBuffer,D=d$g($),L=new D(new E(k*k*4*D.BYTES_PER_ELEMENT));for(let V=0;V<L.length;V+=4)L[V+1]=255;return L}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}};class b2{constructor($){this._client=$,this._filters=[],this._blocks=new Array,this._attributeComputeInfo=null,this._abortController=new AbortController,this._size=Es,this._idsToHighlight=new Map,this._referencesScale=!1,this._referencesGeometry=!1,this._initialized=!1,this.version=0,this._idGenerator=new Zc,this._epoch=1}destroy(){this._abortController.abort()}_initialize(){if(null!=this._blockDescriptors)return;const $=Pt.FLOAT;this._blockDescriptors=[{pixelType:Pt.UNSIGNED_BYTE,layout:1},{pixelType:Pt.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:Pt.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:$,layout:15},{pixelType:$,layout:15},{pixelType:$,layout:15},{pixelType:$,layout:15}],this._blocks=this._blockDescriptors.map((()=>null))}get referencesScale(){return this._referencesScale}get referencesGeometry(){return this._referencesGeometry}get hasHighlight(){return this._idsToHighlight.size>0}createDisplayIdForObjectId($){return this._idGenerator.createIdForObjectId($)}releaseDisplayIdForObjectId($){return this._idGenerator.releaseIdForObjectId($)}incrementDisplayIdGeneration(){this._idGenerator.incrementGeneration()}releaseAllIds(){this._idGenerator.releaseAll()}async update($,k,E,D,L=0){const V=Cs(this._schema,$);if(this.version=L,V&&(oe("esri-2d-update-debug"),this._schema=$,this._attributeComputeInfo=null,this._initialize(),null!=$))if(E&&(this._filters=await Promise.all($.filters.map(($=>$?nc.create({geometryType:E.geometryType,hasM:!1,hasZ:!1,timeInfo:E.timeInfo,fieldsIndex:E.fieldsIndex,spatialReference:D??E.spatialReference,filterJSON:$}):null)))),"subtype"!==$.type)this._attributeComputeInfo={isSubtype:!1,map:new Map},await Promise.all($.bindings.map((async $=>{const E=await this._bind(k,$);this._referencesGeometry=this._referencesGeometry||((null==E?void 0:E.referencesGeometry())??!1),this._referencesScale=this._referencesScale||((null==E?void 0:E.referencesScale())??!1)})));else{this._attributeComputeInfo={isSubtype:!0,subtypeField:$.subtypeField,map:new Map},this._referencesScale=!1,this._referencesGeometry=!1;for(const E in $.bindings){const D=$.bindings[E];await Promise.all(D.map((async $=>{const D=await this._bind(k,$,parseInt(E,10));this._referencesGeometry=this._referencesGeometry||((null==D?void 0:D.referencesGeometry())??!1),this._referencesScale=this._referencesScale||((null==D?void 0:D.referencesScale())??!1)})))}}}setHighlight($,k){const E=this._getBlock(0);E.unsetComponentAllTexels(0,(1<<go.length)-1);for(const{displayId:D,highlightFlags:L}of $){if(null==D)continue;const $=f$6(D);E.setComponent(0,L,[$])}this._idsToHighlight.clear();for(const{objectId:D,highlightFlags:L}of $)this._idsToHighlight.set(D,L);for(const{objectId:D,highlightFlags:L}of k)this._idsToHighlight.set(D,L)}setData($,k,E,D){const L=f$6($);this._ensureSizeForTexel(L),this._getBlock(k).setData($,E,D)}getData($,k,E){return this._getBlock(k).getData($,E)}getHighlightFlags($){return this._idsToHighlight.get($)||0}unsetAttributeData($){const k=f$6($);this._getBlock(0).setData(k,0,0)}setAttributeData($,k,E){const D=f$6($);this._ensureSizeForTexel(D),this._getBlock(0).setData(D,0,this.getFilterFlags(k));const L=this._attributeComputeInfo;let V=null;L&&(V=L.isSubtype?L.map.get(k.readAttribute(L.subtypeField)):L.map,(null==V?void 0:V.size)&&V.forEach((($,L)=>{var V;const U=1*L%4,X=Math.floor(1*L/4),Q=this._getBlock(X+Ps.VV);let J=null==(V=$.field)?void 0:V.read(k,E);$.valueRepresentation&&(J=function g$1($,k){if(!$||!k)return $;switch(k){case"radius":case"distance":return 2*$;case"diameter":case"width":return $;case"area":return Math.sqrt($)}return $}(J,$.valueRepresentation)),(null===J||isNaN(J)||J===1/0||J===-1/0)&&(J=Ai),Q.setData(D,U,J)})))}get epoch(){return this._epoch}sendUpdates(){const $=this._blocks.map(($=>null!=$?$.toMessage():null)),k=this._getInitArgs();oe("esri-2d-log-updating"),this._client.update({initArgs:k,blockData:$,version:this.version,sendUpdateEpoch:this._epoch}),this._epoch+=1,oe("esri-2d-log-updating")}_ensureSizeForTexel($){for(;$>=this._size*this._size;)if(this._expand())return}async _bind($,k,E){const D=await $.createComputedField(k),{valueRepresentation:L}=k,V=this._attributeComputeInfo;if(V.isSubtype){const $=V.map.get(E)??new Map;$.set(k.binding,{field:D,valueRepresentation:L}),V.map.set(E,$)}else V.map.set(k.binding,{field:D,valueRepresentation:L});return D}_getInitArgs(){return this._initialized?null:(this._initialized=!0,this._getBlock(Ps.Animation),this._getBlock(Ps.GPGPU),{blockSize:this._size,blockDescriptors:this._blocks.map(($=>null!=$?{textureOnly:$.textureOnly,buffer:$.buffer,pixelType:$.pixelType}:null))})}_getBlock($){const k=this._blocks[$];if(null!=k)return k;const E=new Qc(this._size,this._blockDescriptors[$],this._client.isLocal);return this._blocks[$]=E,this._initialized=!1,E}_expand(){if(this._size<this._schema.capabilities.maxTextureSize){const $=this._size<<=1;Kc("Expanding block size to",$,this._blocks);for(const k of this._blocks)null==k||k.expand($);return this._initialized=!1,this._size=$,0}return f$3().error(new Et("mapview-limitations","Maximum number of onscreen features exceeded.")),-1}isVisible($){return!!(this._getBlock(0).getData($,0)&1<<go.length)}getFilterFlags($){let k=0;for(let D=0;D<this._filters.length;D++){const E=!!(1<<D),L=this._filters[D];k|=(!E||null==L||L.check($)?1:0)<<D}let E=0;if(this._idsToHighlight.size){const k=$.getObjectId();E=this.getHighlightFlags(k)}return k<<go.length|E}}let Jc=class f3{constructor($,k){this._connection=$,this._source=k,this._version=1,this._registry=new W2,this._proxy=new ri({fetch:($,k)=>this._connection.layerView.fetch($,k),fetchDictionary:($,k)=>this._connection.layerView.fetchDictionary($,k)}),this._attributeStore=new b2({isLocal:!1,update:$=>ht(this._connection.container.updateAttributeView($))})}destroy(){var $;this._proxy.destroy(),null==($=this._strategy)||$.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){var $;return null==($=this._strategy)?void 0:$.aggregateQueryEngine}getDisplayFeatures($){return this._strategy?this._strategy.getDisplayFeatures($):{features:[],aggregates:[]}}getFeatureObjectIdsForAggregate($){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate($):[]}onSubscribe($){var k;null==(k=this._strategy)||k.onSubscribe($)}onUnsubscribe($){var k;null==(k=this._strategy)||k.onUnsubscribe($)}async update($,k,E,D,L){var V,U,X,Q,J;const et=$.processor,st=As(null==(V=this._schema)?void 0:V.storage,et.storage),ut=As(null==(U=this._schema)?void 0:U.mesh.properties,et.mesh.properties),ht=As(null==(X=this._schema)?void 0:X.mesh.factory,et.mesh.factory),_t=As(null==(Q=this._schema)?void 0:Q.mesh.strategy,et.mesh.strategy),vt=ut||ht||_t;if(!st&&!vt&&!D)return;oe("esri-2d-update-debug"),this._schema=et;const Et=os.fromJSON(this._source.service.outSpatialReference),Pt=new rc({fields:this._source.metadata.fieldsIndex,spatialReference:Et});if(await this._attributeStore.update(et.storage,Pt,this._source.metadata,Et,k),null==(J=this._strategy)||J.invalidateAttributeData(),!D&&!vt)return;(_t||ut)&&await this._updateStrategy(et.mesh.strategy,Et,L,et.mesh.properties.timeZone),this._updateSortKey(Pt,"sortKey"in et.mesh.properties?et.mesh.properties.sortKey:null);const Ot=new Ga(Pt,this._proxy,E,this._registry);return(ht||"dictionary"===et.mesh.factory.symbology.type)&&(this._factory=await ei.create(Ot,et.mesh.factory)),this._invalidate(),this._version=k,this._connection.container.updateRenderState(this._version)}async applyLocalEdit($){if(!this._strategy)return;const k=this._strategy.applyLocalEdit($);for await(const D of k)try{await this._process(D)}catch(E){}}async updateChunks(){var $;await this._doUpdateChunks(),null==($=this._strategy)||$.afterUpdateChunks()}async removeChunks($){var k;null==(k=this._strategy)||k.removeChunks($),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:$}){if(!this._strategy)return void this._attributeStore.setHighlight($.map((({objectId:$,highlightFlags:k})=>({objectId:$,highlightFlags:k,displayId:-1}))),$);const k=this._strategy.displayMap($,(({objectId:$})=>$),(($,{highlightFlags:k},E)=>({objectId:E,displayId:$,highlightFlags:k})));this._attributeStore.setHighlight(k,$)}async _doUpdateChunks(){if(!this._strategy)return;const $=this._strategy.updateChunks(),k=[],E=new Map;for await(const D of $){let $=E.get(D.id);null==$&&($=new Va({concurrency:16,process:$=>this._process($)}),E.set(D.id,$));const L=$.push(D).catch(($=>Os($)));k.push(L)}try{await Promise.all(k)}catch(ki){}oe("esri-2d-update-debug"),this._attributeStore.sendUpdates(),oe("esri-2d-update-debug")}async _updateStrategy($,k,E,D){var L;switch(null==(L=this._strategy)||L.destroy(),$.type){case"feature":this._strategy=new Xc(this._source,this._attributeStore,D);break;case"binning":this._strategy=await wc.create($,k,this._source,this._attributeStore,D);break;case"cluster":this._strategy=await Lc.create(this._connection,$,k,this._source,this._attributeStore,D)}for(const V of E)this._strategy.onSubscribe(V)}async _updateSortKey($,k){var E;if(this._sortInfo=zs(null==(E=this._sortInfo)?void 0:E.computed),null!=k){const E=k.byRenderer?null:await $.createComputedField(k);this._sortInfo={...k,computed:E}}}_invalidate(){this._strategy&&this._strategy.invalidate()}async _process($){var k,E,D;const L=$.subscription;if(oe("esri-2d-update-debug")){L.tile}await this._fetchResources($),Rs(L.signal);const V=await this._write($,L.tile.createArcadeEvaluationOptions(null==(k=this._schema)?void 0:k.mesh.properties.timeZone)),U=L.tile.tileInfoView.tileInfo.isWrappable,{message:X,transferList:Q}=V.serialize(U),J={objectIdMap:null,inner:$.createMessage(X,this._version,this._attributeStore.epoch)};if(null==(E=this._schema)?void 0:E.mesh.properties.returnMeshObjectId){J.objectIdMap={};const k=null==(D=$.reader)?void 0:D.getCursor();if(k)for(;k.next();)J.objectIdMap[k.getDisplayId()]=k.getObjectId()}if(Rs(L.signal),await this._connection.container.onMessage(J,{signal:L.signal,transferList:Q}),this._attributeStore.sendUpdates(),oe("esri-2d-update-debug")){L.tile}}async _fetchResources($){await this._fetchMatcherResources($),await this._fetchWriterResources($)}async _fetchMatcherResources($){if($.reader)return this._factory.enqueueMatcherRequests(this._proxy,$.reader)}async _fetchWriterResources($){if(!$.reader)return;const k=$.reader.getCursor(),E=$.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);for(;k.next();)this._factory.enqueueWriterRequests(this._proxy,k,E);await this._proxy.fetchEnqueuedResources()}async _write($,k){var E;const D=$.subscription.tile,L=null==(E=$.reader)?void 0:E.getCursor(),V=(null==L?void 0:L.getSize())??0,U=D.tileInfoView.tileInfo.isWrappable,X=new Wr(D.key,this._strategy.enablePixelBuffering,U,V);if(!L)return X;const Q=D.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);for(;L.next();){const $=this._getSortKeyValue(L,k);X.entityStart(L.getDisplayId(),$),this._factory.write(X,this._proxy,L,Q,D.level),X.entityEnd()}return X}_getSortKeyValue($,k){if(!this._sortInfo)return 0;const{computed:E,order:D,byRenderer:L}=this._sortInfo,V=L?this._factory.getSortKey($,k):null==E?void 0:E.read($,k);return null==V||isNaN(V)?0:V*("asc"===D?-1:1)}},tl=class t13{static from($){let k=0,E=0,D=0;return $.forEach(($=>{const L=$._readGeometry();L&&(E+=L.isPoint?1:L.lengths.reduce((($,k)=>$+k),0),D+=L.isPoint?1:L.lengths.length,k+=1)})),new t13(k,E,D)}constructor($,k,E){this.featureCount=$,this.vertexCount=k,this.ringCount=E}toJSON(){return{featureCount:this.featureCount,ringCount:this.featureCount,vertexCount:this.featureCount}}};let el=class n10{static fromSchema($,k,E){const D="feature"===k.type?k.mutable.dataFilter.queryScaleRanges:[];return new n10(function s$2($,k,E){const D=$.orderByFields??E.objectIdField+" ASC",L=$.source,V={returnCentroid:!(null!==L&&"object"==typeof L&&"path"in L&&Bs(L.path))&&"esriGeometryPolygon"===E.geometryType,returnGeometry:!0,timeReferenceUnknownClient:E.timeReferenceUnknownClient??void 0,outSpatialReference:os.fromJSON($.outSpatialReference),orderByFields:[D],where:k.mutable.dataFilter.definitionExpression??"1=1",outFields:k.mutable.availableFields};if("feature"===k.type){const{gdbVersion:$,historicMoment:E,timeExtent:D}=k.mutable.dataFilter;return{...V,gdbVersion:$,historicMoment:E?new Date(E):null,timeExtent:D?Ns.fromJSON(D):null,outFields:k.mutable.availableFields}}return V}($,k,E),D,E.subtypeField,k.mutable.dataFilter.customParameters,E.geometryType,$.queryMetadata)}constructor($,k,E,D,L,V){this._queryParams=$,this._queryScaleRanges=k,this._subtypeField=E,this._customParameters=D,this._geometryType=L,this._queryMetadata=V}get pageSize(){if(null==this._queryMetadata)throw new Error("InternalError: Service does not support paged queries");const $=this._queryMetadata.supportsMaxRecordCountFactor?4:null,k=(this._queryMetadata.maxRecordCount??8e3)*($??1);return Math.min(8e3,k)}updateHistoricMoment($){this._queryParams.historicMoment=$}updateFields($){this._queryParams.outFields=$}createPatchFieldsQuery($,k){if(!k.getSize())return null;const E=$.clone();if("*"===this._queryParams.outFields[0]){if("*"===(E.outFields??[])[0])return null;E.outFields=this._queryParams.outFields}else{const $=new Set(this._queryParams.outFields),D=[];for(const E of $)k.hasField(E)||D.push(E);if(0===D.length)return null;E.outFields=D}return E.returnGeometry=!1,E.returnCentroid=!1,E.quantizationParameters=null,E.cacheHint=!0,{inner:E,customParameters:this._customParameters}}createQuery($={}){if(!this._queryParams)throw new Error("InternalError: queryInfo should be defined");return{inner:new rs({...this._queryParams,...$}),customParameters:this._customParameters}}createTileQuery($,k){if(null==this._queryMetadata)throw new Error("InternalError: Service does not support tile queries");const E=this.createQuery(k),D=E.inner;if(this._queryScaleRanges.length){const k=this._queryScaleRanges.filter((k=>(!k.minScale||k.minScale>=$.maxScale)&&(!k.maxScale||k.maxScale<=$.minScale))).map(($=>$.subtypeCode));if(k.length){const $=`${this._subtypeField} IN (${k})`;D.where=Ds(D.where,$)}}if(D.quantizationParameters=k.quantizationParameters??$.getQuantizationParameters(),D.resultType="tile",D.geometry=$.extent,this._queryMetadata.supportsQuantization?"esriGeometryPolyline"===this._geometryType&&(D.maxAllowableOffset=$.resolution*oe("feature-polyline-generalization-factor")):"esriGeometryPolyline"!==this._geometryType&&"esriGeometryPolygon"!==this._geometryType||(D.maxAllowableOffset=$.resolution,"esriGeometryPolyline"===this._geometryType&&(D.maxAllowableOffset*=oe("feature-polyline-generalization-factor"))),D.defaultSpatialReferenceEnabled=this._queryMetadata.supportsDefaultSpatialReference,D.compactGeometryEnabled=this._queryMetadata.supportsCompactGeometry,this._queryMetadata.supportsMaxRecordCountFactor&&(D.maxRecordCountFactor=4),oe("esri-tiles-debug")){const k=$.id.replaceAll("/",".");E.customParameters=E.customParameters?{...E.customParameters,tileId:k}:{tileId:k}}return E}createPagedTileQuery($,k){const E=this.pageSize;return this.createTileQuery($,{start:E*k,num:E,returnExceededLimitFeatures:!0})}createPagedQuery($){const k=this.pageSize;return this.createQuery({start:k*$,num:k,returnExceededLimitFeatures:!0,maxRecordCountFactor:4})}};let sl=class o9 extends Se{constructor($){super(),this._connection=$,this._enabledEventTypes=new Set,this._updateInfo={websocket:0,client:0},this._lastTime=performance.now(),this._queuedCommands=[],this.addHandles([Ls((()=>{var $;return(null==($=this._strategy)?void 0:$.connectionStatus)??"disconnected"}),($=>{this._layerView.setProperty({propertyName:"pipelineConnectionStatus",value:$})}),{initial:!0}),Ls((()=>{var $;return(null==($=this._strategy)?void 0:$.errorString)||null}),($=>this._layerView.setProperty({propertyName:"pipelineErrorString",value:$})),{initial:!0})])}destroy(){this._strategy=null,this.removeAllHandles()}get _layerView(){return this._connection.layerView}set strategy($){null==this._strategy&&this._resetUpdateInfo(performance.now());const k="event-handles";this.removeHandles(k),null!=$&&(this.addHandles([$.events.on("data-received",($=>this._onFeature($))),$.events.on("message-received",($=>this._onWebSocketMessage($))),$.events.on("features-updated",($=>this._onUpdate($))),$.events.on("tick",(()=>this._onTick()))],k),this._queuedCommands.forEach((k=>k($))),this._queuedCommands=[]),this._strategy=$}updateCustomParameters($){null!=$&&this._callOrEnqueue((k=>k.updateCustomParameters($)))}sendMessageToSocket($){this._callOrEnqueue((k=>k.sendMessageToSocket($)))}sendMessageToClient($){this._callOrEnqueue((k=>k.sendMessageToClient($)))}enableEvent($,k){k?this._enabledEventTypes.add($):this._enabledEventTypes.delete($)}disconnect(){var $;null==($=this._strategy)||$.disconnect()}connect(){var $;null==($=this._strategy)||$.connect()}clear(){var $;null==($=this._strategy)||$.clear()}_onWebSocketMessage($){this._enabledEventTypes.has("message-received")&&this._layerView.emitEvent({name:"message-received",event:$})}_onFeature($){this._updateInfo.websocket++,this._enabledEventTypes.has("data-received")&&this._layerView.emitEvent({name:"data-received",event:{attributes:$.attributes,centroid:$.centroid,geometry:$.geometry}})}_onUpdate($){this._updateInfo.client+=$}_onTick(){const $=performance.now(),k=$-this._lastTime;if(k>2500){const E=Math.round(this._updateInfo.client/(k/1e3)),D=Math.round(this._updateInfo.websocket/(k/1e3));this._resetUpdateInfo($),this._layerView.emitEvent({name:"update-rate",event:{client:E,websocket:D}})}}_resetUpdateInfo($){this._lastTime=$,this._updateInfo.client=0,this._updateInfo.websocket=0}_callOrEnqueue($){null!=this._strategy?$(this._strategy):this._queuedCommands.push($)}};xe([we()],sl.prototype,"_strategy",void 0),sl=xe([Ie("esri.views.2d.layers.features.sources.StreamMessenger")],sl);let rl=class r12{constructor($){this._store=$,this._controller=new AbortController}destroy(){this._controller.abort()}get _options(){return{signal:this._controller.signal}}unsafeSetQueryHistoricMoment($){throw new Error("InternalError: LoadStrategy does not support query info")}async queryOverride($){throw new Error("InternalError: LoadStrategy does not support fetching")}async queryByObjectId($){throw new Error("InternalError: LoadStrategy does not support fetching")}};const il=268435455;let nl=class o10{constructor(){this.hasFeatures=!1,this.exceededTransferLimit=!1,this.fieldCount=0,this.featureCount=0,this.objectIdFieldIndex=0,this.vertexCount=0,this.offsets={attributes:new Array,geometry:new Array},this.centroid=new Array}};const ol=268435455,al=128e3,cl={small:{delta:new Int32Array(128),decoded:new Int32Array(128)},large:{delta:new Int32Array(al),decoded:new Int32Array(al)}};function _4($){return $<=cl.small.delta.length?cl.small:($<=cl.large.delta.length||(cl.large.delta=new Int32Array(Math.round(1.25*$)),cl.large.decoded=new Int32Array(Math.round(1.25*$))),cl.large)}function l$3($){for(;$.next();){if(1===$.tag())return $.getMessage();$.skip()}return null}function p$1($,k,E,D,L,V){return.5*Math.abs($*D+E*V+L*k-$*V-E*k-L*D)}function y$2($,k,E,D){return 0==$*D-E*k&&$*E+k*D>0}let ll=class m8 extends M2{static fromBuffer($,k,E=!1){const D=k.geometryType,L=function f$1($){try{const k=2,E=new Mr(new Uint8Array($),new DataView($));for(;E.next();){if(E.tag()===k)return l$3(E.getMessage());E.skip()}}catch(L){const k=new Et("query:parsing-pbf","Error while parsing FeatureSet PBF payload",{error:L});Dt.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(k)}return null}($),V=function a$2($,k,E=!1){var D;const L=$.asUnsafe(),V=L.pos(),U=new nl;let X=0,Q=0,J=null,et=null,st=null,ut=!1;const ht=[];for(;L.next();)switch(L.tag()){case 1:J=L.getString();break;case 3:et=L.getString();break;case 12:st=L.processMessage(Fr);break;case 9:if(U.exceededTransferLimit=L.getBool(),U.exceededTransferLimit){U.offsets.geometry=E?new Float64Array(8e3):new Int32Array(8e3),U.centroid=E?new Float64Array(16e3):new Int32Array(16e3);for(let $=0;$<U.centroid.length;$++)U.centroid[$]=il}break;case 13:{const $=L.processMessage(kr);$.index=X++,ht.push($);break}case 15:{const $=L.getLength(),D=L.pos()+$;if(!U.exceededTransferLimit){const $=U.offsets.geometry,k=U.centroid;$.push(0),k.push(il),k.push(il)}!ut&&U.exceededTransferLimit&&(ut=!0,U.offsets.attributes=E?new Float64Array(8e3*X):new Uint32Array(8e3*X));let V=Q*X;for(;L.pos()<D&&L.next();)switch(L.tag()){case 1:{ut?U.offsets.attributes[V++]=L.pos():U.offsets.attributes.push(L.pos());const $=L.getLength();L.skipLen($);break}case 2:if(k){const $=L.getLength(),k=L.pos()+$;for(;L.pos()<k&&L.next();)switch(L.tag()){case 3:{L.getUInt32();const $=L.getSInt64(),k=L.getSInt64();U.centroid[2*Q]=$,U.centroid[2*Q+1]=k;break}default:L.skip()}}else{U.offsets.geometry[Q]=L.pos();const $=L.getLength();U.vertexCount+=$,L.skipLen($)}break;case 4:{const $=L.getLength(),k=L.pos()+$;for(;L.pos()<k&&L.next();)switch(L.tag()){case 3:{L.getUInt32();const $=L.getSInt64(),k=L.getSInt64();U.centroid[2*Q]=$,U.centroid[2*Q+1]=k;break}default:L.skip()}break}default:L.skip()}Q++,U.hasFeatures=!0;break}default:L.skip()}const _t=J||et;if(!_t)throw new Et("FeatureSet has no objectId or globalId field name");return U.fields=new ns(ht),U.featureCount=Q,U.fieldCount=X,U.objectIdFieldIndex=null==(D=U.fields.get(_t))?void 0:D.index,U.transform=st,U.displayIds=new Uint32Array(U.featureCount),U.groupIds=new Uint16Array(U.featureCount),L.move(V),U}(L,"esriGeometryPoint"===D,E);return new m8(L,V,k)}constructor($,k,E){super(E),this._hasNext=!1,this._isPoints=!1,this._featureIndex=-1,this._featureOffset=0,this._cache={area:0,unquantGeometry:void 0,geometry:void 0,centroid:void 0,legacyFeature:void 0,optFeature:void 0},this._parseCaches=new Array,this._geometryType=E.geometryType,this._reader=$,this._header=k,this._hasNext=k.hasFeatures,this._isPoints="esriGeometryPoint"===E.geometryType}get _size(){return this._header.featureCount}get fields(){return this._header.fields}get geometryType(){return this._geometryType}get hasZ(){return!1}get hasM(){return!1}get hasFeatures(){return this._header.hasFeatures}get hasNext(){return this._hasNext}get exceededTransferLimit(){return this._header.exceededTransferLimit}getSize(){return this._size}getInTransform(){return this._header.transform}getCursor(){return this.copy()}getIndex(){return this._featureIndex}setIndex($){this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0,this._featureIndex=$}getAttributeHash(){let $="";for(const k of this._header.fields.fields)$+=this._readAttributeAtIndex(k.index)+".";return $}getObjectId(){return this._readAttributeAtIndex(this._header.objectIdFieldIndex)}getDisplayId(){return this._header.displayIds[this._featureIndex]}setDisplayId($){this._header.displayIds[this._featureIndex]=$}readGeometryArea(){return this._cache.area||this._readGeometry(!0),this._cache.area}copy(){const $=this._reader.clone(),k=new m8($,this._header,this.metadata);return this.copyInto(k),k}next(){for(this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0;++this._featureIndex<this._size&&!this._getExists(););return this._featureIndex<this._size}_readX(){return this._header.centroid[2*this._featureIndex]}_readY(){return this._header.centroid[2*this._featureIndex+1]}_readServerCentroid(){const $=this._header.centroid[2*this._featureIndex],k=this._header.centroid[2*this._featureIndex+1];return $===ol?null:new qt([],[$,k])}_readGeometry($=!1){if(void 0===this._cache.geometry){let k=null;if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===ol)return null;const $=this._header.centroid[2*this._featureIndex],E=this._header.centroid[2*this._featureIndex+1];k=new qt([],[$,E])}else{const E=this._header.offsets.geometry[this._featureIndex],D=this._reader;if(0===E)return null;D.move(E);try{k=$?this._parseGeometryForDisplay(D):this._parseGeometry(D)}catch(ho){return null}}return 0===(null==k?void 0:k.coords.length)&&(k=null),this._cache.geometry=k,k}return this._cache.geometry}_readAttribute($,k){var E;const D=this._header.fields.get($);if(null==D)return;let L=this._readAttributeAtIndex(D.index);"esriFieldTypeTimestampOffset"===(null==(E=this.fields.get($))?void 0:E.type)&&(L=this.parseTimestampOffset(L));const V=this._header.fields.isDateField(D.name);return k?null==L?L:V?new Date(L):L:L}_readAttributes(){const $={};for(const k of this._header.fields.fields)$[k.name]=this._readAttributeAtIndex(k.index);return $}copyInto($){super.copyInto($),$._featureIndex=this._featureIndex,$._featureOffset=this._featureOffset,$._hasNext=this._hasNext,$._parseCaches=this._parseCaches}_readAttributeAtIndex($){let k=this._parseCaches[$];if(k||(k=new ac(this.getSize()),this._parseCaches[$]=k),k.has(this._featureIndex))return k.get(this._featureIndex);const E=this._header.offsets.attributes[this._featureIndex*this._header.fieldCount+$],D=this._reader;D.move(E);const L=function I2($){const k=$.getLength(),E=$.pos()+k;for(;$.pos()<E&&$.next();)switch($.tag()){case 1:return $.getString();case 2:return $.getFloat();case 3:return $.getDouble();case 4:return $.getSInt32();case 5:return $.getUInt32();case 6:return $.getInt64();case 7:return $.getUInt64();case 8:return $.getSInt64();case 9:return $.getBool();default:return $.skip(),null}return null}(D);return k.set(this._featureIndex,L),L}_readGeometryDeltaDecoded($=!1){if(void 0===this._cache.unquantGeometry){const k=this._readGeometry($);if(!k)return this._cache.unquantGeometry=void 0,null;if(!this.getInTransform())return this._cache.unquantGeometry=k,k;const E=_4(k.coords.length).decoded,D=k.clone(E),L=D.coords;let V=0;for(const $ of D.lengths){for(let k=1;k<$;k++){const $=2*(V+k),E=2*(V+k-1);L[$]+=L[E],L[$+1]+=L[E+1]}V+=$}return this._cache.unquantGeometry=D,D}return this._cache.unquantGeometry}_parseGeometry($){const k=$.asUnsafe(),E=k.getLength(),D=k.pos()+E,L=[],V=[];for(;k.pos()<D&&k.next();)switch(k.tag()){case 2:{const $=k.getUInt32(),E=k.pos()+$;for(;k.pos()<E;)V.push(k.getUInt32());break}case 3:{const $=k.getUInt32(),E=k.pos()+$;for(L.push(k.getSInt64()),L.push(k.getSInt64()),this.hasZ&&k.getSInt64(),this.hasM&&k.getSInt64();k.pos()<E;)L.push(k.getSInt64()),L.push(k.getSInt64()),this.hasZ&&k.getSInt64(),this.hasM&&k.getSInt64();break}default:k.skip()}return new qt(V,L)}_parseGeometryForDisplay($){const k=$.asUnsafe(),E=k.getLength(),D=k.pos()+E,L=[],V=[];let U=0,X=0,Q=null,J=0;const et="esriGeometryPolygon"===this.geometryType;for(;k.pos()<D&&k.next();)switch(k.tag()){case 2:{const $=k.getUInt32(),E=k.pos()+$;for(;k.pos()<E;){const $=k.getUInt32();L.push($),U+=$}Q=_4(2*U).delta;break}case 3:{k.getUInt32();const $=2+(this.hasZ?1:0)+(this.hasM?1:0);as(Q);for(const E of L)if(X+$*E>Q.length)for(let $=0;$<E;$++)k.getSInt32(),k.getSInt32(),this.hasZ&&k.getSInt32(),this.hasM&&k.getSInt32();else if(et){const $=this.getAreaSimplificationThreshold(E,this._header.vertexCount);let D=2,L=1;const U=!1;let et=k.getSInt32(),st=k.getSInt32();Q[X++]=et,Q[X++]=st,this.hasZ&&k.getSInt32(),this.hasM&&k.getSInt32();let ut=k.getSInt32(),ht=k.getSInt32();for(this.hasZ&&k.getSInt32(),this.hasM&&k.getSInt32();D<E;){let E=k.getSInt32(),V=k.getSInt32();this.hasZ&&k.getSInt32(),this.hasM&&k.getSInt32();const U=et+ut,_t=st+ht;p$1(et,st,U,_t,U+E,_t+V)>=$?(J+=-.5*(U-et)*(_t+st),L>1&&y$2(Q[X-2],Q[X-1],ut,ht)?(Q[X-2]+=ut,Q[X-1]+=ht):(Q[X++]=ut,Q[X++]=ht,L++),et=U,st=_t):(E+=ut,V+=ht),ut=E,ht=V,D++}L<3||U?X-=2*L:(J+=-.5*(et+ut-et)*(st+ht+st),y$2(Q[X-2],Q[X-1],ut,ht)?(Q[X-2]+=ut,Q[X-1]+=ht,V.push(L)):(Q[X++]=ut,Q[X++]=ht,V.push(++L)))}else{let $=0,D=k.getSInt32(),L=k.getSInt32();this.hasZ&&k.getSInt32(),this.hasM&&k.getSInt32(),Q[X++]=D,Q[X++]=L,$+=1;for(let V=1;V<E;V++){const E=k.getSInt32(),U=k.getSInt32(),et=D+E,st=L+U;J+=-.5*(et-D)*(st+L),this.hasZ&&k.getSInt32(),this.hasM&&k.getSInt32(),V>2&&y$2(Q[X-2],Q[X-1],E,U)?(Q[X-2]+=E,Q[X-1]+=U):(Q[X++]=E,Q[X++]=U,$+=1),D=et,L=st}V.push($)}break}default:k.skip()}return this._cache.area=J,V.length?new qt(V,Q):null!=Q?this._createQuantizedExtrudedGeometry(Q[0],Q[1]):null}};class c8{constructor($,k){this.service=$,this._metadata=k}destroy(){}}let ul=class l8 extends c8{constructor($,k){super($,k),this._portsOpen=async function p7($){const k=new Vs;return await k.open($,{}),k}($.source).then(($=>this.client=$))}destroy(){this.client.close(),this.client=null}async executeQuery($,k){await this._portsOpen;const E=await this.client.invoke("queryFeatures",$.toJSON(),k);return bc.fromFeatureSet(E,this._metadata)}},hl=class d4 extends c8{async executeQuery($,k){const{data:E}=await Ir(this.service.source,$,k),D=!$.quantizationParameters;return ll.fromBuffer(E,this._metadata,D)}};class f4 extends c8{async executeQuery($,k){var E;const{source:D,queryMetadata:L}=this.service;if(null!=$.quantizationParameters&&!L.supportsQuantization){const E=$.clone(),L=js(E.quantizationParameters);E.quantizationParameters=null;const{data:V}=await Sr(D,E,this._metadata.spatialReference,k),U=_s(V,this._metadata.objectIdField);return Gs(L,U),bc.fromOptimizedFeatureSet(U,this._metadata)}const{data:V}=await Sr(D,$,this._metadata.spatialReference,k);return"esriGeometryPoint"===this._metadata.geometryType&&(V.features=null==(E=V.features)?void 0:E.filter(($=>{if(null!=$.geometry){const k=$.geometry;return Number.isFinite(k.x)&&Number.isFinite(k.y)}return!0}))),bc.fromFeatureSet(V,this._metadata)}}let dl=class y3 extends c8{async executeQuery($,k){if($.quantizationParameters&&!this.service.queryMetadata.supportsQuantization){const E=$.clone(),D=js(E.quantizationParameters);E.quantizationParameters=null;const L=await Tr(this.service.source,$,k);return Gs(D,L),bc.fromOptimizedFeatureSet(L,this._metadata)}const E=await Tr(this.service.source,$,k);return bc.fromOptimizedFeatureSet(E,this._metadata)}},pl=class i9 extends rl{constructor($,k,E,D,L){super(E),this._serviceInfo=$,this._queryInfo=k,this._metadata=D,this._connection=L,this._queue=new Ye({concurrency:16,process:async $=>{var k;const E={signal:null==(k=$.options)?void 0:k.signal,query:$.query.customParameters};return this._adapter.executeQuery($.query.inner,E)}}),this._adapter=function m$1($,k){switch($.type){case"memory":return new ul($,k);case"ogc":return new dl($,k);case"feature-service":return $.queryMetadata.supportsFormatPBF&&oe("featurelayer-pbf")?new hl($,k):new f4($,k)}}($,D)}unsafeSetQueryHistoricMoment($){this._queryInfo.updateHistoricMoment($)}async updateFields($){this._queryInfo.updateFields($);const k=Array.from(this._store.chunks()).map((async $=>{const k=rs.fromJSON($.queryInfo.queryJSON);if(k)try{return await this._tryUpdateFields($.reader,k),null}catch(E){return E}})),E=(await Promise.all(k)).filter(($=>$));if(E.length)throw new Et("featurelayer-query","Encountered errors when downloading fields",{errors:E})}async queryByObjectId($){if(0===$.length)return bc.empty(this._metadata);const k=this._queryInfo.createQuery({objectIds:$});return this._fetch(k)}async _fetch($,k){const E=await this._enqueue($,k);return await this._tryUpdateFields(E,$.inner),E}async _tryUpdateFields($,k){const E=this._queryInfo.createPatchFieldsQuery(k,$);if(!E)return;const D=await this._enqueue(E,this._options);$.joinAttributes(D)}async _enqueue($,k){return this._connection.onEvent({type:"fetchStart"}),this._queue.push({query:$,options:k}).finally((()=>{this._connection.onEvent({type:"fetchEnd",done:0===this._queue.length})}))}},fl=class s16 extends pl{constructor(){super(...arguments),this._chunksById=new Map}unload($){this._removeChunks($.tile)}_addChunk($){const k=$.tile.id;this._chunksById.has(k)||this._chunksById.set(k,[]);($.size()||$.first||$.end)&&(oe("esri-2d-update-debug"),this._chunksById.get(k).push($),this._store.insert($))}_removeChunks($){const k=this._chunksById.get($.key.id)??[];for(const E of k)oe("esri-2d-update-debug"),this._store.remove(E);this._chunksById.delete($.key.id)}};class i10 extends Uc{constructor($,k,E,D,L,V){var U,X;super(),this._reader=$,this._queryJSON=k,this._tile=E,this._sourceTile=D,this._sourceTileDepth=L,this._end=V,this.chunkId=`${this._tile.key.id}.${null==(U=this._sourceTile)?void 0:U.key.id}${this._end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${null==(X=this._sourceTile)?void 0:X.key.normalizedId}${this._end?"e":""}`}get queryInfo(){var $;return{type:"drill-down-tile",chunkId:this.chunkId,tileId:this._tile.key.id,queryJSON:this._queryJSON,sourceTileDepth:this._sourceTileDepth,sourceTileId:null==($=this._sourceTile)?void 0:$.key.id,size:this.size(),end:this.end}}get first(){return 0===this._sourceTileDepth}get reader(){return this._reader}get end(){return this._end}get tile(){return this._tile}get isTiled(){return!0}getTileReader($){return this._tile.key.id===$.key.id?this.reader:null}}let _l=class l9{constructor($,k){this.subscription=$,this._tileIdToResult=new Map,this._controller=new AbortController,this._handles=qs([Us($.signal,(()=>this._controller.abort())),Us(k,(()=>this._controller.abort()))])}destroy(){this._controller.abort(),this._handles.remove()}get($){return this._tileIdToResult.get($)}set($,k){this._tileIdToResult.set($,k)}get options(){return{signal:this._controller.signal}}},ml=class a9 extends fl{constructor(){super(...arguments),this._loadStates=new Map}destroy(){super.destroy();for(const $ of this._loadStates.values())$.destroy();this._loadStates.clear()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}async load($){this._loadStates.has($.key.id)||this._loadStates.set($.key.id,new _l($,this._options));const k=this._loadStates.get($.key.id);let E;try{for await(const E of this._fetchChunkInfos(k,$.tile,0)){const{queryJSON:$,reader:D,sourceTile:L,sourceTileDepth:V,tile:U}=E,X=new i10(D,$,U,L,V,!1);Rs(k.options),this._addChunk(X)}}catch(L){E=L}const D=new i10(bc.empty(this._metadata),null,$.tile,null,-1,!0);if(this._addChunk(D),E)throw E}unload($){var k;super.unload($),null==(k=this._loadStates.get($.key.id))||k.destroy(),this._loadStates.delete($.key.id)}async*_fetchChunkInfos($,k,E){let D=$.get(k.id);const L=!!D;if(D||(D=await this._fetchChunkInfo($,k,E),$.set(k.id,D)),D.reader.exceededTransferLimit&&E<oe("featurelayer-query-max-depth"))for(const V of k.createChildTiles())yield*this._fetchChunkInfos($,V,E+1);else L||(yield D)}async _fetchChunkInfo($,k,E){const D=$.subscription.tile.getQuantizationParameters(),L=this._queryInfo.createTileQuery(k,{returnExceededLimitFeatures:!1,quantizationParameters:D});return{reader:await this._fetch(L,$.options),queryJSON:L.inner.toJSON(),tile:$.subscription.tile,sourceTile:k,sourceTileDepth:E}}},yl=class t14 extends Uc{constructor($,k,E,D,L){super(),this._reader=$,this._queryJSON=k,this._tile=E,this._page=D,this._end=L,this.chunkId=`${this._tile.key.id}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${this._page}${this.end?"e":""}`}get queryInfo(){return{type:"paged-tile",chunkId:this.chunkId,tileId:this._tile.key.id,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get reader(){return this._reader}get first(){return 0===this._page}get end(){return this._end}get page(){return this._page}get tile(){return this._tile}get isTiled(){return!0}getTileReader($){return this._tile.key.id===$.key.id?this.reader:null}},gl=class n11{constructor($,k){this.subscription=$,this._pages=new Set,this._controller=new AbortController,this._done=!1,this._handles=qs([Us($.signal,(()=>this._controller.abort())),Us(k,(()=>this._controller.abort()))])}destroy(){this._controller.abort(),this._handles.remove()}get pageStart(){let $=-1;for(const k of this._pages.values())$=Math.max($,k);return $+1}get done(){return this._done}get options(){return{signal:this._controller.signal}}add($,k){this._pages.add($),this._done=this._done||k}};class l10 extends fl{constructor(){super(...arguments),this._loadStates=new Map}destroy(){super.destroy();for(const $ of this._loadStates.values())$.destroy();this._loadStates.clear()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}async load($){this._loadStates.has($.key.id)||this._loadStates.set($.key.id,new gl($,this._options));const k=this._loadStates.get($.key.id);let E;try{await this._fetchPages(k)}catch(L){E=L}const D=new yl(bc.empty(this._metadata),null,$.tile,-1,!0);if(Ws(k.options)||this._addChunk(D),E)throw E}unload($){var k;super.unload($),null==(k=this._loadStates.get($.key.id))||k.destroy(),this._loadStates.delete($.key.id)}async _fetchPages($){let k=0,E=$.pageStart,D=1;for(;k<20&&!$.done;){const L=[];for(let k=0;k<D;k++)L.push(this._fetchChunk($,E++));const V=await Promise.all(L);for(const k of V)(0!==k.size()||k.first)&&($.add(k.page,!k.reader.exceededTransferLimit),Rs($.options),this._addChunk(k));k++,D=Math.min(D+1,4)}}async _fetchChunk($,k){const E=$.subscription.tile,D=this._queryInfo.createPagedTileQuery(E,k),L=await this._fetch(D,$.options);return new yl(L,D.inner.toJSON(),E,k,!1)}}let xl=class t15 extends Uc{constructor($,k,E,D){super(),this._reader=$,this._queryJSON=k,this._page=E,this._end=D,this.chunkId=`${this._page}${this.end?"e":""}`,this.normalizedChunkId=this.chunkId}get reader(){return this._reader}get first(){return 0===this._page}get end(){return this._end}get queryInfo(){return{type:"snapshot",chunkId:this.chunkId,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader($){const k=this.queryFeaturesInBounds($.bounds);return k.setTransformForDisplay($.transform),k}};class a10 extends pl{constructor($,k,E,D,L,V){super($,k,E,L,V),this._random=new Ys(1e3),this._featureCount=D}get about(){return{willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}load($){return null==this._promise&&(this._promise=this._downloadPages(this._featureCount)),this._promise}unload($){}async _downloadPages($){const k=Math.ceil($/this._queryInfo.pageSize),E=Array.from({length:k},(($,k)=>k)).sort((($,k)=>this._random.getInt()-this._random.getInt())),D=await Promise.all(E.map(($=>this._downloadPage($)))),L=new xl(bc.empty(this._metadata),null,-1,!0);this._store.insert(L);const V=D.filter(($=>$));if(V.length)throw new Et("featurelayer-query","Encountered errors when downloading data",{errors:V})}async _downloadPage($){try{const k=this._queryInfo.createPagedQuery($),E=await this._fetch(k,this._options),D=new xl(E,k.inner.toJSON(),$,!1);return Rs(this._options),this._store.insert(D),null}catch(k){return k}}}let bl=class extends Se{constructor($){super($)}get connectionStatus(){var $;return null==($=this.connection)?void 0:$.connectionStatus}get errorString(){var $;return null==($=this.connection)?void 0:$.errorString}};xe([we()],bl.prototype,"connection",void 0),xe([we()],bl.prototype,"connectionStatus",null),xe([we()],bl.prototype,"errorString",null),bl=xe([Ie("esri.views.2d.layers.features.sources.StreamConnectionState")],bl);let vl=class t16{constructor($,k){this._metadata=$,this._onUpdate=k,this._objectIdToFeature=new Map}get size(){return this._objectIdToFeature.size}get reader(){return bc.fromFeatures([...this._objectIdToFeature.values()],this._metadata)}add($){this._objectIdToFeature.set($.objectId,$)}forEach($){this._objectIdToFeature.forEach($)}removeById($){const k=this._objectIdToFeature.get($);return k?(this._objectIdToFeature.delete($),k):null}clear(){this._objectIdToFeature=new Map}update($,k){this._onUpdate((null==$?void 0:$.length)??0)}};class r13 extends Uc{constructor($){super(),this._reader=$,this.chunkId="stream-chunk",this.normalizedChunkId="stream-chunk"}get reader(){return this._reader}get first(){return!0}get end(){return!0}get queryInfo(){return{type:"stream",chunkId:this.chunkId,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader($){const k=this.queryFeaturesInBounds($.bounds);return k.setTransformForDisplay($.transform),k}}class h7 extends rl{constructor($,k,E,D,L){super(E),this._service=$,this._dataFilter=k,this._streamOptions=D,this._metadata=L,this._connectionState=new bl,this._forceRefresh=!1,this.events=new Xe;const{objectIdField:V,timeInfo:U}=this._metadata,{purgeOptions:X}=k;this._stagingStore=new vl(this._metadata,($=>this.events.emit("features-updated",$))),this._manager=new Er(this._stagingStore,V,U,X),this.connect()}destroy(){super.destroy(),this.disconnect()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}get connectionStatus(){return this._connectionState.connectionStatus}get errorString(){var $;return null==($=this._connectionState)?void 0:$.errorString}async refresh(){const $=null!=this._chunk;this._manager.checkForUpdates()||!$||this._forceRefresh?(this._chunk&&this._store.remove(this._chunk),this._forceRefresh=!1,this._chunk=new r13(this._stagingStore.reader),this._store.insert(this._chunk),this.events.emit("tick")):this.events.emit("tick")}async updateFields($){throw new Error("Updating available fields not supported for StreamLayer")}async load($){}unload($){}disconnect(){var $;this._connection=zs(this._connection),this._connectionState.connection=null,null==($=this._handlesGroup)||$.remove()}connect(){if(null!=this._connection)return;const{geometryType:$,spatialReference:k}=this._metadata,{maxReconnectionAttempts:E,maxReconnectionInterval:D,geometryDefinition:L,definitionExpression:V,customParameters:U}=this._dataFilter;this._connection=Cr(this._service.source,k,this._streamOptions.outSR,$,V,L,E,D,U),this._handlesGroup=qs([this._connection.on("data-received",($=>this._onFeature($))),this._connection.on("message-received",($=>this._onWebSocketMessage($)))]),this._connectionState.connection=this._connection}clear(){this._manager.checkForUpdates(),this._stagingStore.clear(),this._forceRefresh=!0}updateCustomParameters($){var k;null==(k=this._connection)||k.updateCustomParameters($)}sendMessageToSocket($){var k;null==(k=this._connection)||k.sendMessageToSocket($)}sendMessageToClient($){var k;null==(k=this._connection)||k.sendMessageToClient($)}_onWebSocketMessage($){if("type"in $)switch($.type){case"delete":if($.objectIds)for(const k of $.objectIds)this._manager.removeById(k);if($.trackIds)for(const k of $.trackIds)this._manager.removeByTrackId(k);break;case"clear":this.clear()}this.events.emit("message-received",$)}_onFeature($){try{this._manager.add($),this.events.emit("data-received",$)}catch(ho){}}}let wl=class n12{constructor($){this._onChange=$,this._chunks=new Map,this._chunksToRemove=[],this.events=new Xe,this.featureAdapter=new ic}destroy(){this.clear()}clear(){for(const $ of this._chunks.values())this._chunksToRemove.push($);this._chunks.clear(),null!=this._localEditChunk&&this._chunksToRemove.push(this._localEditChunk),this._localEditChunk=null}*chunks(){this._localEditChunk&&(yield this._localEditChunk),this._localOverridesChunk&&(yield this._localOverridesChunk),yield*this._chunks.values()}insert($){var k,E;oe("esri-2d-update-debug"),(null==(k=this._localOverridesChunk)?void 0:k.overriddenIds.size)&&$.reader.removeIds(this._localOverridesChunk.overriddenIds),(null==(E=this._localEditChunk)?void 0:E.overriddenIds.size)&&this._localEditChunk.removeOverrides($),this._chunks.set($.chunkId,$),this.events.emit("changed"),this._onChange()}remove($){oe("esri-2d-update-debug"),this._chunks.delete($.chunkId),this._chunksToRemove.push($)}cleanupRemovedChunks(){const $=this._chunksToRemove;return this._chunksToRemove=[],$}applyLocalOverrides($,k){null==this._localOverridesChunk&&(this._localOverridesChunk=new Wc(k,"localOverride")),this._localOverridesChunk.applyOverrides($);for(const E of this._chunks.values())E.reader.removeIds(this._localOverridesChunk.overriddenIds),E.invalidate()}applyLocalEdit($,k){null==this._localEditChunk&&(this._localEditChunk=new Wc(k,"localEdit")),this._localEditChunk.applyOverrides($);for(const E of this._chunks.values())E.reader.removeIds(this._localEditChunk.overriddenIds),E.invalidate()}forEach($){const k=new Set;for(const E of this.chunks()){const D=E.reader.getCursor();for(;D.next();){const E=D.getObjectId();k.has(E)||($(D.copy()),k.add(E))}}}forEachUnsafe($){const k=new Set;for(const E of this.chunks()){const D=E.reader.getCursor();for(;D.next();){const E=D.getObjectId();k.has(E)||($(D),k.add(E))}}}forEachInBounds($,k){const E=new Set;for(const D of this.chunks()){const L=D.queryFeaturesInBounds($);for(;L.next();){const $=L.getObjectId();E.has($)||(k(L.copy()),E.add($))}}}forEachBounds($,k){const E=He();for(const D of $)D.getBounds(E)&&k(E)}},Il=class extends Se{constructor($){super($),this.debugName="",this._updatingHandles=new Xs,this._idToUpdatingState=new Hs}get updating(){const $=this._updatingHandles.updating||Array.from(this._idToUpdatingState.values()).some(($=>$));if(oe("esri-2d-log-updating")){Array.from(this._idToUpdatingState.entries()).map((([$,k])=>`-> ${$}: ${k}`)).join("\n")}return $}addUpdateTracking($,k){const E=Ls((()=>k.updating),(k=>this._idToUpdatingState.set($,k)),{sync:!0});this.addHandles(E)}addPromise($){return this._updatingHandles.addPromise($)}};xe([we({constructOnly:!0})],Il.prototype,"debugName",void 0),xe([we({readOnly:!0})],Il.prototype,"updating",null),Il=xe([Ie("esri.views.2d.layers.support.UpdateTracking2D")],Il);class S5{constructor($,k,E,D,L){this.service=$,this._aggregateAdapter=k,this._subscriptions=E,this._onChange=D,this._connection=L,this._updateTracking=new Il({debugName:"FeatureSource"}),this._didInvalidateData=!1,this._store=new wl(this._onChange),this._metadata=new oc($.metadata)}destroy(){var $,k;null==($=this._strategy)||$.destroy(),this._store.destroy(),null==(k=this._streamMessenger)||k.destroy(),"memory"===this.service.type&&this.service.source.map(($=>$.close()))}get metadata(){if(!this._metadata)throw new Error("InternalError: Metadata not defined. Was update called?");return this._metadata}get store(){return this._store}get streamMessenger(){return null==this._streamMessenger&&this._initStreamMessenger(),this._streamMessenger}get statistics(){return tl.from(this._store)}get updateTracking(){return this._updateTracking}get queryEngine(){if(!this._queryEngine){if(!this._schema)return null;const{dataFilter:$}=this._schema.mutable,k=this._schema.mutable.availableFields,E=this._metadata;this._queryEngine=new hr({featureStore:this._store,fieldsIndex:E.fieldsIndex,geometryType:E.geometryType,objectIdField:E.objectIdField,hasM:!1,hasZ:!1,spatialReference:this.service.outSpatialReference,cacheSpatialQueries:!0,aggregateAdapter:this._aggregateAdapter,timeInfo:E.timeInfo,definitionExpression:$.definitionExpression,availableFields:k})}return this._queryEngine}get isStream(){return"stream"===this._schema.type}chunks(){return Array.from(this._store.chunks())}cleanupRemovedChunks(){return this._store.cleanupRemovedChunks()}onSubscribe($){var k;this._connection.onEvent({type:"subscribe",tile:$.tile.id});const E=null==(k=this._strategy)?void 0:k.load($);E&&(E.then((()=>this._connection.onEvent({type:"loaded",tile:$.tile.id}))).catch((k=>this._connection.onEvent({type:"error",tile:$.tile.id,error:k}))),this._updateTracking.addPromise(E))}onResume($){var k;this._updateTracking.addPromise(Zs(null==(k=this._strategy)?void 0:k.load($)))}onUnsubscribe($){var k;this._connection.onEvent({type:"unsubscribe",tile:$.tile.id}),null==(k=this._strategy)||k.unload($)}getLocalEdit($){return this._updateTracking.addPromise(this._getGetLocalEdit($))}applyLocalEdit($){this._didInvalidateData=!0,this._store.applyLocalEdit($,this.metadata)}async update($,k){var E,D,L;const V=$.source,U=Cs(null==(E=this._schema)?void 0:E.mutable,V.mutable);if(!U)return!1;if(oe("esri-2d-update-debug"),this._schema=V,null==(D=this._queryEngine)||D.destroy(),this._queryEngine=null,"feature-service"===this.service.type&&null!=this.service.queryMetadata.lastEditDate&&(this._lastEditDate=this.service.queryMetadata.lastEditDate),null==this._streamMessenger&&"stream"===this._schema.type&&this._initStreamMessenger(),Ks(U,"sourceRefreshVersion")&&(null==(L=this._strategy)?void 0:L.refresh))return await this._strategy.refresh(),!0;if("feature"===V.type&&Ks(U,"availableFields")){if(await this._queryLastEditDateChanged()||this._didInvalidateData)this._didInvalidateData=!1,await this._updateStrategy(k);else{this._connection.onEvent({type:"updateFieldsStart"});try{await this._strategy.updateFields(V.mutable.availableFields),this._connection.onEvent({type:"updateFieldsEnd"})}catch(X){this._connection.onEvent({type:"updateFieldsError",error:X})}}return!1}return!(!Qs(U,"dataFilter")&&!Qs(U,"sourceRefreshVersion")||(await this._updateStrategy(k),0))}_initStreamMessenger(){null==this._streamMessenger&&(this._streamMessenger=new sl(this._connection))}async _getGetLocalEdit($){if($.historicMoment&&"feature"===this._schema.type&&(this._schema.mutable.dataFilter.historicMoment=$.historicMoment,this._strategy.unsafeSetQueryHistoricMoment(new Date($.historicMoment))),"edit-by-feature"===$.type){const k=[...$.added,...$.updated].map(($=>ps.fromJSON($,this.metadata.objectIdField)));return{reader:bc.fromOptimizedFeatures(k,this.metadata),removed:this._resolveIdentifiers($.removed)}}const k=this._resolveIdentifiers($.removed);if(!$.updated.length&&!$.added.length)return{reader:bc.empty(this.metadata),removed:k};const E=this._resolveIdentifiers([...$.added,...$.updated]);return{reader:await this._strategy.queryByObjectId(E),removed:k}}_resolveIdentifiers($){const k=[],E=[];for(const D of $)null!=D.objectId&&-1!==D.objectId?E.push(D.objectId):k.push(D.globalId);if(k.length){const $=new Set(k),D=this.metadata.globalIdField;if(null==D)throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");this._store.forEachUnsafe((k=>{const L=k.readAttribute(D);$.has(L)&&E.push(k.getObjectId())}))}return E}async _queryLastEditDateChanged(){if(null==this._lastEditDate)return!1;const $=this.service.source,k={...$.query,f:"json"},E=(await Js($.path,{query:k,responseType:"json"})).data.editingInfo.lastEditDate;return E!==this._lastEditDate&&(this._lastEditDate=E,!0)}async _createStrategy(){const $="isSourceHosted"in this.service&&this.service.isSourceHosted,k=Array.isArray(this.service.source),E=this.service.source&&"collection"in this.service.source,D=$||k||E;if("stream"===this._schema.type){const $=new h7(this.service,this._schema.mutable.dataFilter,this._store,{outSR:this.service.outSpatialReference},this.metadata);return this._streamMessenger.strategy=$,$}const L=this.service,V=el.fromSchema(L,this._schema,this._metadata),U=await this._supportSnapshotMode(L,V);return U?new a10(L,V,this._store,U.featureCount,this.metadata,this._connection):D?new l10(L,V,this._store,this.metadata,this._connection):new ml(L,V,this._store,this.metadata,this._connection)}async _updateStrategy($){var k;const E=await this._createStrategy();this._connection.onEvent({type:"updateStrategyStart",about:E.about});const D=!!this._strategy;this._store.clear(),null==(k=this._strategy)||k.destroy(),this._strategy=E,oe("esri-2d-update-debug");const L=Array.from(this._subscriptions.values());if(!L.length)return void this._connection.onEvent({type:"updateStrategyEnd"});const V=Promise.all(L.map(($=>this._strategy.load($).then((()=>this._connection.onEvent({type:"loaded",tile:$.tile.id}))).catch((k=>this._connection.onEvent({type:"error",tile:$.tile.id,error:k}))))));this._updateTracking.addPromise(V);try{D&&await V}catch(U){Os(U)}this._connection.onEvent({type:"updateStrategyEnd"}),oe("esri-2d-update-debug")}async _supportSnapshotMode($,k){const{queryMetadata:E}=$,D=E.snapshotInfo;if(!D||!D.supportsSnapshotMinThreshold||!D.snapshotCountThresholds)return null;const L=$.source,V=k.createQuery();V.inner.orderByFields=[],V.inner.returnGeometry=!1;const U=(await $r(L,V.inner,{query:V.customParameters})).data.count,{min:X,max:Q}=D.snapshotCountThresholds;return U<=X||D.supportsSnapshotMaxThreshold&&U<Q?{featureCount:U}:null}}class t17{constructor($,k){this.tile=$,this.version=k,this._abortController=new AbortController}get key(){return this.tile.key}get signal(){return this._abortController.signal}abort(){this._abortController.abort()}}class n13{constructor($,k){this.key=new _t(0,0,0,0),this.bounds=ss(),this.objectIds=new Set,this.key.set(k);const E=$.getLODInfoAt(this.key);this.tileInfoView=$,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=E.resolution,this.level=E.level,this.scale=E.scale,this.minScale=$.zoomToScale(E.level-1),this.maxScale=$.zoomToScale(E.level+1)}get lod(){return this.tileInfoView.getLODInfoAt(this.key)}get id(){return this.key.id}get extent(){return $s.fromBounds(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createArcadeEvaluationOptions($){return{$view:{scale:this.scale,timeZone:$}}}createChildTiles(){const $=this.key.getChildKeys(),k=tr.acquire();for(let E=0;E<$.length;E++)k[E]=new n13(this.tileInfoView,$[E]);return k}getQuantizationParameters(){return er.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}class m9{constructor($){this.inner=$,this.resolver=nr()}}class y4{constructor(){this._aggregateAdapter={getFeatureObjectIds:$=>this._processor.getFeatureObjectIdsForAggregate($)},this._subscriptions=new Map,this._updateRequested=!1,this._updateSubscriptionRequests=[],this._updateHighlightRequests=[]}destroy(){this._subscriptions.clear(),this._processor.destroy(),this._source.destroy(),this._handles.remove(),this._updateLocalEditsRequest=null,this._tileInfoView=null}onAttach($){oe("esri-2d-update-debug");const k=this._connection,E=sr.fromJSON($.tileInfoJSON);this._tileInfoView=new rr(E),this._source=new S5($.service,this._aggregateAdapter,this._subscriptions,(()=>this._requestUpdate()),k),this._processor=new Jc(k,this._source),this._handles=qs([Ls((()=>this._source.updateTracking.updating),(()=>{this._requestUpdate(),Zs(this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:!0}))}))])}onDetach(){oe("esri-2d-update-debug"),this.destroy()}set remoteClient($){this._connection=new Nr($)}get features(){var $;const k=null==($=this._source)?void 0:$.queryEngine;if(!k)throw new Et("no-queryEngine","No query engine defined");return k}get aggregates(){var $;const k=null==($=this._processor)?void 0:$.aggregateQueryEngine;if(!k)throw new Et("no-queryEngine","No aggregate query engine defined");return k}get processor(){return this._processor}get streamMessenger(){return this._source.streamMessenger}getDisplayFeatures($){return this._processor.getDisplayFeatures($)}async updateSchema($,k){return oe("esri-2d-update-debug")&&this._updateSchemaRequest,this._updateSchemaRequest=new m9({schema:$,version:k}),this._requestUpdate(),this._updateSchemaRequest.resolver.promise}updateSubscriptions($){const k=new m9($);return this._updateSubscriptionRequests.push(k),this._requestUpdate(),k.resolver.promise}updateHighlight($){const k=new m9($);return this._updateHighlightRequests.push(k),this._requestUpdate(),k.resolver.promise}async onEdits($){if(null!=this._updateLocalEditsRequest)throw new Et("InternalError - Already processing an edit");this._updateLocalEditsRequest=new m9($);const k=this._updateLocalEditsRequest.resolver.promise;return this._requestUpdate(),k}queryStatistics(){return this._source.statistics.toJSON()}async queryVisibleFeatures($,k){return this.features.executeQuery($,k)}async queryHeatmapStatistics($){const k=Math.round(fe($.radius));let E=Number.POSITIVE_INFINITY,D=Number.NEGATIVE_INFINITY;const L="string"==typeof $.fieldOffset,V=$.fieldOffset??0,U=Array.from(this._subscriptions.values()),X=this._source.chunks(),Q=k**2,J=3/(Math.PI*Q),et=2*k,st=Math.ceil(vt/et);for(const ut of U){const k=ut.tile,U=new Float64Array(st*st);for(const E of X){const D=E.getTileReader(k);if(!D)continue;const X=D.getCursor();for(;X.next();){let k=1;if(null!=$.field){const E=X.readAttribute($.field);k=L?-1*+E:+E+V}const E=X.readXForDisplay()/et,D=X.readYForDisplay()/et,ut=Math.floor(E),ht=Math.floor(D);if(ut<0||ht<0||ut>=st||ht>=st)continue;const _t=((.5+ut-E)*et)**2+((.5+ht-D)*et)**2;if(_t>Q)continue;const vt=k*(J*(1-_t/Q)**2);U[ht+ut*st]+=vt}}for(let $=0;$<U.length;$++)E=Math.min(E,U[$]),D=Math.max(D,U[$])}return{max:D,min:E}}async getSampleFeatures($){const k=this._source.chunks();if(k.reduce((($,k)=>$+k.size()),0)<=$.minFeatureCount){if(!this._source.updateTracking.updating){const $=[];return this._source.store.forEachUnsafe((k=>$.push(k.readLegacyFeatureWorldSpace()))),$}return null}const E=new Set,D=[],L=k.map(($=>$.reader.getCursor())),V=new Ys,U=3*$.sampleSize;for(let X=0;X<U&&D.length<$.sampleSize;X++){const $=L[V.getIntRange(0,k.length-1)];if(0===$.getSize())continue;const U=V.getIntRange(0,$.getSize()-1);$.setIndex(U);const X=$.getObjectId();E.has(X)||(E.add(X),D.push($.readLegacyFeatureWorldSpace()))}return D.length>=$.sampleSize?D:null}_requestUpdate(){this._updateRequested||(this._updateRequested=!0,ir((()=>this._scheduleNextUpdate())))}_scheduleNextUpdate(){this._updateRequested&&(this._ongoingUpdate||(this._ongoingUpdate=ht(this._doUpdate()).finally((()=>{this._ongoingUpdate=null,this._scheduleNextUpdate()})),this._updateRequested=!1))}_subscribe($){const k=$.tileId;if(this._subscriptions.has(k))return;oe("esri-2d-update-debug");const E=new n13(this._tileInfoView,k),D=new t17(E,$.version);this._subscriptions.set(k,D),this._source.onSubscribe(D),this._processor.onSubscribe(D)}_unsubscribe($){const k=this._subscriptions.get($);k&&(oe("esri-2d-update-debug"),k.abort(),this._source.onUnsubscribe(k),this._processor.onUnsubscribe(k),this._subscriptions.delete(k.key.id))}async _doUpdate(){if(oe("esri-2d-update-debug"),await this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:!0}),this._updateSubscriptionRequests.length){const $=this._updateSubscriptionRequests;this._updateSubscriptionRequests=[];for(const k of $)this._doUpdateSubscriptions(k.inner),k.resolver.resolve()}const $=this._updateSchemaRequest;if(this._updateSchemaRequest=null,null!=$){const{schema:k,version:E}=$.inner;await this._doUpdateSchema(k,E)}const k=this._updateLocalEditsRequest;if(this._updateLocalEditsRequest=null,null!=k){oe("esri-2d-update-debug");const $=await this._source.getLocalEdit(k.inner);await this._processor.applyLocalEdit($),this._source.applyLocalEdit($),oe("esri-2d-update-debug")}if(this._updateHighlightRequests.length){const $=this._updateHighlightRequests;this._updateHighlightRequests=[];for(const k of $)this._processor.updateHighlight(k.inner),k.resolver.resolve()}const E=this._source.cleanupRemovedChunks();this._processor.removeChunks(E);try{this._subscriptions.size&&(oe("esri-2d-update-debug"),await this._processor.updateChunks(),oe("esri-2d-update-debug"))}catch(D){Os(D)}null!=k&&k.resolver.resolve(),null!=$&&$.resolver.resolve(),this._updateRequested?(oe("esri-2d-update-debug"),await this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:!0})):(oe("esri-2d-update-debug"),await this._connection.layerView.setUpdating({data:this._source.updateTracking.updating,pipeline:this._updateRequested}))}async _doUpdateSchema($,k){var E;oe("esri-2d-update-debug");const D={tileInfo:null==(E=this._tileInfoView)?void 0:E.tileInfo},L=await this._source.update($,k),V=Array.from(this._subscriptions.values());await this._processor.update($,k,D,L,V),oe("esri-2d-update-debug")}_doUpdateSubscriptions($){oe("esri-2d-update-debug");for(const k of $.subscribe)this._subscribe(k);for(const k of $.unsubscribe)this._unsubscribe(k)}}export{y4 as default};
