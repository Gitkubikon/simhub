import{e as t,y as d,a as g,bk as y,gH as N,c7 as it,c8 as ut,bn as ct,mD as dt,gM as ft,sC as yt,et as vt,sD as xt,bj as bt,fP as wt,ul as At,b as Tt,tl as Pt,aw as Ft,az as Nt}from"./index-DSIPxOWi.js";import{c as It,g as Rt,Q as Ct,V as kt,X as _t,Y as Bt,Z as jt,_ as St,$ as $t,t as Mt,a0 as Dt,a1 as Ot,a2 as Gt,a3 as Et,a4 as zt,a5 as Vt,a6 as Ut,b as Lt,a7 as Wt,a8 as qt,a9 as Ht,aa as Xt,ab as Kt,ac as Jt,ad as Yt,ae as Zt,af as Qt,ag as te,ah as ee,ai as ne}from"./dataUtils-DNEwlV4z.js";let se=class e extends y{constructor(){super(...arguments),this.raster=void 0}};t([d({json:{write:!0}})],se.prototype,"raster",void 0),se=t([g("esri.layers.support.rasterFunctions.BaseFunctionArguments")],se);const re=se;var oe;let ie=oe=class extends re{constructor(){super(...arguments),this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new oe({raster:this.raster,raster2:this.raster2,operation:this.operation})}};t([d({json:{write:!0}})],ie.prototype,"operation",void 0),t([d({json:{write:!0}})],ie.prototype,"raster2",void 0),t([d({readOnly:!0})],ie.prototype,"rasters",null),ie=oe=t([g("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")],ie);const ae=ie,ue=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let le=class u extends y{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.rawSourceRasterInfos=null,this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){var t;const d=this.getWebGLProcessorDefinition();if(!d)return null;const g=[d],{parameters:y}=d;let N=y.rasters||y.raster&&[y.raster];for(;null==N?void 0:N.length;){g.unshift(...N);const t=[];for(let d=0;d<N.length;d++){const{parameters:g}=N[d],y=g.rasters||g.raster&&[g.raster];(null==y?void 0:y.length)&&t.push(...y)}N=t}for(let dt=g.length-1;dt>=0;dt--)g[dt].isNoopProcess&&g.splice(dt,1);let it=!1;for(let dt=0;dt<g.length;dt++){const t=g[dt];t.id=g.length-dt-1;const{rasters:d}=t.parameters;it=it||null!=d&&d.length>1}const ut=g.some((({name:t})=>ue.has(t.toLowerCase()))),{rawSourceRasterInfos:ct}=this;return{functions:g,hasBranches:it,hasFocalFunction:ut,isSourceSingleBand:1===(null==(t=null==ct?void 0:ct[0])?void 0:t.bandCount)}}bind(t,d=!1,g=-1){this.id=g+1;const y=this._getRasterValues();let N=!0;for(let it=0;it<y.length;it++){const g=y[it];if(null!=g&&this._isRasterFunctionValue(g)){const y=g.bind(t,d,this.id+it);if(!y.success)return this._bindingResult=y,y;N=N&&y.supportsGPU}}return!this.rasterInfo||d?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),this._bindingResult.success&&this._patchRasterInfo(),this._bindingResult.supportsGPU=N&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this.processInputBandIds(),this._bindingResult)}process(t){const d=this._getRasterValues(),g=0===d.length?t.pixelBlocks??t.primaryPixelBlocks:d.map((d=>this._readRasterValue(d,t)));return this._processPixels({...t,pixelBlocks:g})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);let d;if(t.length>1){const d=t.map((t=>t.processInputBandIds()[0]));this.rawInputBandIds=d,this.isInputBandIdsSwizzled=this.rawInputBandIds.some(((t,d)=>t!==d));const g=t.filter((t=>"ExtractBand"===t.functionName));return g.length&&g.forEach(((t,d)=>{t.isInputBandIdsSwizzled=!0,t.swizzledBandSelection=[d,d,d]})),this.rawInputBandIds}const g=t[0];if(g){if(d=g.processInputBandIds(),g.isInputBandIdsSwizzled)return this.rawInputBandIds=d,d}else{d=[];const{bandCount:t}=this.sourceRasterInfos[0];for(let g=0;g<t;g++)d.push(g)}const y=this._getInputBandIds(d);return this.isInputBandIdsSwizzled=y.some(((t,d)=>t!==d)),this.rawInputBandIds=y,this.rawInputBandIds}getPrimaryRasters(){const t=[],d=[];return this._getPrimaryRasters(this,t,d),{rasters:t,rasterIds:d}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:d,rasters:g}=this.functionArguments;return g&&Array.isArray(g)&&g.length?(t.rasters=g.map((t=>this._isRasterFunctionValue(t)?t.getWebGLProcessorDefinition():"number"==typeof t?{name:"Constant",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1})),t.rasters.some((t=>null!=t))||(t.rasters=null)):this._isRasterFunctionValue(d)&&(t.raster=d.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getClippingGeometries(){const t=[];"Clip"===this.functionName&&t.push(this.functionArguments);const{raster:d,rasters:g}=this.functionArguments;if(g&&Array.isArray(g)&&g.length)g.forEach((d=>{if(this._isRasterFunctionValue(d)){const g=d.getClippingGeometries();t.push(...g)}}));else if(this._isRasterFunctionValue(d)){const g=d.getClippingGeometries();t.push(...g)}return t}_getOutputPixelType(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_removeStatsHistColormapVAT(t){t.statistics=null,t.histograms=null,t.colormap=null,t.attributeTable=null}_getRasterValues(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]?this.functionArguments.rasters??[]:t.flatMap((t=>this.functionArguments[t]))}_getSourceRasterInfos(t){const d=this._getRasterValues(),{rasterInfos:g,rasterIds:y}=t;if(0===d.length)return g;const N=d.map((t=>t&&"object"==typeof t&&"bind"in t&&t.rasterInfo?t.rasterInfo:"string"==typeof t&&y.includes(t)?g[y.indexOf(t)]:"number"!=typeof t?g[0]:void 0)),it=N.find((t=>t))??g[0];return N.forEach(((t,d)=>{void 0===t&&(N[d]=it)})),N}_getPrimaryRasterId(t){return null==t?void 0:t.rasterId}_getPrimaryRasters(t,d=[],g=[]){for(let y=0;y<t.sourceRasters.length;y++){const N=t.sourceRasters[y];if("number"!=typeof N)if("bind"in N)this._getPrimaryRasters(N,d,g);else{const t=N,y=this._getPrimaryRasterId(t);if(null==y)continue;g.includes(y)||(this.mainPrimaryRasterId===y?(d.unshift(t),g.unshift(y)):(d.push(t),g.push(y)))}}}_isRasterFunctionValue(t){return null!=t&&"object"==typeof t&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,d){const{primaryPixelBlocks:g}=d;if(null==t||"$$"===t){const t=g[0];return null==t?null:t.clone()}if("string"==typeof t){const y=d.primaryRasterIds.indexOf(t);return-1===y?null:g[y]}if("number"==typeof t){const d=g[0];if(null==d)return null;const{width:y,height:N,pixelType:it}=d,ut=new Float32Array(y*N);ut.fill(t);const ct=this.sourceRasterInfos[0].bandCount,dt=new Array(ct).fill(ut);return new Rt({width:y,height:N,pixelType:it,pixels:dt})}return t.process(d)}_patchRasterInfo(){const{rasterInfo:t}=this;if(!(null==t?void 0:t.keyProperties))return;const{bandCount:d,keyProperties:g,statistics:y,histograms:N}=t,it=g.BandProperties;it&&it.length!==d&&(t.keyProperties={...g,BandProperties:void 0}),y&&y.length!==d&&(t.statistics=y.length>d?y.slice(0,d):null),N&&N.length!==d&&(t.histograms=N.length>d?N.slice(0,d):null),g.BAND_COUNT&&Number(g.BAND_COUNT)!==d&&(t.keyProperties={...g,BAND_COUNT:"string"==typeof g.BAND_COUNT?String(d):d})}};t([d({json:{write:!0}})],le.prototype,"functionName",void 0),t([d({json:{write:!0}})],le.prototype,"functionArguments",void 0),t([d()],le.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}}),N((t=>null==t?void 0:t.toLowerCase()))],le.prototype,"outputPixelType",void 0),t([d({json:{write:!0}})],le.prototype,"mainPrimaryRasterId",void 0),t([d()],le.prototype,"sourceRasters",void 0),t([d({type:[It],json:{write:!0}})],le.prototype,"sourceRasterInfos",void 0),t([d({json:{write:!0}})],le.prototype,"rasterInfo",void 0),t([d({json:{write:!0}})],le.prototype,"readingBufferSize",void 0),t([d({json:{write:!0}})],le.prototype,"id",void 0),t([d()],le.prototype,"isNoopProcess",void 0),t([d()],le.prototype,"supportsGPU",null),t([d()],le.prototype,"rawInputBandIds",void 0),t([d()],le.prototype,"rawSourceRasterInfos",void 0),t([d()],le.prototype,"isInputBandIdsSwizzled",void 0),t([d()],le.prototype,"swizzledBandSelection",void 0),t([d()],le.prototype,"isBranch",void 0),t([d({readOnly:!0})],le.prototype,"flatWebGLFunctionChain",null),t([d()],le.prototype,"_bindingResult",void 0),le=t([g("esri.layers.support.rasterFunctions.BaseRasterFunction")],le);const ce=le,pe={userDefined:-1,lineDetectionHorizontal:0,lineDetectionVertical:1,lineDetectionLeftDiagonal:2,lineDetectionRightDiagonal:3,gradientNorth:4,gradientWest:5,gradientEast:6,gradientSouth:7,gradientNorthEast:8,gradientNorthWest:9,smoothArithmeticMean:10,smoothing3x3:11,smoothing5x5:12,sharpening3x3:13,sharpening5x5:14,laplacian3x3:15,laplacian5x5:16,sobelHorizontal:17,sobelVertical:18,sharpen:19,sharpen2:20,pointSpread:21,none:255},he={bitwiseAnd:11,bitwiseLeftShift:12,bitwiseNot:13,bitwiseOr:14,bitwiseRightShift:15,bitwiseXOr:16,booleanAnd:17,booleanNot:18,booleanOr:19,booleanXOr:20,equalTo:24,greaterThan:28,greaterThanEqual:29,lessThan:33,lessThanEqual:34,isNull:31,notEqual:46},de={acos:6,asin:7,atan:8,atanh:9,cos:21,cosh:22,sin:51,sinh:52,tan:56,tanh:57,acosh:59,asinh:60,atan2:61},me={setNull:50,conditional:78},fe={plus:1,minus:2,times:3,sqrt:4,power:5,abs:10,divide:23,exp:25,exp10:26,exp2:27,int:30,float:32,ln:35,log10:36,log2:37,mod:44,negate:45,roundDown:48,roundUp:49,square:53,floatDivide:64,floorDivide:65,...he,...de,majority:38,max:39,mean:40,med:41,min:42,minority:43,range:47,stddev:54,sum:55,variety:58,majorityIgnoreNoData:66,maxIgnoreNoData:67,meanIgnoreNoData:68,medIgnoreNoData:69,minIgnoreNoData:70,minorityIgnoreNoData:71,rangeIgnoreNoData:72,stddevIgnoreNoData:73,sumIgnoreNoData:74,varietyIgnoreNoData:75,...me},ge=new Map([[de.acos,{domain:[0,Math.PI],isInteger:!1}],[de.asin,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[de.atan,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[de.cos,{domain:[-1,1],isInteger:!1}],[de.sin,{domain:[-1,1],isInteger:!1}],[he.booleanAnd,{domain:[0,1],isInteger:!0}],[he.booleanNot,{domain:[0,1],isInteger:!0}],[he.booleanOr,{domain:[0,1],isInteger:!0}],[he.booleanXOr,{domain:[0,1],isInteger:!0}],[he.equalTo,{domain:[0,1],isInteger:!0}],[he.notEqual,{domain:[0,1],isInteger:!0}],[he.greaterThan,{domain:[0,1],isInteger:!0}],[he.greaterThanEqual,{domain:[0,1],isInteger:!0}],[he.lessThan,{domain:[0,1],isInteger:!0}],[he.lessThanEqual,{domain:[0,1],isInteger:!0}],[he.isNull,{domain:[0,1],isInteger:!0}]]);function l$d(t){return ge.get(t)}const ye=[0,2,2,2,1,2,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,999,999,999,999,999,999,2,1,2,999,1,1,2,1,1,1,999,999,1,1,999,1,1,2,999,999,2,2,999,999,999,999,999,999,999,999,999,999,3,999,3];function i$o(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]+N[ct]);return ut}function u$c(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand("f32",N);return it.set(y),it}function h$2(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand(g,N);for(let ut=0;ut<N;ut++)d&&!d[ut]||(it[ut]=y[ut]*y[ut]);return it}function g$2(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]-N[ct]);return ut}function p$e(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]*N[ct]);return ut}function m$8(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand(g,N);for(let ut=0;ut<N;ut++)d&&!d[ut]||(it[ut]=Math.sign(y[ut])*Math.floor(Math.abs(y[ut])));return it}function d$5(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]/N[ct]);return ut}function y$2(t,d,g){return d$5(t,d,"f32")}function E$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=Math.floor(y[ct]/N[ct]));return ut}function M$1(t,d,g,y){const N=t[0],it=N.length,ut=Rt.createEmptyBand(g,it);if(y===de.atanh){for(let t=0;t<it;t++)if(d[t]){const g=N[t];Math.abs(g)>=1?d[t]=0:ut[t]=Math.atanh(g)}return ut}const ct=y===de.asin?Math.asin:Math.acos;for(let dt=0;dt<it;dt++)if(d[dt]){const t=N[dt];Math.abs(t)>1?d[dt]=0:ut[dt]=ct(t)}return ut}function B$1(t,d,g,y){const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y(N[ct]));return ut}function I(t,d,g,y){const[N,it]=t,ut=N.length,ct=Rt.createEmptyBand(g,ut);for(let dt=0;dt<ut;dt++)d&&!d[dt]||(ct[dt]=y(N[dt],it[dt]));return ct}function w$2(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]&N[ct]);return ut}function x$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]<<N[ct]);return ut}function b$1(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand(g,N);for(let ut=0;ut<N;ut++)d&&!d[ut]||(it[ut]=~y[ut]);return it}function A$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]|N[ct]);return ut}function P(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]>>N[ct]);return ut}function T$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]^N[ct]);return ut}function k$2(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]&&N[ct]?1:0);return ut}function N$1(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand(g,N);for(let ut=0;ut<N;ut++)d&&!d[ut]||(it[ut]=y[ut]?0:1);return it}function q(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]||N[ct]?1:0);return ut}function U(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=(y[ct]?1:0)^(N[ct]?1:0));return ut}function F$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]===N[ct]?1:0);return ut}function j(t,d,g,y){const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it),ct=y===Math.E;for(let dt=0;dt<it;dt++)d&&!d[dt]||(ut[dt]=ct?Math.exp(N[dt]):y**N[dt]);return ut}function z(t,d,g){return j(t,d,g,10)}function O$1(t,d,g){return j(t,d,g,2)}function C(t,d,g){return j(t,d,g,Math.E)}function R$1(t,d,g,y){const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(N[ct]<=0?d[ct]=0:ut[ct]=y(N[ct]));return ut}function S$1(t,d,g){return R$1(t,d,g,Math.log10)}function X(t,d,g){return R$1(t,d,g,Math.log2)}function v$2(t,d,g){return R$1(t,d,g,Math.log)}function D$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]>N[ct]?1:0);return ut}function G(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]>=N[ct]?1:0);return ut}function H$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]<N[ct]?1:0);return ut}function J(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]<=N[ct]?1:0);return ut}function K(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand(g,N);if(!d)return it;for(let ut=0;ut<N;ut++)it[ut]=d[ut]?0:1;return it}function L$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]%N[ct]);return ut}function Q(t,d,g){const[y]=t,N=y.length,it=Rt.createEmptyBand(g,N);for(let ut=0;ut<N;ut++)d&&!d[ut]||(it[ut]=-y[ut]);return it}function V$1(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d&&!d[ct]||(ut[ct]=y[ct]===N[ct]?0:1);return ut}function W(t,d,g){const[y,N]=t,it=y.length,ut=Rt.createEmptyBand(g,it),ct=new Uint8Array(it);for(let dt=0;dt<it;dt++)null!=d&&!d[dt]||0!==y[dt]||(ut[dt]=N[dt],ct[dt]=255);return{band:ut,mask:ct}}function Y(t,d,g){const[y,N,it]=t,ut=y.length,ct=Rt.createEmptyBand(g,ut);for(let dt=0;dt<ut;dt++)d&&!d[dt]||(ct[dt]=y[dt]?N[dt]:it[dt]);return ct}function Z(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)if(!d||d[ct]){let d=N[ct];for(let g=1;g<y;g++){const y=t[g][ct];d<y&&(d=y)}ut[ct]=d}return ut}function $$1(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)if(!d||d[ct]){let d=N[ct];for(let g=1;g<y;g++){const y=t[g][ct];d>y&&(d=y)}ut[ct]=d}return ut}function _(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)if(!d||d[ct]){let d=N[ct],g=d;for(let N=1;N<y;N++){const y=t[N][ct];g<y?g=y:d>y&&(d=y)}ut[ct]=g-d}return ut}function tt(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)if(!d||d[ct]){let d=0;for(let g=0;g<y;g++)d+=t[g][ct];ut[ct]=d/y}return ut}function et(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)if(!d||d[ct])for(let d=0;d<y;d++){const g=t[d];ut[ct]+=g[ct]}return ut}function nt(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)if(!d||d[ct]){const d=new Float32Array(y);let g=0;for(let it=0;it<y;it++){const y=t[it];g+=y[ct],d[it]=y[ct]}g/=y;let N=0;for(let t=0;t<y;t++)N+=(d[t]-g)**2;ut[ct]=Math.sqrt(N/y)}return ut}function rt(t,d,g){const y=t.length;if(y<2)return t[0];const N=Math.floor(y/2),[it]=t,ut=it.length,ct=Rt.createEmptyBand(g,ut),dt=new Float32Array(y),ft=y%2==1;for(let yt=0;yt<ut;yt++)if(!d||d[yt]){for(let d=0;d<y;d++)dt[d]=t[d][yt];dt.sort(),ct[yt]=ft?dt[N]:(dt[N]+dt[N-1])/2}return ct}function ot(t,d,g){const[y,N]=t;if(null==N)return y;const it=y.length,ut=Rt.createEmptyBand(g,it);for(let ct=0;ct<it;ct++)d[ct]&&(y[ct]===N[ct]?ut[ct]=y[ct]:d[ct]=0);return ut}function st(t,d,g){const y=t.length;if(y<=2)return ot(t,d,g);const N=t[0].length,it=Rt.createEmptyBand(g,N),ut=new Map;for(let ct=0;ct<N;ct++)if(!d||d[ct]){let d;ut.clear();for(let it=0;it<y;it++)d=t[it][ct],ut.set(d,ut.has(d)?ut.get(d)+1:1);let g=0,N=0;for(const t of ut.keys())g=ut.get(t),g>N&&(N=g,d=t);it[ct]=d}return it}function at(t,d,g){const y=t.length;if(y<=2)return ot(t,d,g);const N=t[0].length,it=Rt.createEmptyBand(g,N),ut=new Map;for(let ct=0;ct<N;ct++)if(!d||d[ct]){let d;ut.clear();for(let it=0;it<y;it++)d=t[it][ct],ut.set(d,ut.has(d)?ut.get(d)+1:1);let g=0,N=t.length;for(const t of ut.keys())g=ut.get(t),g<N&&(N=g,d=t);it[ct]=d}return it}function lt(t,d,g){const y=t.length;if(y<2)return t[0];const[N]=t,it=N.length,ut=Rt.createEmptyBand(g,it),ct=new Set;for(let dt=0;dt<it;dt++)if(!d||d[dt]){let d;ct.clear();for(let g=0;g<y;g++)d=t[g][dt],ct.add(d);ut[dt]=ct.size}return ut}const ve=new Map,xe=new Map,be=new Map,we=new Map;function gt(t,d,g,y){let[N,it]=Ct(g);const ut=kt(g);ut&&(N-=1e-5,it+=1e-5);for(let ct=0;ct<d.length;ct++)if(d[ct]){const g=t[ct];isNaN(g)||g<N||g>it?d[ct]=0:y[ct]=ut?Math.round(g):g}}function pt(t,d,g={}){!function ht(){ve.size||(ve.set(4,Math.sqrt),ve.set(6,Math.acos),ve.set(7,Math.asin),ve.set(8,Math.atan),ve.set(9,Math.atanh),ve.set(10,Math.abs),ve.set(21,Math.cos),ve.set(22,Math.cosh),ve.set(48,Math.floor),ve.set(49,Math.ceil),ve.set(51,Math.sin),ve.set(52,Math.sinh),ve.set(56,Math.tan),ve.set(57,Math.tanh),ve.set(59,Math.acosh),ve.set(60,Math.asinh),ve.set(65,Math.floor),xe.set(5,Math.pow),xe.set(61,Math.atan2),be.set(1,i$o),be.set(2,g$2),be.set(3,p$e),be.set(11,w$2),be.set(12,x$1),be.set(13,b$1),be.set(14,A$1),be.set(15,P),be.set(16,T$1),be.set(17,k$2),be.set(18,N$1),be.set(19,q),be.set(20,U),be.set(23,d$5),be.set(24,F$1),be.set(25,C),be.set(26,z),be.set(27,O$1),be.set(28,D$1),be.set(29,G),be.set(30,m$8),be.set(31,K),be.set(32,u$c),be.set(33,H$1),be.set(34,J),be.set(35,v$2),be.set(36,S$1),be.set(37,X),be.set(44,L$1),be.set(45,Q),be.set(46,V$1),be.set(53,h$2),be.set(64,y$2),be.set(65,E$1),be.set(76,Y),be.set(78,Y),we.set(38,st),we.set(39,Z),we.set(40,tt),we.set(41,rt),we.set(42,$$1),we.set(43,at),we.set(47,_),we.set(54,nt),we.set(55,et),we.set(58,lt),we.set(66,st),we.set(67,Z),we.set(68,tt),we.set(69,rt),we.set(70,$$1),we.set(71,at),we.set(72,_),we.set(73,nt),we.set(74,et),we.set(75,lt))}();let y=function f$1(t,d=!1){const g=t.map((t=>t.mask)),y=g.filter((t=>null!=t)),N=t[0].pixels[0].length;if(0===y.length||d&&y.length!==g.length)return new Uint8Array(N).fill(255);const it=y[0],ut=new Uint8Array(it);if(1===y.length)return ut;if(!d){for(let t=1;t<y.length;t++){const d=y[t];for(let t=0;t<ut.length;t++)ut[t]&&(ut[t]=d[t]?255:0)}return ut}for(let ct=1;ct<y.length;ct++){const t=y[ct];for(let d=0;d<ut.length;d++)0===ut[d]&&(ut[d]=t[d]?255:0)}return ut}(t,d>=66&&d<=75);const{outputPixelType:N="f32"}=g,it=!we.has(d)||g.processAsMultiband,ut=it?t[0].pixels.length:1,ct=[];for(let ft=0;ft<ut;ft++){const g=we.has(d)&&!it?t.flatMap((t=>t.pixels)):t.map((t=>t.pixels[ft]));let ut,dt=!0;if(d===me.setNull){const t=W(g,y,N);ut=t.band,y=t.mask,dt=!1}else be.has(d)?ut=be.get(d)(g,y,"f64"):ve.has(d)?ut=d===de.asin||d===de.acos||d===de.atanh?M$1(g,y,"f64",d):B$1(g,y,"f64",ve.get(d)):xe.has(d)?ut=I(g,y,"f64",xe.get(d)):we.has(d)?ut=we.get(d)(g,y,"f64"):(ut=g[0],dt=!1);if(dt&&d!==he.isNull&&!ge.has(d)){const t=Rt.createEmptyBand(N,ut.length);y||(y=new Uint8Array(ut.length).fill(255)),gt(ut,y,N,t),ut=t}ct.push(ut)}const dt=t[0];return new Rt({width:dt.width,height:dt.height,pixelType:N,mask:d===he.isNull?null:y,pixels:ct})}let Ae=class p extends ce{constructor(){super(...arguments),this.functionName="Arithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{operation:t}=this.functionArguments;if(t<1||t>6)return{success:!1,supportsGPU:!1,error:"unsupported operation"};const d=this.sourceRasterInfos[0].clone();return this.outputPixelType=this._getOutputPixelType(d.pixelType),d.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(d),this.rasterInfo=d,{success:!0,supportsGPU:d.bandCount<=3}}_processPixels(t){const{pixelBlocks:d}=t;return null==(null==d?void 0:d[0])||null==(null==d?void 0:d[1])?null:function mt(t,d,g){return pt(t,d=[null,1,2,3,23,5,44][d]??1,{outputPixelType:g})}(d,this.functionArguments.operation,this.outputPixelType)}_getWebGLParameters(){const{operation:t}=this.functionArguments,d=["","plus","minus","times","divide","power","mod"][t],g=this.outputPixelType??"f32";let[y,N]=Ct(g);const it=kt(g);return it&&(y-=1e-4,N+=1e-4),{imageCount:2,operationName:d,domainRange:[y,N],isOutputRounded:it}}};t([d({json:{write:!0,name:"rasterFunction"}})],Ae.prototype,"functionName",void 0),t([d({type:ae,json:{write:!0,name:"rasterFunctionArguments"}})],Ae.prototype,"functionArguments",void 0),t([d()],Ae.prototype,"rasterArgumentNames",void 0),Ae=t([g("esri.layers.support.rasterFunctions.ArithmeticFunction")],Ae);const Te=Ae;var Pe;let Fe=Pe=class extends re{clone(){return new Pe({raster:this.raster})}};Fe=Pe=t([g("esri.layers.support.rasterFunctions.AspectFunctionArguments")],Fe);const Ne=Fe;let Ie=class n extends ce{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var t;const d=this.sourceRasterInfos[0];this.isGCS=(null==(t=d.spatialReference)?void 0:t.isGeographic)??!1,this.outputPixelType=this._getOutputPixelType("f32");const g=d.clone();return g.pixelType=this.outputPixelType,g.statistics=[{min:-1,max:360,avg:180,stddev:30}],g.histograms=null,g.colormap=null,g.attributeTable=null,g.bandCount=1,this.rasterInfo=g,{success:!0,supportsGPU:!0}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const{extent:y,primaryPixelSizes:N}=t,it=(null==N?void 0:N[0])??(y?{x:y.width/g.width,y:y.height/g.height}:{x:1,y:1});return _t(g,{resolution:it})}};t([d({json:{write:!0,name:"rasterFunction"}})],Ie.prototype,"functionName",void 0),t([d({type:Ne,json:{write:!0,name:"rasterFunctionArguments"}})],Ie.prototype,"functionArguments",void 0),t([d()],Ie.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],Ie.prototype,"isGCS",void 0),Ie=t([g("esri.layers.support.rasterFunctions.AspectFunction")],Ie);const Re=Ie,Ce=new Set(["+","-","*","/","(",")"]);function n$e(t,d){return t.toLowerCase().startsWith("b")?d[parseInt(t.slice(1),10)-1]:parseFloat(t)}function r$4(t,d,g,y){if("number"==typeof g&&"number"==typeof y)return g+y;let N,it,ut;"number"==typeof g?(ut=y,N=ut.length,it=new Float32Array(N),it.fill(g)):(N=g.length,it=g,y.constructor===Number?(ut=new Float32Array(N),ut.fill(y)):ut=y);const ct=new Float32Array(N);switch(d){case"+":for(let d=0;d<N;d++)(null==t||t[d])&&(ct[d]=it[d]+ut[d]);break;case"-":for(let d=0;d<N;d++)(null==t||t[d])&&(ct[d]=it[d]-ut[d]);break;case"*":for(let d=0;d<N;d++)(null==t||t[d])&&(ct[d]=it[d]*ut[d]);break;case"/":for(let d=0;d<N;d++)(null==t||t[d])&&ut[d]&&(ct[d]=it[d]/ut[d]);break;case"(":case")":throw new Error("encountered error with custom band index equation")}return ct}function l$c(t,d){t.splice(d,1);let g=0,y=0;do{g=0,y=0;for(let d=0;d<t.length;d++)if("("===t[d])g=d;else if(")"===t[d]){y=d;break}y===g+1&&t.splice(g,2)}while(y===g+1);return t}function o$6(t){if(1===t.length)return{opIndex:0,numIndex:0};let d=0,g=0;for(let ut=0;ut<t.length;ut++)if("("===t[ut])d=ut;else if(")"===t[ut]){g=ut;break}const y=0===g?t:t.slice(d+1,g);let N=-1;for(let ut=0;ut<y.length;ut++)if("*"===y[ut]||"/"===y[ut]){N=ut;break}if(N>-1)g>0&&(N+=d+1);else{for(let t=0;t<y.length;t++)if("+"===y[t]||"-"===y[t]){N=t;break}g>0&&(N+=d+1)}let it=0;for(let ut=0;ut<N;ut++)"("===t[ut]&&it++;return{opIndex:N,numIndex:N-it}}function s$6(t,d,g){let y,{ops:N,nums:it}=function t$3(t,d){(t=t.replaceAll(" ","")).startsWith("-")&&(t="0"+t),t.startsWith("+")&&(t=t.slice(1,t.length));const g=t.split(""),y=[],N=[];let it="";for(let ut=0;ut<g.length;ut++){const t=g[ut];Ce.has(t)?(it.length&&N.push(n$e(it,d)),y.push(t),it=""):it=it.concat(t)}return it.length&&N.push(n$e(it,d)),{ops:y,nums:N}}(g,d);if(0===N.length){const t=1===it.length?it[0]:d[0];if(t instanceof Float32Array)return[t];const g=new Float32Array(d[0].length);return"number"==typeof t?g.fill(t):g.set(t),[g]}for(;N.length>0;){const{numIndex:d,opIndex:g}=o$6(N);if(y=r$4(t,N[g],it[d],it[d+1]),1===N.length)break;N=l$c(N,g),it.splice(d,2,y)}return[y]}const ke=new it({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function a$i(t,d){if(!Bt(t))return t;const{equation:g,method:y}=d,N=d.bandIndexes.map((t=>t-1)),{pixels:it,mask:ut}=t;let ct;switch(y){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":ct=l$b(ut,it[N[0]],it[N[1]]);break;case"ndwi":ct=l$b(ut,it[N[1]],it[N[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":ct=function c$p(t,d,g){const y=g.length,N=new Float32Array(y);for(let it=0;it<y;it++)if(null==t||t[it]){const t=d[it],y=g[it];y&&(N[it]=t/y)}return[N]}(ut,it[N[0]],it[N[1]]);break;case"ci-g":case"ci-re":ct=function u$b(t,d,g){const y=d.length,N=new Float32Array(y);for(let it=0;it<y;it++)if(null==t||t[it]){const t=d[it],y=g[it];y&&(N[it]=t/y-1)}return[N]}(ut,it[N[0]],it[N[1]]);break;case"savi":ct=function f(t,d,g,y){const N=g.length,it=new Float32Array(N);for(let ut=0;ut<N;ut++)if(null==t||t[ut]){const t=g[ut],N=d[ut],ct=N+t+y;ct&&(it[ut]=(N-t)/ct*(1+y))}return[it]}(ut,it[N[0]],it[N[1]],N[2]+1);break;case"tsavi":ct=function w$1(t,d,g,y,N,it){const ut=g.length,ct=new Float32Array(ut),dt=-N*y+it*(1+y*y);for(let ft=0;ft<ut;ft++)if(null==t||t[ft]){const t=g[ft],it=d[ft],ut=N*it+t+dt;ut&&(ct[ft]=y*(it-y*t-N)/ut)}return[ct]}(ut,it[N[0]],it[N[1]],N[2]+1,N[3]+1,N[4]+1);break;case"msavi":ct=function h$1(t,d,g){const y=g.length,N=new Float32Array(y);for(let it=0;it<y;it++)if(null==t||t[it]){const t=g[it],y=d[it],ut=2*y+1;N[it]=.5*(ut-Math.sqrt(ut*ut-8*(y-t)))}return[N]}(ut,it[N[0]],it[N[1]]);break;case"gemi":ct=function m$7(t,d,g){const y=g.length,N=new Float32Array(y);for(let it=0;it<y;it++)if(null==t||t[it]){const t=g[it],y=d[it];if(1!==t&&y+t+.5!==0){const d=(2*(y*y-t*t)+1.5*y+.5*t)/(y+t+.5);N[it]=d*(1-.25*d)-(t-.125)/(1-t)}}return[N]}(ut,it[N[0]],it[N[1]]);break;case"pvi":ct=function d$4(t,d,g,y,N){const it=g.length,ut=new Float32Array(it),ct=1/Math.sqrt(1+y*y);for(let dt=0;dt<it;dt++)if(null==t||t[dt]){const t=g[dt],it=d[dt];ut[dt]=(it-y*t-N)*ct}return[ut]}(ut,it[N[0]],it[N[1]],N[2]+1,N[3]+1);break;case"gvitm":ct=function g$1(t,d){const[g,y,N,it,ut,ct]=d,dt=g.length,ft=new Float32Array(dt);for(let yt=0;yt<dt;yt++)(null==t||t[yt])&&(ft[yt]=-.2848*g[yt]-.2435*y[yt]-.5436*N[yt]+.7243*it[yt]+.084*ut[yt]-.18*ct[yt]);return[ft]}(ut,[it[N[0]],it[N[1]],it[N[2]],it[N[3]],it[N[4]],it[N[5]]]);break;case"sultan":ct=function y$1(t,d){const[g,y,N,it,ut]=d,ct=g.length,dt=new Float32Array(ct),ft=new Float32Array(ct),yt=new Float32Array(ct);for(let vt=0;vt<ct;vt++)(null==t||t[vt])&&(dt[vt]=ut[vt]?it[vt]/ut[vt]*100:0,ft[vt]=g[vt]?it[vt]/g[vt]*100:0,yt[vt]=N[vt]?y[vt]/N[vt]*(it[vt]/N[vt])*100:0);return[dt,ft,yt]}(ut,[it[N[0]],it[N[1]],it[N[2]],it[N[3]],it[N[4]]]);break;case"vari":ct=function b(t,d){const[g,y,N]=d,it=g.length,ut=new Float32Array(it);for(let ct=0;ct<it;ct++)if(null==t||t[ct])for(ct=0;ct<it;ct++){const t=g[ct],d=y[ct],it=d+t-N[ct];it&&(ut[ct]=(d-t)/it)}return[ut]}(ut,[it[N[0]],it[N[1]],it[N[2]]]);break;case"mtvi2":ct=function v$1(t,d){const[g,y,N]=d,it=g.length,ut=new Float32Array(it);for(let ct=0;ct<it;ct++)if(null==t||t[ct])for(ct=0;ct<it;ct++){const t=g[ct],d=y[ct],it=N[ct],dt=Math.sqrt((2*t+1)**2-(6*t-5*Math.sqrt(d))-.5);if(dt){const g=1.5*(1.2*(t-it)-2.5*(d-it));ut[ct]=g/dt}}return[ut]}(ut,[it[N[0]],it[N[1]],it[N[2]]]);break;case"rtvi-core":ct=function k$1(t,d){const[g,y,N]=d,it=g.length,ut=new Float32Array(it);for(let ct=0;ct<it;ct++)if(null==t||t[ct])for(ct=0;ct<it;ct++){const t=g[ct],d=y[ct],it=N[ct];ut[ct]=100*(t-d)-10*(t-it)}return[ut]}(ut,[it[N[0]],it[N[1]],it[N[2]]]);break;case"evi":ct=function A(t,d){const[g,y,N]=d,it=g.length,ut=new Float32Array(it);for(let ct=0;ct<it;ct++)if(null==t||t[ct])for(ct=0;ct<it;ct++){const t=g[ct],d=y[ct],it=t+6*d-7.5*N[ct]+1;it&&(ut[ct]=2.5*(t-d)/it)}return[ut]}(ut,[it[N[0]],it[N[1]],it[N[2]]]);break;case"wndwi":ct=function p$b(t,d,g=.5){const[y,N,it]=d,ut=N.length,ct=new Float32Array(ut);for(let dt=0;dt<ut;dt++)if(null==t||t[dt])for(dt=0;dt<ut;dt++){const t=y[dt],d=N[dt],ut=it[dt],ft=t+g*d+(1-g)*ut;ft&&(ct[dt]=(t-g*d-(1-g)*ut)/ft)}return[ct]}(ut,[it[N[0]],it[N[1]],it[N[2]]],N[3]?N[3]+1:.5);break;case"bai":ct=function F(t,d,g){const y=g.length,N=new Float32Array(y);for(let it=0;it<y;it++)if(null==t||t[it])for(it=0;it<y;it++){const t=(.1-d[it])**2+(.06-g[it])**2;t&&(N[it]=1/t)}return[N]}(ut,it[N[0]],it[N[1]]);break;case"custom":ct=s$6(ut,it,g);break;default:return t}const dt=null!=ut?new Uint8Array(ut.length):null;null!=ut&&null!=dt&&dt.set(ut);const ft=new Rt({width:t.width,height:t.height,pixelType:"f32",pixels:ct,mask:dt});return ft.updateStatistics(),ft}function i$n(t){const d=new Float32Array(9);return d[3*t[0]]=1,d[3*t[1]+1]=1,d[3*t[2]+2]=1,d}function l$b(t,d,g){const y=g.length,N=new Float32Array(y);for(let it=0;it<y;it++)if(null==t||t[it]){const t=d[it],y=g[it],ut=t+y;ut&&(N[it]=(t-y)/ut)}return[N]}var _e;let Be=_e=class extends re{constructor(){super(...arguments),this.method="custom"}clone(){return new _e({method:this.method,bandIndexes:this.bandIndexes,raster:ct(this.raster)})}};t([d({json:{type:String,write:!0}})],Be.prototype,"bandIndexes",void 0),t([ut(ke)],Be.prototype,"method",void 0),Be=_e=t([g("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],Be);const je=Be,Se=new Set(["vari","mtvi2","rtvi-core","evi"]);let $e=class c extends ce{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0];if(t.bandCount<2)return{success:!1,supportsGPU:!1,error:"band-arithmetic-function: source raster has insufficient amount of raster bands"};const d=t.clone();return d.pixelType=this.outputPixelType,d.bandCount="sultan"===this.functionArguments.method?3:1,this._removeStatsHistColormapVAT(d),d.keyProperties={...d.keyProperties,BandProperties:void 0},this.rasterInfo=d,{success:!0,supportsGPU:!["custom","gvitm","sultan"].includes(this.functionArguments.method)}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return g;const{method:y,bandIndexes:N}=this.functionArguments;return a$i(g,{method:y,bandIndexes:N.split(" ").map((t=>parseFloat(t))),equation:N})}_getWebGLParameters(){const t=this.functionArguments.bandIndexes.split(" ").map((t=>parseFloat(t)-1));2===t.length&&t.push(0);const d=this.isInputBandIdsSwizzled?[0,1,2]:t;let g,y;const N=new Float32Array(3),{method:it}=this.functionArguments;switch(it){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":g=i$n([d[0],d[1],0]),y="ndxi";break;case"ndwi":g=i$n([d[1],d[0],0]),y="ndxi";break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":g=i$n([d[0],d[1],0]),y="sr";break;case"ci-g":case"ci-re":g=i$n([d[0],d[1],0]),y="ci";break;case"savi":g=i$n([d[0],d[1],0]),y="savi",N[0]=t[2]+1;break;case"tsavi":g=i$n([d[0],d[1],0]),y="tsavi",N[0]=t[2]+1,N[1]=t[3]+1,N[2]=t[4]+1;break;case"msavi":g=i$n([d[0],d[1],0]),y="msavi";break;case"gemi":g=i$n([d[0],d[1],0]),y="gemi";break;case"pvi":g=i$n([d[0],d[1],0]),y="tsavi",N[0]=t[2]+1,N[1]=t[3]+1;break;case"vari":g=i$n([d[0],d[1],d[2]]),y="vari";break;case"mtvi2":g=i$n([d[0],d[1],d[2]]),y="mtvi";break;case"rtvi-core":g=i$n([d[0],d[1],d[2]]),y="rtvicore";break;case"evi":g=i$n([d[0],d[1],d[2]]),y="evi";break;case"wndwi":g=i$n([d[0],d[1],0]),y="wndwi",N[0]=t[3]?t[3]+1:.5;break;case"bai":g=i$n([d[1],d[0],0]),y="bai";break;default:g=i$n([0,1,2]),y="custom"}return{bandIndexMat3:g,indexType:y,adjustments:N}}_getInputBandIds(t){if("custom"===this.functionArguments.method)return t;const d=this.functionArguments.bandIndexes.split(" ").map((t=>parseFloat(t)-1)),g=t.length,y=d.map((t=>t>=g?g-1:t)),N=Se.has(this.functionArguments.method)?3:2,it=y.slice(0,N).map((d=>t[d]));return 2===it.length&&it.push(0),it}};t([d({json:{write:!0,name:"rasterFunction"}})],$e.prototype,"functionName",void 0),t([d({type:je,json:{write:!0,name:"rasterFunctionArguments"}})],$e.prototype,"functionArguments",void 0),t([d()],$e.prototype,"rasterArgumentNames",void 0),$e=t([g("esri.layers.support.rasterFunctions.BandArithmeticFunction")],$e);const Me=$e;var De;const Oe=new it({1:"outside",2:"inside"},{useNumericKeys:!0});let Ge=De=class extends re{constructor(){super(...arguments),this.clippingType="outside"}clone(){return new De({clippingGeometry:this.clippingGeometry.clone(),clippingType:this.clippingType})}};t([d({types:dt,json:{read:ft,write:!0}})],Ge.prototype,"clippingGeometry",void 0),t([d({json:{read:Oe.read,write:Oe.write}})],Ge.prototype,"clippingType",void 0),Ge=De=t([g("esri.layers.support.rasterFunctions.ClipFunctionArguments")],Ge);const Ee=Ge;let ze=class i extends ce{constructor(){super(...arguments),this.functionName="Clip",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone();return this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType,this.rasterInfo=t,{success:!0,supportsGPU:!0}}_processPixels(t){var d;return null==(d=t.pixelBlocks)?void 0:d[0]}_getWebGLParameters(){const{clippingGeometry:t,clippingType:d}=this.functionArguments;return{clippingGeometry:t.toJSON(),clippingType:d}}};t([d({json:{write:!0,name:"rasterFunction"}})],ze.prototype,"functionName",void 0),t([d({type:Ee,json:{write:!0,name:"rasterFunctionArguments"}})],ze.prototype,"functionArguments",void 0),t([d()],ze.prototype,"rasterArgumentNames",void 0),t([d()],ze.prototype,"isNoopProcess",void 0),ze=t([g("esri.layers.support.rasterFunctions.ClipFunction")],ze);const Ve=ze;var Ue;let Le=Ue=class extends re{castColormapName(t){if(!t)return null;const d=t.toLowerCase();return St.includes(d)?d:null}readColorRamp(t){return xt(t)}readColorRampName(t,d){if(!t)return null;const g=jt.jsonValues.find((d=>d.toLowerCase()===t.toLowerCase()));return g?jt.fromJSON(g):null}clone(){var t;return new Ue({colormap:ct(this.colormap),colormapName:this.colormapName,colorRamp:null==(t=this.colorRamp)?void 0:t.clone(),colorRampName:this.colorRampName})}};t([d({type:[[Number]],json:{write:!0}})],Le.prototype,"colormap",void 0),t([d({type:String,json:{write:!0}})],Le.prototype,"colormapName",void 0),t([N("colormapName")],Le.prototype,"castColormapName",null),t([d({types:yt,json:{write:!0}})],Le.prototype,"colorRamp",void 0),t([vt("colorRamp")],Le.prototype,"readColorRamp",null),t([d({type:jt.apiValues,json:{type:jt.jsonValues,write:jt.write}})],Le.prototype,"colorRampName",void 0),t([vt("colorRampName")],Le.prototype,"readColorRampName",null),Le=Ue=t([g("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],Le);const We=Le,qe=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[112,75,3],[113,76,3],[114,77,3],[115,77,3],[116,78,3],[117,79,3],[118,79,3],[119,80,3],[121,81,4],[122,82,4],[123,82,4],[124,83,4],[125,84,4],[126,84,4],[127,85,4],[128,86,4],[129,86,4],[130,87,4],[131,88,4],[132,89,4],[133,89,4],[134,90,4],[135,91,4],[136,91,4],[137,92,4],[138,93,4],[139,94,4],[140,94,4],[142,95,5],[143,96,5],[144,96,5],[145,97,5],[146,98,5],[147,99,5],[148,99,5],[149,100,5],[150,101,5],[151,101,5],[152,102,5],[153,103,5],[154,104,5],[155,104,5],[156,105,5],[157,106,5],[158,106,5],[159,107,5],[160,108,5],[161,108,5],[162,109,5],[164,110,6],[165,111,6],[166,111,6],[167,112,6],[168,113,6],[169,113,6],[170,114,6],[171,115,6],[172,116,6],[173,116,6],[174,117,6],[245,0,0],[245,5,0],[245,10,0],[246,15,0],[246,20,0],[246,25,0],[246,30,0],[247,35,0],[247,40,0],[247,45,0],[247,50,0],[247,55,0],[248,60,0],[248,65,0],[248,70,0],[248,75,0],[249,81,0],[249,86,0],[249,91,0],[249,96,0],[250,101,0],[250,106,0],[250,111,0],[250,116,0],[250,121,0],[251,126,0],[251,131,0],[251,136,0],[251,141,0],[252,146,0],[252,151,0],[252,156,0],[252,156,0],[251,159,0],[250,162,0],[249,165,0],[248,168,0],[247,171,0],[246,174,0],[245,177,0],[245,179,0],[244,182,0],[243,185,0],[242,188,0],[241,191,0],[240,194,0],[239,197,0],[238,200,0],[237,203,0],[236,206,0],[235,209,0],[234,212,0],[233,215,0],[232,218,0],[231,221,0],[230,224,0],[230,226,0],[229,229,0],[228,232,0],[227,235,0],[226,238,0],[225,241,0],[224,244,0],[223,247,0],[165,247,0],[163,244,0],[161,240,0],[158,237,0],[156,233,1],[154,230,1],[152,227,1],[149,223,1],[147,220,1],[145,216,1],[143,213,1],[140,210,2],[138,206,2],[136,203,2],[134,200,2],[132,196,2],[129,193,2],[127,189,2],[125,186,3],[123,183,3],[120,179,3],[118,176,3],[116,172,3],[114,169,3],[111,166,3],[109,162,4],[107,159,4],[105,155,4],[103,152,4],[100,149,4],[98,145,4],[96,142,4],[94,138,5],[91,135,5],[89,132,5],[87,128,5],[85,125,5],[82,121,5],[80,118,5],[78,115,6],[76,111,6],[73,108,6],[71,105,6],[69,101,6],[67,98,6],[65,94,6],[62,91,7],[60,88,7],[58,84,7],[56,81,7],[53,77,7],[51,74,7],[49,71,7],[47,67,8],[44,64,8],[42,60,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8]],He=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[245,20,0],[245,24,0],[245,29,0],[245,31,0],[247,33,0],[247,33,0],[247,37,0],[247,41,0],[247,41,0],[247,41,0],[247,45,0],[247,45,0],[247,47,0],[247,49,0],[247,49,0],[247,54,0],[247,54,0],[247,56,0],[247,58,0],[247,58,0],[250,62,0],[250,62,0],[250,62,0],[250,67,0],[250,67,0],[250,67,0],[250,69,0],[250,71,0],[250,71,0],[250,75,0],[250,75,0],[250,78,0],[250,79,0],[250,79,0],[250,79,0],[250,81,0],[250,83,0],[250,83,0],[250,87,0],[250,87,0],[250,90,0],[250,92,0],[252,93,0],[252,93,0],[252,97,0],[252,97,0],[252,97,0],[252,97,0],[252,101,0],[252,101,0],[252,101,0],[252,101,0],[252,105,0],[252,105,0],[252,107,0],[252,109,0],[252,109,0],[252,113,13],[255,118,20],[255,119,23],[255,121,25],[255,126,33],[255,132,38],[255,133,40],[255,135,43],[255,141,48],[255,144,54],[255,150,59],[255,152,61],[255,153,64],[255,159,69],[255,163,77],[255,165,79],[255,168,82],[255,174,87],[255,176,92],[255,181,97],[255,183,99],[255,186,102],[255,191,107],[255,197,115],[255,201,120],[255,203,123],[255,205,125],[255,209,130],[255,214,138],[255,216,141],[255,218,143],[255,224,150],[255,228,156],[255,234,163],[255,236,165],[255,238,168],[255,243,173],[255,248,181],[255,252,186],[253,252,186],[250,252,187],[244,250,180],[238,247,176],[234,246,173],[231,245,169],[223,240,163],[217,237,157],[211,235,150],[205,233,146],[200,230,142],[195,227,136],[189,224,132],[184,222,126],[180,220,123],[174,217,119],[169,214,114],[163,212,108],[160,210,105],[154,207,101],[148,204,96],[143,201,93],[138,199,88],[134,197,84],[130,194,81],[126,191,77],[117,189,70],[115,186,68],[112,184,64],[106,181,60],[100,179,55],[94,176,49],[92,174,47],[90,173,45],[81,168,37],[75,166,33],[71,163,28],[66,160,24],[62,158,21],[56,156,14],[51,153,0],[51,153,0],[51,153,0],[50,150,0],[50,150,0],[50,150,0],[50,150,0],[49,148,0],[49,148,0],[49,148,0],[48,145,0],[48,145,0],[48,145,0],[48,145,0],[48,143,0],[48,143,0],[48,143,0],[48,143,0],[47,140,0],[47,140,0],[47,140,0],[47,140,0],[46,138,0],[46,138,0],[46,138,0],[46,138,0],[45,135,0],[45,135,0],[45,135,0],[45,135,0],[44,133,0],[44,133,0],[44,133,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[42,128,0],[42,128,0],[42,128,0],[42,125,0],[42,125,0],[42,125,0],[42,125,0],[41,122,0],[41,122,0],[41,122,0],[41,122,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[39,117,0],[39,117,0],[39,117,0],[39,117,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0]];function e$2(t,d){const g=[],y=[];for(let it=0;it<t.length-1;it++)g.push({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:t[it].slice(1),toColor:t[it+1].slice(1)}),y.push(t[it+1][0]-t[it][0]);const N=t[t.length-1][0];return $t({type:"multipart",colorRamps:g},{numColors:N,weights:d=d??y})}function c$m(t){let d;switch(t){case"elevation":d=function n$c(){return e$2([[0,0,191,191],[51,0,0,255],[102,255,0,255],[153,255,0,127],[204,191,63,127],[256,20,20,20]])}();break;case"gray":d=function l$a(){return $t({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:[0,0,0],toColor:[255,255,255]})}();break;case"hillshade":d=function a$f(){return e$2([[0,38,41,54],[69,79,82,90],[131,156,156,156],[256,253,253,241]],[.268,.238,.495])}();break;case"ndvi":d=qe;break;case"ndvi2":d=function s$4(){const t=e$2([[0,255,255,255],[70,0,255,0],[80,205,173,193],[100,150,150,150],[110,120,51,100],[130,120,100,200],[140,28,3,144],[160,6,0,55],[180,10,25,30],[201,6,7,27]]);for(let d=t.length;d<256;d++)t.push([6,27,7]);return t}();break;case"ndvi3":d=He;break;case"random":d=function i$j(){const t=[];for(let d=0;d<256;d++){const d=[];for(let t=0;t<3;t++)d.push(Math.round(255*Math.random()));t.push(d)}return t}()}return d?(d=d.map(((t,d)=>[d,...t])),d):null}let Xe=class m extends ce{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"colormap-function: source data must be single band"};let{colormap:d,colormapName:g,colorRamp:y,colorRampName:N}=this.functionArguments;if(!(null==d?void 0:d.length))if(y)this.colorRamp=y,d=Mt(y,{interpolateAlpha:!0});else if(N){const t=Dt(N);t&&(d=Mt(t),this.colorRamp=xt(t))}else g&&(d=c$m(g));if(!(null==d?void 0:d.length))return{success:!1,supportsGPU:!1,error:"colormap-function: missing colormap argument"};const it=this._getOutputPixelType(t.pixelType);this.outputPixelType=it.startsWith("f")?"s32":it;const ut=t.clone();return ut.pixelType=this.outputPixelType,ut.colormap=d,ut.bandCount=1,this.rasterInfo=ut,{success:!0,supportsGPU:!0}}_processPixels(t){var d;let g=null==(d=t.pixelBlocks)?void 0:d[0];return!g||kt(g.pixelType)||(g=g.clone(),g.clamp(this.outputPixelType)),g}};t([d({json:{write:!0,name:"rasterFunction"}})],Xe.prototype,"functionName",void 0),t([d({type:We,json:{write:!0,name:"rasterFunctionArguments"}})],Xe.prototype,"functionArguments",void 0),t([d()],Xe.prototype,"rasterArgumentNames",void 0),t([d()],Xe.prototype,"isNoopProcess",void 0),t([d({json:{write:!0}})],Xe.prototype,"indexedColormap",void 0),t([d()],Xe.prototype,"colorRamp",void 0),Xe=t([g("esri.layers.support.rasterFunctions.ColormapFunction")],Xe);const Ke=Xe;var Je;let Ye=Je=class extends re{constructor(){super(...arguments),this.rasters=[]}writeRasters(t,d){d.rasters=t.map((t=>"number"==typeof t||"string"==typeof t?t:t.toJSON()))}clone(){return new Je({rasters:ct(this.rasters)})}};t([d({json:{write:!0}})],Ye.prototype,"rasters",void 0),t([bt("rasters")],Ye.prototype,"writeRasters",null),Ye=Je=t([g("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],Ye);const Ze=Ye;let Qe=class i2 extends ce{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,d=t[0];this.outputPixelType=this._getOutputPixelType(d.pixelType);const g=d.clone();if(g.attributeTable=null,g.colormap=null,g.pixelType=this.outputPixelType,g.bandCount=t.map((({bandCount:t})=>t)).reduce(((t,d)=>t+d)),t.every((({statistics:t})=>null!=t&&t.length))){const d=[];t.forEach((({statistics:t})=>null!=t&&d.push(...t))),g.statistics=d}if(t.every((({histograms:t})=>null!=t&&t.length))){const d=[];t.forEach((({histograms:t})=>null!=t&&d.push(...t))),g.histograms=d}g.bandCount>1&&(g.colormap=null,g.attributeTable=null);const y=t.every((t=>{var d;return null==(d=t.keyProperties.BandProperties)?void 0:d.length}))?t.flatMap((t=>t.keyProperties.BandProperties)):void 0;return g.keyProperties={...g.keyProperties,BandProperties:y},this.rasterInfo=g,{success:!0,supportsGPU:g.bandCount<=3}}_processPixels(t){const{pixelBlocks:d}=t;if(!d)return null;return null==(null==d?void 0:d[0])?null:Ot(d)}_getWebGLParameters(){return{bandCount:this.rasterInfo.bandCount}}};t([d({json:{write:!0,name:"rasterFunction"}})],Qe.prototype,"functionName",void 0),t([d({type:Ze,json:{write:!0,name:"rasterFunctionArguments"}})],Qe.prototype,"functionArguments",void 0),t([d()],Qe.prototype,"rasterArgumentNames",void 0),Qe=t([g("esri.layers.support.rasterFunctions.CompositeBandFunction")],Qe);const tn=Qe,en=new it({0:"difference",1:"relative-difference",2:"categorical",3:"euclidean-distance",4:"angle-difference",5:"band-with-most-change"},{useNumericKeys:!0}),nn=new it({0:"all",1:"changed",2:"unchanged"},{useNumericKeys:!0});function i$g(t,d,g,y){const[N,it]=t,ut=kt(g)&&!kt(N.pixelType)&&!kt(it.pixelType),ct=[N.mask,it.mask].filter((t=>t)),dt=Rt.combineBandMasks(ct),ft=t.map((t=>t.pixels[0])),{width:yt,height:vt}=N,xt=Rt.createEmptyBand(g,yt*vt);switch(d){case"difference":case"relative-difference":!function o$2(t){const{bands:[d,g],mask:y,isRelative:N,isRoundingNeeded:it,outBand:ut}=t,ct=d.length;for(let dt=0;dt<ct;dt++)if(!y||y[dt]){let t=d[dt]-g[dt];if(N){const y=Math.max(Math.abs(d[dt])-Math.abs(g[dt]));t=y>0?t/y:0}ut[dt]=it?Math.round(t):t}}({bands:ft,mask:dt,outBand:xt,isRoundingNeeded:ut,isRelative:"relative-difference"===d});break;case"categorical":!function c$k(t){const{bands:[d,g],categoryIndexLookups:[y,N],classNames:[it,ut],mask:ct,keepMethod:dt,outBand:ft}=t,yt=d.length,vt=it.length,xt=ut.length,bt=vt*xt,wt=bt+1,At=bt+2;for(let Tt=0;Tt<yt;Tt++)if(!ct||ct[Tt]){const t=d[Tt],ct=g[Tt],yt=y[t],vt=N[ct],Pt=it[yt],Ft=ut[vt];ft[Tt]=null==yt||null==vt?bt:"changed"===dt&&Pt===Ft?wt:"unchanged"===dt&&Pt!==Ft?At:yt*xt+vt}}({bands:ft,mask:dt,outBand:xt,...y});break;case"euclidean-distance":!function l$9(t){const{pixels:[d,g],mask:y,outBand:N}=t,it=d[0].length,ut=d.length;for(let ct=0;ct<it;ct++)if(!y||y[ct]){let t=0;for(let y=0;y<ut;y++){const N=d[y][ct]-g[y][ct];t+=N*N}N[ct]=Math.sqrt(t)}}({pixels:t.map((t=>t.pixels)),mask:dt,outBand:xt});break;case"angle-difference":!function r$3(t){const{pixels:[d,g],mask:y,outBand:N}=t,it=d[0].length,ut=d.length;for(let ct=0;ct<it;ct++)if(!y||y[ct]){let t=0,y=0,it=0;for(let N=0;N<ut;N++){const ut=d[N][ct],dt=g[N][ct];t+=ut*dt,y+=ut*ut,it+=dt*dt}const dt=Math.sqrt(y*it);N[ct]=dt?Math.acos(t/dt):1.5707963267948966}}({pixels:t.map((t=>t.pixels)),mask:dt,outBand:xt});break;case"band-with-most-change":!function d$2(t){const{pixels:[d,g],mask:y,outBand:N}=t,it=d[0].length,ut=d.length;for(let ct=0;ct<it;ct++)if(!y||y[ct]){let t=0,y=0;for(let N=0;N<ut;N++){const it=Math.abs(d[N][ct]-g[N][ct]);it>t&&(t=it,y=N)}N[ct]=y}}({pixels:t.map((t=>t.pixels)),mask:dt,outBand:xt})}const bt=new Rt({width:yt,height:vt,pixels:[xt],pixelType:g,mask:dt});return bt.updateStatistics(),bt}var sn;let rn=sn=class extends re{constructor(){super(...arguments),this.method="difference",this.keepMethod="all",this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new sn({raster:this.raster,raster2:this.raster2,method:this.method,keepMethod:this.keepMethod})}};t([ut(en)],rn.prototype,"method",void 0),t([ut(nn)],rn.prototype,"keepMethod",void 0),t([d({json:{write:!0}})],rn.prototype,"raster2",void 0),t([d({readOnly:!0})],rn.prototype,"rasters",null),rn=sn=t([g("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")],rn);const on=rn;let an=class l extends ce{constructor(){super(...arguments),this.functionName="ComputeChange",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{method:t}=this.functionArguments,d=this.sourceRasterInfos[0].clone();if(this.outputPixelType=this._getOutputPixelType(d.pixelType),d.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(d),"categorical"===t){const t=this.sourceRasterInfos.map((t=>t.attributeTable)),g=this._getFieldNames(t,"value"),y=t.map((t=>this._getClassFieldName(t)));if(null==g[0]||null==g[1]||null==y[0]||null==y[1])return{success:!1,supportsGPU:!1,error:"both inputs must have proper attribute table with value and class fields"};this._updateAttributeTable(d,g,y)}return d.bandCount=1,this.rasterInfo=d,{success:!0,supportsGPU:"difference"===t||"relative-difference"===t}}_processPixels(t){const{pixelBlocks:d}=t;if(null==(null==d?void 0:d[0])||null==(null==d?void 0:d[1]))return null;const{method:g}=this.functionArguments;return i$g(d,g,this.outputPixelType,this._categoryConfig)}_getWebGLParameters(){const t=this.outputPixelType??"f32";let[d,g]=Ct(t);const y=kt(t);return y&&(d-=1e-4,g+=1e-4),{method:this.functionArguments.method,domainRange:[d,g],isOutputRounded:y}}_updateAttributeTable(t,d,g){const y=this.sourceRasterInfos.map((t=>t.attributeTable)),N=y.map(((t,g)=>t.features.map((t=>t.attributes[d[g]])))),it=y.map(((t,d)=>t.features.map((t=>t.attributes[g[d]])))),ut=N.map((t=>{const d=[];return t.forEach(((t,g)=>d[t]=g)),d})),{keepMethod:ct}=this.functionArguments;this._categoryConfig={categoryIndexLookups:ut,classNames:it,keepMethod:ct};const dt=y[0].clone();dt.fields=[new wt({name:"OID",type:"oid"}),new wt({name:"Value",type:"integer"}),new wt({name:"ClassName",type:"string"}),new wt({name:"Class_From",type:"string"}),new wt({name:"Class_To",type:"string"})];const ft=this._getFieldNames(y,"red"),yt=this._getFieldNames(y,"green"),vt=this._getFieldNames(y,"blue"),xt=[],bt=2===ft.length&&2===yt.length&&2===vt.length;bt&&(xt.push(...y.map(((t,d)=>t.features.map((t=>[t.attributes[ft[d]],t.attributes[yt[d]],t.attributes[vt[d]]]))))),dt.fields.push(new wt({name:"Red",type:"integer"}),new wt({name:"Green",type:"integer"}),new wt({name:"Blue",type:"integer"})));const At=dt.features[0].clone();At.geometry=null;const Tt=[],[Pt,Ft]=N.map((t=>t.length));let Nt=1;for(let wt=0;wt<Pt;wt++){const t=it[0][wt];for(let d=0;d<Ft;d++){const g=it[1][d];if("changed"===ct&&t===g||"unchanged"===ct&&t!==g)continue;const y=At.clone();y.attributes={OID:Nt++,Value:wt*Ft+d,ClassName:t===g?t:`${t} -> ${g}`,Class_From:t,Class_To:g},bt&&(y.attributes.Red=xt[0][wt][0]+xt[1][d][0]>>1,y.attributes.Green=xt[0][wt][1]+xt[1][d][1]>>1,y.attributes.Blue=xt[0][wt][2]+xt[1][d][2]>>1),Tt.push(y)}}if("changed"===ct){const t=At.clone();t.attributes={OID:Nt++,Value:Pt*Ft+1,ClassName:"No Change",Class_From:"Same",Class_To:"Same"},Tt.push(t)}else if("unchanged"===ct){const t=At.clone();t.attributes={OID:Nt++,Value:Pt*Ft+2,ClassName:"Changed",Class_From:"Any",Class_To:"Any"},Tt.push(t)}dt.features=Tt,t.attributeTable=dt}_getFieldNames(t,d){return t.map((({fields:t})=>{var g;return null==(g=t.find((t=>t.name.toLowerCase()===d)))?void 0:g.name})).filter((t=>t))}_getClassFieldName(t){const d=t.fields.find((t=>"string"===t.type&&t.name.toLowerCase().startsWith("class")))??t.fields.find((t=>"string"===t.type&&t.name.toLowerCase().includes("class")||t.name.toLowerCase().includes("type")||t.name.toLowerCase().includes("name")))??t.fields.find((t=>"string"===t.type));return null==d?void 0:d.name}};t([d({json:{write:!0,name:"rasterFunction"}})],an.prototype,"functionName",void 0),t([d({type:on,json:{write:!0,name:"rasterFunctionArguments"}})],an.prototype,"functionArguments",void 0),t([d()],an.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],an.prototype,"_categoryConfig",void 0),an=t([g("esri.layers.support.rasterFunctions.ComputeChangeFunction")],an);const un=an;var ln;let cn=ln=class extends re{constructor(){super(...arguments),this.contrastOffset=0,this.brightnessOffset=0}clone(){return new ln({contrastOffset:this.contrastOffset,brightnessOffset:this.brightnessOffset,raster:this.raster})}};t([d({json:{write:!0}})],cn.prototype,"contrastOffset",void 0),t([d({json:{write:!0}})],cn.prototype,"brightnessOffset",void 0),cn=ln=t([g("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")],cn);const pn=cn;let hn=class u2 extends ce{constructor(){super(...arguments),this.functionName="ContrastBrightness",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const{sourceRasterInfos:t}=this,d=t[0];if("u8"!==d.pixelType)return{success:!1,supportsGPU:!1,error:"Only unsigned 8 bit raster is supported by ContrastBrightness function."};this.outputPixelType=this._getOutputPixelType("u8");const g=d.clone();this._removeStatsHistColormapVAT(g),this.rasterInfo=g;const{contrastOffset:y,brightnessOffset:N}=this.functionArguments;return this.lookup=Gt(y,N),{success:!0,supportsGPU:!0}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];return null==g?null:Et(g,{lut:g.pixels.map((()=>this.lookup)),offset:0,outputPixelType:"u8"})}_getWebGLParameters(){const{contrastOffset:t,brightnessOffset:d}=this.functionArguments;return{contrastOffset:t,brightnessOffset:d}}};t([d({json:{write:!0,name:"rasterFunction"}})],hn.prototype,"functionName",void 0),t([d({type:pn,json:{write:!0,name:"rasterFunctionArguments"}})],hn.prototype,"functionArguments",void 0),t([d()],hn.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],hn.prototype,"lookup",void 0),hn=t([g("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")],hn);const dn=hn;function o$1(t,d,g,y,N){const it=Math.floor(y/2);for(let ct=0;ct<it;ct++)for(let y=0;y<d;y++)t[ct*d+y]=t[(N-1-ct)*d+y],t[(g-1-ct)*d+y]=t[(g-N+ct)*d+y];const ut=Math.floor(N/2);for(let ct=0;ct<g;ct++){const g=ct*d;for(let y=0;y<ut;y++)t[g+y]=t[g+N-1-y],t[g+d-y-1]=t[g+d+y-N]}}const mn=new Map;function r$2(t,d,g,y,N,it,ut){const ct=new Float32Array(d*g),dt=it.length,ft=ut?0:y,yt=ut?y:0,vt=ut?1:d;for(let xt=ft;xt<g-ft;xt++){const g=xt*d;for(let ut=yt;ut<d-yt;ut++){if(N&&!N[g+ut])continue;let d=0;for(let N=0;N<dt;N++)d+=t[g+ut+(N-y)*vt]*it[N];ct[g+ut]=d}}return ct}function s$2(t,d,g,y,N,it,ut){const ct=new Float32Array(d*g),dt=Math.floor(y/2),ft=Math.floor(N/2);for(let yt=dt;yt<g-dt;yt++){const g=yt*d;for(let yt=ft;yt<d-ft;yt++){if(it&&!it[g+yt])continue;let vt=0;for(let it=0;it<y;it++)for(let y=0;y<N;y++)vt+=t[g+yt+(it-dt)*d+y-ft]*ut[it*N+y];ct[g+yt]=vt}}return ct}function h(t,d){const g=function o(t){const d=Math.sqrt(t.length),g=t.slice(0,d),y=[1];for(let N=1;N<d;N++){let g=null;for(let y=0;y<d;y++){const it=t[y+N*d],ut=t[y];if(null==g)if(0===ut){if(it)return{separable:!1,row:null,col:null}}else g=it/ut;else if(it/ut!==g)return{separable:!1,row:null,col:null}}if(null==g)return{separable:!1,row:null,col:null};y.push(g)}return{separable:!0,row:g,col:y}}(d.kernel),y=!1!==d.mirrorEdges,N=g.separable?function a$c(t,d,g,y=!0){const{pixels:N,width:it,height:ut,pixelType:ct,mask:dt}=t,ft=N.length,yt=[],vt=d.length,xt=g.length,bt=Math.floor(vt/2),wt=Math.floor(xt/2);for(let At=0;At<ft;At++){let t=r$2(N[At],it,ut,bt,dt,d,!0);t=r$2(t,it,ut,wt,dt,g,!1),y&&o$1(t,it,ut,vt,xt),yt.push(t)}return new Rt({width:it,height:ut,pixelType:ct,pixels:yt,mask:dt})}(t,g.row,g.col,y):function i$d(t,d,g=!0){const{pixels:y,width:N,height:it,pixelType:ut,mask:ct}=t,dt=y.length,ft=[],{kernel:yt,rows:vt,cols:xt}=d;for(let bt=0;bt<dt;bt++){const t=s$2(y[bt],N,it,vt,xt,ct,yt);g&&o$1(t,N,it,vt,xt),ft.push(t)}return new Rt({width:N,height:it,pixelType:ut,pixels:ft,mask:ct})}(t,d,y),{outputPixelType:it}=d;return it&&N.clamp(it),N}var fn;mn.set(pe.none,[0,0,0,0,1,0,0,0,0]),mn.set(pe.lineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),mn.set(pe.lineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),mn.set(pe.lineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),mn.set(pe.lineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),mn.set(pe.gradientNorth,[-1,-2,-1,0,0,0,1,2,1]),mn.set(pe.gradientWest,[-1,0,1,-2,0,2,-1,0,1]),mn.set(pe.gradientEast,[1,0,-1,2,0,-2,1,0,-1]),mn.set(pe.gradientSouth,[1,2,1,0,0,0,-1,-2,-1]),mn.set(pe.gradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),mn.set(pe.gradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),mn.set(pe.smoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),mn.set(pe.smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),mn.set(pe.smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),mn.set(pe.sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),mn.set(pe.sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),mn.set(pe.laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),mn.set(pe.laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),mn.set(pe.sobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),mn.set(pe.sobelVertical,[-1,0,1,-2,0,2,-1,0,1]),mn.set(pe.sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),mn.set(pe.sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),mn.set(pe.pointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);let gn=fn=class extends re{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set convolutionType(t){this._set("convolutionType",t);const d=mn.get(t);if(!d||t===pe.userDefined||t===pe.none)return;const g=Math.sqrt(d.length);this._set("kernel",d),this._set("cols",g),this._set("rows",g)}clone(){return new fn({cols:this.cols,rows:this.rows,kernel:[...this.kernel],convolutionType:this.convolutionType,raster:ct(this.raster)})}};t([d({json:{type:Number,write:!0}})],gn.prototype,"rows",void 0),t([d({json:{type:Number,write:!0}})],gn.prototype,"cols",void 0),t([d({json:{name:"type",type:Number,write:!0}})],gn.prototype,"convolutionType",null),t([d({json:{type:[Number],write:!0}})],gn.prototype,"kernel",void 0),gn=fn=t([g("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],gn);const yn=gn;let vn=class l2 extends ce{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}get _normalizedKernel(){const{kernel:t,convolutionType:d}=this.functionArguments,g=t.reduce(((t,d)=>t+d));return-1===d||0===g||1===g?t:t.map((t=>t/g))}_bindSourceRasters(){const{convolutionType:t,rows:d,cols:g,kernel:y}=this.functionArguments;if(!Object.values(pe).includes(t))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==pe.none&&d*g!==y.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const N=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(N.pixelType);const it=N.clone();it.pixelType=this.outputPixelType;const ut=[pe.none,pe.sharpen,pe.sharpen2,pe.sharpening3x3,pe.sharpening5x5];return(-1===t||"u8"!==this.outputPixelType&&!ut.includes(t))&&(it.statistics=null,it.histograms=null),it.colormap=null,it.attributeTable=null,this.rasterInfo=it,{success:!0,supportsGPU:y.length<=25}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g||this.functionArguments.convolutionType===pe.none)return g;const{rows:y,cols:N}=this.functionArguments,{_normalizedKernel:it}=this;return h(g,{kernel:it,rows:y,cols:N,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=new Float32Array(25);return t.set(this._normalizedKernel),{kernelRows:this.functionArguments.rows,kernelCols:this.functionArguments.cols,kernel:t,clampRange:Ct(this.outputPixelType)}}};t([d({json:{write:!0,name:"rasterFunction"}})],vn.prototype,"functionName",void 0),t([d({type:yn,json:{write:!0,name:"rasterFunctionArguments"}})],vn.prototype,"functionArguments",void 0),t([d()],vn.prototype,"rasterArgumentNames",void 0),t([d()],vn.prototype,"_normalizedKernel",null),vn=t([g("esri.layers.support.rasterFunctions.ConvolutionFunction")],vn);const xn=vn;var bn;const wn=new it({0:"standard",1:"platform",2:"profile"},{useNumericKeys:!0});let An=bn=class extends re{constructor(){super(...arguments),this.curvatureType="standard",this.zFactor=1}readCurvatureType(t,d){return wn.fromJSON(d.type??d.curvatureType??0)}clone(){return new bn({curvatureType:this.curvatureType,zFactor:this.zFactor,raster:this.raster})}};t([d({json:{write:{target:"type"}}}),ut(wn)],An.prototype,"curvatureType",void 0),t([vt("curvatureType",["type","curvatureType"])],An.prototype,"readCurvatureType",null),t([d({type:Number,json:{write:!0}})],An.prototype,"zFactor",void 0),An=bn=t([g("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")],An);const Tn=An;let Pn=class u3 extends ce{constructor(){super(...arguments),this.functionName="Curvature",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var t;this.outputPixelType=this._getOutputPixelType("f32");const d=this.sourceRasterInfos[0].clone();return d.pixelType=this.outputPixelType,d.bandCount=1,this._removeStatsHistColormapVAT(d),this.rasterInfo=d,this.isGCS=(null==(t=d.spatialReference)?void 0:t.isGeographic)??!1,{success:!0,supportsGPU:!0}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const{zFactor:y,curvatureType:N}=this.functionArguments,{extent:it,primaryPixelSizes:ut}=t,ct=(null==ut?void 0:ut[0])??(it?{x:it.width/g.width,y:it.height/g.height}:{x:1,y:1}),dt=this.isGCS&&y>=1?y*zt:y;return Vt(g,{zFactor:dt,curvatureType:N,resolution:ct})}_getWebGLParameters(){const{zFactor:t,curvatureType:d}=this.functionArguments;return{curvatureType:d,zFactor:this.isGCS&&t>=1?t*zt:t}}};t([d({json:{write:!0,name:"rasterFunction"}})],Pn.prototype,"functionName",void 0),t([d({type:Tn,json:{write:!0,name:"rasterFunctionArguments"}})],Pn.prototype,"functionArguments",void 0),t([d()],Pn.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],Pn.prototype,"isGCS",void 0),Pn=t([g("esri.layers.support.rasterFunctions.CurvatureFunction")],Pn);const Fn=Pn;var Nn;let In=Nn=class extends re{constructor(){super(...arguments),this.bandIds=[],this.bandNames=[],this.bandWavelengths=[],this.missingBandAction=Ut.bestMatch}clone(){var t,d,g;return new Nn({bandIds:null==(t=this.bandIds)?void 0:t.slice(),bandNames:null==(d=this.bandNames)?void 0:d.slice(),bandWavelengths:null==(g=this.bandWavelengths)?void 0:g.slice(),missingBandAction:this.missingBandAction,method:this.method,wavelengthMatchTolerance:this.wavelengthMatchTolerance})}};t([d({json:{write:!0}})],In.prototype,"bandIds",void 0),t([d({json:{write:!0}})],In.prototype,"bandNames",void 0),t([d({json:{write:!0}})],In.prototype,"bandWavelengths",void 0),t([ut({0:"name",1:"wavelength",2:"id"})],In.prototype,"method",void 0),t([d({json:{write:!0}})],In.prototype,"missingBandAction",void 0),t([d({json:{write:!0}})],In.prototype,"wavelengthMatchTolerance",void 0),In=Nn=t([g("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],In);const Rn=In;let Cn=class i3 extends ce{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){var t;const{functionArguments:d,sourceRasterInfos:g}=this,y=g[0],{method:N,bandNames:it,bandWavelengths:ut,bandIds:ct,missingBandAction:dt}=d,ft=(null==it?void 0:it.length)&&("name"===N||"id"!==N&&!(null==ct?void 0:ct.length)),yt=(null==ut?void 0:ut.length)&&("wavelength"===N||"id"!==N&&!(null==ct?void 0:ct.length)),vt=dt===Ut.fail,xt=ft?function u$4(t,d){const g=t.bandInfos.map((({name:t})=>t.toLowerCase())),y=[];for(let N=0;N<d.length;N++){const t=d[N].toLowerCase();let it=g.indexOf(t);if(-1===it&&"nearinfrared"===t&&(it=g.findIndex((t=>t.startsWith("nearinfrared_1"))),-1===it&&(it=g.findIndex((t=>t.startsWith("nearinfrared"))))),-1===it)return null;y.push(it)}return y}(y,it):yt?function d$1(t,d,{wavelengthMatchTolerance:g},y){const{bandInfos:N}=t,it=[];for(let ct=0;ct<N.length;ct++){const{minWavelength:t,maxWavelength:d}=N[ct];if(!t||!d)return null;it.push({minWavelength:t,maxWavelength:d})}const ut=[];for(let ct=0;ct<d.length;ct++){const t=d[ct];let N=!1,dt=-1,ft=Number.MAX_VALUE;for(let d=0;d<it.length;d++){const g=it[d],y=t>=g.minWavelength&&t<=g.maxWavelength,ut=Math.abs(t-(g.minWavelength+g.maxWavelength)/2);y?ut<ft&&(N=!0,dt=d,ft=ut):!N&&ut<ft&&(dt=d,ft=ut)}if(!N&&g&&ft<g&&(N=!0),!N&&y)return null;ut.push(dt)}return ut}(y,ut,this.functionArguments,vt):function c$d(t,d,g){const{bandCount:y}=t;return!(null==d?void 0:d.length)||g&&d.some((t=>t<0||t>=y))?null:d}(y,ct,vt);if(null==xt)return{success:!1,supportsGPU:!1,error:`extract-band-function: Invalid ${ft?"band names":yt?"band wavelengths":"band ids"} for the imagery data source`};this.functionArguments.bandIds=xt,this.functionArguments.method="id",this.outputPixelType=this._getOutputPixelType("f32");const bt=y.clone();bt.pixelType=this.outputPixelType,bt.bandCount=xt.length;const{statistics:wt,histograms:At}=bt;null!=wt&&wt.length&&(bt.statistics=xt.map((t=>wt[t]||wt[wt.length-1]))),null!=At&&At.length&&(bt.histograms=xt.map((t=>At[t]||At[At.length-1])));let Tt=null==(t=bt.keyProperties)?void 0:t.BandProperties;return(null==Tt?void 0:Tt.length)&&(Tt=xt.map((t=>t>=Tt.length?Tt[Tt.length-1]:Tt[t])),bt.keyProperties={...bt.keyProperties,BandProperties:Tt}),this.rasterInfo=bt,{success:!0,supportsGPU:bt.bandCount<=3}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const y=g.pixels.length,N=this.functionArguments.bandIds.map((t=>t>=y?y-1:t));return g.extractBands(N)}_getWebGLParameters(){let t;if(this.isInputBandIdsSwizzled)t=this.swizzledBandSelection.length?this.swizzledBandSelection:[0,1,2];else{t=[...this.functionArguments.bandIds],0===t.length?t=[0,1,2]:t.length<3&&(t[1]=t[1]??t[0],t[2]=t[2]??t[1]);for(let d=0;d<3;d++)t[d]=Math.min(t[d],2)}return{bandIndexMat3:i$n(t)}}_getInputBandIds(t){const d=t.length;return this.functionArguments.bandIds.map((t=>t>=d?d-1:t)).map((d=>t[d]))}};t([d({json:{write:!0,name:"rasterFunction"}})],Cn.prototype,"functionName",void 0),t([d({type:Rn,json:{write:!0,name:"rasterFunctionArguments"}})],Cn.prototype,"functionArguments",void 0),t([d()],Cn.prototype,"rasterArgumentNames",void 0),Cn=t([g("esri.layers.support.rasterFunctions.ExtractBandFunction")],Cn);const kn=Cn;var _n;let Bn=_n=class extends re{clone(){return new _n({conversionParameters:[...this.conversionParameters],raster:this.raster})}};t([d({type:[Number],json:{write:!0}})],Bn.prototype,"conversionParameters",void 0),Bn=_n=t([g("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")],Bn);const jn=Bn;let Sn=class i4 extends ce{constructor(){super(...arguments),this.functionName="Grayscale",this.functionArguments=null,this.rasterArgumentNames=["raster"]}get _normalizedWeights(){const{conversionParameters:t}=this.functionArguments,d=t.reduce(((t,d)=>t+d));return t.map((t=>t/d))}_bindSourceRasters(){const{conversionParameters:t}=this.functionArguments;if(!(null==t?void 0:t.length))return{success:!1,supportsGPU:!1,error:"missing valid conversion parameters."};const d=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(d.pixelType),d.pixelType=this.outputPixelType;const g=3===t.length||3===d.bandCount&&t.length>3;return d.bandCount=1,this._removeStatsHistColormapVAT(d),this.rasterInfo=d,{success:!0,supportsGPU:g}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];return null==g?null:function i$9(t,d,g){const{pixels:y,width:N,height:it,mask:ut,bandMasks:ct}=t,dt=N*it,ft=(null==ct?void 0:ct.length)?Rt.combineBandMasks(ct):ut,yt=Math.min(d.length,y.length),vt=g.startsWith("f"),xt=!vt&&g!==t.pixelType,[bt,wt]=Ct(g),At=Rt.createEmptyBand(g,dt);for(let Pt=0;Pt<it;Pt++){let t=Pt*N;for(let g=0;g<N;g++,t++)if(!ft||ft[t]){let g=0;for(let N=0;N<yt;N++)g+=d[N]*y[N][t];vt||(g=Math.round(g),xt&&(g=g>wt?wt:g<bt?bt:g)),At[t]=g}}const Tt=new Rt({width:N,height:it,pixels:[At],pixelType:g,mask:ft});return Tt.updateStatistics(),Tt}(g,this._normalizedWeights,this.outputPixelType)}_getWebGLParameters(){return{weights:this._normalizedWeights}}};t([d({json:{write:!0,name:"rasterFunction"}})],Sn.prototype,"functionName",void 0),t([d({type:jn,json:{write:!0,name:"rasterFunctionArguments"}})],Sn.prototype,"functionArguments",void 0),t([d()],Sn.prototype,"rasterArgumentNames",void 0),t([d()],Sn.prototype,"_normalizedWeights",null),Sn=t([g("esri.layers.support.rasterFunctions.GrayscaleFunction")],Sn);const $n=Sn;var Mn;let Dn=Mn=class extends re{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!0}writeRasters(t,d){d.rasters=t.map((t=>"number"==typeof t||"string"==typeof t?t:t.toJSON()))}clone(){return new Mn({operation:this.operation,processAsMultiband:this.processAsMultiband,rasters:ct(this.rasters)})}};t([d({json:{write:!0}})],Dn.prototype,"operation",void 0),t([d({json:{write:!0}})],Dn.prototype,"rasters",void 0),t([bt("rasters")],Dn.prototype,"writeRasters",null),t([d({json:{write:!0}})],Dn.prototype,"processAsMultiband",void 0),Dn=Mn=t([g("esri.layers.support.rasterFunctions.LocalFunctionArguments")],Dn);const On=Dn;let Gn=class m2 extends ce{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,d=t[0],{bandCount:g}=d,{processAsMultiband:y}=this.functionArguments;if(t.some((t=>t.bandCount!==g)))return{success:!1,supportsGPU:!1,error:"local-function: input rasters do not have same band count"};const{operation:N,rasters:it}=this.functionArguments,ut=ye[N];if(!(999===ut||it.length===ut||it.length<=1&&1===ut))return{success:!1,supportsGPU:!1,error:`local-function: the length of functionArguments.rasters does not match operation's requirement: ${ut}`};const ct=d.clone();return ct.bandCount=999!==ut||y?g:1,this._removeStatsHistColormapVAT(ct),this._updateStatistics(ct),this._updatePixelType(ct),this.rasterInfo=ct,{success:!0,supportsGPU:1===ct.bandCount&&ut<=3&&(N<11||N>16)}}_processPixels(t){const{pixelBlocks:d}=t;return null==d||d.some((t=>null==t))?null:pt(d,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:this.outputPixelType??void 0})}_getWebGLParameters(){var t;const{operation:d}=this.functionArguments,g=ye[d],y=(null==(t=Object.keys(fe).find((t=>fe[t]===d)))?void 0:t.toLowerCase())??"undefined",N=this.outputPixelType??"f32";let[it,ut]=Ct(N);const ct=kt(N);return ct&&(it-=1e-4,ut+=1e-4),{imageCount:g,operationName:y,domainRange:[it,ut],isOutputRounded:ct}}_updateStatistics(t){var d,g;const y=this.sourceRasterInfos[0],{operation:N}=this.functionArguments,it=null==(d=l$d(N))?void 0:d.domain;if(it){t.statistics=[];for(let d=0;d<t.bandCount;d++)t.statistics[d]={min:it[0],max:it[1],avg:(it[0]+it[1])/2,stddev:(it[0]+it[1])/10}}else 45===N&&(null==(g=y.statistics)?void 0:g.length)&&(t.statistics=y.statistics.map((t=>({min:-t.max,max:-t.min,avg:null!=t.avg?-t.avg:void 0,stddev:null!=t.stddev?-t.stddev:void 0}))))}_updatePixelType(t){const{statistics:d,pixelType:g}=this.sourceRasterInfos[0],{operation:y}=this.functionArguments,{domain:N,isInteger:it}=l$d(y)??{domain:null,isInteger:!1};let ut="f32";if(N&&it)ut=Lt(N[0],N[1]);else if(30===y){const t=null==d?void 0:d[0];ut=t?Lt(t.min,t.max):kt(g)?g:"s32"}else if(45===y&&kt(g)){const t=null==d?void 0:d.map((({max:t})=>-t)),y=null==d?void 0:d.map((({min:t})=>-t)),N=(null==t?void 0:t.length)?Math.min(...t):null,it=(null==y?void 0:y.length)?Math.min(...y):null;ut=null!=N&&null!=it?Lt(N,it):g.startsWith("s")?g.replace("s","u"):"u1"===g||"u2"===g||"u4"===g?"s8":"u8"===g?"s16":"s32"}t.pixelType=this.outputPixelType=this._getOutputPixelType(ut)}};t([d({json:{write:!0,name:"rasterFunction"}})],Gn.prototype,"functionName",void 0),t([d({type:On,json:{write:!0,name:"rasterFunctionArguments"}})],Gn.prototype,"functionArguments",void 0),t([d()],Gn.prototype,"rasterArgumentNames",void 0),Gn=t([g("esri.layers.support.rasterFunctions.LocalFunction")],Gn);const En=Gn;var zn;let Vn=zn=class extends re{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=Wt.matchAny}get normalizedNoDataValues(){const{noDataValues:t}=this;if(!(null==t?void 0:t.length))return null;let d=!1;const g=t.map((t=>{if("number"==typeof t)return d=!0,[t];if("string"==typeof t){const g=t.trim().split(" ").filter((t=>""!==t.trim())).map((t=>Number(t)));return d=d||g.length>0,0===g.length?null:g}return null}));return d?g:null}clone(){var t,d;return new zn({includedRanges:(null==(t=this.includedRanges)?void 0:t.slice())??[],noDataValues:(null==(d=this.noDataValues)?void 0:d.slice())??[],noDataInterpretation:this.noDataInterpretation})}};t([d({json:{write:!0}})],Vn.prototype,"includedRanges",void 0),t([d({json:{write:!0}})],Vn.prototype,"noDataValues",void 0),t([d()],Vn.prototype,"normalizedNoDataValues",null),t([d({json:{write:!0}})],Vn.prototype,"noDataInterpretation",void 0),Vn=zn=t([g("esri.layers.support.rasterFunctions.MaskFunctionArguments")],Vn);const Un=Vn;let Ln=class c2 extends ce{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:d}=t;this.outputPixelType=this._getOutputPixelType(d),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:g,normalizedNoDataValues:y}=this.functionArguments;if(!(null==g?void 0:g.length)&&!(null==y?void 0:y.length))return{success:!1,supportsGPU:!1,error:"missing includedRanges or noDataValues argument"};let N=[];for(let ut=0;ut<t.bandCount;ut++){const t=qt(d,null==g?void 0:g.slice(2*ut,2*ut+2),null==y?void 0:y[ut]);if(null==t){N=null;break}N.push(t)}this.lookups=N;const it=null!=y&&y.every((t=>{var d;return(null==t?void 0:t.length)===(null==(d=y[0])?void 0:d.length)}));return{success:!0,supportsGPU:(!g||g.length<=2*Ht)&&(!y||it&&y[0].length<=Ht)}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const{outputPixelType:y,lookups:N}=this,{includedRanges:it,noDataInterpretation:ut,normalizedNoDataValues:ct}=this.functionArguments,dt=ut===Wt.matchAll;return Xt(g,{includedRanges:it,noDataValues:ct,outputPixelType:y,matchAll:dt,lookups:N})}_getWebGLParameters(){var t;const{includedRanges:d,normalizedNoDataValues:g}=this.functionArguments,y=new Float32Array(Ht);y.fill(At),(null==(t=null==g?void 0:g[0])?void 0:t.length)&&y.set(g[0]);const N=new Float32Array(Ht);for(let it=0;it<N.length;it+=2)N[it]=(null==d?void 0:d[it])??-At,N[it+1]=(null==d?void 0:d[it+1])??At;return(null==d?void 0:d.length)&&N.set(d),{bandCount:this.sourceRasterInfos[0].bandCount,noDataValues:y,includedRanges:N}}};t([d({json:{write:!0,name:"rasterFunction"}})],Ln.prototype,"functionName",void 0),t([d({type:Un,json:{write:!0,name:"rasterFunctionArguments"}})],Ln.prototype,"functionArguments",void 0),t([d()],Ln.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],Ln.prototype,"lookups",void 0),Ln=t([g("esri.layers.support.rasterFunctions.MaskFunction")],Ln);const Wn=Ln;var qn;let Hn=qn=class extends re{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scientificOutput=!1}clone(){const{visibleBandID:t,infraredBandID:d,scientificOutput:g}=this;return new qn({visibleBandID:t,infraredBandID:d,scientificOutput:g})}};t([d({json:{write:!0}})],Hn.prototype,"visibleBandID",void 0),t([d({json:{write:!0}})],Hn.prototype,"infraredBandID",void 0),t([d({json:{write:!0}})],Hn.prototype,"scientificOutput",void 0),Hn=qn=t([g("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],Hn);const Xn=Hn;let Kn=class u4 extends ce{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scientificOutput:t,visibleBandID:d,infraredBandID:g}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(t?"f32":"u8");const y=this.sourceRasterInfos[0],N=Math.max(d,g);if(y.bandCount<2||N>=y.bandCount)return{success:!1,supportsGPU:!1,error:"ndvi-function: source raster has insufficient amount of raster bands"};const it=y.clone();it.pixelType=this.outputPixelType,it.colormap=null,it.histograms=null,it.bandCount=1,it.keyProperties={...it.keyProperties,BandProperties:void 0};const[ut,ct,dt,ft]=t?[-1,1,0,.1]:[0,200,100,10];return it.statistics=[{min:ut,max:ct,avg:dt,stddev:ft}],this.rasterInfo=it,{success:!0,supportsGPU:!0}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const{visibleBandID:y,infraredBandID:N,scientificOutput:it}=this.functionArguments;return function s$5(t,d,g,y){const{mask:N,pixels:it,width:ut,height:ct}=t,dt=it[g],ft=it[d],yt=ft.length,vt=y?new Uint8Array(yt):new Float32Array(yt),xt=y?100:1,bt=y?100.5:0;for(let At=0;At<yt;At++)if(null==N||N[At]){const t=dt[At],d=ft[At],g=t+d;g&&(vt[At]=(t-d)/g*xt+bt)}const wt=new Rt({width:ut,height:ct,mask:N,pixelType:y?"u8":"f32",pixels:[vt]});return wt.updateStatistics(),wt}(g,y,N,!it)}_getWebGLParameters(){const{visibleBandID:t,infraredBandID:d,scientificOutput:g}=this.functionArguments;return{bandIndexMat3:i$n(this.isInputBandIdsSwizzled?[0,1,2]:[d,t,0]),scaled:!g}}_getInputBandIds(t){const{visibleBandID:d,infraredBandID:g}=this.functionArguments;return[g,d,0].map((d=>t[d]))}};t([d({json:{write:!0,name:"rasterFunction"}})],Kn.prototype,"functionName",void 0),t([d({type:Xn,json:{write:!0,name:"rasterFunctionArguments"}})],Kn.prototype,"functionArguments",void 0),t([d()],Kn.prototype,"rasterArgumentNames",void 0),Kn=t([g("esri.layers.support.rasterFunctions.NDVIFunction")],Kn);const Jn=Kn;var Yn;let Zn=Yn=class extends re{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1,this.isLastInputRangeInclusive=!1}clone(){return new Yn({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched,isLastInputRangeInclusive:this.isLastInputRangeInclusive})}};t([d({json:{write:!0}})],Zn.prototype,"inputRanges",void 0),t([d({json:{write:!0}})],Zn.prototype,"outputValues",void 0),t([d({json:{write:!0}})],Zn.prototype,"noDataRanges",void 0),t([d({json:{write:!0}})],Zn.prototype,"allowUnmatched",void 0),t([d({json:{write:!0}})],Zn.prototype,"isLastInputRangeInclusive",void 0),Zn=Yn=t([g("esri.layers.support.rasterFunctions.RemapFunctionArguments")],Zn);const Qn=Zn;let ts=class m3 extends ce{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:d}=t;this.outputPixelType=this._getOutputPixelType(d),t.pixelType=this.outputPixelType,t.colormap=null,t.histograms=null,t.bandCount=1,t.attributeTable=null;const{statistics:g}=t,{allowUnmatched:y,outputValues:N,inputRanges:it,noDataRanges:ut,isLastInputRangeInclusive:ct}=this.functionArguments;if(null!=g&&g.length&&(null==N?void 0:N.length))if(y){const d=Math.min.apply(null,[...N,g[0].min]),y=Math.max.apply(null,[...N,g[0].max]);t.statistics=[{...g[0],min:d,max:y}]}else{let d=N[0],y=d;for(let t=0;t<N.length;t++)d=d>N[t]?N[t]:d,y=y>N[t]?y:N[t];t.statistics=[{...g[0],min:d,max:y}]}return this.rasterInfo=t,this.lookup=y?null:Kt({srcPixelType:d,inputRanges:it,outputValues:N,noDataRanges:ut,allowUnmatched:y,isLastInputRangeInclusive:ct,outputPixelType:this.outputPixelType}),{success:!0,supportsGPU:(!N||N.length<=Ht)&&(!ut||ut.length<=Ht)}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const{lookup:y,outputPixelType:N}=this;if(y){const t=Et(g,{lut:[y.lut],offset:y.offset,outputPixelType:N});return null!=t&&y.mask&&(t.mask=Jt(g.pixels[0],g.mask,y.mask,y.offset,"u8")),t}const{inputRanges:it,outputValues:ut,noDataRanges:ct,allowUnmatched:dt,isLastInputRangeInclusive:ft}=this.functionArguments;return Yt(g,{inputRanges:it,outputValues:ut,noDataRanges:ct,outputPixelType:N,allowUnmatched:dt,isLastInputRangeInclusive:ft})}_getWebGLParameters(){const{allowUnmatched:t,noDataRanges:d,isLastInputRangeInclusive:g}=this.functionArguments,y=new Float32Array(3*Ht),N=1e-5,it=this.functionArguments.inputRanges??[],ut=this.functionArguments.outputValues??[],ct=ut.length;for(let ft=0;ft<Ht;ft++)y[3*ft]=it[2*ft]??At-1,y[3*ft+1]=it[2*ft+1]??At,y[3*ft+2]=ut[ft]??0,ft<ct&&(ft>0&&(y[3*ft]-=N),(ft<ct-1||!g)&&(y[3*ft+1]-=N));const dt=new Float32Array(2*Ht);return dt.fill(At),(null==d?void 0:d.length)&&dt.set(d),{allowUnmatched:t,rangeMaps:y,noDataRanges:dt,clampRange:Ct(this.outputPixelType)}}};t([d({json:{write:!0,name:"rasterFunction"}})],ts.prototype,"functionName",void 0),t([d({type:Qn,json:{write:!0,name:"rasterFunctionArguments"}})],ts.prototype,"functionArguments",void 0),t([d()],ts.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],ts.prototype,"lookup",void 0),ts=t([g("esri.layers.support.rasterFunctions.RemapFunction")],ts);const es=ts;var ns;const ss=new it({1:"degree",2:"percent-rise",3:"adjusted"},{useNumericKeys:!0});let rs=ns=class extends re{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.removeEdgeEffect=!1}clone(){return new ns({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};t([ut(ss)],rs.prototype,"slopeType",void 0),t([d({type:Number,json:{write:!0}})],rs.prototype,"zFactor",void 0),t([d({type:Number,json:{name:"psPower",write:!0}})],rs.prototype,"pixelSizePower",void 0),t([d({type:Number,json:{name:"psZFactor",write:!0}})],rs.prototype,"pixelSizeFactor",void 0),t([d({type:Boolean,json:{write:!0}})],rs.prototype,"removeEdgeEffect",void 0),rs=ns=t([g("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],rs);const os=rs;let is=class p2 extends ce{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){var t;this.outputPixelType=this._getOutputPixelType("f32");const d=this.sourceRasterInfos[0].clone();return d.pixelType=this.outputPixelType,d.statistics="percent-rise"!==this.functionArguments.slopeType?[{min:0,max:90,avg:1,stddev:1}]:null,d.histograms=null,d.colormap=null,d.attributeTable=null,d.bandCount=1,this.rasterInfo=d,this.isGCS=(null==(t=d.spatialReference)?void 0:t.isGeographic)??!1,{success:!0,supportsGPU:!0}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return null;const{zFactor:y,slopeType:N,pixelSizePower:it,pixelSizeFactor:ut}=this.functionArguments,{isGCS:ct}=this,{extent:dt,primaryPixelSizes:ft}=t,yt=(null==ft?void 0:ft[0])??(dt?{x:dt.width/g.width,y:dt.height/g.height}:{x:1,y:1});return Zt(g,{zFactor:y,slopeType:N,pixelSizePower:it,pixelSizeFactor:ut,isGCS:ct,resolution:yt})}_getWebGLParameters(){const{zFactor:t,slopeType:d,pixelSizeFactor:g,pixelSizePower:y}=this.functionArguments;return{zFactor:this.isGCS&&t>=1?t*zt:t,slopeType:d,pixelSizeFactor:g??0,pixelSizePower:y??0}}};t([d({json:{write:!0,name:"rasterFunction"}})],is.prototype,"functionName",void 0),t([d({type:os,json:{write:!0,name:"rasterFunctionArguments"}})],is.prototype,"functionArguments",void 0),t([d()],is.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],is.prototype,"isGCS",void 0),is=t([g("esri.layers.support.rasterFunctions.SlopeFunction")],is);const as=is,us=new it({1:"min",2:"max",3:"mean",4:"stddev",5:"median",6:"majority",7:"minority"},{useNumericKeys:!0});function s(t,d){const{fillNoDataOnly:g}=d,{band:y,width:N,height:it,mask:ut,outBand:ct}=t;if(g&&!ut)return void ct.set(y);const{statisticsType:dt,kernelRows:ft,kernelCols:yt}=d,vt="stddev"===dt,xt=N*it,bt=new Float64Array(xt),wt=new Float64Array(xt),At=new Uint32Array(xt);for(let Ct=0;Ct<it;Ct++){const t=Ct*N;let d=0,g=0,it=0;for(let N=0;N<yt;N++)ut&&!ut[t+N]||(d+=y[t+N],vt&&(g+=y[t+N]**2),it++);bt[t]=d,wt[t]=g,At[t]=it;for(let ct=1;ct<=N-yt;ct++){const N=t+ct-1,dt=N+yt;ut?(ut[N]&&(it--,d-=y[N],vt&&(g-=y[N]**2)),ut[dt]&&(it++,d+=y[dt],vt&&(g+=y[dt]**2))):(d-=y[N],d+=y[dt],vt&&(g-=y[N]**2,g+=y[dt]**2)),bt[t+ct]=d,At[t+ct]=it,vt&&(wt[t+ct]=g)}}const Tt=new Float64Array(xt),Pt=new Float64Array(xt),Ft=new Uint32Array(xt),Nt=ft*N;for(let Ct=0;Ct<=N-yt;Ct++){let t=0,d=0,g=0;for(let y=0;y<ft;y++){const it=y*N+Ct;t+=bt[it],g+=At[it],vt&&(d+=wt[it])}Tt[Ct]=t,Pt[Ct]=d,Ft[Ct]=g;for(let y=1;y<=it-ft;y++){const it=(y-1)*N+Ct,ut=it+Nt;t-=bt[it],t+=bt[ut],g-=At[it],g+=At[ut],vt&&(d-=wt[it],d+=wt[ut]),Tt[y*N+Ct]=t,Pt[y*N+Ct]=d,Ft[y*N+Ct]=g}}const It=Math.floor(ft/2),Rt=Math.floor(yt/2);for(let Ct=It;Ct<it-It;Ct++){const t=Ct*N;for(let d=Rt;d<N-Rt;d++){const y=(Ct-It)*N+d-Rt,it=Ft[y];if(0===it||g&&(!ut||ut[t+d]))continue;const dt=Tt[y]/it,ft=vt?Math.sqrt((Pt[y]-Tt[y]*dt)/it):dt;ct[t+d]=ft,ut&&(ut[t+d]=255)}}}function r(t,d){const{fillNoDataOnly:g}=d,{band:y,width:N,height:it,mask:ut,outBand:ct}=t;if(g&&!ut)return void ct.set(y);const{kernelRows:dt,kernelCols:ft,statisticsType:yt}=d,vt=Math.floor(dt/2),xt=Math.floor(ft/2),bt="min"===yt,wt=ct.slice(),At=new Uint32Array(N*it);for(let Tt=vt;Tt<it-vt;Tt++){const t=Tt*N;for(let d=xt;d<N-xt;d++){let g=bt?Number.MAX_VALUE:-Number.MAX_VALUE,it=0;for(let ct=0;ct<dt;ct++)for(let dt=0;dt<ft;dt++){const ft=t+d+(ct-vt)*N+dt-xt;ut&&!ut[ft]||(g=bt?Math.min(g,y[ft]):Math.max(g,y[ft]),it++)}ut?(wt[t+d]=0===it?0:g,At[t+d]=it):ct[t+d]=0===it?0:g}}if(ut)for(let Tt=vt;Tt<it-vt;Tt++){const t=Tt*N;for(let d=xt;d<N-xt;d++)if(At[t+d]){if(g&&ut[t+d])continue;ct[t+d]=wt[t+d],ut[t+d]=255}}}function i$3(t,d){const{fillNoDataOnly:g}=d,{band:y,width:N,height:it,mask:ut,outBand:ct}=t;if(g&&!ut)return void ct.set(y);const{kernelRows:dt,kernelCols:ft}=d,yt=Math.floor(dt/2),vt=Math.floor(ft/2),xt=ct.slice(),bt=new Uint32Array(N*it);for(let wt=yt;wt<it-yt;wt++){const t=wt*N;for(let d=vt;d<N-vt;d++){if(g&&(null==ut?void 0:ut[t+d]))continue;const it=[];for(let g=0;g<dt;g++)for(let ct=0;ct<ft;ct++){const dt=t+d+(g-yt)*N+ct-vt;ut&&!ut[dt]||it.push(y[dt])}it.length&&(it.sort(((t,d)=>t-d)),ut?(xt[t+d]=it[Math.floor((it.length-1)/2)],bt[t+d]=it.length):ct[t+d]=it[Math.floor((it.length-1)/2)])}}if(ut)for(let wt=yt;wt<it-yt;wt++){const t=wt*N;for(let d=vt;d<N-vt;d++)if(bt[t+d]){if(g&&ut[t+d])continue;ct[t+d]=xt[t+d],ut[t+d]=255}}}function l$3(t,d){const{fillNoDataOnly:g}=d,{band:y,width:N,height:it,mask:ut,outBand:ct}=t;if(g&&!ut)return void ct.set(y);const{kernelRows:dt,kernelCols:ft}=d,yt=Math.floor(dt/2),vt=Math.floor(ft/2),xt="majority"===d.statisticsType,bt=dt*ft,wt=ct.slice(),At=new Uint32Array(N*it);for(let Tt=yt;Tt<it-yt;Tt++){const t=Tt*N;for(let d=vt;d<N-vt;d++){if(g&&(null==ut?void 0:ut[t+d]))continue;const it=new Map;for(let g=0;g<dt;g++)for(let ct=0;ct<ft;ct++){const dt=t+d+(g-yt)*N+ct-vt;if(ut&&!ut[dt])continue;const ft=y[dt];it.set(ft,it.has(ft)?it.get(ft)+1:1)}if(0===it.size)continue;let Tt=0,Pt=0,Ft=xt?0:bt+1;for(const t of it.keys())Pt=it.get(t),xt===Pt>Ft&&(Ft=Pt,Tt=t);ut?(wt[t+d]=Tt,At[t+d]=it.size):ct[t+d]=Tt}}if(ut)for(let Tt=yt;Tt<it-yt;Tt++){const t=Tt*N;for(let d=vt;d<N-vt;d++)if(At[t+d]){if(g&&ut[t+d])continue;ct[t+d]=wt[t+d],ut[t+d]=255}}}var ls;let cs=ls=class extends re{constructor(){super(...arguments),this.rows=3,this.cols=3,this.fillNoDataOnly=!1,this.statisticsType="min"}clone(){return new ls({rows:this.rows,cols:this.cols,fillNoDataOnly:this.fillNoDataOnly,statisticsType:this.statisticsType,raster:ct(this.raster)})}};t([d({json:{write:!0,read:{source:["kernelRows","rows"],reader:(t,d)=>Number(t??(null==d?void 0:d.kernelRows)??3)}}})],cs.prototype,"rows",void 0),t([d({json:{write:!0,read:{source:["kernelCols","cols"],reader:(t,d)=>Number(t??(null==d?void 0:d.kernelCols)??3)}}})],cs.prototype,"cols",void 0),t([d({json:{write:!0}})],cs.prototype,"fillNoDataOnly",void 0),t([d({json:{read:{source:["statisticsType","type"],reader:(t,d)=>us.fromJSON((null==d?void 0:d.statisticsType)??(null==d?void 0:d.type))??"min"},write:{target:"type"}}}),ut(us)],cs.prototype,"statisticsType",void 0),cs=ls=t([g("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")],cs);const ps=cs;let hs=class c3 extends ce{constructor(){super(...arguments),this.functionName="Statistics",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{type:t}=this.functionArguments.toJSON();if(t<1||t>7)return{success:!1,supportsGPU:!1,error:`statistics-function: the given statistics type is not supported ${t}`};const d=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(d.pixelType);const g=d.clone();g.pixelType=this.outputPixelType;const{statisticsType:y}=this.functionArguments;return"stddev"===y&&this._removeStatsHistColormapVAT(g),this.rasterInfo=g,{success:!0,supportsGPU:g.bandCount<=3&&t<5}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return g;const{statisticsType:y,rows:N,cols:it,fillNoDataOnly:ut}=this.functionArguments;return function a$4(t,d){const{mask:g}=t,{fillNoDataOnly:y}=d;if(y&&!g)return t;const{pixels:N,width:it,height:ut,bandMasks:ct,pixelType:dt}=t,ft=N.length,yt=it*ut,vt=[],{kernelRows:xt,kernelCols:bt,statisticsType:wt,mirrorEdges:At}=d;if(y&&!g)return t;const Tt=d.outputPixelType??dt,Pt=[];for(let It=0;It<ft;It++){const t=N[It],dt=Rt.createEmptyBand(Tt,yt);y&&dt.set(t);const ft=(null==ct?void 0:ct[It])??g,Ft=(null==ft?void 0:ft.slice())??null,Nt={band:t,width:it,height:ut,mask:Ft,outBand:dt};switch(wt){case"min":case"max":r(Nt,d);break;case"mean":case"stddev":s(Nt,d);break;case"median":i$3(Nt,d);break;case"majority":case"minority":l$3(Nt,d)}At&&!y&&o$1(dt,it,ut,xt,bt),vt.push(dt),Ft&&Pt.push(Ft)}let Ft=Pt[0]??g;Pt.length!==ft&&(Pt.length=0),ft>1&&(null==ct?void 0:ct.length)&&(Ft=Rt.combineBandMasks(ct));const Nt=new Rt({pixelType:Tt,width:it,height:ut,pixels:vt,bandMasks:ct&&Pt.length?Pt:null,mask:Ft});return Nt.updateStatistics(),Nt}(g,{kernelRows:N,kernelCols:it,fillNoDataOnly:ut,outputPixelType:this.outputPixelType,statisticsType:y,mirrorEdges:!0})}_getWebGLParameters(){const{rows:t,cols:d,statisticsType:g,fillNoDataOnly:y}=this.functionArguments;return{fillNoDataOnly:y,kernelRows:t,kernelCols:d,statisticsType:g,clampRange:Ct(this.outputPixelType)}}};t([d({json:{write:!0,name:"rasterFunction"}})],hs.prototype,"functionName",void 0),t([d({type:ps,json:{write:!0,name:"rasterFunctionArguments"}})],hs.prototype,"functionArguments",void 0),t([d()],hs.prototype,"rasterArgumentNames",void 0),hs=t([g("esri.layers.support.rasterFunctions.StatisticsFunction")],hs);const ds=hs;var ms;let fs=ms=class extends re{constructor(){super(...arguments),this.statistics=null,this.histograms=null}readStatistics(t,d){if(!(null==t?void 0:t.length))return null;const g=[];return t.forEach((t=>{const d={min:t.min,max:t.max,avg:t.avg??t.mean,stddev:t.stddev??t.standardDeviation};g.push(d)})),g}writeStatistics(t,d,g){if(!(null==t?void 0:t.length))return;const y=[];t.forEach((t=>{const d={...t,mean:t.avg,standardDeviation:t.stddev};delete d.avg,delete d.stddev,y.push(d)})),d[g]=y}clone(){return new ms({statistics:ct(this.statistics),histograms:ct(this.histograms)})}};t([d({json:{write:!0}})],fs.prototype,"statistics",void 0),t([vt("statistics")],fs.prototype,"readStatistics",null),t([bt("statistics")],fs.prototype,"writeStatistics",null),t([d({json:{write:!0}})],fs.prototype,"histograms",void 0),fs=ms=t([g("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")],fs);const gs=fs;let ys=class i5 extends ce{constructor(){super(...arguments),this.functionName="StatisticsHistogram",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const d=t.clone(),{statistics:g,histograms:y}=this.functionArguments;return y&&(d.histograms=y),g&&(d.statistics=g),this.rasterInfo=d,{success:!0,supportsGPU:!0}}_processPixels(t){var d;return null==(d=t.pixelBlocks)?void 0:d[0]}};t([d({json:{write:!0,name:"rasterFunction"}})],ys.prototype,"functionName",void 0),t([d({type:gs,json:{write:!0,name:"rasterFunctionArguments"}})],ys.prototype,"functionArguments",void 0),t([d()],ys.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],ys.prototype,"indexedColormap",void 0),t([d()],ys.prototype,"isNoopProcess",void 0),ys=t([g("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")],ys);const vs=ys;var xs;const bs=new it({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",9:"sigmoid"},{useNumericKeys:!0});let ws=xs=class extends re{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(t,d,g){(null==t?void 0:t.length)&&(Array.isArray(t[0])||(t=t.map((t=>[t.min,t.max,t.avg,t.stddev]))),d[g]=t)}clone(){return new xs({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:ct(this.statistics),gamma:ct(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:ct(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};t([d({type:Boolean,json:{write:!0}})],ws.prototype,"computeGamma",void 0),t([d({type:Boolean,json:{name:"dra",write:!0}})],ws.prototype,"dynamicRangeAdjustment",void 0),t([d({type:[Number],json:{write:!0}})],ws.prototype,"gamma",void 0),t([d()],ws.prototype,"histograms",void 0),t([d({type:Number,json:{write:!0}})],ws.prototype,"maxPercent",void 0),t([d({type:Number,json:{write:!0}})],ws.prototype,"minPercent",void 0),t([d({type:Number,json:{write:!0}})],ws.prototype,"numberOfStandardDeviations",void 0),t([d({type:Number,json:{name:"max",write:!0}})],ws.prototype,"outputMax",void 0),t([d({type:Number,json:{name:"min",write:!0}})],ws.prototype,"outputMin",void 0),t([d({type:Number,json:{write:!0}})],ws.prototype,"sigmoidStrengthLevel",void 0),t([d({json:{type:[[Number]],write:!0}})],ws.prototype,"statistics",void 0),t([bt("statistics")],ws.prototype,"writeStatistics",null),t([ut(bs)],ws.prototype,"stretchType",void 0),t([d({type:Boolean,json:{write:!0}})],ws.prototype,"useGamma",void 0),ws=xs=t([g("esri.layers.support.rasterFunctions.StretchFunctionArguments")],ws);const As=ws;let Ts=class c4 extends ce{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const t=this.sourceRasterInfos[0],{pixelType:d}=t,{functionArguments:g}=this,{dynamicRangeAdjustment:y,gamma:N,useGamma:it}=g;if(!y&&["u8","u16","s8","s16"].includes(d)){const y=Qt(g.toJSON(),{rasterInfo:t}),ut=kt(this.outputPixelType)?"round":"float";this.lookup=te({pixelType:d,...y,gamma:it?N:null,rounding:ut}),this.cutOffs=y}else y||(this.cutOffs=Qt(g.toJSON(),{rasterInfo:t}));this.outputPixelType=this._getOutputPixelType(d);const ut=t.clone();ut.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(ut),"u8"===this.outputPixelType&&(ut.keyProperties.DataType="processed");const{outputMin:ct=0,outputMax:dt=255}=this.functionArguments;ut.statistics=[];for(let ft=0;ft<ut.bandCount;ft++)ut.statistics[ft]={min:ct,max:dt};return this.rasterInfo=ut,{success:!0,supportsGPU:!y}}_processPixels(t){var d;const g=null==(d=t.pixelBlocks)?void 0:d[0];if(null==g)return g;const{lookup:y}=this;if(y)return Et(g,{...y,outputPixelType:this.rasterInfo.pixelType});const{functionArguments:N}=this,it=this.cutOffs||Qt(N.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:g}),ut=N.useGamma?N.gamma:null;return ee(g,{...it,gamma:ut,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const{outputMin:t=0,outputMax:d=255,gamma:g,useGamma:y}=this.functionArguments,N=this.rasterInfo.bandCount>=2?3:1,it=y&&(null==g?void 0:g.length)?ne(N,g):[1,1,1],{minCutOff:ut,maxCutOff:ct}=this.cutOffs??{minCutOff:[0,0,0],maxCutOff:[255,255,255]};1===ut.length&&(ut[1]=ut[2]=ut[0],ct[1]=ct[2]=ct[0]);const dt=new Float32Array(N);let ft;for(ft=0;ft<N;ft++)dt[ft]=(d-t)/(ct[ft]-ut[ft]);const yt=kt(this.outputPixelType);return{bandCount:N,outMin:t,outMax:d,minCutOff:ut,maxCutOff:ct,factor:dt,useGamma:y,gamma:y&&g?g:[1,1,1],gammaCorrection:y&&it?it:[1,1,1],stretchType:this.functionArguments.stretchType,isOutputRounded:yt,type:"stretch"}}};t([d({json:{write:!0,name:"rasterFunction"}})],Ts.prototype,"functionName",void 0),t([d({type:As,json:{write:!0,name:"rasterFunctionArguments"}})],Ts.prototype,"functionArguments",void 0),t([d()],Ts.prototype,"rasterArgumentNames",void 0),t([d({json:{write:!0}})],Ts.prototype,"lookup",void 0),t([d({json:{write:!0}})],Ts.prototype,"cutOffs",void 0),Ts=t([g("esri.layers.support.rasterFunctions.StretchFunction")],Ts);const Ps=Ts;var Fs;let Ns=Fs=class extends re{constructor(){super(...arguments),this.attributeTableAsRecordSet=null}clone(){return new Fs({attributeTableAsRecordSet:ct(this.attributeTableAsRecordSet)})}};t([d({json:{write:!0}})],Ns.prototype,"attributeTableAsRecordSet",void 0),Ns=Fs=t([g("esri.layers.support.rasterFunctions.TableFunctionArguments")],Ns);const Is=Ns;let Rs=class extends ce{constructor(){super(...arguments),this.functionName="Table",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1||t.pixelType.startsWith("f"))return{success:!1,supportsGPU:!1,error:"table-function: Source data must be single band and integer pixel type."};const{attributeTableAsRecordSet:d}=this.functionArguments;if(!d)return{success:!1,supportsGPU:!1,error:"table-function: Missing attributeTableAsRecordSet argument."};this.outputPixelType=this._getOutputPixelType(t.pixelType);const g=t.clone();return g.pixelType=this.outputPixelType,g.bandCount=1,"thematic"!==g.dataType&&(g.keyProperties=g.keyProperties?{...g.keyProperties,DataType:"thematic"}:{DataType:"thematic"}),this.rasterInfo=g,{success:!0,supportsGPU:!0}}_processPixels(t){var d;return null==(d=t.pixelBlocks)?void 0:d[0]}};t([d({json:{write:!0,name:"rasterFunction"}})],Rs.prototype,"functionName",void 0),t([d({type:Is,json:{write:!0,name:"rasterFunctionArguments"}})],Rs.prototype,"functionArguments",void 0),t([d()],Rs.prototype,"rasterArgumentNames",void 0),t([d()],Rs.prototype,"isNoopProcess",void 0),Rs=t([g("esri.layers.support.rasterFunctions.TableFunction")],Rs);const Cs=Rs,ks=new Map;function R(t,d){const{rasterFunctionArguments:g}=t;g&&(g.rasters||[g.raster,g.raster2]).forEach((t=>{t&&"number"!=typeof t&&("string"==typeof t?t.startsWith("http")&&(d.includes(t)||d.push(t)):"rasterFunctionArguments"in t&&R(t,d))}))}function S(t,d){if(d=d??{},"function"in(t=ct(t))&&"arguments"in t&&t.arguments){const g=x(t,new Map,d);if(M(g),!g.renderingRule)throw new Tt("raster-function-helper","Unsupported raster function json.");t=g.renderingRule}if("rasterFunction"in t)return V(t=D(t),d);throw new Tt("raster-function-helper","unsupported raster function json.")}function w(t){return!!(t&&"object"==typeof t&&t.rasterFunction&&t.rasterFunctionArguments)}function D(t){var d;const{rasterFunction:g,rasterFunctionArguments:y}=t,N={};for(const it in y){let t=y[it];const d=it.toLowerCase();if("rasters"===d&&Array.isArray(t))N.rasters=t.map((t=>w(t)?D(t):t));else switch(w(t)&&(t=D(t)),d){case"dra":N.dra=t;break;case"pspower":N.psPower=t;break;case"pszfactor":N.psZFactor=t;break;case"bandids":N.bandIds=t;break;default:N[it[0].toLowerCase()+it.slice(1)]=t}}return"Local"!==g||(null==(d=N.rasters)?void 0:d.length)||(N.rasters=["$$"]),{...t,rasterFunctionArguments:N}}function V(t,d){var g,y;const{rasterFunction:N,rasterFunctionArguments:it}=t,ut=null==(g=t.outputPixelType)?void 0:g.toLowerCase();if(null==N||!ks.has(N))throw new Tt("raster-function-helper",`unsupported raster function: ${N}`);const ct=ks.get(N),dt=("function"==typeof ct.ctor?ct.ctor:ct.ctor.default).fromJSON({...t,outputPixelType:ut}),{rasterArgumentNames:ft}=dt,yt=[],vt=function v(t,d){return"rasters"===d[0]&&Array.isArray(t.rasters)?t.rasters:d.map((d=>t[d]))}(it,ft),xt="rasters"===ft[0]||ft.length>1,bt=[];for(let wt=0;wt<vt.length;wt++){const t=vt[wt];let g;null==t||"string"==typeof t&&t.startsWith("$")?yt.push(null==d?void 0:d.raster):"string"==typeof t?d[t]&&yt.push(d[t]):"number"!=typeof t&&"rasterFunction"in t&&(g=V(t,d),xt||(dt.functionArguments[ft[wt]]=g),yt.push(g)),xt&&bt.push(g??t)}if(xt&&("rasters"===ft[0]?dt.functionArguments.rasters=bt:ft.forEach(((t,d)=>{dt.functionArguments[t]=bt[d]}))),d){dt.sourceRasters=yt;const t=null==(y=d.raster)?void 0:y.url;t&&(dt.mainPrimaryRasterId=t)}return dt}function T(t,d){if(t&&d)for(const g in t){const y=t[g];y&&"object"==typeof y&&"type"in y&&("RasterFunctionTemplate"===y.type?T(y.arguments,d):"RasterFunctionVariable"===y.type&&null!=d[y.name]&&(y.value=d[y.name]))}}function k(t,d){var g;if(!t||"object"!=typeof t)return t;const{value:y}=t;if(!y||"object"!=typeof y)return t.isDataset?"$$":y;if(Array.isArray(y))return 0===y.length?[]:y.map((t=>"object"==typeof t&&"RasterFunctionVariable"===t.type?k(t,d):t));if("value"in y&&["number","string","boolean"].includes(typeof y.value))return y.value;if(t.isDataset&&"Scalar"!==y.type)return"$$";if(!("type"in y))return y;let N=y;switch(y.type){case"Scalar":N=y.value;break;case"AlgorithmicColorRamp":N=B(y);break;case"MultiPartColorRamp":N={type:"multipart",colorRamps:y.ArrayOfColorRamp.map(B)};break;case"ArgumentArray":if((null==(g=y.elements)?void 0:g.length)&&"RasterStatistics"!==y.elements[0].type){const t=[];for(let g=0;g<y.elements.length;g++){const N=y.elements[g],{type:it}=N;if(it)if("RasterFunctionTemplate"===it){const{renderingRule:g}=x(N,d);t.push(g),null!=N._object_id&&d.set(N._object_id,g)}else{if("RasterFunctionVariable"!==it)throw new Tt("raster-function-helper","unsupported raster function json.");{const g=k(N,d);t.push(g),null!=N._object_id&&d.set(N._object_id,g)}}else t.push(N)}N=t}else N=y.elements}return null!=y._object_id&&d.set(y._object_id,N),N}function B(t){const d=t.algorithm??"esriHSVAlgorithm";let{FromColor:g,ToColor:y}=t;if(!Array.isArray(g)){const{r:t,g:d,b:y}=Pt({h:g.Hue,s:g.Saturation,v:g.Value});g=[t,d,y,g.AlphaValue]}if(!Array.isArray(y)){const{r:t,g:d,b:g}=Pt({h:y.Hue,s:y.Saturation,v:y.Value});y=[t,d,g,y.AlphaValue]}return{type:"algorithmic",algorithm:d,fromColor:g,toColor:y}}function x(t,d,g){g&&T(t,g);const y={renderingRule:{},templates:d};return E(t,y),y}function E(t,d){if(!t||!d.renderingRule)return;const{renderingRule:g,templates:y}=d,{function:N,arguments:it,_object_id:ut}=t;if(!N||!it)return;null!=ut&&y.set(ut,g),g.rasterFunction=N.type.replace("Function",""),g.outputPixelType=N.pixelType;const ct={};g.rasterFunctionArguments=ct;for(const dt in it){if("type"===dt||"object_id"===dt||"_object_ref_id"===dt)continue;const t=it[dt];t&&"object"==typeof t&&"type"in t&&("RasterFunctionTemplate"===t.type||"RasterFunctionVariable"===t.type)?("RasterFunctionVariable"===t.type?ct[dt]=k(t,y):(g.rasterFunctionArguments[dt]={},E(t,{renderingRule:g.rasterFunctionArguments[dt],templates:y})),null!=t._object_id&&y.set(t._object_id,ct[dt])):ct[dt]=t}switch(ct.DEM&&!ct.Raster&&(ct.Raster=ct.DEM,delete ct.DEM),g.rasterFunction){case"Stretch":!function $(t){var d;(null==(d=t.Statistics)?void 0:d.length)&&"object"==typeof t.Statistics&&(t.Statistics=t.Statistics.map((t=>[t.min,t.max,t.mean,t.standardDeviation]))),null!=t.NumberOfStandardDeviation&&(t.NumberOfStandardDeviations=t.NumberOfStandardDeviation,delete t.NumberOfStandardDeviation)}(ct);break;case"Colormap":!function L(t){var d,g;"randomcolorramp"===(null==(g=null==(d=t.ColorRamp)?void 0:d.type)?void 0:g.toLowerCase())&&(delete t.ColorRamp,t.ColormapName="Random"),0===t.ColorSchemeType&&delete t.ColorRamp}(ct);break;case"Convolution":!function O(t){null!=t.ConvolutionType&&(t.Type=t.ConvolutionType,delete t.ConvolutionType)}(ct);break;case"Mask":!function H(t){var d;(null==(d=t.NoDataValues)?void 0:d.length)&&"string"==typeof t.NoDataValues[0]&&(t.NoDataValues=t.NoDataValues.filter((t=>""!==t)).map((t=>Number(t))))}(ct)}}function M(t){const{renderingRule:d,templates:g}=t;if("object"!=typeof d||!(null==d?void 0:d.rasterFunctionArguments)||!g.size)return;const{rasterFunctionArguments:y}=d;for(const N in y){const t=y[N],d="_object_ref_id"===N?t:t&&"object"==typeof t&&"_object_ref_id"in t?t._object_ref_id:null;if(null==d)t&&"object"==typeof t&&(t.rasterFunctionArguments&&M({renderingRule:t,templates:g}),Array.isArray(t)&&t.forEach(((y,N)=>{if("object"==typeof y)if(null!=y._object_ref_id){if(!g.has(y._object_ref_id))throw new Tt("raster-function-helper",`unsupported raster function json. _object_ref_id: ${t} does not exist`);const it=g.get(d);it&&"object"==typeof it?Object.assign(y,it):t[N]=it}else M({renderingRule:y,templates:g})})));else{if(!g.has(d))throw new Tt("raster-function-helper",`unsupported raster function json. _object_ref_id: ${d} does not exist`);const t=g.get(d);"_object_ref_id"!==N?y[N]=t:t&&"object"==typeof t&&Object.assign(y,t)}}}ks.set("Arithmetic",{desc:"Arithmetic Function",ctor:Te,rasterArgumentNames:["rasters"]}),ks.set("Aspect",{desc:"Aspect Function",ctor:Re,rasterArgumentNames:["raster"]}),ks.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:Me,rasterArgumentNames:["raster"]}),ks.set("Colormap",{desc:"Colormap Function",ctor:Ke,rasterArgumentNames:["raster"]}),ks.set("CompositeBand",{desc:"CompositeBand Function",ctor:tn,rasterArgumentNames:["rasters"]}),ks.set("ComputeChange",{desc:"ComputeChange Function",ctor:un,rasterArgumentNames:["rasters"]}),ks.set("Convolution",{desc:"Convolution Function",ctor:xn,rasterArgumentNames:["raster"]}),ks.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:dn,rasterArgumentNames:["raster"]}),ks.set("ExtractBand",{desc:"ExtractBand Function",ctor:kn,rasterArgumentNames:["raster"]}),ks.set("Curvature",{desc:"Curvature Function",ctor:Fn,rasterArgumentNames:["raster"]}),ks.set("Grayscale",{desc:"Grayscale Function",ctor:$n,rasterArgumentNames:["raster"]}),ks.set("Clip",{desc:"Clip Function",ctor:Ve,rasterArgumentNames:["raster"]}),ks.set("Local",{desc:"Local Function",ctor:En,rasterArgumentNames:["rasters"]}),ks.set("Mask",{desc:"Mask Function",ctor:Wn,rasterArgumentNames:["raster"]}),ks.set("NDVI",{desc:"NDVI Function",ctor:Jn,rasterArgumentNames:["raster"]}),ks.set("Remap",{desc:"Remap Function",ctor:es,rasterArgumentNames:["raster"]}),ks.set("Slope",{desc:"Slope Function",ctor:as,rasterArgumentNames:["raster"]}),ks.set("Statistics",{desc:"Focal Statistics Function",ctor:ds,rasterArgumentNames:["raster"]}),ks.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:vs,rasterArgumentNames:["raster"]}),ks.set("Stretch",{desc:"Stretch Function",ctor:Ps,rasterArgumentNames:["raster"]}),ks.set("Table",{desc:"Attribute Table Function",ctor:Cs,rasterArgumentNames:["raster"]});let _s=class extends y{get affectsPixelSize(){return!1}forwardTransform(t){return t}inverseTransform(t){return t}};t([d()],_s.prototype,"affectsPixelSize",null),t([d({json:{write:!0}})],_s.prototype,"spatialReference",void 0),_s=t([g("esri.layers.support.rasterTransforms.BaseRasterTransform")],_s);const Bs=_s;var js;let Ss=js=class extends Bs{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(t){return"point"===(t=t.clone()).type?(t.x>180+this.tolerance&&(t.x-=360),t):(t.xmin>=180-this.tolerance?(t.xmax-=360,t.xmin-=360):t.xmax>180+this.tolerance&&(t.xmin=-180,t.xmax=180),t)}inverseTransform(t){return"point"===(t=t.clone()).type?(t.x<-this.tolerance&&(t.x+=360),t):(t.xmin<-this.tolerance&&(t.xmin+=360,t.xmax+=360),t)}clone(){return new js({tolerance:this.tolerance})}};t([ut({GCSShiftXform:"gcs-shift"})],Ss.prototype,"type",void 0),t([d()],Ss.prototype,"tolerance",void 0),Ss=js=t([g("esri.layers.support.rasterTransforms.GCSShiftTransform")],Ss);const $s=Ss;var Ms;function a(t,d,g){const{x:y,y:N}=d;if(g<2)return{x:t[0]+y*t[2]+N*t[4],y:t[1]+y*t[3]+N*t[5]};if(2===g){const d=y*y,g=N*N,it=y*N;return{x:t[0]+y*t[2]+N*t[4]+d*t[6]+it*t[8]+g*t[10],y:t[1]+y*t[3]+N*t[5]+d*t[7]+it*t[9]+g*t[11]}}const it=y*y,ut=N*N,ct=y*N,dt=it*y,ft=it*N,yt=y*ut,vt=N*ut;return{x:t[0]+y*t[2]+N*t[4]+it*t[6]+ct*t[8]+ut*t[10]+dt*t[12]+ft*t[14]+yt*t[16]+vt*t[18],y:t[1]+y*t[3]+N*t[5]+it*t[7]+ct*t[9]+ut*t[11]+dt*t[13]+ft*t[15]+yt*t[17]+vt*t[19]}}function c5(t,d,g){const{xmin:y,ymin:N,xmax:it,ymax:ut,spatialReference:ct}=d;let dt=[];if(g<2)dt.push({x:y,y:ut}),dt.push({x:it,y:ut}),dt.push({x:y,y:N}),dt.push({x:it,y:N});else{let t=10;for(let d=0;d<t;d++)dt.push({x:y,y:N+(ut-N)*d/(t-1)}),dt.push({x:it,y:N+(ut-N)*d/(t-1)});t=8;for(let d=1;d<=t;d++)dt.push({x:y+(it-y)*d/t,y:N}),dt.push({x:y+(it-y)*d/t,y:ut})}dt=dt.map((d=>a(t,d,g)));const ft=dt.map((t=>t.x)),yt=dt.map((t=>t.y));return new Nt({xmin:Math.min.apply(null,ft),xmax:Math.max.apply(null,ft),ymin:Math.min.apply(null,yt),ymax:Math.max.apply(null,yt),spatialReference:ct})}let Ds=Ms=class extends Bs{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(t,d){const{coeffX:g,coeffY:y}=d;if(!(null==g?void 0:g.length)||!(null==y?void 0:y.length)||g.length!==y.length)return null;const N=[];for(let it=0;it<g.length;it++)N.push(g[it]),N.push(y[it]);return N}writeForwardCoefficients(t,d,g){const y=[],N=[];for(let it=0;it<(null==t?void 0:t.length);it++)it%2==0?y.push(t[it]):N.push(t[it]);d.coeffX=y,d.coeffY=N}get inverseCoefficients(){let t=this._get("inverseCoefficients");const d=this._get("forwardCoefficients");return!t&&d&&this.polynomialOrder<2&&(t=function m4(t){const[d,g,y,N,it,ut]=t,ct=y*ut-it*N,dt=it*N-y*ut;return[(it*g-d*ut)/ct,(y*g-d*N)/dt,ut/ct,N/dt,-it/ct,-y/dt]}(d)),t}set inverseCoefficients(t){this._set("inverseCoefficients",t)}readInverseCoefficients(t,d){const{inverseCoeffX:g,inverseCoeffY:y}=d;if(!(null==g?void 0:g.length)||!(null==y?void 0:y.length)||g.length!==y.length)return null;const N=[];for(let it=0;it<g.length;it++)N.push(g[it]),N.push(y[it]);return N}writeInverseCoefficients(t,d,g){const y=[],N=[];for(let it=0;it<(null==t?void 0:t.length);it++)it%2==0?y.push(t[it]):N.push(t[it]);d.inverseCoeffX=y,d.inverseCoeffY=N}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(t){if("point"===t.type){const d=a(this.forwardCoefficients,t,this.polynomialOrder);return new Ft({x:d.x,y:d.y,spatialReference:t.spatialReference})}return c5(this.forwardCoefficients,t,this.polynomialOrder)}inverseTransform(t){if("point"===t.type){const d=a(this.inverseCoefficients,t,this.polynomialOrder);return new Ft({x:d.x,y:d.y,spatialReference:t.spatialReference})}return c5(this.inverseCoefficients,t,this.polynomialOrder)}clone(){return new Ms({polynomialOrder:this.polynomialOrder,forwardCoefficients:this.forwardCoefficients?[...this.forwardCoefficients]:null,inverseCoefficients:this.inverseCoefficients?[...this.inverseCoefficients]:null})}};t([d({json:{write:!0}})],Ds.prototype,"polynomialOrder",void 0),t([d()],Ds.prototype,"forwardCoefficients",void 0),t([vt("forwardCoefficients",["coeffX","coeffY"])],Ds.prototype,"readForwardCoefficients",null),t([bt("forwardCoefficients")],Ds.prototype,"writeForwardCoefficients",null),t([d({json:{write:!0}})],Ds.prototype,"inverseCoefficients",null),t([vt("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],Ds.prototype,"readInverseCoefficients",null),t([bt("inverseCoefficients")],Ds.prototype,"writeInverseCoefficients",null),t([d()],Ds.prototype,"affectsPixelSize",null),t([ut({PolynomialXform:"polynomial"})],Ds.prototype,"type",void 0),Ds=Ms=t([g("esri.layers.support.rasterTransforms.PolynomialTransform")],Ds);const Os=Ds;export{R,S,Bs as a,$s as c,Os as y};
