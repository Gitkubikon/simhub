const __vite__fileDeps=["assets/lerc-wasm-B1SHZh7G.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{e as C,y as $,gH as L,a as z,bk as q,b as K,bn as J,n as X,av as Z,c as Q,b9 as tt,_ as et,fS as rt,hX as ot,et as nt,bj as it,aw as st,az as at,I as lt,c7 as ut,cL as ct,ti as ht,tj as ft,tk as dt,tl as pt,ak as mt,m as gt,b3 as yt,tm as wt}from"./index-DSIPxOWi.js";let vt=class l{constructor(C=null,$=null,L=null){this.minValue=C,this.maxValue=$,this.noDataValue=L}};const Ct=9999999e31,bt=2e-7,xt={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function s$7(C){return xt[C]??[-34028234663852886e22,34028234663852886e22]}function u$c(C,$){return null==C||null==$?"s32":C<0?C>=-128&&$<128?"s8":C>=-32768&&$<32768?"s16":"s32":$<256?"u8":$<65536?"u16":"u32"}function i$9(C){return((null==C?void 0:C.startsWith("s"))||(null==C?void 0:C.startsWith("u")))??!1}function l$6(C,$,L){var z,q;if(C.depthCount&&C.depthCount>1)return;const{pixels:K,statistics:J,pixelType:X}=C,Z=K[0].length,Q=C.bandMasks??[],tt=C.mask??new Uint8Array(Z).fill(255),et="f32"===X||"f64"===X,rt=s$7(X);let ot=!1;for(let nt=0;nt<K.length;nt++){const C="number"==typeof $?$:$[nt];if(null==C)continue;const Z=(null==(z=null==J?void 0:J[nt])?void 0:z.minValue)??rt[0],it=(null==(q=null==J?void 0:J[nt])?void 0:q.maxValue)??rt[1];if(Z>C+Number.EPSILON||it<C-Number.EPSILON)continue;const st=Q[nt]||tt.slice(),at=K[nt],lt=null==L?void 0:L.customFloatTolerance;if(et&&0!==lt){let $=lt;$||($=Math.abs(C)>=Ct?bt*Math.abs(C):"f32"===X?2**-23:Number.EPSILON);for(let L=0;L<at.length;L++)st[L]&&Math.abs(at[L]-C)<$&&(at[L]=0,st[L]=0,tt[L]=0,ot=!0)}else for(let $=0;$<at.length;$++)st[$]&&at[$]===C&&(at[$]=0,st[$]=0,tt[$]=0,ot=!0);Q[nt]=st}ot&&(C.bandMasks=C.bandMasks||C.pixels.length>1?Q:null,C.mask=tt),ot&&"updateStatistics"in C&&C.updateStatistics()}var kt;let At=kt=class extends q{static createEmptyBand(C,$){return new(kt.getPixelArrayConstructor(C))($)}static combineBandMasks(C){if(C.length<2)return C[0];const $=C[0].length,L=new Uint8Array($).fill(255);for(let z=0;z<C.length;z++){const q=C[z];for(let C=0;C<$;C++)q[C]||(L[C]=0)}return L}static getPixelArrayConstructor(C){let $;switch(C){case"u1":case"u2":case"u4":case"u8":$=Uint8Array;break;case"u16":$=Uint16Array;break;case"u32":$=Uint32Array;break;case"s8":$=Int8Array;break;case"s16":$=Int16Array;break;case"s32":$=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":$=Float32Array;break;case"f64":$=Float64Array}return $}constructor(C){super(C),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(C){if(!C)return"f32";let $=C.toLowerCase();return["u1","u2","u4"].includes($)?$="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes($)||($="f32"),$}getPlaneCount(){var C;return null==(C=this.pixels)?void 0:C.length}addData(C){if(!C.pixels||C.pixels.length!==this.width*this.height)throw new K("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(C.pixels),this.statistics.push(C.statistics??new vt)}getAsRGBA(){const C=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(C);break;default:this._fillFrom8Bit(C)}return new Uint8ClampedArray(C)}getAsRGBAFloat(){const C=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(C),C}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map((C=>function u$b(C,$){let L=1/0,z=-1/0;const q=C.length;let K,J=0;if(null!=$)for(K=0;K<q;K++)$[K]&&(J=C[K],L=J<L?J:L,z=J>z?J:z);else for(K=0;K<q;K++)J=C[K],L=J<L?J:L,z=J>z?J:z;return new vt(L,z)}(C,this.mask)));const C=this.mask;let $=0;if(null!=C)for(let L=0;L<C.length;L++)C[L]&&$++;else $=this.width*this.height;this.validPixelCount=$}clamp(C){if(!C||"f64"===C||"f32"===C||!this.pixels)return;const[$,L]=s$7(C),z=this.pixels,q=this.width*this.height,K=z.length;let J,X,Z;const Q=[];for(let tt=0;tt<K;tt++){Z=kt.createEmptyBand(C,q),J=z[tt];for(let C=0;C<q;C++)X=J[C],Z[C]=X>L?L:X<$?$:X;Q.push(Z)}this.pixels=Q,this.pixelType=C}extractBands(C){var $;const{pixels:L,statistics:z}=this;if(null==C||0===C.length||!L||0===L.length)return this;const q=L.length,K=C.some((C=>C>=L.length)),J=q===C.length&&!C.some(((C,$)=>C!==$));if(K||J)return this;const X=(null==($=this.bandMasks)?void 0:$.length)===q?C.map((C=>this.bandMasks[C])):void 0;let{mask:Z,validPixelCount:Q}=this;const{width:tt,height:et}=this;return(null==X?void 0:X.length)&&(Z=kt.combineBandMasks(X),Q=Z.filter((C=>!!C)).length),new kt({pixelType:this.pixelType,width:tt,height:et,mask:Z,bandMasks:X,validPixelCount:Q,maskIsAlpha:this.maskIsAlpha,pixels:C.map((C=>L[C])),statistics:z&&C.map((C=>z[C]))})}clone(){const C=new kt({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let $;null!=this.mask&&(C.mask=new Uint8Array(this.mask)),this.bandMasks&&(C.bandMasks=this.bandMasks.map((C=>new Uint8Array(C))));const L=kt.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){C.pixels=[];const z=!!this.pixels[0].slice;for($=0;$<this.pixels.length;$++)C.pixels[$]=z?this.pixels[$].slice(0,this.pixels[$].length):new L(this.pixels[$])}if(this.statistics)for(C.statistics=[],$=0;$<this.statistics.length;$++)C.statistics[$]=J(this.statistics[$]);return C.premultiplyAlpha=this.premultiplyAlpha,C}_fillFrom8Bit(C){const{mask:$,maskIsAlpha:L,premultiplyAlpha:z,pixels:q}=this;if(!C||!(null==q?void 0:q.length))return void X.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let K,J,Z,Q;K=J=Z=q[0],q.length>=3?(J=q[1],Z=q[2]):2===q.length&&(J=q[1]);const tt=new Uint32Array(C),et=this.width*this.height;if(K.length===et)if(null!=$&&$.length===et)if(L)for(Q=0;Q<et;Q++){const C=$[Q];if(C){const $=C/255;tt[Q]=z?C<<24|Z[Q]*$<<16|J[Q]*$<<8|K[Q]*$:C<<24|Z[Q]<<16|J[Q]<<8|K[Q]}}else for(Q=0;Q<et;Q++)$[Q]&&(tt[Q]=255<<24|Z[Q]<<16|J[Q]<<8|K[Q]);else for(Q=0;Q<et;Q++)tt[Q]=255<<24|Z[Q]<<16|J[Q]<<8|K[Q];else X.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(C){const{pixels:$,mask:L,statistics:z}=this;if(!C||!(null==$?void 0:$.length))return void X.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const q=this.pixelType;let K=1,J=0,Z=1;if(z&&z.length>0){for(const C of z)if(null!=C.minValue&&(J=Math.min(J,C.minValue)),null!=C.maxValue&&null!=C.minValue){const $=C.maxValue-C.minValue;Z=Math.max(Z,$)}K=255/Z}else{let C=255;"s8"===q?(J=-128,C=127):"u16"===q?C=65535:"s16"===q?(J=-32768,C=32767):"u32"===q?C=4294967295:"s32"===q?(J=-2147483648,C=2147483647):"f32"===q?(J=-34e38,C=34e38):"f64"===q&&(J=-Number.MAX_VALUE,C=Number.MAX_VALUE),K=255/(C-J)}const Q=new Uint32Array(C),tt=this.width*this.height;let et,rt,ot,nt,it;if(et=rt=ot=$[0],et.length!==tt)return X.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if($.length>=2)if(rt=$[1],$.length>=3&&(ot=$[2]),null!=L&&L.length===tt)for(nt=0;nt<tt;nt++)L[nt]&&(Q[nt]=255<<24|(ot[nt]-J)*K<<16|(rt[nt]-J)*K<<8|(et[nt]-J)*K);else for(nt=0;nt<tt;nt++)Q[nt]=255<<24|(ot[nt]-J)*K<<16|(rt[nt]-J)*K<<8|(et[nt]-J)*K;else if(null!=L&&L.length===tt)for(nt=0;nt<tt;nt++)it=(et[nt]-J)*K,L[nt]&&(Q[nt]=255<<24|it<<16|it<<8|it);else for(nt=0;nt<tt;nt++)it=(et[nt]-J)*K,Q[nt]=255<<24|it<<16|it<<8|it}_fillFrom32Bit(C){const{pixels:$,mask:L}=this;if(!C||!(null==$?void 0:$.length))return X.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let z,q,K,J;z=q=K=$[0],$.length>=3?(q=$[1],K=$[2]):2===$.length&&(q=$[1]);const Z=this.width*this.height;if(z.length!==Z)return X.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let Q=0;if(null!=L&&L.length===Z)for(J=0;J<Z;J++)C[Q++]=z[J],C[Q++]=q[J],C[Q++]=K[J],C[Q++]=1&L[J];else for(J=0;J<Z;J++)C[Q++]=z[J],C[Q++]=q[J],C[Q++]=K[J],C[Q++]=1}};C([$({json:{write:!0}})],At.prototype,"width",void 0),C([$({json:{write:!0}})],At.prototype,"height",void 0),C([$({json:{write:!0}})],At.prototype,"pixelType",void 0),C([L("pixelType")],At.prototype,"castPixelType",null),C([$({json:{write:!0}})],At.prototype,"validPixelCount",void 0),C([$({json:{write:!0}})],At.prototype,"mask",void 0),C([$({json:{write:!0}})],At.prototype,"maskIsAlpha",void 0),C([$({json:{write:!0}})],At.prototype,"pixels",void 0),C([$()],At.prototype,"premultiplyAlpha",void 0),C([$({json:{write:!0}})],At.prototype,"statistics",void 0),C([$({json:{write:!0}})],At.prototype,"depthCount",void 0),C([$({json:{write:!0}})],At.prototype,"noDataValues",void 0),C([$({json:{write:!0}})],At.prototype,"bandMasks",void 0),At=kt=C([z("esri.layers.support.PixelBlock")],At);const St=At;var Tt,It,$t,Mt={exports:{}};It=Mt,void 0!==(Tt=function(){function t2(){this.pos=0,this.bufferLength=0,this.eof=!1,this.buffer=null}return t2.prototype={ensureBuffer:function(C){var $=this.buffer,L=$?$.byteLength:0;if(C<L)return $;for(var z=512;z<C;)z<<=1;for(var q=new Uint8Array(z),K=0;K<L;++K)q[K]=$[K];return this.buffer=q},getByte:function(){for(var C=this.pos;this.bufferLength<=C;){if(this.eof)return null;this.readBlock()}return this.buffer[this.pos++]},getBytes:function(C){var $=this.pos;if(C){this.ensureBuffer($+C);for(var L=$+C;!this.eof&&this.bufferLength<L;)this.readBlock();var z=this.bufferLength;L>z&&(L=z)}else{for(;!this.eof;)this.readBlock();L=this.bufferLength}return this.pos=L,this.buffer.subarray($,L)},lookChar:function(){for(var C=this.pos;this.bufferLength<=C;){if(this.eof)return null;this.readBlock()}return String.fromCharCode(this.buffer[this.pos])},getChar:function(){for(var C=this.pos;this.bufferLength<=C;){if(this.eof)return null;this.readBlock()}return String.fromCharCode(this.buffer[this.pos++])},makeSubStream:function(C,$,L){for(var z=C+$;this.bufferLength<=z&&!this.eof;)this.readBlock();return new Stream(this.buffer,C,$,L)},skip:function(C){C||(C=1),this.pos+=C},reset:function(){this.pos=0}},t2}(),$t=function(){if(!self||!self.Uint32Array)return null;var C=new Uint32Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),$=new Uint32Array([3,4,5,6,7,8,9,10,65547,65549,65551,65553,131091,131095,131099,131103,196643,196651,196659,196667,262211,262227,262243,262259,327811,327843,327875,327907,258,258,258]),L=new Uint32Array([1,2,3,4,65541,65543,131081,131085,196625,196633,262177,262193,327745,327777,393345,393409,459009,459137,524801,525057,590849,591361,657409,658433,724993,727041,794625,798721,868353,876545]),z=[new Uint32Array([459008,524368,524304,524568,459024,524400,524336,590016,459016,524384,524320,589984,524288,524416,524352,590048,459012,524376,524312,589968,459028,524408,524344,590032,459020,524392,524328,59e4,524296,524424,524360,590064,459010,524372,524308,524572,459026,524404,524340,590024,459018,524388,524324,589992,524292,524420,524356,590056,459014,524380,524316,589976,459030,524412,524348,590040,459022,524396,524332,590008,524300,524428,524364,590072,459009,524370,524306,524570,459025,524402,524338,590020,459017,524386,524322,589988,524290,524418,524354,590052,459013,524378,524314,589972,459029,524410,524346,590036,459021,524394,524330,590004,524298,524426,524362,590068,459011,524374,524310,524574,459027,524406,524342,590028,459019,524390,524326,589996,524294,524422,524358,590060,459015,524382,524318,589980,459031,524414,524350,590044,459023,524398,524334,590012,524302,524430,524366,590076,459008,524369,524305,524569,459024,524401,524337,590018,459016,524385,524321,589986,524289,524417,524353,590050,459012,524377,524313,589970,459028,524409,524345,590034,459020,524393,524329,590002,524297,524425,524361,590066,459010,524373,524309,524573,459026,524405,524341,590026,459018,524389,524325,589994,524293,524421,524357,590058,459014,524381,524317,589978,459030,524413,524349,590042,459022,524397,524333,590010,524301,524429,524365,590074,459009,524371,524307,524571,459025,524403,524339,590022,459017,524387,524323,589990,524291,524419,524355,590054,459013,524379,524315,589974,459029,524411,524347,590038,459021,524395,524331,590006,524299,524427,524363,590070,459011,524375,524311,524575,459027,524407,524343,590030,459019,524391,524327,589998,524295,524423,524359,590062,459015,524383,524319,589982,459031,524415,524351,590046,459023,524399,524335,590014,524303,524431,524367,590078,459008,524368,524304,524568,459024,524400,524336,590017,459016,524384,524320,589985,524288,524416,524352,590049,459012,524376,524312,589969,459028,524408,524344,590033,459020,524392,524328,590001,524296,524424,524360,590065,459010,524372,524308,524572,459026,524404,524340,590025,459018,524388,524324,589993,524292,524420,524356,590057,459014,524380,524316,589977,459030,524412,524348,590041,459022,524396,524332,590009,524300,524428,524364,590073,459009,524370,524306,524570,459025,524402,524338,590021,459017,524386,524322,589989,524290,524418,524354,590053,459013,524378,524314,589973,459029,524410,524346,590037,459021,524394,524330,590005,524298,524426,524362,590069,459011,524374,524310,524574,459027,524406,524342,590029,459019,524390,524326,589997,524294,524422,524358,590061,459015,524382,524318,589981,459031,524414,524350,590045,459023,524398,524334,590013,524302,524430,524366,590077,459008,524369,524305,524569,459024,524401,524337,590019,459016,524385,524321,589987,524289,524417,524353,590051,459012,524377,524313,589971,459028,524409,524345,590035,459020,524393,524329,590003,524297,524425,524361,590067,459010,524373,524309,524573,459026,524405,524341,590027,459018,524389,524325,589995,524293,524421,524357,590059,459014,524381,524317,589979,459030,524413,524349,590043,459022,524397,524333,590011,524301,524429,524365,590075,459009,524371,524307,524571,459025,524403,524339,590023,459017,524387,524323,589991,524291,524419,524355,590055,459013,524379,524315,589975,459029,524411,524347,590039,459021,524395,524331,590007,524299,524427,524363,590071,459011,524375,524311,524575,459027,524407,524343,590031,459019,524391,524327,589999,524295,524423,524359,590063,459015,524383,524319,589983,459031,524415,524351,590047,459023,524399,524335,590015,524303,524431,524367,590079]),9],q=[new Uint32Array([327680,327696,327688,327704,327684,327700,327692,327708,327682,327698,327690,327706,327686,327702,327694,0,327681,327697,327689,327705,327685,327701,327693,327709,327683,327699,327691,327707,327687,327703,327695,0]),5];function o2(C){throw new Error(C)}function n2(C){var $=0,L=C[$++],z=C[$++];-1!=L&&-1!=z||o2("Invalid header in flate stream"),8!=(15&L)&&o2("Unknown compression method in flate stream"),((L<<8)+z)%31!=0&&o2("Bad FCHECK in flate stream"),32&z&&o2("FDICT bit set in flate stream"),this.bytes=C,this.bytesPos=2,this.codeSize=0,this.codeBuf=0,Tt.call(this)}return n2.prototype=Object.create(Tt.prototype),n2.prototype.getBits=function(C){for(var $,L=this.codeSize,z=this.codeBuf,q=this.bytes,K=this.bytesPos;L<C;)void 0===($=q[K++])&&o2("Bad encoding in flate stream"),z|=$<<L,L+=8;return $=z&(1<<C)-1,this.codeBuf=z>>C,this.codeSize=L-=C,this.bytesPos=K,$},n2.prototype.getCode=function(C){for(var $=C[0],L=C[1],z=this.codeSize,q=this.codeBuf,K=this.bytes,J=this.bytesPos;z<L;){var X;void 0===(X=K[J++])&&o2("Bad encoding in flate stream"),q|=X<<z,z+=8}var Z=$[q&(1<<L)-1],Q=Z>>16,tt=65535&Z;return(0==z||z<Q||0==Q)&&o2("Bad encoding in flate stream"),this.codeBuf=q>>Q,this.codeSize=z-Q,this.bytesPos=J,tt},n2.prototype.generateHuffmanTable=function(C){for(var $=C.length,L=0,z=0;z<$;++z)C[z]>L&&(L=C[z]);for(var q=1<<L,K=new Uint32Array(q),J=1,X=0,Z=2;J<=L;++J,X<<=1,Z<<=1)for(var Q=0;Q<$;++Q)if(C[Q]==J){var tt=0,et=X;for(z=0;z<J;++z)tt=tt<<1|1&et,et>>=1;for(z=tt;z<q;z+=Z)K[z]=J<<16|Q;++X}return[K,L]},n2.prototype.readBlock=function(){function e2(C,$,L,z,q){for(var K=C.getBits(L)+z;K-- >0;)$[rt++]=q}var K=this.getBits(3);if(1&K&&(this.eof=!0),0!=(K>>=1)){var J,X;if(1==K)J=z,X=q;else if(2==K){for(var Z=this.getBits(5)+257,Q=this.getBits(5)+1,tt=this.getBits(4)+4,et=Array(C.length),rt=0;rt<tt;)et[C[rt++]]=this.getBits(3);for(var ot=this.generateHuffmanTable(et),nt=0,it=(rt=0,Z+Q),st=new Array(it);rt<it;){var at=this.getCode(ot);16==at?e2(this,st,2,3,nt):17==at?e2(this,st,3,3,nt=0):18==at?e2(this,st,7,11,nt=0):st[rt++]=nt=at}J=this.generateHuffmanTable(st.slice(0,Z)),X=this.generateHuffmanTable(st.slice(Z,it))}else o2("Unknown block type in flate stream");for(var lt=(Ct=this.buffer)?Ct.length:0,ut=this.bufferLength;;){var ct=this.getCode(J);if(ct<256)ut+1>=lt&&(lt=(Ct=this.ensureBuffer(ut+1)).length),Ct[ut++]=ct;else{if(256==ct)return void(this.bufferLength=ut);var ht=(ct=$[ct-=257])>>16;ht>0&&(ht=this.getBits(ht)),nt=(65535&ct)+ht,ct=this.getCode(X),(ht=(ct=L[ct])>>16)>0&&(ht=this.getBits(ht));var ft=(65535&ct)+ht;ut+nt>=lt&&(lt=(Ct=this.ensureBuffer(ut+nt)).length);for(var dt=0;dt<nt;++dt,++ut)Ct[ut]=Ct[ut-ft]}}}else{var pt,mt=this.bytes,gt=this.bytesPos;void 0===(pt=mt[gt++])&&o2("Bad block header in flate stream");var yt=pt;void 0===(pt=mt[gt++])&&o2("Bad block header in flate stream"),yt|=pt<<8,void 0===(pt=mt[gt++])&&o2("Bad block header in flate stream");var wt=pt;void 0===(pt=mt[gt++])&&o2("Bad block header in flate stream"),(wt|=pt<<8)!=(65535&~yt)&&o2("Bad uncompressed block length in flate stream"),this.codeBuf=0,this.codeSize=0;var vt=this.bufferLength,Ct=this.ensureBuffer(vt+yt),bt=vt+yt;this.bufferLength=bt;for(var xt=vt;xt<bt;++xt){if(void 0===(pt=mt[gt++])){this.eof=!0;break}Ct[xt]=pt}this.bytesPos=gt}},n2}())&&(It.exports=$t);const Pt=Z(Mt.exports);let Et=class i{constructor(C){this._canvas=null,this._ctx=null,C&&(this._canvas=C.canvas,this._ctx=C.ctx||C.canvas&&C.canvas.getContext("2d"))}decode(C,$,L){if(!C||C.byteLength<10)throw new K("imagecanvasdecoder: decode","required a valid encoded data as input.");let{width:z=0,height:q=0,format:J}=$;const{applyJpegMask:X}=$;if(X&&(!z||!q))throw new K("imagecanvasdecoder: decode","image width and height are needed to apply jpeg mask directly to canvas");return new Promise(((K,Z)=>{let et=null;"jpg"===J&&X&&(et=i._getMask(C,{width:z,height:q}));const rt=new Blob([new Uint8Array(C)],{type:"image/"+J=="jpg"?"jpeg":J}),ot=URL.createObjectURL(rt),nt=new Image;let it;nt.src=ot,nt.onload=()=>{if(URL.revokeObjectURL(ot),Q(L))return void Z(tt());z=nt.width,q=nt.height,this._canvas&&this._ctx?(this._canvas.width===z&&this._canvas.height===q||(this._canvas.width=z,this._canvas.height=q),this._ctx.clearRect(0,0,z,q)):(this._canvas=document.createElement("canvas"),this._canvas.width=z,this._canvas.height=q,this._ctx=this._canvas.getContext("2d")),this._ctx.drawImage(nt,0,0);const C=this._ctx.getImageData(0,0,z,q);let J;if(it=C.data,$.renderOnCanvas){if(et)for(J=0;J<et.length;J++)et[J]?it[4*J+3]=255:it[4*J+3]=0;return this._ctx.putImageData(C,0,0),void K(null)}const X=z*q,rt=new Uint8Array(X),st=new Uint8Array(X),at=new Uint8Array(X);if(et)for(J=0;J<X;J++)rt[J]=it[4*J],st[J]=it[4*J+1],at[J]=it[4*J+2];else for(et=new Uint8Array(X),J=0;J<X;J++)rt[J]=it[4*J],st[J]=it[4*J+1],at[J]=it[4*J+2],et[J]=it[4*J+3];K({width:z,height:q,pixels:[rt,st,at],mask:et,pixelType:"u8"})},nt.onerror=()=>{URL.revokeObjectURL(ot),Z("cannot load image")}}))}static _getMask(C,$){let L=null;try{const z=new Uint8Array(C),q=Math.ceil(z.length/2);let K=0;const J=z.length-2;for(K=q;K<J&&(255!==z[K]||217!==z[K+1]);K++);if(K+=2,K<z.length-1){const C=new Pt(z.subarray(K)).getBytes();L=new Uint8Array($.width*$.height);let q=0;for(let $=0;$<C.length;$++)for(let z=7;z>=0;z--)L[q++]=C[$]>>z&1}}catch(z){}return L}};var Rt,Lt,Ut,Dt={exports:{}};Rt=Dt,Lt=function(){var C=function(){function e3(C){this.message="JPEG error: "+C}return e3.prototype=new Error,e3.prototype.name="JpegError",e3.constructor=e3,e3}();return function(){if(!self||!self.Uint8ClampedArray)return null;var $=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),L=4017,z=799,q=3406,K=2276,J=1567,X=3784,Z=5793,Q=2896;function l3(){this.decodeTransform=null,this.colorTransform=-1}function u2(C,$){for(var L,z,q=0,K=[],J=16;J>0&&!C[J-1];)J--;K.push({children:[],index:0});var X,Z=K[0];for(L=0;L<J;L++){for(z=0;z<C[L];z++){for((Z=K.pop()).children[Z.index]=$[q];Z.index>0;)Z=K.pop();for(Z.index++,K.push(Z);K.length<=L;)K.push(X={children:[],index:0}),Z.children[Z.index]=X.children,Z=X;q++}L+1<J&&(K.push(X={children:[],index:0}),Z.children[Z.index]=X.children,Z=X)}return K[0].children}function h2(C,$,L){return 64*((C.blocksPerLine+1)*$+L)}function v2(L,z,q,K,J,X,Z,Q,tt){var et=q.mcusPerLine,rt=q.progressive,ot=z,nt=0,it=0;function k2(){if(it>0)return it--,nt>>it&1;if(255===(nt=L[z++])){var $=L[z++];if($)throw new C("unexpected marker "+(nt<<8|$).toString(16))}return it=7,nt>>>7}function g2($){for(var L=$;;){if("number"==typeof(L=L[k2()]))return L;if("object"!=typeof L)throw new C("invalid huffman sequence")}}function C2(C){for(var $=0;C>0;)$=$<<1|k2(),C--;return $}function w2(C){if(1===C)return 1===k2()?1:-1;var $=C2(C);return $>=1<<C-1?$:$+(-1<<C)+1}var st=0;var at,lt=0;function U2(C,$,L,z,q){var K=L%et;$(C,h2(C,(L/et|0)*C.v+z,K*C.h+q))}var ut,ct,ht,ft,dt,pt,mt=K.length;pt=rt?0===X?0===Q?function y2(C,$){var L=g2(C.huffmanTableDC),z=0===L?0:w2(L)<<tt;C.blockData[$]=C.pred+=z}:function D2(C,$){C.blockData[$]|=k2()<<tt}:0===Q?function P2(C,L){if(st>0)st--;else for(var z=X,q=Z;z<=q;){var K=g2(C.huffmanTableAC),J=15&K,Q=K>>4;if(0!==J){var et=$[z+=Q];C.blockData[L+et]=w2(J)*(1<<tt),z++}else{if(Q<15){st=C2(Q)+(1<<Q)-1;break}z+=16}}}:function _2(L,z){for(var q,K,J=X,Q=Z,et=0;J<=Q;){var rt=$[J];switch(lt){case 0:if(et=(K=g2(L.huffmanTableAC))>>4,0==(q=15&K))et<15?(st=C2(et)+(1<<et),lt=4):(et=16,lt=1);else{if(1!==q)throw new C("invalid ACn encoding");at=w2(q),lt=et?2:3}continue;case 1:case 2:L.blockData[z+rt]?L.blockData[z+rt]+=k2()<<tt:0==--et&&(lt=2===lt?3:0);break;case 3:L.blockData[z+rt]?L.blockData[z+rt]+=k2()<<tt:(L.blockData[z+rt]=at<<tt,lt=0);break;case 4:L.blockData[z+rt]&&(L.blockData[z+rt]+=k2()<<tt)}J++}4===lt&&0==--st&&(lt=0)}:function x2(C,L){var z=g2(C.huffmanTableDC),q=0===z?0:w2(z);C.blockData[L]=C.pred+=q;for(var K=1;K<64;){var J=g2(C.huffmanTableAC),X=15&J,Z=J>>4;if(0!==X){var Q=$[K+=Z];C.blockData[L+Q]=w2(X),K++}else{if(Z<15)break;K+=16}}};var gt,yt,wt,vt,Ct,bt,xt=0;for(yt=1===mt?K[0].blocksPerLine*K[0].blocksPerColumn:et*q.mcusPerColumn;xt<yt;){var kt=J?Math.min(yt-xt,J):yt;for(ct=0;ct<mt;ct++)K[ct].pred=0;if(st=0,1===mt)for(ut=K[0],dt=0;dt<kt;dt++)pt(Ct=ut,h2(Ct,(bt=xt)/Ct.blocksPerLine|0,bt%Ct.blocksPerLine)),xt++;else for(dt=0;dt<kt;dt++){for(ct=0;ct<mt;ct++)for(wt=(ut=K[ct]).h,vt=ut.v,ht=0;ht<vt;ht++)for(ft=0;ft<wt;ft++)U2(ut,pt,xt,ht,ft);xt++}it=0,(gt=p2(L,z))&&gt.invalid&&(z=gt.offset);var At=gt&&gt.marker;if(!At||At<=65280)throw new C("marker was not found");if(!(At>=65488&&At<=65495))break;z+=2}return(gt=p2(L,z))&&gt.invalid&&(z=gt.offset),z-ot}function m2($,tt,et){var rt,ot,nt,it,st,at,lt,ut,ct,ht,ft,dt,pt,mt,gt,yt,wt,vt=$.quantizationTable,Ct=$.blockData;if(!vt)throw new C("missing required Quantization Table.");for(var bt=0;bt<64;bt+=8)ct=Ct[tt+bt],ht=Ct[tt+bt+1],ft=Ct[tt+bt+2],dt=Ct[tt+bt+3],pt=Ct[tt+bt+4],mt=Ct[tt+bt+5],gt=Ct[tt+bt+6],yt=Ct[tt+bt+7],ct*=vt[bt],ht|ft|dt|pt|mt|gt|yt?(ht*=vt[bt+1],ft*=vt[bt+2],dt*=vt[bt+3],pt*=vt[bt+4],mt*=vt[bt+5],gt*=vt[bt+6],yt*=vt[bt+7],ot=(rt=(rt=Z*ct+128>>8)+(ot=Z*pt+128>>8)+1>>1)-ot,wt=(nt=ft)*X+(it=gt)*J+128>>8,nt=nt*J-it*X+128>>8,lt=(st=(st=Q*(ht-yt)+128>>8)+(lt=mt<<4)+1>>1)-lt,at=(ut=(ut=Q*(ht+yt)+128>>8)+(at=dt<<4)+1>>1)-at,it=(rt=rt+(it=wt)+1>>1)-it,nt=(ot=ot+nt+1>>1)-nt,wt=st*K+ut*q+2048>>12,st=st*q-ut*K+2048>>12,ut=wt,wt=at*z+lt*L+2048>>12,at=at*L-lt*z+2048>>12,lt=wt,et[bt]=rt+ut,et[bt+7]=rt-ut,et[bt+1]=ot+lt,et[bt+6]=ot-lt,et[bt+2]=nt+at,et[bt+5]=nt-at,et[bt+3]=it+st,et[bt+4]=it-st):(wt=Z*ct+512>>10,et[bt]=wt,et[bt+1]=wt,et[bt+2]=wt,et[bt+3]=wt,et[bt+4]=wt,et[bt+5]=wt,et[bt+6]=wt,et[bt+7]=wt);for(var xt=0;xt<8;++xt)ct=et[xt],(ht=et[xt+8])|(ft=et[xt+16])|(dt=et[xt+24])|(pt=et[xt+32])|(mt=et[xt+40])|(gt=et[xt+48])|(yt=et[xt+56])?(ot=(rt=4112+((rt=Z*ct+2048>>12)+(ot=Z*pt+2048>>12)+1>>1))-ot,wt=(nt=ft)*X+(it=gt)*J+2048>>12,nt=nt*J-it*X+2048>>12,it=wt,lt=(st=(st=Q*(ht-yt)+2048>>12)+(lt=mt)+1>>1)-lt,at=(ut=(ut=Q*(ht+yt)+2048>>12)+(at=dt)+1>>1)-at,wt=st*K+ut*q+2048>>12,st=st*q-ut*K+2048>>12,ut=wt,wt=at*z+lt*L+2048>>12,at=at*L-lt*z+2048>>12,ct=(ct=(rt=rt+it+1>>1)+ut)<16?0:ct>=4080?255:ct>>4,ht=(ht=(ot=ot+nt+1>>1)+(lt=wt))<16?0:ht>=4080?255:ht>>4,ft=(ft=(nt=ot-nt)+at)<16?0:ft>=4080?255:ft>>4,dt=(dt=(it=rt-it)+st)<16?0:dt>=4080?255:dt>>4,pt=(pt=it-st)<16?0:pt>=4080?255:pt>>4,mt=(mt=nt-at)<16?0:mt>=4080?255:mt>>4,gt=(gt=ot-lt)<16?0:gt>=4080?255:gt>>4,yt=(yt=rt-ut)<16?0:yt>=4080?255:yt>>4,Ct[tt+xt]=ct,Ct[tt+xt+8]=ht,Ct[tt+xt+16]=ft,Ct[tt+xt+24]=dt,Ct[tt+xt+32]=pt,Ct[tt+xt+40]=mt,Ct[tt+xt+48]=gt,Ct[tt+xt+56]=yt):(wt=(wt=Z*ct+8192>>14)<-2040?0:wt>=2024?255:wt+2056>>4,Ct[tt+xt]=wt,Ct[tt+xt+8]=wt,Ct[tt+xt+16]=wt,Ct[tt+xt+24]=wt,Ct[tt+xt+32]=wt,Ct[tt+xt+40]=wt,Ct[tt+xt+48]=wt,Ct[tt+xt+56]=wt)}function d2(C,$){for(var L=$.blocksPerLine,z=$.blocksPerColumn,q=new Int16Array(64),K=0;K<z;K++)for(var J=0;J<L;J++)m2($,h2($,K,J),q);return $.blockData}function p2(C,$,L){function o3($){return C[$]<<8|C[$+1]}var z=C.length-1,q=L<$?L:$;if($>=z)return null;var K=o3($);if(K>=65472&&K<=65534)return{invalid:null,marker:K,offset:$};for(var J=o3(q);!(J>=65472&&J<=65534);){if(++q>=z)return null;J=o3(q)}return{invalid:K.toString(16),marker:J,offset:q}}return l3.prototype={parse:function(L){function o3(){var C=L[K]<<8|L[K+1];return K+=2,C}function a4(){var C=o3(),$=K+C-2,z=p2(L,$,K);z&&z.invalid&&($=z.offset);var q=L.subarray(K,$);return K+=q.length,q}function t3(C){for(var $=Math.ceil(C.samplesPerLine/8/C.maxH),L=Math.ceil(C.scanLines/8/C.maxV),z=0;z<C.components.length;z++){bt=C.components[z];var q=Math.ceil(Math.ceil(C.samplesPerLine/8)*bt.h/C.maxH),K=Math.ceil(Math.ceil(C.scanLines/8)*bt.v/C.maxV),J=$*bt.h,X=L*bt.v*64*(J+1);bt.blockData=new Int16Array(X),bt.blocksPerLine=q,bt.blocksPerColumn=K}C.mcusPerLine=$,C.mcusPerColumn=L}var z,q,K=0,J=null,X=null,Z=[],Q=[],tt=[],et=o3();if(65496!==et)throw new C("SOI not found");for(et=o3();65497!==et;){var rt,ot,nt;switch(et){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var it=a4();65504===et&&74===it[0]&&70===it[1]&&73===it[2]&&70===it[3]&&0===it[4]&&(J={version:{major:it[5],minor:it[6]},densityUnits:it[7],xDensity:it[8]<<8|it[9],yDensity:it[10]<<8|it[11],thumbWidth:it[12],thumbHeight:it[13],thumbData:it.subarray(14,14+3*it[12]*it[13])}),65518===et&&65===it[0]&&100===it[1]&&111===it[2]&&98===it[3]&&101===it[4]&&(X={version:it[5]<<8|it[6],flags0:it[7]<<8|it[8],flags1:it[9]<<8|it[10],transformCode:it[11]});break;case 65499:for(var st=o3()+K-2;K<st;){var at=L[K++],lt=new Uint16Array(64);if(at>>4){if(at>>4!=1)throw new C("DQT - invalid table spec");for(ot=0;ot<64;ot++)lt[$[ot]]=o3()}else for(ot=0;ot<64;ot++)lt[$[ot]]=L[K++];Z[15&at]=lt}break;case 65472:case 65473:case 65474:if(z)throw new C("Only single frame JPEGs supported");o3(),(z={}).extended=65473===et,z.progressive=65474===et,z.precision=L[K++],z.scanLines=o3(),z.samplesPerLine=o3(),z.components=[],z.componentIds={};var ut,ct=L[K++],ht=0,ft=0;for(rt=0;rt<ct;rt++){ut=L[K];var dt=L[K+1]>>4,pt=15&L[K+1];ht<dt&&(ht=dt),ft<pt&&(ft=pt);var mt=L[K+2];nt=z.components.push({h:dt,v:pt,quantizationId:mt,quantizationTable:null}),z.componentIds[ut]=nt-1,K+=3}z.maxH=ht,z.maxV=ft,t3(z);break;case 65476:var gt=o3();for(rt=2;rt<gt;){var yt=L[K++],wt=new Uint8Array(16),vt=0;for(ot=0;ot<16;ot++,K++)vt+=wt[ot]=L[K];var Ct=new Uint8Array(vt);for(ot=0;ot<vt;ot++,K++)Ct[ot]=L[K];rt+=17+vt,(yt>>4?Q:tt)[15&yt]=u2(wt,Ct)}break;case 65501:o3(),q=o3();break;case 65498:o3();var bt,xt=L[K++],kt=[];for(rt=0;rt<xt;rt++){var At=z.componentIds[L[K++]];bt=z.components[At];var St=L[K++];bt.huffmanTableDC=tt[St>>4],bt.huffmanTableAC=Q[15&St],kt.push(bt)}var Tt=L[K++],It=L[K++],$t=L[K++],Mt=v2(L,K,z,kt,q,Tt,It,$t>>4,15&$t);K+=Mt;break;case 65535:255!==L[K]&&K--;break;default:if(255===L[K-3]&&L[K-2]>=192&&L[K-2]<=254){K-=3;break}throw new C("unknown marker "+et.toString(16))}et=o3()}for(this.width=z.samplesPerLine,this.height=z.scanLines,this.jfif=J,this.eof=K,this.adobe=X,this.components=[],rt=0;rt<z.components.length;rt++){var Pt=Z[(bt=z.components[rt]).quantizationId];Pt&&(bt.quantizationTable=Pt),this.components.push({output:d2(0,bt),scaleX:bt.h/z.maxH,scaleY:bt.v/z.maxV,blocksPerLine:bt.blocksPerLine,blocksPerColumn:bt.blocksPerColumn})}this.numComponents=this.components.length},_getLinearizedBlockData:function(C,$){var L,z,q,K,J,X,Z,Q,tt,et,rt,ot=this.width/C,nt=this.height/$,it=0,st=this.components.length,at=C*$*st,lt=new Uint8ClampedArray(at),ut=new Uint32Array(C),ct=4294967288;for(Z=0;Z<st;Z++){for(z=(L=this.components[Z]).scaleX*ot,q=L.scaleY*nt,it=Z,rt=L.output,K=L.blocksPerLine+1<<3,J=0;J<C;J++)Q=0|J*z,ut[J]=(Q&ct)<<3|7&Q;for(X=0;X<$;X++)for(et=K*((Q=0|X*q)&ct)|(7&Q)<<3,J=0;J<C;J++)lt[it]=rt[et+ut[J]],it+=st}var ht=this.decodeTransform;if(ht)for(Z=0;Z<at;)for(Q=0,tt=0;Q<st;Q++,Z++,tt+=2)lt[Z]=(lt[Z]*ht[tt]>>8)+ht[tt+1];return lt},_isColorConversionNeeded:function(){return this.adobe?!!this.adobe.transformCode:3===this.numComponents?0!==this.colorTransform:1===this.colorTransform},_convertYccToRgb:function(C){for(var $,L,z,q=0,K=C.length;q<K;q+=3)$=C[q],L=C[q+1],z=C[q+2],C[q]=$-179.456+1.402*z,C[q+1]=$+135.459-.344*L-.714*z,C[q+2]=$-226.816+1.772*L;return C},_convertYcckToRgb:function(C){for(var $,L,z,q,K=0,J=0,X=C.length;J<X;J+=4)$=C[J],L=C[J+1],z=C[J+2],q=C[J+3],C[K++]=L*(-660635669420364e-19*L+.000437130475926232*z-54080610064599e-18*$+.00048449797120281*q-.154362151871126)-122.67195406894+z*(-.000957964378445773*z+.000817076911346625*$-.00477271405408747*q+1.53380253221734)+$*(.000961250184130688*$-.00266257332283933*q+.48357088451265)+q*(-.000336197177618394*q+.484791561490776),C[K++]=107.268039397724+L*(219927104525741e-19*L-.000640992018297945*z+.000659397001245577*$+.000426105652938837*q-.176491792462875)+z*(-.000778269941513683*z+.00130872261408275*$+.000770482631801132*q-.151051492775562)+$*(.00126935368114843*$-.00265090189010898*q+.25802910206845)+q*(-.000318913117588328*q-.213742400323665),C[K++]=L*(-.000570115196973677*L-263409051004589e-19*z+.0020741088115012*$-.00288260236853442*q+.814272968359295)-20.810012546947+z*(-153496057440975e-19*z-.000132689043961446*$+.000560833691242812*q-.195152027534049)+$*(.00174418132927582*$-.00255243321439347*q+.116935020465145)+q*(-.000343531996510555*q+.24165260232407);return C},_convertYcckToCmyk:function(C){for(var $,L,z,q=0,K=C.length;q<K;q+=4)$=C[q],L=C[q+1],z=C[q+2],C[q]=434.456-$-1.402*z,C[q+1]=119.541-$+.344*L+.714*z,C[q+2]=481.816-$-1.772*L;return C},_convertCmykToRgb:function(C){for(var $,L,z,q,K=0,J=1/255,X=0,Z=C.length;X<Z;X+=4)$=C[X]*J,L=C[X+1]*J,z=C[X+2]*J,q=C[X+3]*J,C[K++]=255+$*(-4.387332384609988*$+54.48615194189176*L+18.82290502165302*z+212.25662451639585*q-285.2331026137004)+L*(1.7149763477362134*L-5.6096736904047315*z-17.873870861415444*q-5.497006427196366)+z*(-2.5217340131683033*z-21.248923337353073*q+17.5119270841813)-q*(21.86122147463605*q+189.48180835922747),C[K++]=255+$*(8.841041422036149*$+60.118027045597366*L+6.871425592049007*z+31.159100130055922*q-79.2970844816548)+L*(-15.310361306967817*L+17.575251261109482*z+131.35250912493976*q-190.9453302588951)+z*(4.444339102852739*z+9.8632861493405*q-24.86741582555878)-q*(20.737325471181034*q+187.80453709719578),C[K++]=255+$*(.8842522430003296*$+8.078677503112928*L+30.89978309703729*z-.23883238689178934*q-14.183576799673286)+L*(10.49593273432072*L+63.02378494754052*z+50.606957656360734*q-112.23884253719248)+z*(.03296041114873217*z+115.60384449646641*q-193.58209356861505)-q*(22.33816807309886*q+180.12613974708367);return C},getData:function($,L,z){if(this.numComponents>4)throw new C("Unsupported color mode");var q=this._getLinearizedBlockData($,L);if(1===this.numComponents&&z){for(var K=q.length,J=new Uint8ClampedArray(3*K),X=0,Z=0;Z<K;Z++){var Q=q[Z];J[X++]=Q,J[X++]=Q,J[X++]=Q}return J}if(3===this.numComponents&&this._isColorConversionNeeded())return this._convertYccToRgb(q);if(4===this.numComponents){if(this._isColorConversionNeeded())return z?this._convertYcckToRgb(q):this._convertYcckToCmyk(q);if(z)return this._convertCmykToRgb(q)}return q}},l3}()},void 0!==(Ut=Lt())&&(Rt.exports=Ut);const Ot=Z(Dt.exports);let Gt=class r{static decode(C,$=!1){const L=new Uint8Array(C),z=new Ot;z.parse(L);const{width:q,height:K,numComponents:J,eof:X}=z,Z=z.getData(q,K,!0),Q=q*K;let tt,et=null,rt=0,ot=0,nt=0;if(!$&&X<L.length-1)try{const C=new Pt(L.subarray(X)).getBytes();et=new Uint8Array(Q);let $=0;for(rt=0;rt<C.length;rt++)for(nt=7;nt>=0;nt--)et[$++]=C[rt]>>nt&1}catch{}if(1===J&&Z.length===q*K){const C=new Uint8Array(Z.buffer);tt=[C,C,C]}else{for(tt=[],rt=0;rt<3;rt++)tt.push(new Uint8Array(Q));for(nt=0,ot=0;ot<Q;ot++)for(rt=0;rt<3;rt++)tt[rt][ot]=Z[nt++]}return{width:q,height:K,pixels:tt,mask:et}}};const Bt=[{pixelType:"S8",size:1,ctor:Int8Array,range:[-128,127]},{pixelType:"U8",size:1,ctor:Uint8Array,range:[0,255]},{pixelType:"S16",size:2,ctor:Int16Array,range:[-32768,32767]},{pixelType:"U16",size:2,ctor:Uint16Array,range:[0,65536]},{pixelType:"S32",size:4,ctor:Int32Array,range:[-2147483648,2147483647]},{pixelType:"U32",size:4,ctor:Uint32Array,range:[0,4294967296]},{pixelType:"F32",size:4,ctor:Float32Array,range:[-34027999387901484e22,34027999387901484e22]},{pixelType:"F64",size:8,ctor:Float64Array,range:[-17976931348623157e292,17976931348623157e292]}];let Nt=null;function r$9(){return Nt||(Nt=et((()=>import("./lerc-wasm-B1SHZh7G.js")),__vite__mapDeps([0,1,2])).then((C=>C.l)).then((({default:C})=>C({locateFile:C=>rt(`esri/layers/support/rasterFormats/${C}`)}))).then((C=>{!function l$5(C){const{_malloc:$,_free:L,_lerc_getBlobInfo:z,_lerc_getDataRanges:q,_lerc_decode_4D:K,asm:J}=C;let X;const Z=Object.values(J).find(($=>$&&"buffer"in $&&$.buffer===C.HEAPU8.buffer)),y2=C=>{const L=C.map((C=>function o$6(C){return 16+(C>>3<<3)}(C))),z=L.reduce(((C,$)=>C+$)),q=$(z);X=new Uint8Array(Z.buffer);let K=L[0];L[0]=q;for(let $=1;$<L.length;$++){const C=L[$];L[$]=L[$-1]+K,K=C}return L};Ft.getBlobInfo=C=>{const $=12,K=3,J=new Uint8Array(4*$),Q=new Uint8Array(8*K),[tt,et,rt]=y2([C.length,J.length,Q.length]);X.set(C,tt),X.set(J,et),X.set(Q,rt);let ot=z(tt,C.length,et,rt,$,K);if(ot)throw L(tt),new Error(`lerc-getBlobInfo: error code is ${ot}`);X=new Uint8Array(Z.buffer),s$5(X,et,J),s$5(X,rt,Q);const nt=new Uint32Array(J.buffer),it=new Float64Array(Q.buffer),[st,at,,lt,ut,ct,ht,ft,dt,pt,mt]=nt,gt={version:st,depthCount:pt,width:lt,height:ut,validPixelCount:ht,bandCount:ct,blobSize:ft,maskCount:dt,dataType:at,minValue:it[0],maxValue:it[1],maxZerror:it[2],statistics:[],bandCountWithNoData:mt};if(mt&&pt>1)return L(tt),gt;if(1===pt&&1===ct)return L(tt),gt.statistics.push({minValue:it[0],maxValue:it[1]}),gt;const yt=pt*ct*8,wt=new Uint8Array(yt),vt=new Uint8Array(yt);let Ct=tt,bt=0,xt=0,kt=!1;if(X.byteLength<tt+2*yt?(L(tt),kt=!0,[Ct,bt,xt]=y2([C.length,yt,yt]),X.set(C,Ct)):[bt,xt]=y2([yt,yt]),X.set(wt,bt),X.set(vt,xt),ot=q(Ct,C.length,pt,ct,bt,xt),ot)throw L(Ct),kt||L(bt),new Error(`lerc-getDataRanges: error code is ${ot}`);X=new Uint8Array(Z.buffer),s$5(X,bt,wt),s$5(X,xt,vt);const At=new Float64Array(wt.buffer),St=new Float64Array(vt.buffer),Tt=gt.statistics;for(let L=0;L<ct;L++)if(pt>1){const C=At.slice(L*pt,(L+1)*pt),$=St.slice(L*pt,(L+1)*pt),z=Math.min.apply(null,C),q=Math.max.apply(null,$);Tt.push({minValue:z,maxValue:q,depthStats:{minValues:C,maxValues:$}})}else Tt.push({minValue:At[L],maxValue:St[L]});return L(Ct),kt||L(bt),gt},Ft.decode=(C,$)=>{const{maskCount:z,depthCount:q,bandCount:J,width:Q,height:tt,dataType:et,bandCountWithNoData:rt}=$,ot=Bt[et],nt=Q*tt,it=new Uint8Array(nt*J),st=nt*q*J*ot.size,at=new Uint8Array(st),lt=new Uint8Array(J),ut=new Uint8Array(8*J),[ct,ht,ft,dt,pt]=y2([C.length,it.length,at.length,lt.length,ut.length]);X.set(C,ct),X.set(it,ht),X.set(at,ft),X.set(lt,dt),X.set(ut,pt);const mt=K(ct,C.length,z,ht,q,Q,tt,J,et,ft,dt,pt);if(mt)throw L(ct),new Error(`lerc-decode: error code is ${mt}`);X=new Uint8Array(Z.buffer),s$5(X,ft,at),s$5(X,ht,it);let gt=null;if(rt){s$5(X,dt,lt),s$5(X,pt,ut),gt=[];const C=new Float64Array(ut.buffer);for(let $=0;$<lt.length;$++)gt.push(lt[$]?C[$]:null)}return L(ct),{data:at,maskData:it,noDataValues:gt}}}(C)})),Nt)}const Ft={getBlobInfo:null,decode:null};function s$5(C,$,L){L.set(C.slice($,$+L.length))}function i$6(C,$,L,z,q){if(L<2)return C;const K=new z($*L);for(let J=0,X=0;J<$;J++)for(let z=0,q=J;z<L;z++,q+=$)K[q]=C[X++];return K}function u$a(C,$={}){const L=$.inputOffset??0,z=C instanceof Uint8Array?C.subarray(L):new Uint8Array(C,L),q=Ft.getBlobInfo(z),{data:K,maskData:J,noDataValues:X}=Ft.decode(z,q),{width:Z,height:Q,bandCount:tt,depthCount:et,dataType:rt,maskCount:ot,statistics:nt}=q,it=Bt[rt],st=new it.ctor(K.buffer),at=[],lt=[],ut=Z*Q,ct=ut*et;for(let gt=0;gt<tt;gt++){const C=st.subarray(gt*ct,(gt+1)*ct);if($.returnInterleaved)at.push(C);else{const $=i$6(C,ut,et,it.ctor);at.push($)}lt.push(J.subarray(gt*ct,(gt+1)*ct))}const ht=0===ot?null:1===ot?lt[0]:new Uint8Array(ut);if(ot>1){ht.set(lt[0]);for(let C=1;C<lt.length;C++){const $=lt[C];for(let C=0;C<ut;C++)ht[C]=ht[C]&$[C]}}const{noDataValue:ft}=$,dt=null!=ft&&it.range[0]<=ft&&it.range[1]>=ft;if(ot>0&&dt)for(let gt=0;gt<tt;gt++){const C=at[gt],$=lt[gt]||ht;for(let L=0;L<ut;L++)0===$[L]&&(C[L]=ft)}const pt=ot===tt&&tt>1?lt:null,{pixelType:mt}=it;return{width:Z,height:Q,bandCount:tt,pixelType:mt,depthCount:et,statistics:nt,pixels:at,mask:ht,bandMasks:pt,noDataValues:X}}function n$8(){const C=[];for(let $=0;$<=257;$++)C[$]=[$];return C}function t$4(C,$){for(let L=0;L<$.length;L++)C.push($[L])}const Vt=new Set;function i$5(C,$,L,z=!0){const q=function e$3(C,$,L,z=!0){if($%4!=0||L%4!=0){const q=new ArrayBuffer(4*Math.ceil(L/4)),K=new Uint8Array(q),J=new Uint8Array(C,$,L);if(z)for(let C=0;C<K.length;C+=4)K[C]=J[C+3],K[C+1]=J[C+2],K[C+2]=J[C+1],K[C+3]=J[C];else K.set(J);return new Uint32Array(K.buffer)}if(z){const z=new Uint8Array(C,$,L),q=new Uint8Array(z.length);for(let C=0;C<q.length;C+=4)q[C]=z[C+3],q[C+1]=z[C+2],q[C+2]=z[C+1],q[C+3]=z[C];return new Uint32Array(q.buffer)}return new Uint32Array(C,$,L/4)}(C,$,L,z);let K=9,J=n$8(),X=32,Z=J.length,Q=[],tt=1,et=q[0],rt=0;const ot=q.length,nt=8*(4*ot-L),it=[];for(;null!=et;){if(X>=K)X-=K,rt=et>>>32-K,et<<=K;else{rt=et>>>32-X,et=q[tt++];const C=K-X;X=32-C,rt=(rt<<C)+(et>>>X),et<<=C}if(257===rt)break;if(256===rt){K=9,J=n$8(),Z=J.length,Q=[];continue}const C=J[rt];if(null==C){if(rt>J.length)throw new Error("data integrity issue: code does not exist on code page");Q.push(Q[0]),J[Z++]=Q.slice(),t$4(it,Q)}else t$4(it,C),Q.push(C[0]),Q.length>1&&(J[Z++]=Q.slice()),Q=C.slice();if(Vt.has(Z)&&K++,0===X&&(et=q[tt++],X=32),tt>ot||tt===ot&&X<=nt)break}return new Uint8Array(it)}Vt.add(511),Vt.add(1023),Vt.add(2047),Vt.add(4095),Vt.add(8191);const e$2=(C,$)=>{const L=$.width*$.height,z=$.pixelType;return Math.floor(C.byteLength/(L*t$3(z)))},t$3=C=>{let $=1;switch(C){case Uint8Array:case Int8Array:$=1;break;case Uint16Array:case Int16Array:$=2;break;case Uint32Array:case Int32Array:case Float32Array:$=4;break;case Float64Array:$=8}return $};let _t=class a{static decode(C,$){const L=$.pixelType,z=[],q=$.width*$.height,K=e$2(C,$),{bandIds:J,format:X}=$,Z=(null==J?void 0:J.length)||e$2(C,$),Q=C.byteLength-C.byteLength%(q*t$3(L)),tt=new L(C,0,q*K);let et,rt,ot,nt,it=null;if("bip"===X)for(et=0;et<Z;et++){for(ot=new L(q),nt=J?J[et]:et,rt=0;rt<q;rt++)ot[rt]=tt[rt*K+nt];z.push(ot)}else if("bsq"===X)for(et=0;et<Z;et++)nt=J?J[et]:et,z.push(tt.subarray(nt*q,(nt+1)*q));return Q<C.byteLength-1&&(it=((C,$)=>{if(8*C.byteLength<$)return null;const L=new Uint8Array(C,0,Math.ceil($/8)),z=new Uint8Array($);let q=0,K=0,J=0,X=0;for(J=0;J<L.length-1;J++)for(K=L[J],X=7;X>=0;X--)z[q++]=K>>X&1;for(X=7;q<$-1;)K=L[L.length-1],z[q++]=K>>X&1,X--;return z})(C.slice(Q),q)),{pixels:z,mask:it}}};function r$6(C,$){let L=0,z="",q=0,K=0;const J=C.length;for(;L<J;)K=C[L++],q=K>>4,q<8?q=1:15===q?(q=4,K=(7&K)<<18|(63&C[L++])<<12|(63&C[L++])<<6|63&C[L++]):14===q?(q=3,K=(15&K)<<12|(63&C[L++])<<6|63&C[L++]):(q=2,K=(31&K)<<6|63&C[L++]),(0!==K||$)&&(z+=String.fromCharCode(K));return z}const zt=(()=>{const C=[];return C[254]="NEWSUBFILETYPE",C[255]="SUBFILETYPE",C[256]="IMAGEWIDTH",C[257]="IMAGELENGTH",C[258]="BITSPERSAMPLE",C[259]="COMPRESSION",C[262]="PHOTOMETRICINTERPRETATION",C[263]="THRESHHOLDING",C[264]="CELLWIDTH",C[265]="CELLLENGTH",C[266]="FILLORDER",C[269]="DOCUMENTNAME",C[270]="IMAGEDESCRIPTION",C[271]="MAKE",C[272]="MODEL",C[273]="STRIPOFFSETS",C[274]="ORIENTATION",C[277]="SAMPLESPERPIXEL",C[278]="ROWSPERSTRIP",C[279]="STRIPBYTECOUNTS",C[280]="MINSAMPLEVALUE",C[281]="MAXSAMPLEVALUE",C[282]="XRESOLUTION",C[283]="YRESOLUTION",C[284]="PLANARCONFIGURATION",C[285]="PAGENAME",C[286]="XPOSITION",C[287]="YPOSITION",C[288]="FREEOFFSETS",C[289]="FREEBYTECOUNTS",C[290]="GRAYRESPONSEUNIT",C[291]="GRAYRESPONSECURVE",C[292]="T4OPTIONS",C[293]="T6OPTIONS",C[296]="RESOLUTIONUNIT",C[297]="PAGENUMBER",C[300]="COLORRESPONSEUNIT",C[301]="TRANSFERFUNCTION",C[305]="SOFTWARE",C[306]="DATETIME",C[315]="ARTIST",C[316]="HOSTCOMPUTER",C[317]="PREDICTOR",C[318]="WHITEPOINT",C[319]="PRIMARYCHROMATICITIES",C[320]="COLORMAP",C[321]="HALFTONEHINTS",C[322]="TILEWIDTH",C[323]="TILELENGTH",C[324]="TILEOFFSETS",C[325]="TILEBYTECOUNTS",C[326]="BADFAXLINES",C[327]="CLEANFAXDATA",C[328]="CONSECUTIVEBADFAXLINES",C[330]="SUBIFD",C[332]="INKSET",C[333]="INKNAMES",C[334]="NUMBEROFINKS",C[336]="DOTRANGE",C[337]="TARGETPRINTER",C[338]="EXTRASAMPLES",C[339]="SAMPLEFORMAT",C[340]="SMINSAMPLEVALUE",C[341]="SMAXSAMPLEVALUE",C[342]="TRANSFERRANGE",C[347]="JPEGTABLES",C[512]="JPEGPROC",C[513]="JPEGIFOFFSET",C[514]="JPEGIFBYTECOUNT",C[515]="JPEGRESTARTINTERVAL",C[517]="JPEGLOSSLESSPREDICTORS",C[518]="JPEGPOINTTRANSFORM",C[519]="JPEGQTABLES",C[520]="JPEGDCTABLES",C[521]="JPEGACTABLES",C[529]="YCBCRCOEFFICIENTS",C[530]="YCBCRSUBSAMPLING",C[531]="YCBCRPOSITIONING",C[532]="REFERENCEBLACKWHITE",C[700]="XMP",C[33550]="GEOPIXELSCALE",C[33922]="GEOTIEPOINTS",C[33432]="COPYRIGHT",C[42112]="GDAL_METADATA",C[42113]="GDAL_NODATA",C[50844]="RPCCOEFFICIENT",C[34264]="GEOTRANSMATRIX",C[34735]="GEOKEYDIRECTORY",C[34736]="GEODOUBLEPARAMS",C[34737]="GEOASCIIPARAMS",C[34665]="EXIFIFD",C[34853]="GPSIFD",C[40965]="INTEROPERABILITYIFD",C})(),jt=(()=>{const C=zt.slice();return C[36864]="ExifVersion",C[40960]="FlashpixVersion",C[40961]="ColorSpace",C[42240]="Gamma",C[37121]="ComponentsConfiguration",C[37122]="CompressedBitsPerPixel",C[40962]="PixelXDimension",C[40963]="PixelYDimension",C[37500]="MakerNote",C[37510]="UserComment",C[40964]="RelatedSoundFile",C[36867]="DateTimeOriginal",C[36868]="DateTimeDigitized",C[36880]="OffsetTime",C[36881]="OffsetTimeOriginal",C[36882]="OffsetTimeDigitized",C[37520]="SubSecTime",C[37521]="SubSecTimeOriginal",C[37522]="SubSecTimeDigitized",C[37888]="Temperature",C[37889]="Humidity",C[37890]="Pressure",C[37891]="WaterDepth",C[37892]="Acceleration",C[37893]="CameraElevationAngle",C[42016]="ImageUniqueID",C[42032]="CameraOwnerName",C[42033]="BodySerialNumber",C[42034]="LensSpecification",C[42035]="LensMake",C[42036]="LensModel",C[42037]="LensSerialNumber",C[33434]="ExposureTime",C[33437]="FNumber",C[34850]="ExposureProgram",C[34852]="SpectralSensitivity",C[34855]="PhotographicSensitivity",C[34856]="OECF",C[34864]="SensitivityType",C[34865]="StandardOutputSensitivity",C[34866]="RecommendedExposureIndex",C[34867]="ISOSpeed",C[34868]="ISOSpeedLatitudeyyy",C[34869]="ISOSpeedLatitudezzz",C[37377]="ShutterSpeedValue",C[37378]="ApertureValue",C[37379]="BrightnessValue",C[37380]="ExposureBiasValue",C[37381]="MaxApertureValue",C[37382]="SubjectDistance",C[37383]="MeteringMode",C[37384]="LightSource",C[37385]="Flash",C[37386]="FocalLength",C[37396]="SubjectArea",C[41483]="FlashEnergy",C[41484]="SpatialFrequencyResponse",C[41486]="FocalPlaneXResolution",C[41487]="FocalPlaneYResolution",C[41488]="FocalPlaneResolutionUnit",C[41492]="SubjectLocation",C[41493]="ExposureIndex",C[41495]="SensingMethod",C[41728]="FileSource",C[41729]="SceneType",C[41730]="CFAPattern",C[41985]="CustomRendered",C[41986]="ExposureMode",C[41987]="WhiteBalance",C[41988]="DigitalZoomRatio",C[41989]="FocalLengthIn35mmFilm",C[41990]="SceneCaptureType",C[41991]="GainControl",C[41992]="Contrast",C[41993]="Saturation",C[41994]="Sharpness",C[41995]="DeviceSettingDescription",C[41996]="SubjectDistanceRange",C})(),Wt=(()=>{const C=[];return C[1024]="GTModelTypeGeoKey",C[1025]="GTRasterTypeGeoKey",C[1026]="GTCitationGeoKey",C[2048]="GeographicTypeGeoKey",C[2049]="GeogCitationGeoKey",C[2050]="GeogGeodeticDatumGeoKey",C[2051]="GeogPrimeMeridianGeoKey",C[2052]="GeogLinearUnitsGeoKey",C[2053]="GeogLinearUnitSizeGeoKey",C[2054]="GeogAngularUnitsGeoKey",C[2055]="GeogAngularUnitSizeGeoKey",C[2056]="GeogEllipsoidGeoKey",C[2057]="GeogSemiMajorAxisGeoKey",C[2058]="GeogSemiMinorAxisGeoKey",C[2059]="GeogInvFlatteningGeoKey",C[2061]="GeogPrimeMeridianLongGeoKey",C[2060]="GeogAzimuthUnitsGeoKey",C[3072]="ProjectedCSTypeGeoKey",C[3073]="PCSCitationGeoKey",C[3074]="ProjectionGeoKey",C[3075]="ProjCoordTransGeoKey",C[3076]="ProjLinearUnitsGeoKey",C[3077]="ProjLinearUnitSizeGeoKey",C[3078]="ProjStdParallel1GeoKey",C[3079]="ProjStdParallel2GeoKey",C[3080]="ProjNatOriginLongGeoKey",C[3081]="ProjNatOriginLatGeoKey",C[3082]="ProjFalseEastingGeoKey",C[3083]="ProjFalseNorthingGeoKey",C[3084]="ProjFalseOriginLongGeoKey",C[3085]="ProjFalseOriginLatGeoKey",C[3086]="ProjFalseOriginEastingGeoKey",C[3087]="ProjFalseOriginNorthingGeoKey",C[3088]="ProjCenterLongGeoKey",C[3090]="ProjCenterEastingGeoKey",C[3091]="ProjCenterNorthingGeoKey",C[3092]="ProjScaleAtNatOriginGeoKey",C[3093]="ProjScaleAtCenterGeoKey",C[3094]="ProjAzimuthAngleGeoKey",C[3095]="ProjStraightVertPoleLongGeoKey",C[4096]="VerticalCSTypeGeoKey",C[4097]="VerticalCitationGeoKey",C[4098]="VerticalDatumGeoKey",C[4099]="VerticalUnitsGeoKey",C})(),Ht=new Map;Ht.set("EXIFIFD",jt),Ht.set("GPSIFD",["GPSVersionID","GPSLatitudeRef","GPSLatitude","GPSLongitudeRef","GPSLongitude","GPSAltitudeRef","GPSAltitude","GPSTimeStamp","GPSSatellites","GPSStatus","GPSMeasureMode","GPSDOP","GPSSpeedRef","GPSSpeed","GPSTrackRef","GPSTrack","GPSImgDirectionRef","GPSImgDirection","GPSMapDatum","GPSDestLatitudeRef","GPSDestLatitude","GPSDestLongitudeRef","GPSDestLongitude","GPSDestBearingRef","GPSDestBearing","GPSDestDistanceRef","GPSDestDistance","GPSProcessingMethod","GPSAreaInformation","GPSDateStamp","GPSDifferential","GPSHPositioningError"]);const qt={tiffTags:zt,ifdTags:Ht,geoKeys:Wt,getTagName:(C,$)=>{let L=($||zt)[C];return void 0===L&&(L="unknown"+String(C)),L}},Kt=(()=>{const C=new ArrayBuffer(4),$=new Uint8Array(C);return new Uint32Array(C)[0]=1,1===$[0]})(),Jt=[0,1,1,2,4,8,1,1,2,4,8,4,8,-1,-1,-1,8,8,8],Yt=4294967296,Xt=new Set([1,5,6,7,8,34712,34887]);function h$7(C,$){let L="unknown";return 3===C?L=64===$?"f64":"f32":1===C?1===$?L="u1":2===$?L="u2":4===$?L="u4":$<=8?L="u8":$<=16?L="u16":$<=32&&(L="u32"):2===C&&($<=8?L="s8":$<=16?L="s16":$<=32&&(L="s32")),L}function g$4(C){let $=null;switch(C?C.toLowerCase():"f32"){case"u1":case"u2":case"u4":case"u8":$=Uint8Array;break;case"u16":$=Uint16Array;break;case"u32":$=Uint32Array;break;case"s8":$=Int8Array;break;case"s16":$=Int16Array;break;case"s32":$=Int32Array;break;case"f64":$=Float64Array;break;default:$=Float32Array}return $}function E$1(C,$){return{x:$[0]*C.x+$[1]*C.y+$[2],y:$[3]*C.x+$[4]*C.y+$[5]}}function T$2(C,$){var L;return null==(L=C.get($))?void 0:L.values}function I$3(C,$){var L;return null==(L=C.get($))?void 0:L.values}function w$4(C,$){var L,z;return null==(z=null==(L=C.get($))?void 0:L.values)?void 0:z[0]}function p$5(C,$){var L,z;return null==(z=null==(L=C.get($))?void 0:L.values)?void 0:z[0]}function d$4(C,$,L,z=0,q=qt.tiffTags,K=4){const J=8===K,X=J?C$4(new DataView(C,L,8),0,$):new DataView(C,L,2).getUint16(0,$),Z=4+2*K,Q=J?8:2,tt=Q+X*Z;if(L+tt>C.byteLength)return{success:!1,ifd:null,nextIFD:null,requiredBufferSize:tt};const et=L+tt+4<=C.byteLength?v$4(new DataView(C,L+tt,8===K?8:4),0,$,8===K):null,rt=L+Q,ot=new Map;let nt,it,st,at,lt,ut=0,ct=0;for(let ht=0;ht<X;ht++){it=new DataView(C,rt+Z*ht,Z),st=it.getUint16(0,$),lt=it.getUint16(2,$),at=qt.getTagName(st,q);const L=[];2===K?(ut=it.getUint16(4,$),ct=it.getUint16(6,$)):4===K?(ut=it.getUint32(4,$),ct=it.getUint32(8,$)):8===K&&(ut=v$4(it,4,$,!0),ct=v$4(it,12,$,!0),L.push(it.getUint32(12,$)),L.push(it.getUint32(16,$))),nt={id:st,type:lt,valueCount:ut,valueOffset:ct,valueOffsets:L,values:null},L$1(C,$,nt,z,!1,K),ot.set(at,nt)}return{success:!0,ifd:ot,nextIFD:et,requiredBufferSize:tt}}const m$6=(C,$)=>u$a(C,{inputOffset:$}).pixels[0];function y$3(C,$){if(1!==$&&2!==$&&4!==$)return C;const L=new Uint8Array(C),z=8/$,q=new Uint8Array(C.byteLength*z);let K=0;const J=2**$-1;for(let X=0;X<L.length;X++){const C=L[X];for(let L=0;L<z;L++)q[K++]=C<<$*L>>>8-$&J}return q.buffer}function S$2(C,$,L){const z=new Ot;z.parse(C),z.colorTransform=6===L?-1:0;const q=z.getData(z.width,z.height,1!==$&&4!==$);return new Uint8Array(q.buffer)}function A$3(C){const $=new Pt(C).getBytes(),L=new ArrayBuffer($.length),z=new Uint8Array(L);return z.set($),z}async function M$1(C,$,L,z,q){const K=Kt===$,J=p$5(L,"BITSPERSAMPLE"),X=p$5(L,"SAMPLESPERPIXEL")??1,Z=p$5(L,"PHOTOMETRICINTERPRETATION"),Q=p$5(L,"SAMPLEFORMAT")??1,tt=h$7(Q,J),et=p$5(L,"COMPRESSION")??1,rt=g$4(tt);let ot,nt,it;if(34887===et)return await r$9(),m$6(C,z);if(1===et)ot=C.slice(z,z+q),nt=new Uint8Array(ot);else if(8===et||32946===et)nt=new Uint8Array(C,z,q),nt=A$3(nt),ot=nt.buffer;else if(6===et)nt=new Uint8Array(C,z,q),nt=S$2(nt,X,Z),ot=nt.buffer;else if(7===et){const $=L.get("JPEGTABLES").values,K=$.length-2;nt=new Uint8Array(K+q-2);for(let C=0;C<K;C++)nt[C]=$[C];const J=new Uint8Array(C,z+2,q-2);for(let C=0;C<J.length;C++)nt[K+C]=J[C];nt=S$2(nt,X,Z),ot=nt.buffer}else{if(5!==et)throw new Error("tiff-decode: unsupport compression "+et);nt=i$5(C,z,q,$),ot=nt.buffer}if(ot=y$3(ot,J),"u8"===tt||"s8"===tt||K)it=new rt(ot);else{ot=new ArrayBuffer(nt.length);const C=new Uint8Array(ot);switch(tt){case"u16":case"s16":for(let $=0;$<nt.length;$+=2)C[$]=nt[$+1],C[$+1]=nt[$];break;case"u32":case"s32":case"f32":for(let $=0;$<nt.length;$+=4)C[$]=nt[$+3],C[$+1]=nt[$+2],C[$+2]=nt[$+1],C[$+3]=nt[$]}it=new rt(ot)}const st=p$5(L,"PREDICTOR")??1,at=p$5(L,"TILEWIDTH"),lt=p$5(L,"TILELENGTH");if(st>1&&(5===et||8===et||32946===et)&&at&&lt){const C=D$3(L),$=new rt(it.length);$.set(it),it=function W$1(C,$,L,z,q){const K=z?4:1,J=L*K*q;z&&(C=new Uint8Array(C.buffer));for(let Q=0;Q<$;Q++){const $=Q*J;for(let L=q;L<J;L++)C[$+L]+=C[$+L-q]}if(!z)return C;const X=new Uint8Array(C.length),Z=L*q;for(let Q=0;Q<$;Q++){const $=Q*J;for(let L=0;L<Z;L++)for(let z=0;z<K;z++)X[$+L*K+z]=C[$+L+(K-z-1)*Z]}return new Float32Array(X.buffer)}($,lt,at,3===Q&&3===st,C?1:X)}return it}const O$2=(C,$,L)=>{const z=Kt===$.littleEndian,q=I$3(L,"STRIPOFFSETS");if(void 0===q)return null;const{width:K,height:J,pixelType:X}=R$2([L]),Z=p$5(L,"SAMPLESPERPIXEL")||$.planes,Q=p$5(L,"PHOTOMETRICINTERPRETATION"),tt=K*J,et=p$5(L,"BITSPERSAMPLE"),rt=g$4(X),ot=new rt(tt*Z),nt=I$3(L,"STRIPBYTECOUNTS"),it=p$5(L,"ROWSPERSTRIP"),st=p$5(L,"COMPRESSION")??1;let at,lt,ut,ct,ht,ft,dt,pt,mt;if(et%8==0)for(at=0;at<q.length;at++){if(ht=at*(it*K)*Z,"u8"===X||"s8"===X||z)8===st||32946===st?(dt=new Uint8Array(C,q[at],nt[at]),dt=A$3(dt),ft=dt.buffer):6===st?(dt=new Uint8Array(C,q[at],nt[at]),dt=S$2(dt,Z,Q),ft=dt.buffer):5===st?(dt=i$5(C,q[at],nt[at],$.littleEndian),ft=dt.buffer):ft=C.slice(q[at],q[at]+nt[at]),ft=y$3(ft,et),ct=new rt(ft);else{switch(6===st||8===st||32946===st?(dt=new Uint8Array(C,q[at],nt[at]),pt=A$3(dt),ft=pt.buffer):(ft=new ArrayBuffer(nt[at]),dt=new Uint8Array(C,q[at],nt[at]),pt=new Uint8Array(ft)),X){case"u16":case"s16":for(ut=0;ut<dt.length;ut+=2)pt[ut]=dt[ut+1],pt[ut+1]=dt[ut];break;case"u32":case"s32":case"f32":for(ut=0;ut<dt.length;ut+=4)pt[ut]=dt[ut+3],pt[ut+1]=dt[ut+2],pt[ut+2]=dt[ut+1],pt[ut+3]=dt[ut]}ft=y$3(ft,et),ct=new rt(ft)}ot.set(ct,ht)}const gt=[];if(1===Z)gt.push(ot);else for(at=0;at<Z;at++){for(mt=new rt(tt),lt=0;lt<tt;lt++)mt[lt]=ot[lt*Z+at];gt.push(mt)}return{width:K,height:J,pixelType:X,pixels:gt}},b$3=(C,$,L)=>{if(!(C&&C.length>0&&$&&L))return null;let z,q,K;const J=C[0].length,X=C.length,Z=new Uint8Array(J);for(let Q=0;Q<X;Q++)if(z=C[Q],q=$[Q],K=L[Q],0===Q)for(let C=0;C<J;C++)Z[C]=z[C]<q||z[C]>K?0:1;else for(let C=0;C<J;C++)Z[C]&&(Z[C]=z[C]<q||z[C]>K?0:1);return Z},x$3=C=>{if(!C)return null;const $=C.match(/<Item(.*?)Item>/gi);if(!$||0===$.length)return null;const L=new Map;let z,q,K,J,X;for(let at=0;at<$.length;at++)z=$[at],q=z.slice(6,z.indexOf(">")),J=z.indexOf("sample="),J>-1&&(X=z.slice(J+8,z.indexOf('"',J+8))),J=z.indexOf("name="),J>-1&&(q=z.slice(J+6,z.indexOf('"',J+6))),q&&(K=z.slice(z.indexOf(">")+1,z.indexOf("</Item>")).trim(),null!=X?L.has(q)?L.get(q)[X]=K:L.set(q,[K]):L.set(q,K)),X=null;const Z=L.get("STATISTICS_MINIMUM"),Q=L.get("STATISTICS_MAXIMUM"),tt=L.get("STATISTICS_MEAN"),et=L.get("STATISTICS_STDDEV");let rt=null;if(Z&&Q){rt=[];for(let C=0;C<Z.length;C++)rt.push({min:parseFloat(Z[C]),max:parseFloat(Q[C]),avg:tt&&parseFloat(tt[C]),stddev:et&&parseFloat(et[C])})}const ot=L.get("BandName"),nt=L.get("WavelengthMin"),it=L.get("WavelengthMax");let st=null;if(ot){st=[];for(let C=0;C<ot.length;C++)st.push({BandName:ot[C],WavelengthMin:nt&&parseFloat(nt[C]),WavelengthMax:it&&parseFloat(it[C])})}return{statistics:rt,bandProperties:st,dataType:L.get("DataType"),rawMetadata:L}};function L$1(C,$,L,z=0,q=!1,K=4){if(L.values)return!0;const J=L.type,X=L.valueCount;let Z=L.valueOffset,Q=[];const tt=Jt[J],et=8*tt,rt=X*tt,ot=X*Jt[J]*8;let nt,it;const st=8===K?64:32,at=L.valueOffsets;if(ot>st&&rt>(q?C.byteLength:C?C.byteLength-Z+z:0))return L.offlineOffsetSize=[Z,rt],L.values=null,!1;if(ot<=st){if(!$)if(st<=32)Z>>>=32-ot;else{const C=(null==at?void 0:at.length)?at[0]:Z>>>0,$=(null==at?void 0:at.length)?at[1]:Math.round((Z-C)/Yt);ot<=32?(Z=C>>>32-ot,at[0]=Z):(Z=C*2**(32-ot)+($>>>32-ot),at[0]=C,at[1]=$>>>32-ot)}if(1===X&&et===st)Q=[Z];else if(64===st){const C=(null==at?void 0:at.length)?at[0]:Z>>>0,$=(null==at?void 0:at.length)?at[1]:Math.round((Z-C)/Yt);let L=C,z=32;for(it=1;it<=X;it++){const C=32-et*it%32;if(z<et){const q=L<<C>>>32-z,K=$<<32-z>>>32-z;L=$,Q.push(q+K*2**(et-z)),z-=32-(et-z)}else Q.push(L<<C>>>32-et),z-=et;0===z&&(z=32,L=$)}}else for(it=1;it<=X;it++){const C=32-et*it;Q.push(Z<<C>>>32-et)}}else{Z-=z,q&&(Z=0);for(let L=Z;L<Z+rt;L+=tt){switch(J){case 1:case 2:case 7:nt=new DataView(C,L,1).getUint8(0);break;case 3:nt=new DataView(C,L,2).getUint16(0,$);break;case 4:case 13:nt=new DataView(C,L,4).getUint32(0,$);break;case 5:nt=new DataView(C,L,4).getUint32(0,$)/new DataView(C,L+4,4).getUint32(0,$);break;case 6:nt=new DataView(C,L,1).getInt8(0);break;case 8:nt=new DataView(C,L,2).getInt16(0,$);break;case 9:nt=new DataView(C,L,4).getInt32(0,$);break;case 10:nt=new DataView(C,L,4).getInt32(0,$)/new DataView(C,L+4,4).getInt32(0,$);break;case 11:nt=new DataView(C,L,4).getFloat32(0,$);break;case 12:nt=new DataView(C,L,8).getFloat64(0,$);break;case 16:case 18:nt=C$4(new DataView(C,L,8),0,$);break;case 17:nt=G$1(new DataView(C,L,8),0,$);break;default:nt=null}Q.push(nt)}}if(2===J){let C="";const $=Q;for(Q=[],it=0;it<$.length;it++)0===$[it]&&""!==C?(Q.push(C),C=""):C+=String.fromCharCode($[it]);""===C&&0!==Q.length||Q.push(C)}return L.values=Q,!0}function R$2(C){const $=C[0],L=p$5($,"TILEWIDTH"),z=p$5($,"TILELENGTH"),q=p$5($,"IMAGEWIDTH"),K=p$5($,"IMAGELENGTH"),J=p$5($,"BITSPERSAMPLE"),X=p$5($,"SAMPLESPERPIXEL"),Z=p$5($,"SAMPLEFORMAT")??1,Q=h$7(Z,J),tt=D$3($),et=T$2($,"GDAL_NODATA");let rt=null;(null==et?void 0:et.length)&&(rt=et.map((C=>parseFloat(C))),rt.some((C=>isNaN(C)))&&(rt=null));const ot=p$5($,"COMPRESSION")??1;let nt;switch(ot){case 1:nt="NONE";break;case 2:case 3:case 4:case 32771:nt="CCITT";break;case 5:nt="LZW";break;case 6:case 7:nt="JPEG";break;case 32773:nt="PACKBITS";break;case 8:case 32946:nt="DEFLATE";break;case 34712:nt="JPEG2000";break;case 34887:nt="LERC";break;default:nt=String(ot)}let it=!0,st="";Xt.has(ot)||(it=!1,st+="unsupported tag compression "+ot),Z>3&&(it=!1,st+="unsupported tag sampleFormat "+Z),1!==J&&2!==J&&4!==J&&J%8!=0&&(it=!1,st+="unsupported tag bitsPerSample "+J);const at=w$4($,"GEOASCIIPARAMS");let lt;if(at){const C=at.split("|").find((C=>C.includes("ESRI PE String = "))),$=C?C.replace("ESRI PE String = ",""):"";lt=$.startsWith("COMPD_CS")||$.startsWith("PROJCS")||$.startsWith("GEOGCS")?{wkid:null,wkt:$}:null}const ut=I$3($,"GEOTIEPOINTS"),ct=I$3($,"GEOPIXELSCALE"),ht=I$3($,"GEOTRANSMATRIX"),ft=$.has("GEOKEYDIRECTORY")?$.get("GEOKEYDIRECTORY").data:null;let dt,pt,mt=!1,gt=!1;if(ft){mt=2===p$5(ft,"GTRasterTypeGeoKey");const C=p$5(ft,"GTModelTypeGeoKey");if(2===C){const C=p$5(ft,"GeographicTypeGeoKey");C>=1024&&C<=32766&&(lt={wkid:C}),lt||32767!==C||(gt=!0,lt={wkid:4326})}else if(1===C){const C=p$5(ft,"ProjectedCSTypeGeoKey");C>=1024&&C<=32766&&(lt={wkid:C})}}if(ct&&ut&&ut.length>=6?(dt=[ct[0],0,ut[3]-ut[0]*ct[0],0,-Math.abs(ct[1]),ut[4]-ut[1]*ct[1]],mt&&(dt[2]-=.5*dt[0]+.5*dt[1],dt[5]-=.5*dt[3]+.5*dt[4])):ht&&16===ht.length&&(dt=mt?[ht[0],ht[1],ht[3]-.5*ht[0],ht[4],ht[5],ht[7]-.5*ht[5]]:[ht[0],ht[1],ht[3],ht[4],ht[5],ht[7]]),dt){const C=[{x:0,y:K},{x:0,y:0},{x:q,y:K},{x:q,y:0}];let $,L=Number.POSITIVE_INFINITY,z=Number.POSITIVE_INFINITY,J=Number.NEGATIVE_INFINITY,X=Number.NEGATIVE_INFINITY;for(let q=0;q<C.length;q++)$=E$1(C[q],dt),L=$.x>L?L:$.x,J=$.x<J?J:$.x,z=$.y>z?z:$.y,X=$.y<X?X:$.y;pt={xmin:L,xmax:J,ymin:z,ymax:X,spatialReference:lt}}else pt={xmin:-.5,ymin:.5-K,xmax:q-.5,ymax:.5,spatialReference:lt};gt&&(pt.xmax-pt.xmin>400||Math.max(Math.abs(pt.xmin),Math.abs(pt.xmax))>361)&&(lt=null,pt.spatialReference=null);const yt=U$3(C);let wt,vt,Ct,bt,xt;if(yt.length>0){Ct=Math.round(Math.log(q/p$5(yt[0],"IMAGEWIDTH"))/Math.LN2);const C=yt[yt.length-1];bt=yt.length,wt=p$5(C,"TILEWIDTH"),vt=p$5(C,"TILELENGTH")}wt=null!=bt&&bt>0?wt||L:null,vt=null!=bt&&bt>0?vt||z:null,L&&(xt=[{maxCol:Math.ceil(q/L)-1,maxRow:Math.ceil(K/z)-1,minRow:0,minCol:0}],yt.forEach((C=>{xt.push({maxCol:Math.ceil(p$5(C,"IMAGEWIDTH")/p$5(C,"TILEWIDTH"))-1,maxRow:Math.ceil(p$5(C,"IMAGELENGTH")/p$5(C,"TILELENGTH"))-1,minRow:0,minCol:0})})));const kt=w$4(C[0],"GDAL_METADATA"),At=x$3(kt);st+=" "+V$1({width:q,height:K,tileWidth:L,tileHeight:z,planes:X,ifds:C});const St=N(C).length===yt.length+1,Tt=(null==yt?void 0:yt.length)?yt.map((C=>({x:q/p$5(C,"IMAGEWIDTH"),y:K/p$5(C,"IMAGELENGTH")}))):void 0;return{width:q,height:K,tileWidth:L,tileHeight:z,planes:X,isBSQ:tt,pixelType:Q,compression:nt,noData:rt,hasMaskBand:St,isSupported:it,pyramidResolutions:Tt,message:st,extent:pt,isPseudoGeographic:gt,affine:ct?null:dt,firstPyramidLevel:Ct,maximumPyramidLevel:bt,pyramidBlockWidth:wt,pyramidBlockHeight:vt,tileBoundary:xt,metadata:At}}function D$3(C,$){const L=T$2(C,"PLANARCONFIGURATION");return L?2===L[0]:!!$&&$.isBSQ}function U$3(C){return C.filter((C=>1===p$5(C,"NEWSUBFILETYPE")))}function N(C){return C.filter((C=>{const $=!(4&~(p$5(C,"NEWSUBFILETYPE")??0)),L=4===p$5(C,"PHOTOMETRICINTERPRETATION");return $&&L}))}function C$4(C,$,L){const z=C.getUint32($,L),q=C.getUint32($+4,L);return L?q*Yt+z:z*Yt+q}function G$1(C,$,L){let z=L?C.getInt32($,L):C.getUint32($,L),q=L?C.getUint32($+4,L):C.getInt32($+4,L);const K=(L?z:q)>=0?1:-1;return L?z*=K:q*=K,K*(L?q*Yt+z:z*Yt+q)}function v$4(C,$,L,z){return z?C$4(C,$,L):C.getUint32($,L)}function F(C){const $=new DataView(C,0,16),L=$.getUint16(0,!1);let z=null;if(18761===L)z=!0;else{if(19789!==L)throw new Error("unexpected endianess byte");z=!1}const q=$.getUint16(2,z);if(42!==q&&43!==q)throw new Error("unexpected tiff identifier");let K=4;const J=43===q;if(J){const C=$.getUint16(K,z);if(K+=2,8!==C)throw new Error("unsupported bigtiff version");if(0!==$.getUint16(K,z))throw new Error("unsupported bigtiff version");K+=2}return{littleEndian:z,isBigTiff:J,firstIFDPos:v$4($,K,z,J)}}function B$2(C,$,L,z=0,q=qt.tiffTags,K=4){const J=d$4(C,$,L,z,q,K);let X;const Z=J.ifd;if(Z){if(qt.ifdTags.forEach(((L,q)=>{Z.has(q)&&(X=Z.get(q),X.data=d$4(C,$,X.valueOffset-z,z,L).ifd)})),Z.has("GEOKEYDIRECTORY")){X=Z.get("GEOKEYDIRECTORY");const L=X.values;if(L&&L.length>4){const q=L[0]+"."+L[1]+"."+L[2];X.data=d$4(C,$,X.valueOffset+6-z,z,qt.geoKeys,2).ifd,X.data&&X.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[q]})}}if(Z.has("XMP")){X=Z.get("XMP");const C=X.values;"number"==typeof C[0]&&7===X.type&&(X.values=[r$6(new Uint8Array(C))])}}return J}function V$1(C){const{width:$,height:L,tileHeight:z,tileWidth:q}=C,K=C.planes,J=q?q*z:$*L,X=p$5(C.ifds[0],"BITSPERSAMPLE");let Z="";return J*K>2**30/(X>8?X/8:1)&&(Z=q?"tiled tiff exceeding 1 gigabits per tile is not supported":"scanline tiff exceeding 1 gigabits is not supported"),Z}async function Y(C,$={}){const L=$.pyramidLevel||0,z=$.headerInfo||function k$3(C){const{littleEndian:$,isBigTiff:L,firstIFDPos:z}=F(C);let q=z;const K=[];do{const z=B$2(C,$,q,0,qt.tiffTags,L?8:4);if(!z.success)break;K.push(z.ifd),q=z.nextIFD}while(q>0);return{...R$2(K),littleEndian:$,isBigTiff:L,ifds:K,pyramidIFDs:U$3(K),maskIFDs:N(K)}}(C),{ifds:q,noData:K}=z;if(0===q.length)throw new Error("no valid image file directory");const J=V$1(z);if(J)throw J;let X=null;const Z=-1===L?q[q.length-1]:q[L],Q=K??$.noDataValue;return X=z.tileWidth?await async function P$2(C,$,L){const z=I$3(L,"TILEOFFSETS");if(void 0===z)return null;const q=I$3(L,"TILEBYTECOUNTS"),{width:K,height:J,pixelType:X,tileWidth:Z,tileHeight:Q}=R$2([L]),tt=D$3(L,$),et=p$5(L,"SAMPLESPERPIXEL")||$.planes,rt=K*J,ot=p$5(L,"BITSPERSAMPLE"),nt=34887===(p$5(L,"COMPRESSION")??1),it=g$4(X),st=[];for(let kt=0;kt<et;kt++)st.push(new it(rt));let at,lt,ut,ct,ht,ft,dt,pt,mt,gt,yt,wt,vt;const Ct=Math.ceil(K/Z),bt=new Uint8Array(rt).fill(255);let xt=!1;if(ot%8==0)if(nt&&tt&&et>1){const X=Math.round(z.length/et);for(at=0;at<X;at++){ft=Math.floor(at/Ct)*Q,dt=at%Ct*Z,pt=ft*K+dt;for(let X=0;X<et;X++){const tt=at*et+X;for(0===q[tt]?(ut=null,xt=!0):ut=await M$1(C,$.littleEndian,L,z[tt],q[tt]),gt=0,mt=pt,wt=Math.min(Z,K-dt),yt=Math.min(Q,J-ft),vt=st[X],ct=0;ct<yt;ct++)for(mt=pt+ct*K,gt=ct*Z,ht=0;ht<wt;ht++,mt++,gt++)ut?vt[mt]=ut[gt]:bt[mt]=0}}}else for(at=0;at<z.length;at++)for(ft=Math.floor(at/Ct)*Q,dt=at%Ct*Z,pt=ft*K+dt,0===q[at]?(ut=null,xt=!0):ut=await M$1(C,$.littleEndian,L,z[at],q[at]),gt=0,mt=pt,wt=Math.min(Z,K-dt),yt=Math.min(Q,J-ft),lt=0;lt<et;lt++)if(vt=st[lt],tt||nt)for(ct=0;ct<yt;ct++)for(mt=pt+ct*K,gt=Z*Q*lt+ct*Z,ht=0;ht<wt;ht++,mt++,gt++)ut?vt[mt]=ut[gt]:bt[mt]=0;else for(ct=0;ct<yt;ct++)for(mt=pt+ct*K,gt=ct*Z*et+lt,ht=0;ht<wt;ht++,mt++,gt+=et)ut?vt[mt]=ut[gt]:bt[mt]=0;return{width:K,height:J,pixelType:X,pixels:st,mask:xt?bt:void 0}}(C,z,Z):O$2(C,z,Z),X?(null!=Q&&l$6(X,Q),X):X}var Zt=function(C){var $,L,z;function o2(C){var $,L,z,q,K,J,X,Z,Q,tt,et,rt,ot;for(this.data=C,this.pos=8,this.palette=[],this.imgData=[],this.transparency={},this.animation=null,this.text={},K=null;;){switch($=this.readUInt32(),Z=function(){var C,$;for($=[],C=0;C<4;++C)$.push(String.fromCharCode(this.data[this.pos++]));return $}.call(this).join("")){case"IHDR":this.width=this.readUInt32(),this.height=this.readUInt32(),this.bits=this.data[this.pos++],this.colorType=this.data[this.pos++],this.compressionMethod=this.data[this.pos++],this.filterMethod=this.data[this.pos++],this.interlaceMethod=this.data[this.pos++];break;case"acTL":this.animation={numFrames:this.readUInt32(),numPlays:this.readUInt32()||1/0,frames:[]};break;case"PLTE":this.palette=this.read($);break;case"fcTL":K&&this.animation.frames.push(K),this.pos+=4,K={width:this.readUInt32(),height:this.readUInt32(),xOffset:this.readUInt32(),yOffset:this.readUInt32()},q=this.readUInt16(),z=this.readUInt16()||100,K.delay=1e3*q/z,K.disposeOp=this.data[this.pos++],K.blendOp=this.data[this.pos++],K.data=[];break;case"IDAT":case"fdAT":for("fdAT"===Z&&(this.pos+=4,$-=4),C=(null!=K?K.data:void 0)||this.imgData,et=0;0<=$?et<$:et>$;0<=$?++et:--et)C.push(this.data[this.pos++]);break;case"tRNS":switch(this.transparency={},this.colorType){case 3:if(this.transparency.indexed=this.read($),(Q=255-this.transparency.indexed.length)>0)for(rt=0;0<=Q?rt<Q:rt>Q;0<=Q?++rt:--rt)this.transparency.indexed.push(255);break;case 0:this.transparency.grayscale=this.read($)[0];break;case 2:this.transparency.rgb=this.read($)}break;case"tEXt":J=(tt=this.read($)).indexOf(0),X=String.fromCharCode.apply(String,tt.slice(0,J)),this.text[X]=String.fromCharCode.apply(String,tt.slice(J+1));break;case"IEND":return K&&this.animation.frames.push(K),this.colors=function(){switch(this.colorType){case 0:case 3:case 4:return 1;case 2:case 6:return 3}}.call(this),this.hasAlphaChannel=4===(ot=this.colorType)||6===ot,L=this.colors+(this.hasAlphaChannel?1:0),this.pixelBitlength=this.bits*L,this.colorSpace=function(){switch(this.colors){case 1:return"DeviceGray";case 3:return"DeviceRGB"}}.call(this),void(this.imgData=new Uint8Array(this.imgData));default:this.pos+=$}if(this.pos+=4,this.pos>this.data.length)throw new Error("Incomplete or corrupt PNG file")}}return o2.load=function(C,$,L){var z;return"function"==typeof $&&(L=$),(z=new XMLHttpRequest).open("GET",C,!0),z.responseType="arraybuffer",z.onload=function(){var C;return C=new o2(new Uint8Array(z.response||z.mozResponseArrayBuffer)),"function"==typeof(null!=$?$.getContext:void 0)&&C.render($),"function"==typeof L?L(C):void 0},z.send(null)},o2.prototype.read=function(C){var $,L;for(L=[],$=0;0<=C?$<C:$>C;0<=C?++$:--$)L.push(this.data[this.pos++]);return L},o2.prototype.readUInt32=function(){return this.data[this.pos++]<<24|this.data[this.pos++]<<16|this.data[this.pos++]<<8|this.data[this.pos++]},o2.prototype.readUInt16=function(){return this.data[this.pos++]<<8|this.data[this.pos++]},o2.prototype.decodePixels=function(C){var $,L,z,q,K,J,X,Z,Q,tt,et,rt,ot,nt,it,st,at,lt,ut,ct,ht,ft,dt;if(null==C&&(C=this.imgData),0===C.length)return new Uint8Array(0);for(C=(C=new Pt(C)).getBytes(),st=(rt=this.pixelBitlength/8)*this.width,ot=new Uint8Array(st*this.height),J=C.length,it=0,nt=0,L=0;nt<J;){switch(C[nt++]){case 0:for(q=ut=0;ut<st;q=ut+=1)ot[L++]=C[nt++];break;case 1:for(q=ct=0;ct<st;q=ct+=1)$=C[nt++],K=q<rt?0:ot[L-rt],ot[L++]=($+K)%256;break;case 2:for(q=ht=0;ht<st;q=ht+=1)$=C[nt++],z=(q-q%rt)/rt,at=it&&ot[(it-1)*st+z*rt+q%rt],ot[L++]=(at+$)%256;break;case 3:for(q=ft=0;ft<st;q=ft+=1)$=C[nt++],z=(q-q%rt)/rt,K=q<rt?0:ot[L-rt],at=it&&ot[(it-1)*st+z*rt+q%rt],ot[L++]=($+Math.floor((K+at)/2))%256;break;case 4:for(q=dt=0;dt<st;q=dt+=1)$=C[nt++],z=(q-q%rt)/rt,K=q<rt?0:ot[L-rt],0===it?at=lt=0:(at=ot[(it-1)*st+z*rt+q%rt],lt=z&&ot[(it-1)*st+(z-1)*rt+q%rt]),X=K+at-lt,Z=Math.abs(X-K),tt=Math.abs(X-at),et=Math.abs(X-lt),Q=Z<=tt&&Z<=et?K:tt<=et?at:lt,ot[L++]=($+Q)%256;break;default:throw new Error("Invalid filter algorithm: "+C[nt-1])}it++}return ot},o2.prototype.decodePalette=function(){var C,$,L,z,q,K,J,X,Z;for(L=this.palette,K=this.transparency.indexed||[],q=new Uint8Array((K.length||0)+L.length),z=0,L.length,C=0,$=J=0,X=L.length;J<X;$=J+=3)q[z++]=L[$],q[z++]=L[$+1],q[z++]=L[$+2],q[z++]=null!=(Z=K[C++])?Z:255;return q},o2.prototype.copyToImageData=function(C,$){var L,z,q,K,J,X,Z,Q,tt,et,rt;if(z=this.colors,tt=null,L=this.hasAlphaChannel,this.palette.length&&(tt=null!=(rt=this._decodedPalette)?rt:this._decodedPalette=this.decodePalette(),z=4,L=!0),Q=(q=C.data||C).length,J=tt||$,K=X=0,1===z)for(;K<Q;)Z=tt?4*$[K/4]:X,et=J[Z++],q[K++]=et,q[K++]=et,q[K++]=et,q[K++]=L?J[Z++]:this.transparency.grayscale&&this.transparency.grayscale===et?0:255,X=Z;else for(;K<Q;)Z=tt?4*$[K/4]:X,q[K++]=J[Z++],q[K++]=J[Z++],q[K++]=J[Z++],q[K++]=L?J[Z++]:this.transparency.rgb&&this.transparency.rgb[1]===J[Z-3]&&this.transparency.rgb[3]===J[Z-2]&&this.transparency.rgb[5]===J[Z-1]?0:255,X=Z},o2.prototype.decode=function(){var C;return C=new Uint8Array(this.width*this.height*4),this.copyToImageData(C,this.decodePixels()),C},L=C.document&&C.document.createElement("canvas"),z=L&&L.getContext("2d"),$=function(C){var $;return z.width=C.width,z.height=C.height,z.clearRect(0,0,C.width,C.height),z.putImageData(C,0,0),($=new Image).src=L.toDataURL(),$},o2.prototype.decodeFrames=function(C){var L,z,q,K,J,X,Z,Q;if(this.animation){for(Q=[],z=J=0,X=(Z=this.animation.frames).length;J<X;z=++J)L=Z[z],q=C.createImageData(L.width,L.height),K=this.decodePixels(new Uint8Array(L.data)),this.copyToImageData(q,K),L.imageData=q,Q.push(L.image=$(q));return Q}},o2.prototype.renderFrame=function(C,$){var L,z,q;return L=(z=this.animation.frames)[$],q=z[$-1],0===$&&C.clearRect(0,0,this.width,this.height),1===(null!=q?q.disposeOp:void 0)?C.clearRect(q.xOffset,q.yOffset,q.width,q.height):2===(null!=q?q.disposeOp:void 0)&&C.putImageData(q.imageData,q.xOffset,q.yOffset),0===L.blendOp&&C.clearRect(L.xOffset,L.yOffset,L.width,L.height),C.drawImage(L.image,L.xOffset,L.yOffset)},o2.prototype.animate=function(C){var $,L,z,q,K,J,X=this;return L=0,J=this.animation,q=J.numFrames,z=J.frames,K=J.numPlays,($=function(){var J,Z;if(J=L++%q,Z=z[J],X.renderFrame(C,J),q>1&&L/q<K)return X.animation._timeout=setTimeout($,Z.delay)})()},o2.prototype.stopAnimation=function(){var C;return clearTimeout(null!=(C=this.animation)?C._timeout:void 0)},o2.prototype.render=function(C){var $,L;return C._png&&C._png.stopAnimation(),C._png=this,C.width=this.width,C.height=this.height,$=C.getContext("2d"),this.animation?(this.decodeFrames($),this.animate($)):(L=$.createImageData(this.width,this.height),this.copyToImageData(L,this.decodePixels()),$.putImageData(L,0,0))},o2}(self);const Qt=new Set(["jpg","png","bmp","gif"]);async function w$3(C,$){if(!Kt)throw new K("rasterCoded:decode","lerc decoder is not supported on big endian platform");await r$9();const{offset:L}=$,{width:z,height:q,pixelType:J,statistics:X,depthCount:Z,noDataValues:Q,bandMasks:tt,pixels:et,mask:rt}=u$a(C,{inputOffset:L,returnInterleaved:$.returnInterleaved}),ot=new St({width:z,height:q,pixelType:J.toLowerCase(),pixels:et,mask:rt,statistics:X.map((({minValue:C,maxValue:$})=>new vt(C,$))),bandMasks:tt,depthCount:Z,noDataValues:Q});return(null==X?void 0:X.length)||ot.updateStatistics(),ot}async function y$2(C,$){const L=await Y(C,{...$,noDataValue:null});ot(L);const z=new St({width:L.width,height:L.height,pixels:L.pixels,pixelType:L.pixelType.toLowerCase(),mask:L.mask,bandMasks:L.bandMasks,statistics:null});return z.updateStatistics(),z}async function x$2(C,$){const L=await async function H(C,$){const{headerInfo:L,ifd:z,offsets:q,sizes:K}=$,J=[];for(let mt=0;mt<q.length;mt++){K[mt];const $=await M$1(C,L.littleEndian,z,q[mt],K[mt]||C.byteLength);J.push($)}const X=D$3(z,L),Z=p$5(z,"BITSPERSAMPLE"),Q=h$7(p$5(z,"SAMPLEFORMAT")??1,Z),tt=p$5(z,"SAMPLESPERPIXEL")||L.planes,et=g$4(Q),rt=p$5(z,"TILEWIDTH"),ot=p$5(z,"TILELENGTH"),nt=p$5(z,"COMPRESSION")??1,it=rt*ot;let st;const at=[];let lt=J[0];const ut=34887===nt;for(let mt=0;mt<tt;mt++){if(st=new et(it),J.length===tt)lt=J[mt],lt.length===it&&(st=lt);else if(lt.length)if(X||ut)st=lt.length===it?lt:lt.slice(it*mt,it*(mt+1));else for(let C=0;C<it;C++)st[C]=lt[C*tt+mt];at.push(st)}const ct=L.noData?L.noData[0]:$.noDataValue,ht=L.metadata?L.metadata.statistics:null,ft=ht?ht.map((C=>C.min)):null,dt=ht?ht.map((C=>C.max)):null,pt={pixelType:Q,width:rt,height:ot,pixels:at,noDataValue:ct};return null!=ct?l$6(pt,ct):ft&&dt&&$.applyMinMaxConstraint&&(pt.mask=b$3(at,ft,dt)),pt}(C,$.customOptions),z=new St({width:L.width,height:L.height,pixels:L.pixels,pixelType:L.pixelType.toLowerCase(),mask:L.mask,statistics:null});return z.updateStatistics(),z}function b$2(C,$){const L=$.pixelType||"u8",z=St.getPixelArrayConstructor(L),q="u8"===L?C:new z(C.buffer),K=[],J=$.planes||1;if(1===J)K.push(q);else for(let Z=0;Z<J;Z++){const L=($.width||1)*($.height||C.length),X=new z(L);for(let C=0;C<L;C++)X[C]=q[C*J+Z];K.push(X)}const X=new St({width:$.width||1,height:$.height||C.length,pixels:K,pixelType:L,statistics:null});return X.updateStatistics(),X}function k$2(C,$){return b$2(new Pt(new Uint8Array(C)).getBytes(),$)}function T$1(C,$){return b$2(i$5(C,$.offset,$.eof,!$.isInputBigEndian),$)}function I$2(C,$,L){const{pixelTypeCtor:z}=function S$1(C){let $=null,L=null;switch(C?C.toLowerCase():"f32"){case"u1":case"u2":case"u4":case"u8":L=255,$=Uint8Array;break;case"u16":L=L||65535,$=Uint16Array;break;case"u32":L=L||2**32-1,$=Uint32Array;break;case"s8":L=L||-128,$=Int8Array;break;case"s16":L=L||-32768,$=Int16Array;break;case"s32":L=L||0-2**31,$=Int32Array;break;default:$=Float32Array}return{pixelTypeCtor:$,noDataValue:L}}($.pixelType),q=(0,_t.decode)(C,{width:$.width,height:$.height,pixelType:z,format:L}),K=new St({width:$.width,height:$.height,pixels:q.pixels,pixelType:$.pixelType,mask:q.mask,statistics:null});return K.updateStatistics(),K}function C$3(C,$){const L=Gt.decode(C,$.hasNoZlibMask??void 0),z=new St({width:L.width,height:L.height,pixels:L.pixels,pixelType:"u8",mask:L.mask,statistics:null});return z.updateStatistics(),z}function v$3(C,$){const L=new Uint8Array(C),z=new Zt(L),{width:q,height:K}=$,J=q*K,X=z.decode();let Z,Q=0,tt=0;const et=new Uint8Array(J);for(Q=0;Q<J;Q++)et[Q]=X[4*Q+3];const rt=new St({width:q,height:K,pixels:[],pixelType:"u8",mask:et,statistics:[]});for(Q=0;Q<3;Q++){for(Z=new Uint8Array(J),tt=0;tt<J;tt++)Z[tt]=X[4*tt+Q];rt.addData({pixels:Z})}return rt.updateStatistics(),rt}function U$2(C){if(null==C)throw new K("rasterCodec:decode","parameter encodeddata is required.");const $=new Uint8Array(C,0,10);let L="";return 255===$[0]&&216===$[1]?L="jpg":137===$[0]&&80===$[1]&&78===$[2]&&71===$[3]?L="png":67===$[0]&&110===$[1]&&116===$[2]&&90===$[3]&&73===$[4]&&109===$[5]&&97===$[6]&&103===$[7]&&101===$[8]&&32===$[9]?L="lerc":76===$[0]&&101===$[1]&&114===$[2]&&99===$[3]&&50===$[4]&&32===$[5]?L="lerc2":73===$[0]&&73===$[1]&&42===$[2]&&0===$[3]||77===$[0]&&77===$[1]&&0===$[2]&&42===$[3]||73===$[0]&&73===$[1]&&43===$[2]&&0===$[3]||77===$[0]&&77===$[1]&&0===$[2]&&43===$[3]?L="tiff":71===$[0]&&73===$[1]&&70===$[2]?L="gif":66===$[0]&&77===$[1]?L="bmp":String.fromCharCode.apply(null,$).toLowerCase().includes("error")&&(L="error"),L}function P$1(C){let $=U$2(C);return"lerc2"===$?$="lerc":"error"===$&&($=""),$}async function j(C,$={},L){var z;if(null==C)throw new K("rasterCodec:decode","missing encodeddata parameter.");let q=null==(z=$.format)?void 0:z.toLowerCase();if(!("bsq"!==q&&"bip"!==q||null!=$.width&&null!=$.height))throw new K("rasterCodec:decode","requires width and height in options parameter.");if("tiff"===q&&$.customOptions)return x$2(C,$);if((!q||"bsq"!==q&&"bip"!==q&&"deflate"!==q&&"lzw"!==q)&&(q=U$2(C)),$.useCanvas&&Qt.has(q))return async function A$2(C,$,L,z){const q=new Et,K={applyJpegMask:!1,format:$,...L},J=await q.decode(C,K,z),X=new St(J);return X.updateStatistics(),X}(C,q,$,L);const J=function D$2(C){let $=null;switch(C){case"lerc":case"lerc2":$=w$3;break;case"jpg":$=C$3;break;case"png":$=v$3;break;case"bsq":case"bip":$=($,L)=>I$2($,L,C);break;case"tiff":$=y$2;break;case"deflate":$=k$2;break;case"lzw":$=T$1;break;case"error":$=()=>{throw new K("rasterCodec:decode","input data contains error")};break;default:$=()=>{throw new K("rasterCodec:decode","unsupported raster format")}}return $}(q);let X;$.isPoint&&(null!=($={...$}).width&&$.width++,null!=$.height&&$.height++);const{offsets:Z}=$;if(Z&&Z.length>1){const L=Z.map(((L,z)=>J(C.slice(L,Z[z+1]),$))),z=await Promise.all(L);X=z[0],X.pixels=z.map((C=>C.pixels[0]));const q=z.map((C=>C.mask));z.some((C=>null!=C))&&(q.forEach(((C,$)=>{null==C&&(q[$]=new Uint8Array(X.width*X.height).fill(255))})),X.bandMasks=q,X.mask=St.combineBandMasks(q)),X.updateStatistics()}else X=await J(C,{...$,offset:(null==Z?void 0:Z[0])??$.offset});return"jpg"!==q&&null!=$.noDataValue&&1===X.depthCount&&l$6(X,$.noDataValue,{customFloatTolerance:$.tolerance}),$.isPoint&&function O$1(C,$=1){if(!C)return;const{pixels:L,width:z,height:q,mask:K}=C;if(!L||0===L.length)return;const J=L.length,X=z-1,Z=q-1,Q=[];let tt,et,rt,ot,nt,it,st=null;const at=St.getPixelArrayConstructor(C.pixelType);if(0===$){for(tt=0;tt<J;tt++){for(nt=L[tt],it=new at(X*Z),et=0;et<Z;et++)for(ot=et*z,rt=0;rt<X;rt++)it[et*X+rt]=nt[ot+rt];Q.push(it)}if(null!=K)for(st=new Uint8Array(X*Z),et=0;et<Z;et++)for(ot=et*z,rt=0;rt<X;rt++)st[et*X+rt]=K[ot+rt]}else{for(tt=0;tt<J;tt++){for(nt=L[tt],it=new at(X*Z),et=0;et<Z;et++)for(ot=et*z,rt=0;rt<X;rt++)it[et*X+rt]=(nt[ot+rt]+nt[ot+rt+1]+nt[ot+z+rt]+nt[ot+z+rt+1])/4;Q.push(it)}if(K)for(st=new Uint8Array(X*Z),et=0;et<Z;et++)for(ot=et*z,rt=0;rt<X;rt++)st[et*X+rt]=Math.min.apply(null,[K[ot+rt],K[ot+rt+1],K[ot+z+rt],K[ot+z+rt+1]])}C.width=X,C.height=Z,C.mask=st,C.pixels=Q}(X),X}var te,ee,re;(re=te||(te={}))[re.matchAny=0]="matchAny",re[re.matchAll=1]="matchAll",function(C){C[C.bestMatch=0]="bestMatch",C[C.fail=1]="fail"}(ee||(ee={}));const oe=6;function o$4(C){return null!=C&&"esri.layers.support.PixelBlock"===C.declaredClass&&C.pixels&&C.pixels.length>0}function r$4(C){var $;if(!(null==C?void 0:C.length)||C.some((C=>!o$4(C))))return null;if(1===C.length)return(null==($=C[0])?void 0:$.clone())??null;const L=C,{width:z,height:q,pixelType:K}=L[0];if(L.some((C=>C.width!==z||C.height!==q)))return null;const J=L.map((({mask:C})=>C)).filter((C=>null!=C));let X=null;J.length&&(X=new Uint8Array(z*q),X.set(J[0]),J.length>1&&m$4(J.slice(1),X));const Z=[];L.forEach((({pixels:C})=>Z.push(...C)));const Q=L.map((({statistics:C})=>C)).filter((C=>null==C?void 0:C.length)),tt=[];return Q.forEach((C=>tt.push(...C))),new St({pixelType:K,width:z,height:q,mask:X,pixels:Z,statistics:tt.length?tt:null})}function a$7(C){if(!C)return;const $=C.colormap;if(!$||0===$.length)return;const L=$.sort(((C,$)=>C[0]-$[0]));let z=0;L[0][0]<0&&(z=L[0][0]);const q=Math.max(256,L[L.length-1][0]-z+1),K=new Uint8Array(4*q),J=[];let X,Z=0,Q=0;const tt=5===L[0].length;if(q>65536)return L.forEach((C=>{J[C[0]-z]=tt?C.slice(1):C.slice(1).concat([255])})),{indexed2DColormap:J,offset:z,alphaSpecified:tt};if(C.fillUnspecified)for(X=L[Q],Z=X[0]-z;Z<q;Z++)K[4*Z]=X[1],K[4*Z+1]=X[2],K[4*Z+2]=X[3],K[4*Z+3]=tt?X[4]:255,Z===X[0]-z&&(X=Q===L.length-1?X:L[++Q]);else for(Z=0;Z<L.length;Z++)X=L[Z],Q=4*(X[0]-z),K[Q]=X[1],K[Q+1]=X[2],K[Q+2]=X[3],K[Q+3]=tt?X[4]:255;return{indexedColormap:K,offset:z,alphaSpecified:tt}}function h$6(C,$){if(!o$4(C))return C;if(!$||!$.indexedColormap&&!$.indexed2DColormap)return C;const L=C.clone(),z=L.pixels;let q=L.mask;const K=L.width*L.height;if(1!==z.length)return C;const{indexedColormap:J,indexed2DColormap:X,offset:Z,alphaSpecified:Q}=$;let tt=0;const et=z[0],rt=new Uint8Array(et.length),ot=new Uint8Array(et.length),nt=new Uint8Array(et.length);let it,st=0;if(J){const C=J.length-1;if(null!=q)for(tt=0;tt<K;tt++)q[tt]&&(st=4*(et[tt]-Z),st<Z||st>C?q[tt]=0:(rt[tt]=J[st],ot[tt]=J[st+1],nt[tt]=J[st+2],q[tt]=J[st+3]));else{for(q=new Uint8Array(K),tt=0;tt<K;tt++)st=4*(et[tt]-Z),st<Z||st>C?q[tt]=0:(rt[tt]=J[st],ot[tt]=J[st+1],nt[tt]=J[st+2],q[tt]=J[st+3]);L.mask=q}}else if(X)if(null!=q)for(tt=0;tt<K;tt++)q[tt]&&(it=X[et[tt]],rt[tt]=it[0],ot[tt]=it[1],nt[tt]=it[2],q[tt]=it[3]);else{for(q=new Uint8Array(K),tt=0;tt<K;tt++)it=X[et[tt]],rt[tt]=it[0],ot[tt]=it[1],nt[tt]=it[2],q[tt]=it[3];L.mask=q}return L.pixels=[rt,ot,nt],L.statistics=null,L.pixelType="u8",L.maskIsAlpha=Q,L}function f$5(C,$){if(!o$4(C))return null;const{pixels:L,mask:z}=C,q=L.length;let K=$.lut;const{offset:J}=$;K&&1===K[0].length&&(K=L.map((()=>K)));const X=[],Z=$.outputPixelType||"u8";for(let tt=0;tt<q;tt++){const C=c$6(L[tt],z,K[tt],J||0,Z);X.push(C)}const Q=new St({width:C.width,height:C.height,pixels:X,mask:z,pixelType:Z});return Q.updateStatistics(),Q}function c$6(C,$,L,z,q){const K=C.length,J=St.createEmptyBand(q,K);if($)for(let X=0;X<K;X++)$[X]&&(J[X]=L[C[X]-z]);else for(let X=0;X<K;X++)J[X]=L[C[X]-z];return J}function p$4(C,$){if(!o$4(C))return null;const{width:L,height:z}=C,{inputRanges:q,outputValues:K,outputPixelType:J,noDataRanges:X,allowUnmatched:Z,isLastInputRangeInclusive:Q}=$,tt=C.pixels[0],et=St.createEmptyBand(J,tt.length),rt=C.mask,ot=new Uint8Array(L*z);rt?ot.set(rt):ot.fill(255);const nt=C.pixelType.startsWith("f")?1e-6:0,it=q.map((C=>C-nt));it[0]=q[0],it[it.length-1]=q[q.length-1]+(Q?1e-6:0);const st=q.length/2,[at,lt]=s$7(J);for(let ct=0;ct<z;ct++)for(let C=0;C<L;C++){const $=ct*L+C;if(ot[$]){const C=tt[$];let L=!1;for(let z=st-1;z>=0;z--)if(C===it[2*z]||C>it[2*z]&&C<it[2*z+1]){et[$]=K[z],L=!0;break}L||(Z?et[$]=C>lt?lt:C<at?at:C:ot[$]=0)}}const ut=null==X?void 0:X.length;if(ut)for(let ct=0;ct<z;ct++)for(let C=0;C<L;C++){const $=ct*L+C;if(!rt||rt[$]){const C=tt[$];for(let L=0;L<ut;L+=2)if(C>=X[L]&&C<=X[L+1]){et[$]=0,ot[$]=0;break}}}return new St({width:L,height:z,pixelType:J,pixels:[et],mask:ot})}function x$1(C,$,L,z){const q=null!=L&&L.length>=2?new Set(L):null,K=1===(null==L?void 0:L.length)?L[0]:null,J=!!(null==$?void 0:$.length);for(let X=0;X<C.length;X++)if(z[X]){const L=C[X];if(J){let C=!1;for(let z=0;z<$.length;z+=2)if(L>=$[z]&&L<=$[z+1]){C=!0;break}C||(z[X]=0)}z[X]&&(L===K||(null==q?void 0:q.has(L)))&&(z[X]=0)}}function d$3(C,$){const L=C[0].length;for(let z=0;z<L;z++)if($[z]){let L=!1;for(let $=0;$<C.length;$++)if(C[$][z]){L=!0;break}L||($[z]=0)}}function m$4(C,$){const L=C[0].length;for(let z=0;z<L;z++)if($[z]){let L=!1;for(let $=0;$<C.length;$++)if(0===C[$][z]){L=!0;break}L&&($[z]=0)}}function g$2(C,$){if(!o$4(C))return null;const{width:L,height:z,pixels:q}=C,K=L*z,J=new Uint8Array(K);C.mask?J.set(C.mask):J.fill(255);const X=q.length,{includedRanges:Z,noDataValues:Q,outputPixelType:tt,matchAll:et,lookups:rt}=$;if(rt){const C=[];for(let $=0;$<X;$++){const L=rt[$],z=c$6(q[$],J,L.lut,L.offset||0,"u8");C.push(z)}1===C.length?J.set(C[0]):et?d$3(C,J):m$4(C,J)}else if(et){const C=[];for(let $=0;$<X;$++){const L=new Uint8Array(K);L.set(J),x$1(q[$],null==Z?void 0:Z.slice(2*$,2*$+2),null==Q?void 0:Q[$],L),C.push(L)}1===C.length?J.set(C[0]):d$3(C,J)}else for(let ot=0;ot<X;ot++)x$1(q[ot],null==Z?void 0:Z.slice(2*ot,2*ot+2),null==Q?void 0:Q[ot],J);return new St({width:L,height:z,pixelType:tt,pixels:q,mask:J})}function y$1(C){const{srcPixelType:$,inputRanges:L,outputValues:z,allowUnmatched:q,noDataRanges:K,isLastInputRangeInclusive:J,outputPixelType:X}=C;if("u8"!==$&&"s8"!==$&&"u16"!==$&&"s16"!==$)return null;const Z=$.includes("16")?65536:256,Q=$.includes("s")?-Z/2:0,tt=St.createEmptyBand(X,Z),et=new Uint8Array(Z);q&&et.fill(255);const[rt,ot]=s$7(X);if((null==L?void 0:L.length)&&(null==z?void 0:z.length)){const C=1e-6,$=L.map(($=>$-C));$[0]=L[0],J&&($[$.length-1]=L[L.length-1]);for(let L=0;L<$.length;L++){const C=z[L]>ot?ot:z[L]<rt?rt:z[L],q=Math.ceil($[2*L]-Q),K=Math.floor($[2*L+1]-Q);for(let $=q;$<=K;$++)tt[$]=C,et[$]=255}}if(null==K?void 0:K.length)for(let nt=0;nt<K.length;nt++){const C=Math.ceil(K[2*nt]-Q),$=Math.floor(K[2*nt+1]-Q);for(let L=C;L<=$;L++)et[L]=0}return{lut:tt,offset:Q,mask:et}}function w$2(C,$,L){if("u8"!==C&&"s8"!==C&&"u16"!==C&&"s16"!==C)return null;const z=C.includes("16")?65536:256,q=C.includes("s")?-z/2:0,K=new Uint8Array(z);if($)for(let J=0;J<$.length;J++){const C=Math.ceil($[2*J]-q),L=Math.floor($[2*J+1]-q);for(let $=C;$<=L;$++)K[$]=255}else K.fill(255);if(L)for(let J=0;J<L.length;J++)K[L[J]-q]=0;return{lut:K,offset:q}}function A$1(C,$,L,z,q,K){const{width:J,height:X}=L.block,{x:Z,y:Q}=L.offset,{width:tt,height:et}=L.mosaic,rt=function k$1(C,$,L,z,q,K,J,X){return{xmin:q<=L*C?0:q<L*C+C?q-L*C:C,ymin:K<=z*$?0:K<z*$+$?K-z*$:$,xmax:q+J<=L*C?0:q+J<L*C+C?q+J-L*C:C,ymax:K+X<=z*$?0:K+X<z*$+$?K+X-z*$:$}}(J,X,z,q,Z,Q,tt,et);let ot=0,nt=0;if(K){const C=K.hasGCSSShiftTransform?360:K.halfWorldWidth??0,$=J*K.resolutionX,L=K.startX+z*$;L<C&&L+$>C?nt=K.rightPadding:L>=C&&(ot=K.leftMargin-K.rightPadding,nt=0)}if(rt.xmax-=nt,"number"!=typeof $)for(let it=rt.ymin;it<rt.ymax;it++){const L=(q*X+it-Q)*tt+(z*J-Z)+ot,K=it*J;for(let z=rt.xmin;z<rt.xmax;z++)C[L+z]=$[K+z]}else for(let it=rt.ymin;it<rt.ymax;it++){const L=(q*X+it-Q)*tt+(z*J-Z)+ot;for(let z=rt.xmin;z<rt.xmax;z++)C[L+z]=$}}function U$1(C,$,L={}){var z;const{clipOffset:q,clipSize:K,alignmentInfo:J,blockWidths:X}=L;if(X)return function b$1(C,$,L){var z;const q=C.find((C=>null!=C));if(null==q)return null;const K=C.some((C=>null==C||!!C.mask)),{width:J,height:X}=$,Z=K?new Uint8Array(J*X):null,{blockWidths:Q}=L,tt=[],et=q.getPlaneCount(),rt=St.getPixelArrayConstructor(q.pixelType);if(K)for(let at=0,lt=0;at<C.length;lt+=Q[at],at++){const $=C[at];if(!o$4($))continue;const L=$.mask;for(let C=0;C<X;C++)for(let z=0;z<Q[at];z++)Z[C*J+z+lt]=null==L?255:L[C*$.width+z]}const ot=C.some((C=>(null==C?void 0:C.bandMasks)&&C.bandMasks.length>1)),nt=ot?[]:void 0,it=J*X;for(let at=0;at<et;at++){const $=new rt(it),L=ot?new Uint8Array(it):void 0;for(let q=0,K=0;q<C.length;K+=Q[q],q++){const Z=C[q];if(!o$4(Z))continue;const tt=Z.pixels[at];if(null!=tt){for(let C=0;C<X;C++)for(let L=0;L<Q[q];L++)$[C*J+L+K]=tt[C*Z.width+L];if(L){const C=(null==(z=Z.bandMasks)?void 0:z[at])??Z.mask;for(let $=0;$<X;$++)for(let z=0;z<Q[q];z++)L[$*J+z+K]=C?C[$*Z.width+z]:255}}}tt.push($),nt&&L&&nt.push(L)}const st=new St({width:J,height:X,mask:Z,bandMasks:nt,pixels:tt,pixelType:q.pixelType});return st.updateStatistics(),st}(C,$,{blockWidths:X});const Z=C.find((C=>o$4(C)));if(null==Z)return null;const Q=K?K.width:$.width,tt=K?K.height:$.height,et=Z.width,rt=Z.height,ot=$.width/et,nt=$.height/rt,it={offset:q||{x:0,y:0},mosaic:K||$,block:{width:et,height:rt}},st=Z.pixelType,at=St.getPixelArrayConstructor(st),lt=Z.pixels.length,ut=[];let ct,ht;for(let yt=0;yt<lt;yt++){ht=new at(Q*tt);for(let $=0;$<nt;$++)for(let L=0;L<ot;L++){const z=C[$*ot+L];o$4(z)&&(ct=z.pixels[yt],A$1(ht,ct,it,L,$,J))}ut.push(ht)}const ft=C.some((C=>null==C||null!=C.mask&&C.mask.length>0)),dt=C.some((C=>(null==C?void 0:C.bandMasks)&&C.bandMasks.length>1)),pt=ft?new Uint8Array(Q*tt):void 0,mt=dt?[]:void 0;if(pt){for(let $=0;$<nt;$++)for(let L=0;L<ot;L++){const z=C[$*ot+L],q=null!=z?z.mask:null;A$1(pt,null!=q?q:z?255:0,it,L,$,J)}if(mt)for(let $=0;$<lt;$++){const L=new Uint8Array(Q*tt);for(let q=0;q<nt;q++)for(let K=0;K<ot;K++){const X=C[q*ot+K],Z=(null==(z=null==X?void 0:X.bandMasks)?void 0:z[$])??(null==X?void 0:X.mask);A$1(L,null!=Z?Z:X?255:0,it,K,q,J)}mt.push(L)}}const gt=new St({width:Q,height:tt,pixels:ut,pixelType:st,bandMasks:mt,mask:pt});return gt.updateStatistics(),gt}function T(C,$,L){if(!o$4(C))return null;const{width:z,height:q}=C,K=$.x,J=$.y,X=L.width+K,Z=L.height+J;if(K<0||J<0||X>z||Z>q)return C;if(0===K&&0===J&&X===z&&Z===q)return C;C.mask||(C.mask=new Uint8Array(z*q));const Q=C.mask;for(let tt=0;tt<q;tt++){const C=tt*z;for(let $=0;$<z;$++)Q[C+$]=tt<J||tt>=Z||$<K||$>=X?0:1}return C.updateStatistics(),C}function B$1(C){if(0===C.size)return 0;let $=0,L=-1,z=0;const q=C.keys();let K=q.next();for(;!K.done;)z=C.get(K.value),z>$&&(L=K.value,$=z),K=q.next();return L}function C$2(C,$,L){if(0===L)return;const z=C.get($);1===z?C.delete($):C.set($,z-1)}function S(C,$,L){0!==L&&C.set($,C.has($)?C.get($)+1:1)}function P(C,$,L){let{x:z,y:q}=$;const{width:K,height:J}=L;if(0===z&&0===q&&J===C.height&&K===C.width)return C;const{width:X,height:Z}=C,Q=Math.max(0,q),tt=Math.max(0,z),et=Math.min(z+K,X),rt=Math.min(q+J,Z);if(et<0||rt<0||!o$4(C))return null;z=Math.max(0,-z),q=Math.max(0,-q);const{pixels:ot}=C,nt=K*J,it=ot.length,st=[];for(let ct=0;ct<it;ct++){const $=ot[ct],L=St.createEmptyBand(C.pixelType,nt);for(let C=Q;C<rt;C++){const J=C*X;let Z=(C+q-Q)*K+z;for(let C=tt;C<et;C++)L[Z++]=$[J+C]}st.push(L)}const at=new Uint8Array(nt),lt=C.mask;for(let ct=Q;ct<rt;ct++){const C=ct*X;let $=(ct+q-Q)*K+z;for(let L=tt;L<et;L++)at[$++]=lt?lt[C+L]:1}const ut=new St({width:L.width,height:L.height,pixelType:C.pixelType,pixels:st,mask:at});return ut.updateStatistics(),ut}function _$1(C,$=!0){if(!o$4(C))return null;const{pixels:L,width:z,height:q,mask:K,pixelType:J}=C,X=[],Z=Math.round(z/2),Q=Math.round(q/2),tt=q-1,et=z-1;for(let ot=0;ot<L.length;ot++){const C=L[ot],K=St.createEmptyBand(J,Z*Q);let rt=0;for(let L=0;L<q;L+=2)for(let q=0;q<z;q+=2){const J=C[L*z+q];if($){const $=q===et?J:C[L*z+q+1],X=L===tt?J:C[L*z+q+z],Z=q===et?X:L===tt?$:C[L*z+q+z+1];K[rt++]=(J+$+X+Z)/4}else K[rt++]=J}X.push(K)}let rt=null;if(null!=K){rt=new Uint8Array(Z*Q);let C=0;for(let L=0;L<q;L+=2)for(let q=0;q<z;q+=2){const J=K[L*z+q];if($){const $=q===et?J:K[L*z+q+1],X=L===tt?J:K[L*z+q+z],Z=q===et?X:L===tt?$:K[L*z+q+z+1];rt[C++]=J*$*X*Z?1:0}else rt[C++]=J}}return new St({width:Z,height:Q,pixelType:J,pixels:X,mask:rt})}function W(C,$,L=0,z=!0){if(!o$4(C))return null;const{width:q,height:K}=$;let{width:J,height:X}=C;const Z=new Map,Q={x:0,y:0},tt=1+L;let et=C;for(let rt=0;rt<tt;rt++){const C=Math.ceil(J/q),L=Math.ceil(X/K);for(let z=0;z<L;z++){Q.y=z*K;for(let L=0;L<C;L++){Q.x=L*q;const C=P(et,Q,$);Z.set(`${rt}/${z}/${L}`,C)}}rt<tt-1&&(et=_$1(et,z)),J=Math.round(J/2),X=Math.round(X/2)}return Z}function E(C){const{pixelBlock:$,tileSize:L,level:z,row:q,col:K,useBilinear:J}=C;if(!o$4($))return null;const{width:X,height:Z}=L,Q=2**z,tt=Q*X,et=Q*Z;let rt=P($,{y:q*et,x:K*tt},{width:tt,height:et});if(!rt)return null;for(let ot=z;ot>0;ot--)rt=_$1(rt,J);return rt}function I$1(C,$,L,z,q=0){const{width:K,height:J}=C,{width:X,height:Z}=$,Q=z.cols,tt=z.rows,et=Math.ceil(X/Q-.1/Q),rt=Math.ceil(Z/tt-.1/tt);let ot,nt,it,st,at,lt,ut;const ct=et*Q,ht=ct*rt*tt,ft=new Float32Array(ht),dt=new Float32Array(ht),pt=new Uint32Array(ht),mt=new Uint32Array(ht);let gt,yt,wt=0;for(let vt=0;vt<rt;vt++)for(let C=0;C<et;C++){ot=12*(vt*et+C),nt=L[ot],it=L[ot+1],st=L[ot+2],at=L[ot+3],lt=L[ot+4],ut=L[ot+5];for(let $=0;$<tt;$++){wt=(vt*tt+$)*ct+C*Q,yt=($+.5)/tt;for(let C=0;C<$;C++)gt=(C+.5)/Q,ft[wt+C]=(nt*gt+it*yt+st)*K+q,dt[wt+C]=(at*gt+lt*yt+ut)*J+q,pt[wt+C]=Math.floor(ft[wt+C]),mt[wt+C]=Math.floor(dt[wt+C])}ot+=6,nt=L[ot],it=L[ot+1],st=L[ot+2],at=L[ot+3],lt=L[ot+4],ut=L[ot+5];for(let $=0;$<tt;$++){wt=(vt*tt+$)*ct+C*Q,yt=($+.5)/tt;for(let C=$;C<Q;C++)gt=(C+.5)/Q,ft[wt+C]=(nt*gt+it*yt+st)*K+q,dt[wt+C]=(at*gt+lt*yt+ut)*J+q,pt[wt+C]=Math.floor(ft[wt+C]),mt[wt+C]=Math.floor(dt[wt+C])}}return{offsets_x:ft,offsets_y:dt,offsets_xi:pt,offsets_yi:mt,gridWidth:ct}}function R$1(C,$){const{coefficients:L,spacing:z}=$,{offsets_x:q,offsets_y:K,gridWidth:J}=I$1(C,C,L,{rows:z[0],cols:z[1]}),{width:X,height:Z}=C,Q=new Float32Array(X*Z),tt=180/Math.PI;for(let et=0;et<Z;et++)for(let C=0;C<X;C++){const $=et*J+C,L=0===et?$:$-J,z=et===Z-1?$:$+J,rt=q[L]-q[z],ot=K[z]-K[L];if(isNaN(rt)||isNaN(ot))Q[et*X+C]=90;else{let $=Math.atan2(ot,rt)*tt;$=(360+$)%360,Q[et*X+C]=$}}return Q}function D$1(C,$,L,z,q="nearest"){if(!o$4(C))return null;"majority"===q&&(C=function v$2(C){if(!o$4(C))return null;const $=C.clone(),{width:L,height:z,pixels:q}=C,K=q[0],J=$.pixels[0],X=C.mask;for(let Z=2;Z<z-1;Z++){const C=new Map;for(let z=Z-2;z<Z+2;z++)for(let $=0;$<4;$++){const q=z*L+$;S(C,K[q],X?X[q]:1)}J[Z*L]=B$1(C),J[Z*L+1]=J[Z*L+2]=J[Z*L];let $=3;for(;$<L-1;$++){let z=(Z-2)*L+$+1;S(C,K[z],X?X[z]:1),z=(Z-1)*L+$+1,S(C,K[z],X?X[z]:1),z=Z*L+$+1,S(C,K[z],X?X[z]:1),z=(Z+1)*L+$+1,S(C,K[z],X?X[z]:1),z=(Z-2)*L+$-3,C$2(C,K[z],X?X[z]:1),z=(Z-1)*L+$-3,C$2(C,K[z],X?X[z]:1),z=Z*L+$-3,C$2(C,K[z],X?X[z]:1),z=(Z+1)*L+$-3,C$2(C,K[z],X?X[z]:1),J[Z*L+$]=B$1(C)}J[Z*L+$+1]=J[Z*L+$]}for(let Z=0;Z<L;Z++)J[Z]=J[L+Z]=J[2*L+Z],J[(z-1)*L+Z]=J[(z-2)*L+Z];return $.updateStatistics(),$}(C));const{pixels:K,mask:J,bandMasks:X,pixelType:Z}=C,Q=C.width,tt=C.height,et=St.getPixelArrayConstructor(Z),rt=K.length,{width:ot,height:nt}=$;let it=!1;for(let yt=0;yt<L.length;yt+=3)-1===L[yt]&&-1===L[yt+1]&&-1===L[yt+2]&&(it=!0);const{offsets_x:st,offsets_y:at,offsets_xi:lt,offsets_yi:ut,gridWidth:ct}=I$1({width:Q,height:tt},$,L,z,"majority"===q?.5:0);let ht;const b2=(C,$,L,z)=>{const q=C instanceof Float32Array||C instanceof Float64Array?0:.5;for(let K=0;K<nt;K++){ht=K*ct;for(let J=0;J<ot;J++){if(st[ht]<0||at[ht]<0)C[K*ot+J]=0;else if(z)C[K*ot+J]=$[lt[ht]+ut[ht]*Q];else{const z=Math.floor(st[ht]),X=Math.floor(at[ht]),Z=Math.ceil(st[ht]),tt=Math.ceil(at[ht]),et=st[ht]-z,rt=at[ht]-X;if(!L||L[z+X*Q]&&L[Z+X*Q]&&L[z+tt*Q]&&L[Z+tt*Q]){const L=(1-et)*$[z+X*Q]+et*$[Z+X*Q],nt=(1-et)*$[z+tt*Q]+et*$[Z+tt*Q];C[K*ot+J]=(1-rt)*L+rt*nt+q}else C[K*ot+J]=$[lt[ht]+ut[ht]*Q]}ht++}}},ft=[];let dt;const pt=(null==X?void 0:X.length)===rt,mt=[];for(let yt=0;yt<rt;yt++){if(pt){const C=new Uint8Array(ot*nt);b2(C,X[yt],X[yt],!0),mt.push(C)}dt=new et(ot*nt),b2(dt,K[yt],pt?X[yt]:J,"nearest"===q||"majority"===q),ft.push(dt)}const gt=new St({width:ot,height:nt,pixelType:Z,pixels:ft,bandMasks:pt?mt:void 0});if(null!=J)gt.mask=new Uint8Array(ot*nt),b2(gt.mask,J,J,!0);else if(it){gt.mask=new Uint8Array(ot*nt);for(let C=0;C<ot*nt;C++)gt.mask[C]=st[C]<0||at[C]<0?0:1}return gt.updateStatistics(),gt}var ne;function n$5(C){return C=Number(C),isNaN(C)?void 0:C}let ie=ne=class extends q{constructor(){super(...arguments),this.name=null,this.minWavelength=void 0,this.maxWavelength=void 0,this.radianceBias=void 0,this.radianceGain=void 0,this.reflectanceBias=void 0,this.reflectanceGain=void 0,this.solarIrradiance=void 0}clone(){return new ne({name:this.name,minWavelength:this.minWavelength,maxWavelength:this.maxWavelength,radianceBias:this.radianceBias,radianceGain:this.radianceGain,reflectanceBias:this.reflectanceBias,reflectanceGain:this.reflectanceGain,solarIrradiance:this.solarIrradiance})}};C([$({json:{name:"BandName",write:!0}})],ie.prototype,"name",void 0),C([$({json:{name:"WavelengthMin",read:{reader:n$5},write:!0}})],ie.prototype,"minWavelength",void 0),C([$({json:{name:"WavelengthMax",read:{reader:n$5},write:!0}})],ie.prototype,"maxWavelength",void 0),C([$({json:{name:"RadianceBias",read:{reader:n$5},write:!0}})],ie.prototype,"radianceBias",void 0),C([$({json:{name:"RadianceGain",read:{reader:n$5},write:!0}})],ie.prototype,"radianceGain",void 0),C([$({json:{name:"ReflectanceBias",read:{reader:n$5},write:!0}})],ie.prototype,"reflectanceBias",void 0),C([$({json:{name:"ReflectanceGain",read:{reader:n$5},write:!0}})],ie.prototype,"reflectanceGain",void 0),C([$({json:{name:"SolarIrradiance",read:{reader:n$5},write:!0}})],ie.prototype,"solarIrradiance",void 0),ie=ne=C([z("esri.layers.support.RasterBandInfo")],ie);const se=ie;var ae;function a$6(C){return C=Number(C),isNaN(C)?void 0:C}let le=ae=class extends q{constructor(){super(...arguments),this.acquisitionDate=void 0,this.cloudCover=void 0,this.productName=void 0,this.sensorName=null,this.sensorAzimuth=void 0,this.sensorElevation=void 0,this.sunAzimuth=void 0,this.sunElevation=void 0}readAcquisitionDate(C){return new Date(C)}writeAcquisitionDate(C,$){$.AcquisitionDate=C.getTime()}clone(){return new ae({acquisitionDate:this.acquisitionDate,cloudCover:this.cloudCover,productName:this.productName,sensorName:this.sensorName,sensorAzimuth:this.sensorAzimuth,sensorElevation:this.sensorElevation,sunAzimuth:this.sunAzimuth,sunElevation:this.sunElevation})}};C([$({json:{name:"AcquisitionDate",write:!0}})],le.prototype,"acquisitionDate",void 0),C([nt("acquisitionDate")],le.prototype,"readAcquisitionDate",null),C([it("acquisitionDate")],le.prototype,"writeAcquisitionDate",null),C([$({json:{name:"CloudCover",read:{reader:a$6},write:!0}})],le.prototype,"cloudCover",void 0),C([$({json:{name:"ProductName",write:!0}})],le.prototype,"productName",void 0),C([$({json:{name:"SensorName",write:!0}})],le.prototype,"sensorName",void 0),C([$({json:{name:"SensorAzimuth",read:{reader:a$6},write:!0}})],le.prototype,"sensorAzimuth",void 0),C([$({json:{name:"SensorElevation",read:{reader:a$6},write:!0}})],le.prototype,"sensorElevation",void 0),C([$({json:{name:"SunAzimuth",read:{reader:a$6},write:!0}})],le.prototype,"sunAzimuth",void 0),C([$({json:{name:"SunElevation",read:{reader:a$6},write:!0}})],le.prototype,"sunElevation",void 0),le=ae=C([z("esri.layers.support.RasterSensorInfo")],le);const ue=le;var ce;let he=ce=class extends q{constructor(){super(...arguments),this.blockWidth=void 0,this.blockHeight=void 0,this.compression=null,this.origin=null,this.firstPyramidLevel=null,this.maximumPyramidLevel=null,this.pyramidScalingFactor=2,this.pyramidBlockWidth=null,this.pyramidBlockHeight=null,this.isVirtualTileInfo=!1,this.tileInfo=null,this.transposeInfo=null,this.blockBoundary=null}clone(){return new ce({blockWidth:this.blockWidth,blockHeight:this.blockHeight,compression:this.compression,origin:J(this.origin),firstPyramidLevel:this.firstPyramidLevel,maximumPyramidLevel:this.maximumPyramidLevel,pyramidResolutions:J(this.pyramidResolutions),pyramidScalingFactor:this.pyramidScalingFactor,pyramidBlockWidth:this.pyramidBlockWidth,pyramidBlockHeight:this.pyramidBlockHeight,isVirtualTileInfo:this.isVirtualTileInfo,tileInfo:J(this.tileInfo),transposeInfo:J(this.transposeInfo),blockBoundary:J(this.blockBoundary)})}};C([$({type:Number,json:{write:!0}})],he.prototype,"blockWidth",void 0),C([$({type:Number,json:{write:!0}})],he.prototype,"blockHeight",void 0),C([$({type:String,json:{write:!0}})],he.prototype,"compression",void 0),C([$({type:st,json:{write:!0}})],he.prototype,"origin",void 0),C([$({type:Number,json:{write:!0}})],he.prototype,"firstPyramidLevel",void 0),C([$({type:Number,json:{write:!0}})],he.prototype,"maximumPyramidLevel",void 0),C([$({json:{write:!0}})],he.prototype,"pyramidResolutions",void 0),C([$({type:Number,json:{write:!0}})],he.prototype,"pyramidScalingFactor",void 0),C([$({type:Number,json:{write:!0}})],he.prototype,"pyramidBlockWidth",void 0),C([$({type:Number,json:{write:!0}})],he.prototype,"pyramidBlockHeight",void 0),C([$({type:Boolean,json:{write:!0}})],he.prototype,"isVirtualTileInfo",void 0),C([$({json:{write:!0}})],he.prototype,"tileInfo",void 0),C([$()],he.prototype,"transposeInfo",void 0),C([$()],he.prototype,"blockBoundary",void 0),he=ce=C([z("esri.layers.support.RasterStorageInfo")],he);const fe=he;var de;let pe=de=class extends q{constructor(C){super(C),this.attributeTable=null,this.bandCount=null,this.colormap=null,this.extent=null,this.format=void 0,this.height=null,this.width=null,this.histograms=null,this.keyProperties={},this.multidimensionalInfo=null,this.noDataValue=null,this.pixelSize=null,this.pixelType=null,this.isPseudoSpatialReference=!1,this.spatialReference=null,this.statistics=null,this.storageInfo=null,this.transform=null}get bandInfos(){const C=this.keyProperties.BandProperties,{bandCount:$}=this;if(!(null==C?void 0:C.length)||C.length<$){const C=[];for(let L=1;L<=$;L++)C.push(new se({name:"band_"+L}));return C}const L=C.map((C=>se.fromJSON(C)));for(let z=0;z<L.length;z++)L[z].name=L[z].name||"band_"+(z+1);return L}get dataType(){var C,$;const L=(null==($=null==(C=this.keyProperties)?void 0:C.DataType)?void 0:$.toLowerCase())??"generic";return"stdtime"===L?"standard-time":L}get nativeExtent(){return this._get("nativeExtent")||this.extent}set nativeExtent(C){C&&this._set("nativeExtent",C)}get nativePixelSize(){if(null==this.transform||!this.transform.affectsPixelSize)return this.pixelSize;const C=this.nativeExtent;return{x:C.width/this.width,y:C.height/this.height}}get hasMultidimensionalTranspose(){var C;return!!(null==(C=this.storageInfo)?void 0:C.transposeInfo)}get sensorInfo(){var C;if(null==(C=this.keyProperties)?void 0:C.SensorName)return ue.fromJSON(this.keyProperties)}clone(){return new de({attributeTable:J(this.attributeTable),bandCount:this.bandCount,colormap:J(this.colormap),extent:J(this.extent),format:this.format,height:this.height,width:this.width,histograms:J(this.histograms),keyProperties:J(this.keyProperties),multidimensionalInfo:J(this.multidimensionalInfo),noDataValue:this.noDataValue,pixelSize:J(this.pixelSize),pixelType:this.pixelType,isPseudoSpatialReference:this.isPseudoSpatialReference,spatialReference:J(this.spatialReference),statistics:J(this.statistics),storageInfo:J(this.storageInfo),transform:J(this.transform)})}};C([$({json:{write:!0}})],pe.prototype,"attributeTable",void 0),C([$({json:{write:!0}})],pe.prototype,"bandCount",void 0),C([$({readOnly:!0})],pe.prototype,"bandInfos",null),C([$({json:{write:!0}})],pe.prototype,"colormap",void 0),C([$({type:String,readOnly:!0})],pe.prototype,"dataType",null),C([$({type:at,json:{write:!0}})],pe.prototype,"extent",void 0),C([$({type:at,json:{write:!0}})],pe.prototype,"nativeExtent",null),C([$({json:{write:!0}})],pe.prototype,"nativePixelSize",null),C([$({json:{write:!0}})],pe.prototype,"format",void 0),C([$({json:{write:!0}})],pe.prototype,"height",void 0),C([$({json:{write:!0}})],pe.prototype,"width",void 0),C([$({json:{write:!0}})],pe.prototype,"hasMultidimensionalTranspose",null),C([$({json:{write:!0}})],pe.prototype,"histograms",void 0),C([$({json:{write:!0}})],pe.prototype,"keyProperties",void 0),C([$({json:{write:!0}})],pe.prototype,"multidimensionalInfo",void 0),C([$({json:{write:!0}})],pe.prototype,"noDataValue",void 0),C([$({json:{write:!0}})],pe.prototype,"pixelSize",void 0),C([$({json:{write:!0}})],pe.prototype,"pixelType",void 0),C([$()],pe.prototype,"isPseudoSpatialReference",void 0),C([$({readOnly:!0})],pe.prototype,"sensorInfo",null),C([$({type:lt,json:{write:!0}})],pe.prototype,"spatialReference",void 0),C([$({json:{write:!0}})],pe.prototype,"statistics",void 0),C([$({type:fe,json:{write:!0}})],pe.prototype,"storageInfo",void 0),C([$({json:{write:!0}})],pe.prototype,"transform",void 0),pe=de=C([z("esri.layers.support.RasterInfo")],pe);const me=pe,ge=1,ye=1/111e3;function o$2(C){let{altitude:$,azimuth:L}=C;const{hillshadeType:z,pixelSizePower:q=1,pixelSizeFactor:K=1,scalingType:J,isGCS:X,resolution:Z}=C,Q="multi-directional"===z?2*C.zFactor:C.zFactor,{x:tt,y:et}=Z;let rt=Q/(8*tt),ot=Q/(8*et);if(X&&Q>.001&&(rt/=ye,ot/=ye),"adjusted"===J)if(X){const C=tt*ye,$=et*ye;rt=(Q+C**q*K)/(8*C),ot=(Q+$**q*K)/(8*$)}else rt=(Q+tt**q*K)/(8*tt),ot=(Q+et**q*K)/(8*et);let nt=(90-$)*Math.PI/180,it=Math.cos(nt),st=(360-L+90)*Math.PI/180,at=Math.sin(nt)*Math.cos(st),lt=Math.sin(nt)*Math.sin(st);const ut=[315,270,225,360,180,0],ct=[60,60,60,60,60,90],ht=new Float32Array([3,5,3,2,1,4]),ft=ht.reduce(((C,$)=>C+$)),dt=ht.map((C=>C/ft)),pt="multi-directional"===z?ut.length:1,mt=new Float32Array(6),gt=new Float32Array(6),yt=new Float32Array(6);if("multi-directional"===z)for(let wt=0;wt<pt;wt++)$=ct[wt],L=ut[wt],nt=(90-$)*Math.PI/180,it=Math.cos(nt),st=(360-L+90)*Math.PI/180,at=Math.sin(nt)*Math.cos(st),lt=Math.sin(nt)*Math.sin(st),mt[wt]=it,gt[wt]=at,yt[wt]=lt;else mt.fill(it),gt.fill(at),yt.fill(lt);return{resolution:Z,factor:[rt,ot],sinZcosA:at,sinZsinA:lt,cosZ:it,sinZcosAs:gt,sinZsinAs:yt,cosZs:mt,weights:dt,hillshadeType:["traditional","multi-directional"].indexOf(z)}}function a$5(C,$){const{width:L,height:z}=C,q=L*z,K=new Uint8Array(q),J=null!=C.mask;let X;if(J){X=new Uint8Array(C.mask);for(let C=0;C<X.length;C++)X[C]&&(K[C]=1,X[C]=1)}const Z=C.pixels[0],Q=new Float32Array(q),tt=new Float32Array(q);let et,rt=0;if($){const{resolution:C}=$,L=C?(C.x+C.y)/2:1;rt=200*$.zFactor/(L*L),et=new Float32Array(q)}const ot=null==$?void 0:$.curvatureType;let nt,it,st,at,lt,ut,ct,ht;for(let ft=ge;ft<z-ge;ft++){const C=ft*L;for(let $=ge;$<L-ge;$++){const z=C+$;if(!X||0!==X[z]){if(X){if(X[z-L-1]+X[z-L]+X[z-L+1]+X[z-1]+X[z+1]+X[z+L-1]+X[z+L]+X[z+L+1]<7){K[z]=0;continue}nt=X[z-L-1]?Z[z-L-1]:Z[z],it=X[z-L]?Z[z-L]:Z[z],st=X[z-L+1]?Z[z-L+1]:Z[z],at=X[z-1]?Z[z-1]:Z[z],lt=X[z+1]?Z[z+1]:Z[z],ut=X[z+L-1]?Z[z+L-1]:Z[z],ct=X[z+L]?Z[z+L]:Z[z],ht=X[z+L+1]?Z[z+L+1]:Z[z]}else nt=Z[z-L-1],it=Z[z-L],st=Z[z-L+1],at=Z[z-1],lt=Z[z+1],ut=Z[z+L-1],ct=Z[z+L],ht=Z[z+L+1];if(Q[z]=st+lt+lt+ht-(nt+at+at+ut),tt[z]=ut+ct+ct+ht-(nt+it+it+st),null!=et){const C=Z[z],$=.5*(at+lt)-C,L=.5*(it+ct)-C;if("standard"===ot)et[z]=-rt*($+L);else{const C=(-nt+st+ut-ht)/4,q=(-at+lt)/2,K=(it-ct)/2,J=q*q,X=K*K,Z=J+X;Z&&(et[z]="profile"===ot?rt*($*J+L*X+C*q*K)/Z:-rt*($*X+L*J-C*q*K)/Z)}}}}}return{outMask:J?K:null,dzxs:Q,dzys:tt,curvatures:et}}function l$2(C,$,L){for(let z=0;z<L;z++)C[z*$]=C[z*$+1],C[(z+1)*$-1]=C[(z+1)*$-2];for(let z=1;z<$-1;z++)C[z]=C[z+$],C[z+(L-1)*$]=C[z+(L-2)*$]}function h$4(C,$){if(!o$4(C))return C;const L=$.zFactor,z=$.pixelSizePower??1,q=$.pixelSizeFactor??1,K=$.slopeType,J=$.isGCS,{x:X,y:Z}=$.resolution;let Q=L/(8*X),tt=L/(8*Z);J&&Math.abs(L-1)<1e-4&&(Q/=ye,tt/=ye),"adjusted"===K&&(Q=(L+X**z*q)/(8*X),tt=(L+Z**z*q)/(8*Z));const{dzxs:et,dzys:rt,outMask:ot}=a$5(C),{width:nt,height:it}=C,st=new Float32Array(nt*it);for(let lt=ge;lt<it-ge;lt++){const C=lt*nt;for(let $=ge;$<nt-ge;$++){const L=C+$;if(!ot||ot[L]){const z=et[L]*Q,q=rt[L]*tt,J=Math.sqrt(z*z+q*q);st[C+$]="percent-rise"===K?100*J:57.2957795*Math.atan(J)}}}l$2(st,nt,it);const at=new St({width:nt,height:it,pixels:[st],mask:ot,pixelType:"f32",validPixelCount:C.validPixelCount});return at.updateStatistics(),at}function u$5(C,$={}){if(!o$4(C))return C;const{resolution:L}=$,z=L?1/L.x:1,q=L?1/L.y:1,{dzxs:K,dzys:J,outMask:X}=a$5(C),{width:Z,height:Q}=C,tt=new Float32Array(Z*Q);for(let et=ge;et<Q-ge;et++){const C=et*Z;for(let $=ge;$<Z-ge;$++){const L=C+$;if(!X||X[L]){const X=K[L]*z,Z=J[L]*q;let Q=-1;0===X&&0===Z||(Q=90-57.29578*Math.atan2(Z,-X),Q<0&&(Q+=360),360===Q?Q=0:Q>360&&(Q%=360)),tt[C+$]=Q}}}return l$2(tt,Z,Q),new St({width:Z,height:Q,pixels:[tt],mask:X,pixelType:"f32",validPixelCount:C.validPixelCount,statistics:[new vt(-1,360)]})}function f$4(C,$){if(!o$4(C))return C;const{curvatures:L,outMask:z}=a$5(C,$),{width:q,height:K}=C;l$2(L,q,K);const J=new St({width:q,height:K,pixels:[L],mask:z,pixelType:"f32",validPixelCount:C.validPixelCount});return J.updateStatistics(),J}const we=["random","ndvi","ndvi2","ndvi3","elevation","gray","hillshade"],ve=[{id:"aspect",type:"multipart",colorRamps:[{fromColor:[190,190,190],toColor:[255,45,8]},{fromColor:[255,45,8],toColor:[255,181,61]},{fromColor:[255,181,61],toColor:[255,254,52]},{fromColor:[255,254,52],toColor:[0,251,50]},{fromColor:[0,251,50],toColor:[255,254,52]},{fromColor:[0,253,255],toColor:[0,181,255]},{fromColor:[0,181,255],toColor:[26,35,253]},{fromColor:[26,35,253],toColor:[255,57,251]},{fromColor:[255,57,251],toColor:[255,45,8]}]},{id:"black-to-white",fromColor:[0,0,0],toColor:[255,255,255]},{id:"blue-bright",fromColor:[204,204,255],toColor:[0,0,224]},{id:"blue-light-to-dark",fromColor:[211,229,232],toColor:[46,100,140]},{id:"blue-green-bright",fromColor:[203,245,234],toColor:[48,207,146]},{id:"blue-green-light-to-dark",fromColor:[216,242,237],toColor:[21,79,74]},{id:"brown-light-to-dark",fromColor:[240,236,170],toColor:[102,72,48]},{id:"brown-to-blue-green-diverging-right",type:"multipart",colorRamps:[{fromColor:[156,85,31],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[33,130,145]}]},{id:"brown-to-blue-green-diverging-dark",type:"multipart",colorRamps:[{fromColor:[110,70,45],toColor:[204,204,102]},{fromColor:[204,204,102],toColor:[48,100,102]}]},{id:"coefficient-bias",fromColor:[214,214,255],toColor:[0,57,148]},{id:"cold-to-hot-diverging",type:"multipart",colorRamps:[{fromColor:[69,117,181],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[214,47,39]}]},{id:"condition-number",type:"multipart",colorRamps:[{fromColor:[0,97,0],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[255,34,0]}]},{id:"cyan-to-purple",type:"multipart",colorRamps:[{fromColor:[0,245,245],toColor:[0,0,245]},{fromColor:[0,0,245],toColor:[245,0,245]}]},{id:"cyan-light-to-blue-dark",type:"multipart",colorRamps:[{fromColor:[182,237,240],toColor:[31,131,224]},{fromColor:[31,131,224],toColor:[9,9,145]}]},{id:"distance",fromColor:[255,200,0],toColor:[0,0,255]},{id:"elevation1",type:"multipart",colorRamps:[{fromColor:[175,240,233],toColor:[255,255,179]},{fromColor:[255,255,179],toColor:[0,128,64]},{fromColor:[0,128,64],toColor:[252,186,3]},{fromColor:[252,186,3],toColor:[128,0,0]},{fromColor:[120,0,0],toColor:[105,48,13]},{fromColor:[105,48,13],toColor:[171,171,171]},{fromColor:[171,171,171],toColor:[255,252,255]}]},{id:"elevation2",type:"multipart",colorRamps:[{fromColor:[118,219,211],toColor:[255,255,199]},{fromColor:[255,255,199],toColor:[255,255,128]},{fromColor:[255,255,128],toColor:[217,194,121]},{fromColor:[217,194,121],toColor:[135,96,38]},{fromColor:[135,96,38],toColor:[150,150,181]},{fromColor:[150,150,181],toColor:[181,150,181]},{fromColor:[181,150,181],toColor:[255,252,255]}]},{id:"errors",fromColor:[255,235,214],toColor:[196,10,10]},{id:"gray-light-to-dark",fromColor:[219,219,219],toColor:[69,69,69]},{id:"green-bright",fromColor:[204,255,204],toColor:[14,204,14]},{id:"green-light-to-dark",fromColor:[220,245,233],toColor:[34,102,51]},{id:"green-to-blue",type:"multipart",colorRamps:[{fromColor:[32,204,16],toColor:[0,242,242]},{fromColor:[0,242,242],toColor:[2,33,227]}]},{id:"orange-bright",fromColor:[255,235,204],toColor:[240,118,5]},{id:"orange-light-to-dark",fromColor:[250,233,212],toColor:[171,65,36]},{id:"partial-spectrum",type:"multipart",colorRamps:[{fromColor:[242,241,162],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[255,0,0]},{fromColor:[252,3,69],toColor:[176,7,237]},{fromColor:[176,7,237],toColor:[2,29,173]}]},{id:"partial-spectrum-1-diverging",type:"multipart",colorRamps:[{fromColor:[135,38,38],toColor:[240,149,12]},{fromColor:[240,149,12],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[74,80,181]},{fromColor:[74,80,181],toColor:[39,32,122]}]},{id:"partial-spectrum-2-diverging",type:"multipart",colorRamps:[{fromColor:[115,77,42],toColor:[201,137,52]},{fromColor:[201,137,52],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[91,63,176]},{fromColor:[91,63,176],toColor:[81,13,97]}]},{id:"pink-to-yellow-green-diverging-bright",type:"multipart",colorRamps:[{fromColor:[158,30,113],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[99,110,45]}]},{id:"pink-to-yellow-green-diverging-dark",type:"multipart",colorRamps:[{fromColor:[97,47,73],toColor:[204,204,102]},{fromColor:[204,204,102],toColor:[22,59,15]}]},{id:"precipitation",type:"multipart",colorRamps:[{fromColor:[194,82,60],toColor:[237,161,19]},{fromColor:[237,161,19],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[0,219,0]},{fromColor:[0,219,0],toColor:[32,153,143]},{fromColor:[32,153,143],toColor:[11,44,122]}]},{id:"prediction",type:"multipart",colorRamps:[{fromColor:[40,146,199],toColor:[250,250,100]},{fromColor:[250,250,100],toColor:[232,16,20]}]},{id:"purple-bright",fromColor:[255,204,255],toColor:[199,0,199]},{id:"purple-to-green-diverging-bright",type:"multipart",colorRamps:[{fromColor:[77,32,150],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[20,122,11]}]},{id:"purple-to-green-diverging-dark",type:"multipart",colorRamps:[{fromColor:[67,14,89],toColor:[204,204,102]},{fromColor:[204,204,102],toColor:[24,79,15]}]},{id:"purple-blue-bright",fromColor:[223,184,230],toColor:[112,12,242]},{id:"purple-blue-light-to-dark",fromColor:[229,213,242],toColor:[93,44,112]},{id:"purple-red-bright",fromColor:[255,204,225],toColor:[199,0,99]},{id:"purple-red-light-to-dark",fromColor:[250,215,246],toColor:[143,17,57]},{id:"red-bright",fromColor:[255,204,204],toColor:[219,0,0]},{id:"red-light-to-dark",fromColor:[255,224,224],toColor:[143,10,10]},{id:"red-to-blue-diverging-bright",type:"multipart",colorRamps:[{fromColor:[196,69,57],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[48,95,207]}]},{id:"red-to-blue-diverging-dark",type:"multipart",colorRamps:[{fromColor:[107,13,13],toColor:[204,204,102]},{fromColor:[204,204,102],toColor:[13,53,97]}]},{id:"red-to-green",type:"multipart",colorRamps:[{fromColor:[245,0,0],toColor:[245,245,0]},{fromColor:[245,245,0],toColor:[0,245,0]}]},{id:"red-to-green-diverging-bright",type:"multipart",colorRamps:[{fromColor:[186,20,20],toColor:[255,255,191]},{fromColor:[255,255,191],toColor:[54,145,33]}]},{id:"red-to-green-diverging-dark",type:"multipart",colorRamps:[{fromColor:[97,21,13],toColor:[204,204,102]},{fromColor:[204,204,102],toColor:[16,69,16]}]},{id:"slope",type:"multipart",colorRamps:[{fromColor:[56,168,0],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[255,0,0]}]},{id:"spectrum-full-bright",type:"multipart",colorRamps:[{fromColor:[255,0,0],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[0,255,255]},{fromColor:[0,255,255],toColor:[0,0,255]}]},{id:"spectrum-full-dark",type:"multipart",colorRamps:[{fromColor:[153,0,0],toColor:[153,153,0]},{fromColor:[153,153,0],toColor:[0,153,153]},{fromColor:[0,153,153],toColor:[0,0,153]}]},{id:"spectrum-full-light",type:"multipart",colorRamps:[{fromColor:[255,153,153],toColor:[255,255,153]},{fromColor:[255,255,153],toColor:[153,255,255]},{fromColor:[153,255,255],toColor:[153,153,255]}]},{id:"surface",type:"multipart",colorRamps:[{fromColor:[112,153,89],toColor:[242,238,162]},{fromColor:[242,238,162],toColor:[242,206,133]},{fromColor:[242,206,133],toColor:[194,140,124]},{fromColor:[194,140,124],toColor:[255,242,255]}]},{id:"temperature",type:"multipart",colorRamps:[{fromColor:[255,252,255],toColor:[255,0,255]},{fromColor:[255,0,255],toColor:[0,0,255]},{fromColor:[0,0,255],toColor:[0,255,255]},{fromColor:[0,255,255],toColor:[0,255,0]},{fromColor:[0,255,0],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[255,128,0]},{fromColor:[255,128,0],toColor:[128,0,0]}]},{id:"white-to-black",fromColor:[255,255,255],toColor:[0,0,0]},{id:"yellow-to-dark-red",type:"multipart",colorRamps:[{fromColor:[255,255,128],toColor:[242,167,46]},{fromColor:[242,167,46],toColor:[107,0,0]}]},{id:"yellow-to-green-to-dark-blue",type:"multipart",colorRamps:[{fromColor:[255,255,128],toColor:[56,224,9]},{fromColor:[56,224,9],toColor:[26,147,171]},{fromColor:[26,147,171],toColor:[12,16,120]}]},{id:"yellow-to-red",fromColor:[245,245,0],toColor:[255,0,0]},{id:"yellow-green-bright",fromColor:[236,252,204],toColor:[157,204,16]},{id:"yellow-green-light-to-dark",fromColor:[215,240,175],toColor:[96,107,45]}],Ce=new ut({Aspect:"aspect","Black to White":"black-to-white","Blue Bright":"blue-bright","Blue Light to Dark":"blue-light-to-dark","Blue-Green Bright":"blue-green-bright","Blue-Green Light to Dark":"blue-green-light-to-dark","Brown Light to Dark":"brown-light-to-dark","Brown to Blue Green Diverging, Bright":"brown-to-blue-green-diverging-right","Brown to Blue Green Diverging, Dark":"brown-to-blue-green-diverging-dark","Coefficient Bias":"coefficient-bias","Cold to Hot Diverging":"cold-to-hot-diverging","Condition Number":"condition-number","Cyan to Purple":"cyan-to-purple","Cyan-Light to Blue-Dark":"cyan-light-to-blue-dark",Distance:"distance","Elevation #1":"elevation1","Elevation #2":"elevation2",Errors:"errors","Gray Light to Dark":"gray-light-to-dark","Green Bright":"green-bright","Green Light to Dark":"green-light-to-dark","Green to Blue":"green-to-blue","Orange Bright":"orange-bright","Orange Light to Dark":"orange-light-to-dark","Partial Spectrum":"partial-spectrum","Partial Spectrum 1 Diverging":"partial-spectrum-1-diverging","Partial Spectrum 2 Diverging":"partial-spectrum-2-diverging","Pink to YellowGreen Diverging, Bright":"pink-to-yellow-green-diverging-bright","Pink to YellowGreen Diverging, Dark":"pink-to-yellow-green-diverging-dark",Precipitation:"precipitation",Prediction:"prediction","Purple Bright":"purple-bright","Purple to Green Diverging, Bright":"purple-to-green-diverging-bright","Purple to Green Diverging, Dark":"purple-to-green-diverging-dark","Purple-Blue Bright":"purple-blue-bright","Purple-Blue Light to Dark":"purple-blue-light-to-dark","Purple-Red Bright":"purple-red-bright","Purple-Red Light to Dark":"purple-red-light-to-dark","Red Bright":"red-bright","Red Light to Dark":"red-light-to-dark","Red to Blue Diverging, Bright":"red-to-blue-diverging-bright","Red to Blue Diverging, Dark":"red-to-blue-diverging-dark","Red to Green":"red-to-green","Red to Green Diverging, Bright":"red-to-green-diverging-bright","Red to Green Diverging, Dark":"red-to-green-diverging-dark",Slope:"slope","Spectrum-Full Bright":"spectrum-full-bright","Spectrum-Full Dark":"spectrum-full-dark","Spectrum-Full Light":"spectrum-full-light",Surface:"surface",Temperature:"temperature","White to Black":"white-to-black","Yellow to Dark Red":"yellow-to-dark-red","Yellow to Green to Dark Blue":"yellow-to-green-to-dark-blue","Yellow to Red":"yellow-to-red","Yellow-Green Bright":"yellow-green-bright","Yellow-Green Light to Dark":"yellow-green-light-to-dark"});function g$1(C,$){if(!C||!$||C.length!==$.length)return!1;for(let L=0;L<C.length;L++)if(C[L]>$[L]+2||C[L]<$[L]-2)return!1;return!0}function p$2(C){const $=C.clone();return $.fromColor=C.toColor,$.toColor=C.fromColor,$.algorithm=C.algorithm,$}function f$3(C,$){if(!C)return;const L=ve;let z=null;return"algorithmic"===C.type?L.some(($=>{if(g$1(C.fromColor.toRgb(),$.fromColor)&&g$1(C.toColor.toRgb(),$.toColor))return z=$.id,!0})):"multipart"===C.type&&L.some(($=>{const L=C.colorRamps,q=$.colorRamps;if(L&&q&&L.length===q.length&&!q.some(((C,$)=>{if(!g$1(L[$].fromColor.toRgb(),new mt(C.fromColor).toRgb())||!g$1(L[$].toColor.toRgb(),new mt(C.toColor).toRgb()))return!0}))){if(z)return!0;z=$.id}})),z}function s$2(C,$,L=!1){if(!C)return;let z=!1,q=f$3(C);return null!=q||L||(z=!0,q=f$3(C=function u$4(C){var $;if("multipart"===C.type){const L=C.clone();return(null==($=L.colorRamps)?void 0:$.length)?(L.colorRamps=L.colorRamps.reverse().map((C=>p$2(C))),L):L}return p$2(C)}(C))),q?{id:q,inverted:z}:void 0}function d$2(C,$=!1){var L;const z="string"==typeof C?C:null==(L=s$2(C,0,$))?void 0:L.id;return z?Ce.toJSON(z):null}function c$3(C,$="esriCIELabAlgorithm"){const L=ve.find((({id:$})=>$===C));return L?L.colorRamps?{type:"multipart",colorRamps:L.colorRamps.map((C=>({type:"algorithmic",algorithm:$,fromColor:[...C.fromColor],toColor:[...C.toColor]})))}:{type:"algorithmic",algorithm:$,fromColor:[...L.fromColor],toColor:[...L.toColor]}:null}function h$3(C){const $=(C=C||{}).numColors||256,L=C.distanceOffset||0,z=null!=C.isCustomInterval?C.isCustomInterval:null!==C.distanceInterval&&C.distanceInterval!==1/($-1),q=C.distanceInterval||1/($-1);return{...C,numColors:$,distanceOffset:L,interpolateAlpha:!!C.interpolateAlpha,distanceInterval:q,isCustomInterval:z,weights:C.weights}}function y(C,$){let{fromColor:L,toColor:z}=C;L=[...L],z=[...z],3===L.length&&(L=L.concat([255])),3===z.length&&(z=z.concat([255]));const q=C.algorithm||"esriCIELabAlgorithm",K=h$3($),{numColors:J,distanceOffset:X,isCustomInterval:Z,interpolateAlpha:Q}=K;if(1===J&&0===X)return[L];if(2===J&&0===X&&!Z)return[L,z];const tt={r:L[0],g:L[1],b:L[2]},et={r:z[0],g:z[1],b:z[2]},rt="esriCIELabAlgorithm"===q?function v$1(C,$,L){const{numColors:z,distanceOffset:q,distanceInterval:K,isCustomInterval:J}=L;let{l:X,a:Z,b:Q}=C;const tt=($.l-X)*K,et=($.a-Z)*K,rt=($.b-Q)*K,ot=[];if(q){const C=q/K;X+=C*tt,Z+=C*et,Q+=C*rt}for(let nt=0;nt<z-1;nt++)ot.push({l:X,a:Z,b:Q}),X+=tt,Z+=et,Q+=rt;return ot.push(J?{l:X,a:Z,b:Q}:$),ot}(ht(tt),ht(et),K):"esriHSVAlgorithm"===q?function b(C,$,L){const{numColors:z,distanceOffset:q,distanceInterval:K,isCustomInterval:J}=L,X=0===C.s,Z=0===$.s;let Q=C.h,tt=$.h;X&&!Z?Q=tt:Z&&!X&&($={...$,h:Q},tt=Q);let et,rt=Math.abs(tt-Q);const ot=360;rt<180?et=(tt-Q)*K:(rt=ot-rt,et=Q>tt?rt*K:-rt*K);const nt=($.s-C.s)*K,it=($.v-C.v)*K;let{s:st,v:at}=C,lt=Q;if(q){const C=q/K;lt=(lt+C*et+ot)%ot,st+=C*nt,at+=C*it}const ut=[];for(let ct=0;ct<z-1;ct++)ut.push({h:lt,s:st,v:at}),lt=(lt+et+ot)%ot,st+=nt,at+=it;return ut.push(J?{h:lt,s:st,v:at}:$),ut}(ft(tt),ft(et),K):function k(C,$,L){const{numColors:z,distanceOffset:q,distanceInterval:K,isCustomInterval:J}=L,X=C.h,Z=$.h,Q=2*Math.PI;let tt;if(X<=Z){const C=Z-X,$=Z-X-Q;tt=Math.abs($)<Math.abs(C)?$:C}else{const C=Z+Q-X,$=Z-X;tt=Math.abs($)<Math.abs(C)?$:C}const et=tt*K,rt=($.l-C.l)*K,ot=($.c-C.c)*K;let{l:nt,c:it,h:st}=C;if(q){const C=q/K;nt+=C*rt,it+=C*ot,st=(st+C*et+Q)%Q}const at=[];for(let lt=0;lt<z-1;lt++)at.push({l:nt,c:it,h:st}),nt+=rt,it+=ot,st=(st+et+Q)%Q;return at.push(J?{l:nt,c:it,h:st}:$),at}(dt(tt),dt(et),K),ot=[],nt=L[3]??255,it=((z[3]??255)-nt)/(J-1);for(let st=0;st<J;st++){const{r:C,g:$,b:L}=pt(rt[st]),z=Q?Math.round(nt+it*st):255;ot.push([C,$,L,z])}return ot}function w$1(C,$){const L=ct(C)?C.toJSON():C;return"multipart"===L.type?function R(C,$){const{numColors:L,interpolateAlpha:z}=h$3($);let q=null==$?void 0:$.weights;const{colorRamps:K}=C;if(q){const C=q.reduce(((C,$)=>C+$));q=q.map(($=>$/C))}else{q=[];for(let C=0;C<K.length;C++)q[C]=1/K.length}const J=[],X=1/(L-1);let Z=0,Q=!1;for(let et=0;et<K.length;et++){const C=J.length,$=Q?0:C*X-Z;Z+=q[et];let tt=et===K.length-1?L-1-C:(q[et]-$)/X;if(Q=Math.ceil(tt)===tt,tt=Math.ceil(tt),0===tt)continue;const rt=y(K[et],{numColors:tt,interpolateAlpha:z,distanceOffset:$/q[et],distanceInterval:X/q[et]});J.push(...rt)}const tt=[...K[K.length-1].toColor];return 3===tt.length&&tt.push(255),J.push(tt),J}(L,$):y(L,$)}function B(C,$){const L=w$1(C,$),z=null==$?void 0:$.interpolateAlpha;return L.forEach(((C,$)=>{C.unshift($),z||C.pop()})),L}function D(C){const $=ft(C);return{type:"HsvColor",Hue:$.h,Saturation:$.s,Value:$.v,AlphaValue:255}}function I(C){const $=C.toJSON();return{Algorithm:(null==$?void 0:$.Algorithm)||"esriHSVAlgorithm",type:"AlgorithmicColorRamp",FromColor:D(C.fromColor),ToColor:D(C.toColor)}}function G(C){const $=d$2(C);if(!$)return null;if("algorithmic"===C.type)return{...I(C),Name:$};if(C.colorRamps){const L=C.colorRamps.map(I);return{type:"MultiPartColorRamp",NumColorRamps:L.length,ArrayOfColorRamp:L,Name:$}}return null}function A(C){const $=C.reverse().map((C=>{const $=C.toString(16);return $.length<2?"0"+$:$}));return 4294967295&Number.parseInt($.join(""),16)}const be=new ut({none:"none",standardDeviation:"standard-deviation",histogramEqualization:"histogram-equalization",minMax:"min-max",percentClip:"percent-clip",sigmoid:"sigmoid"}),xe={0:"none",3:"standardDeviation",4:"histogramEqualization",5:"minMax",6:"percentClip",9:"sigmoid"},ke=1;function r$2(C,$=256){$=Math.min($,256);const{size:L,counts:z}=C,q=new Uint8Array(L),K=z.reduce(((C,L)=>C+L/$),0);let J=0,X=0,Z=0,Q=K;for(let tt=0;tt<L;tt++)if(Z+=z[tt],!(tt<L-1&&Z+z[tt+1]<Q)){for(;J<$-1&&Q<Z;)J++,Q+=K;for(let C=X;C<=tt;C++)q[C]=J;X=tt+1}for(let tt=X;tt<L;tt++)q[tt]=$-1;return q}function a$2(C){const{minCutOff:$,maxCutOff:L,gamma:z,pixelType:q,rounding:K}=C,J=C.outMin||0,X=C.outMax||255;if(!["u8","u16","s8","s16"].includes(q))return null;const Z=$.length;let Q,tt,et=0;"s8"===q?et=-127:"s16"===q&&(et=-32767);let rt=256;["u16","s16"].includes(q)&&(rt=65536);const ot=[],nt=[],it=X-J;for(Q=0;Q<Z;Q++)nt[Q]=L[Q]-$[Q],ot[Q]=0===nt[Q]?0:it/nt[Q];let st;const at=[];let lt,ut,ct;if(z&&z.length>=Z){const C=x(Z,z);for(Q=0;Q<Z;Q++){for(ct=[],tt=0;tt<rt;tt++)if(0!==nt[Q])if(lt=tt+et,st=(lt-$[Q])/nt[Q],ut=1,z[Q]>1&&(ut-=(1/it)**(st*C[Q])),lt<L[Q]&&lt>$[Q]){const C=ut*it*st**(1/z[Q])+J;ct[tt]="floor"===K?Math.floor(C):"round"===K?Math.round(C):C}else lt>=L[Q]?ct[tt]=X:ct[tt]=J;else ct[tt]=J;at[Q]=ct}}else for(Q=0;Q<Z;Q++){for(ct=[],tt=0;tt<rt;tt++)if(lt=tt+et,lt<=$[Q])ct[tt]=J;else if(lt>=L[Q])ct[tt]=X;else{const C=(lt-$[Q])*ot[Q]+J;ct[tt]="floor"===K?Math.floor(C):"round"===K?Math.round(C):C}at[Q]=ct}if(null!=C.contrastOffset){const $=l$1(C.contrastOffset,C.brightnessOffset);for(Q=0;Q<Z;Q++)for(ct=at[Q],tt=0;tt<rt;tt++)ct[tt]=$[ct[tt]]}return{lut:at,offset:et}}function l$1(C,$){const L=Math.min(Math.max(C,-100),100),z=Math.min(Math.max($??0,-100),100),q=255;let K=0,J=0;const X=new Uint8Array(256);for(K=0;K<256;K++)L>0&&L<100?J=(200*K-25500+510*z)/(2*(100-L))+128:L<=0&&L>-100?J=(200*K-25500+510*z)*(100+L)/2e4+128:100===L?(J=200*K-25500+256*(100-L)+510*z,J=J>0?q:0):-100===L&&(J=128),X[K]=J>q?q:J<0?0:J;return X}function u$3(C){if(C<=0||C>=255)return ke;let $=0;150!==C&&($=C<=150?45*Math.cos(.01047*C):17*Math.sin(.021*C));const L=C+$,z=Math.log(C/255),q=Math.log(L/255);if(0===q)return ke;const K=z/q;return isNaN(K)?ke:Math.min(9.9,Math.max(.01,K))}function m$1(C){const{pixels:$,mask:L,pixelType:z,bandMasks:q}=C,K=$.map(((C,$)=>function c$2(C,$,L,z){let q=1/0,K=-1/0,J=0,X=0,Z=0,Q=0;const tt=C.length,et=new Map,rt=[];for(let dt=0;dt<tt;dt++){const L=C[dt];if(!$||$[dt]){rt.push(L);const C=(et.get(L)??0)+1;et.set(L,C),C>Q&&(Q=C,Z=L),q=L<q?L:q,K=L>K?L:K,J+=L,X++}}if(0===X)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const ot=J/X;let nt=0;for(let dt=0;dt<tt;dt++)$&&!$[dt]||(nt+=(C[dt]-ot)**2);const it=$?$.filter((C=>C)).length:tt,st=it<=1?0:Math.sqrt(nt/(it-1));rt.sort(((C,$)=>C-$));const at=X>>>1,lt={min:q,max:K,avg:ot,stddev:st,mode:Z,median:X%2?rt[Math.floor(at)]:(rt[at-1]+rt[at])/2};if(["u8","s8","u4","u2","u1"].includes(L)){const L=K-q+1,z=new Uint32Array(L);for(let K=0;K<tt;K++)$&&!$[K]||z[C[K]-q]++;return{statistics:lt,histogram:{min:q-.5,max:K+.5,size:L,counts:z}}}const ut=256,ct=new Uint32Array(ut),ht=(K-q)/ut;if(0===ht)return{statistics:lt,histogram:{min:q,max:K,size:1,counts:new Uint32Array(1).fill(X)}};const ft=new Uint32Array(257);for(let dt=0;dt<tt;dt++)$&&!$[dt]||ft[Math.floor((C[dt]-q)/ht)]++;for(let dt=0;dt<255;dt++)ct[dt]=ft[dt];return ct[255]=ft[255]+ft[ut],{statistics:lt,histogram:{min:q,max:K,size:ut,counts:ct}}}(C,(null==q?void 0:q[$])??L,z)));return{statistics:K.map((({statistics:C})=>C)),histograms:K.map((({histogram:C})=>C))}}function h$2(C){var $;if(!(null==($=null==C?void 0:C.pixels)?void 0:$.length))return null;const{pixels:L,mask:z,bandMasks:q,pixelType:K}=C,J=C.width*C.height,X=L.length,Z=[],Q=[],tt=256;let et,rt,ot,nt;for(let it=0;it<X;it++){ot=new Uint32Array(tt);const $=L[it],X=(null==q?void 0:q[it])??z;if("u8"===K){if(et=255,rt=0,X){for(let C=0;C<J;C++)if(X[C]){const L=$[C];et=L<et?L:et,rt=L>rt?L:rt,ot[L]++}}else for(let C=0;C<J;C++){const L=$[C];et=L<et?L:et,rt=L>rt?L:rt,ot[L]++}ot=ot.slice(et,rt+1)}else{let L=!1;C.statistics||(C.updateStatistics(),L=!0);const z=C.statistics;et=z[it].minValue,rt=z[it].maxValue;const q=(rt-et)/tt;if(0===q){!z||C.validPixelCount||L||C.updateStatistics();const $=(C.validPixelCount||C.width*C.height)/tt;for(let C=0;C<tt;C++)ot[C]=Math.round($*(C+1))-Math.round($*C)}else{nt=new Uint32Array(257);for(let C=0;C<J;C++)X&&!X[C]||nt[Math.floor(($[C]-et)/q)]++;for(let C=0;C<255;C++)ot[C]=nt[C];ot[255]=nt[255]+nt[tt]}}const st="u8"===K?et-.5:et,at="u8"===K?rt+.5:rt;Z.push({min:st,max:at,size:ot.length,counts:ot});let lt=0,ut=0,ct=0;for(let C=0;C<ot.length;C++)lt+=ot[C],ut+=C*ot[C];const ht=ut/lt;for(let C=0;C<ot.length;C++)ct+=ot[C]*(C-ht)**2;const ft=Math.sqrt(ct/(lt-1)),dt=(at-st)/ot.length,pt=(ht+("u8"===K?0:.5))*dt+et,mt=ft*dt;Q.push({min:et,max:rt,avg:pt,stddev:mt})}return{statistics:Q,histograms:Z}}function g(C){const $=[];for(let L=0;L<C.length;L++){const{min:z,max:q,size:K,counts:J}=C[L];let X=0,Z=0;for(let C=0;C<K;C++)X+=J[C],Z+=C*J[C];const Q=Z/X;let tt=0;for(let C=0;C<K;C++)tt+=J[C]*(C-Q)**2;const et=(q-z)/K,rt=(Q+.5)*et+z,ot=Math.sqrt(tt/(X-1))*et;$.push({min:z,max:q,avg:rt,stddev:ot})}return $}function p$1(C,$){var L;const{pixelBlock:z,bandIds:q,returnHistogramLut:K,rasterInfo:J}=$;let X=null,Z=null,Q=C.stretchType;if("number"==typeof Q&&(Q=xe[Q]),C.dra)if("minMax"===Q&&(null==z?void 0:z.statistics))X=z.statistics.map((C=>[C.minValue,C.maxValue,0,0]));else{const C=h$2(z);X=null!=C?C.statistics:null,Z=null!=C?C.histograms:null}else X=(null==(L=C.statistics)?void 0:L.length)?C.statistics:J.statistics,Z="histograms"in C?C.histograms:void 0,Z||(Z=J.histograms);"percentClip"!==Q&&"histogramEqualization"!==Q||(null==Z?void 0:Z.length)||(Q="minMax");const tt=(null==X?void 0:X.length)||(null==Z?void 0:Z.length)||J.bandCount,et=[],rt=[];let nt,it,st,at,lt,ut,ct,ht,ft;X&&!Array.isArray(X[0])&&(X=X.map((C=>[C.min,C.max,C.avg,C.stddev])));const[dt,pt]=s$7(J.pixelType);if(!(null==X?void 0:X.length)){for(X=[],ht=0;ht<tt;ht++)X.push([dt,pt,1,1]);"standardDeviation"===Q&&(Q="minMax")}switch(Q){case"none":for(ht=0;ht<tt;ht++)et[ht]=dt,rt[ht]=pt;break;case"minMax":for(ht=0;ht<tt;ht++){const C=X[ht];et[ht]=C[0],rt[ht]=C[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:$=2}=C;for(ht=0;ht<tt;ht++){const C=X[ht];et[ht]=C[2]-$*C[3],rt[ht]=C[2]+$*C[3],et[ht]<C[0]&&(et[ht]=C[0]),rt[ht]>C[1]&&(rt[ht]=C[1])}}break;case"histogramEqualization":for(ot(Z),ht=0;ht<tt;ht++)et[ht]=Z[ht].min,rt[ht]=Z[ht].max;break;case"percentClip":for(ot(Z),ht=0;ht<Z.length;ht++){for(nt=Z[ht],lt=new Uint32Array(nt.size),at=[...nt.counts],at.length>=20&&(at[0]=at[1]=at[2]=at[at.length-1]=at[at.length-2]=0),st=0,it=(nt.max-nt.min)/nt.size,ct=-.5===nt.min&&1===it?.5:0,ft=0;ft<nt.size;ft++)st+=at[ft],lt[ft]=st;for(ut=(C.minPercent||0)*st/100,et[ht]=nt.min+ct,ft=0;ft<nt.size;ft++)if(lt[ft]>ut){et[ht]=nt.min+it*(ft+ct);break}for(ut=(1-(C.maxPercent||0)/100)*st,rt[ht]=nt.max+ct,ft=nt.size-2;ft>=0;ft--)if(lt[ft]<ut){rt[ht]=nt.min+it*(ft+2-ct);break}if(rt[ht]<et[ht]){const C=et[ht];et[ht]=rt[ht],rt[ht]=C}}break;default:for(ht=0;ht<tt;ht++){const C=X[ht];et[ht]=C[0],rt[ht]=C[1]}}let mt,gt,yt;return"histogramEqualization"===Q?(ot(Z),gt=Z[0].size||256,mt=0,K&&(yt=Z.map((C=>r$2(C))))):(gt=C.max||255,mt=C.min||0),function d$1(C,$){if(null==$||0===$.length)return C;const L=Math.max.apply(null,$),{minCutOff:z,maxCutOff:q,outMin:K,outMax:J,histogramLut:X}=C;return z.length===$.length||z.length<=L?C:{minCutOff:$.map((C=>z[C])),maxCutOff:$.map((C=>q[C])),histogramLut:X?$.map((C=>X[C])):null,outMin:K,outMax:J}}({minCutOff:et,maxCutOff:rt,outMax:gt,outMin:mt,histogramLut:yt},q)}function x(C,$){const L=new Float32Array(C);for(let z=0;z<C;z++)$[z]>1?$[z]>2?L[z]=6.5+($[z]-2)**2.5:L[z]=6.5+100*(2-$[z])**4:L[z]=1;return L}function M(C,$){var L;if(!(null==(L=null==C?void 0:C.pixels)?void 0:L.length))return C;const{mask:z,bandMasks:q,width:K,height:J,pixels:X}=C,{minCutOff:Z,maxCutOff:Q,gamma:tt}=$,et=$.outMin||0,rt=$.outMax||255,ot=K*J,nt=$.outputPixelType||"u8",it=C.pixels.map((()=>St.createEmptyBand(nt,ot))),st=it.length,at=rt-et,lt=[],ut=[];for(let pt=0;pt<st;pt++)ut[pt]=Q[pt]-Z[pt],lt[pt]=0===ut[pt]?0:at/ut[pt];const ct=nt.startsWith("u")||nt.startsWith("s"),ht=tt&&tt.length>=st,ft=!!$.isRenderer;if(ht){const C=x(st,tt);for(let $=0;$<st;$++){const L=(null==q?void 0:q[$])??z;for(let z=0;z<ot;z++)if(null==L||L[z]){if(0===ut[$]){it[$][z]=et;continue}const L=X[$][z],q=(L-Z[$])/ut[$];let K=1;if(tt[$]>1&&(K-=(1/at)**(q*C[$])),L<Q[$]&&L>Z[$]){const C=K*at*q**(1/tt[$])+et;it[$][z]=ft?Math.floor(C):ct?Math.round(C):C}else L>=Q[$]?it[$][z]=rt:it[$][z]=et}}}else for(let pt=0;pt<st;pt++){const C=(null==q?void 0:q[pt])??z;for(let $=0;$<ot;$++)if(null==C||C[$]){const C=X[pt][$];if(C<Q[pt]&&C>Z[pt]){const L=(C-Z[pt])*lt[pt]+et;it[pt][$]=ft?Math.floor(L):ct?Math.round(L):L}else C>=Q[pt]?it[pt][$]=rt:it[pt][$]=et}}const dt=new St({width:K,height:J,mask:z,bandMasks:q,pixels:it,pixelType:nt});return dt.updateStatistics(),dt}const Ae=new Map;Ae.set("meter-per-second",1),Ae.set("kilometer-per-hour",.277778),Ae.set("knots",.514444),Ae.set("feet-per-second",.3048),Ae.set("mile-per-hour",.44704);const Se=180/Math.PI,Te=new ut({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function a$1(C,$){return Ae.get(C)/Ae.get($)||1}function h$1(C){return(450-C)%360}function l2(C,$="geographic"){const[L,z]=C,q=Math.sqrt(L*L+z*z);let K=Math.atan2(z,L)*Se;return K=(360+K)%360,"geographic"===$&&(K=h$1(K)),[q,K]}function c$1(C,$="geographic"){let L=C[1];"geographic"===$&&(L=h$1(L)),L%=360;const z=C[0];return[z*Math.cos(L/Se),z*Math.sin(L/Se)]}function u$2(C,$,L,z="geographic"){if(!o$4(C)||null==L)return C;const q="vector-magdir"===$?C.clone():f$1(C,$),K=q.pixels[1];for(let J=0;J<K.length;J++)K[J]="geographic"===z?(K[J]+L[J]+270)%360:(K[J]+360-L[J])%360;return"vector-magdir"===$?q:f$1(q,"vector-magdir")}function f$1(C,$,L="geographic",z=1){if(!o$4(C))return C;const{pixels:q,width:K,height:J}=C,X=K*J,Z=q[0],Q=q[1],tt=C.pixelType.startsWith("f")?C.pixelType:"f32",et=St.createEmptyBand(tt,X),rt=St.createEmptyBand(tt,X);let ot=0;for(let it=0;it<J;it++)for(let C=0;C<K;C++)"vector-uv"===$?([et[ot],rt[ot]]=l2([Z[ot],Q[ot]],L),et[ot]*=z):([et[ot],rt[ot]]=c$1([Z[ot],Q[ot]],L),et[ot]*=z,rt[ot]*=z),ot++;const nt=new St({pixelType:tt,width:C.width,height:C.height,mask:C.mask,validPixelCount:C.validPixelCount,maskIsAlpha:C.maskIsAlpha,pixels:[et,rt]});return nt.updateStatistics(),nt}function p(C,$,L=1){if(1===L||!o$4(C))return C;const z=C.clone(),{pixels:q,width:K,height:J}=z,X=q[0];q[1];let Z=0;for(let Q=0;Q<J;Q++)for(let C=0;C<K;C++)X[Z]*=L,Z++;return z.updateStatistics(),z}function t(C,$){const{attributeTable:L,bandCount:z}=C;return!(null!=L||!function n(C){var $,L,z;return["u8","s8"].includes(C.pixelType)&&null!=(null==(L=null==($=C.statistics)?void 0:$[0])?void 0:L.min)&&null!=(null==(z=C.statistics[0])?void 0:z.max)&&1===C.bandCount}(C))||!(null==L||z>1)&&(!$||null!=L.fields.find((C=>C.name.toLowerCase()===$.toLowerCase())))}function e(C){const{bandCount:$,dataType:L,pixelType:z}=C;return"elevation"===L||"generic"===L&&1===$&&("s16"===z||"s32"===z||"f32"===z||"f64"===z)}function u$1(C,$=!1){const{bandCount:L,colormap:z,pixelType:q}=C;return 1===L&&(!!(null==z?void 0:z.length)||!$&&"u8"===q)}function r2(C,$=!1){const{attributeTable:L,bandCount:z}=C;return 1===z&&(!$||null!=L||null!=C.histograms)}function o(C){const{dataType:$}=C;return"vector-uv"===$||"vector-magdir"===$}function i$1(C){const{dataType:$}=C;return"vector-uv"===$||"vector-magdir"===$}let Ie=class extends q{constructor(C){super(C)}bind(){const{rendererJSON:C}=this;if(!C)return{success:!1};let $;switch(this.lookup={rendererJSON:{}},C.type){case"uniqueValue":$=this._updateUVRenderer(C);break;case"rasterColormap":$=this._updateColormapRenderer(C);break;case"rasterStretch":$=this._updateStretchRenderer(C);break;case"classBreaks":$=this._updateClassBreaksRenderer(C);break;case"rasterShadedRelief":$=this._updateShadedReliefRenderer(C);break;case"vectorField":$=this._updateVectorFieldRenderer();break;case"flowRenderer":$=this._updateFlowRenderer()}return $}symbolize(C){let $=null==C?void 0:C.pixelBlock;if(!O($))return $;if(C.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch($,C.simpleStretchParams);try{let L;switch($.pixels.length>3&&($=$.extractBands(C.bandIds??[0,1,2])),this.rendererJSON.type){case"uniqueValue":case"rasterColormap":L=this._symbolizeColormap($);break;case"classBreaks":L=this._symbolizeClassBreaks($);break;case"rasterStretch":L=this._symbolizeStretch($,C.bandIds);break;case"rasterShadedRelief":{const z=C.extent,q=z.spatialReference.isGeographic,K={x:(z.xmax-z.xmin)/$.width,y:(z.ymax-z.ymin)/$.height};L=this._symbolizeShadedRelief($,{isGCS:q,resolution:K});break}}return L}catch(L){return X.getLogger(this).error("symbolize",L.message),$}}simpleStretch(C,$){if(!O(C))return C;try{return C.pixels.length>3&&(C=C.extractBands([0,1,2])),M(C,{...$,isRenderer:!0})}catch(L){return X.getLogger(this).error("symbolize",L.message),C}}generateWebGLParameters(C){if(["uniqueValue","rasterColormap","classBreaks"].includes(this.rendererJSON.type)){const{indexedColormap:C,offset:$}=this.lookup.colormapLut||{};return{colormap:C,colormapOffset:$,type:"lut"}}const{pixelBlock:$,isGCS:L,resolution:z,bandIds:q}=C,{rendererJSON:K}=this;return"rasterStretch"===K.type?this._generateStretchWebGLParams($,K,q):"rasterShadedRelief"===K.type?this._generateShadedReliefWebGLParams(K,L,z??void 0):"vectorField"===K.type?this._generateVectorFieldWebGLParams(K):null}_isLUTChanged(C){if(!this.lookup||!this.lookup.rendererJSON)return!0;if("colorRamp"in this.rendererJSON){const $=this.rendererJSON.colorRamp;return C?JSON.stringify($)!==JSON.stringify(this.lookup.rendererJSON.colorRamp):(this.rendererJSON,this.lookup.rendererJSON,JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON))}return JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON)}_symbolizeColormap(C){return this._isLUTChanged()&&!this.bind().success?C:h$6(C,this.lookup.colormapLut)}_symbolizeClassBreaks(C){const{canUseIndexedLUT:$}=this._analyzeClassBreaks(this.rendererJSON);return this._isLUTChanged()&&!this.bind().success?C:$?h$6(C,this.lookup.colormapLut):function u$8(C,$){if(!o$4(C))return null;const L=C.clone(),{pixels:z}=L,q=L.width*L.height,K=$.length,J=Math.floor(K/2),X=$[Math.floor(J)],Z=z[0];let Q,tt,et,rt,ot,nt,it=!1;const st=new Uint8Array(q),at=new Uint8Array(q),lt=new Uint8Array(q);let ut=L.mask;const ct=4===$[0].mappedColor.length;for(ut||(ut=new Uint8Array(q),ut.fill(ct?255:1),L.mask=ut),ot=0;ot<q;ot++)if(ut[ot]){for(Q=Z[ot],it=!1,nt=J,tt=X,et=0,rt=K-1;rt-et>1;){if(Q===tt.value){it=!0;break}Q>tt.value?et=nt:rt=nt,nt=Math.floor((et+rt)/2),tt=$[Math.floor(nt)]}it||(Q===$[et].value?(tt=$[et],it=!0):Q===$[rt].value?(tt=$[rt],it=!0):Q<$[et].value?(it=!1,tt=null):Q>$[et].value&&(Q<$[rt].value?(tt=$[et],it=!0):rt===K-1?(it=!1,tt=null):(tt=$[rt],it=!0))),it?(st[ot]=tt.mappedColor[0],at[ot]=tt.mappedColor[1],lt[ot]=tt.mappedColor[2],ut[ot]=tt.mappedColor[3]):st[ot]=at[ot]=lt[ot]=ut[ot]=0}return L.pixels=[st,at,lt],L.mask=ut,L.pixelType="u8",L.maskIsAlpha=ct,L}(C,this.lookup.remapLut??[])}_symbolizeStretch(C,$){var L,z;const{rasterInfo:q}=this,{pixelType:K,bandCount:J}=q,X=this.rendererJSON,Z=["u8","u16","s8","s16"].includes(K);let Q,tt;const{dra:et}=X,{gamma:rt}=this.lookup;if("histogramEqualization"===X.stretchType){const z=et?null:null==(L=this.lookup)?void 0:L.histogramLut,K=p$1(X,{rasterInfo:q,pixelBlock:C,bandIds:$,returnHistogramLut:!z});tt=f$5(M(C,{...K,gamma:rt,isRenderer:!0}),{lut:et?K.histogramLut:z,offset:0})}else if(Z){if(et){const L=p$1(X,{rasterInfo:q,pixelBlock:C,bandIds:$});Q=a$2({pixelType:K,...L,gamma:rt,rounding:"floor"})}else if(this._isLUTChanged()){if(!this.bind().success)return C;Q=this.lookup?this.lookup.stretchLut:null}else Q=this.lookup?this.lookup.stretchLut:null;if(!Q)return C;J>1&&null!=$&&$.length===(null==C?void 0:C.pixels.length)&&(null==Q?void 0:Q.lut.length)===J&&(Q={lut:$.map((C=>Q.lut[C])),offset:Q.offset}),tt=f$5(C,Q)}else{tt=M(C,{...p$1(X,{rasterInfo:q,pixelBlock:C,bandIds:$}),gamma:rt,isRenderer:!0})}if(X.colorRamp){if(this._isLUTChanged(!0)&&!this.bind().success)return C;tt=h$6(tt,null==(z=this.lookup)?void 0:z.colormapLut)}return tt}_symbolizeShadedRelief(C,$){var L;const z=this.rendererJSON,q=function r$3(C,$){if(!o$4(C))return C;const{factor:L,sinZcosA:z,sinZsinA:q,cosZ:K,sinZcosAs:J,sinZsinAs:X,cosZs:Z,weights:Q}=o$2($),[tt,et]=L,rt="traditional"===$.hillshadeType,{width:ot,height:nt}=C,it=new Uint8Array(ot*nt),{dzxs:st,dzys:at,outMask:lt}=a$5(C);for(let ut=ge;ut<nt-ge;ut++){const C=ut*ot;for(let $=ge;$<ot-ge;$++){const L=C+$;if(!lt||lt[L]){const C=st[L]*tt,$=at[L]*et,ot=Math.sqrt(1+C*C+$*$);let nt=0;if(rt){let L=255*(K+q*$-z*C)/ot;L<0&&(L=0),nt=L}else{const L=X.length;for(let z=0;z<L;z++){let L=255*(Z[z]+X[z]*$-J[z]*C)/ot;L<0&&(L=0),nt+=L*Q[z]}}it[L]=255&nt}}}return l$2(it,ot,nt),new St({width:ot,height:nt,pixels:[it],mask:lt,pixelType:"u8",validPixelCount:C.validPixelCount,statistics:[new vt(0,255)]})}(C,{...z,...$});if(!z.colorRamp)return q;let K;if(this._isLUTChanged(!0)){if(!this.bind().success)return q;K=this.lookup?this.lookup.hsvMap:null}else K=this.lookup?this.lookup.hsvMap:null;if(!K)return q;return function c$4(C,$,L,z){if(!o$4(C)||!o$4($))return;const{min:q,max:K}=z,J=C.pixels[0],{pixels:X,mask:Z}=$,Q=X[0],tt=255.00001/(K-q),et=new Uint8ClampedArray(Q.length),rt=new Uint8ClampedArray(Q.length),ot=new Uint8ClampedArray(Q.length),nt=L.length-1;for(let it=0;it<Q.length;it++){if(Z&&0===Z[it])continue;const C=Math.floor((Q[it]-q)*tt),[$,z]=L[C<0?0:C>nt?nt:C],K=J[it],X=K*z,st=X*(1-Math.abs($%2-1)),at=K-X;switch(Math.floor($)){case 0:et[it]=X+at,rt[it]=st+at,ot[it]=at;break;case 1:et[it]=st+at,rt[it]=X+at,ot[it]=at;break;case 2:et[it]=at,rt[it]=X+at,ot[it]=st+at;break;case 3:et[it]=at,rt[it]=st+at,ot[it]=X+at;break;case 4:et[it]=st+at,rt[it]=at,ot[it]=X+at;break;case 5:case 6:et[it]=X+at,rt[it]=at,ot[it]=st+at}}C.pixels=[et,rt,ot],C.updateStatistics()}(q,C,K,(null==(L=this.rasterInfo.statistics)?void 0:L[0])??{min:0,max:8e3}),q}_isVectorFieldData(){const{bandCount:C,dataType:$}=this.rasterInfo;return 2===C&&("vector-magdir"===$||"vector-uv"===$)}_updateVectorFieldRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}}_updateFlowRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}}_updateUVRenderer(C){var $;const{bandCount:L,attributeTable:z,pixelType:q}=this.rasterInfo,K=C.field1;if(!K)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const J=C.defaultSymbol,X=1===L&&["u8","s8"].includes(q);if(!t(this.rasterInfo,K)&&!X)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const Z=[];if(null!=z){const $=z.fields.find((C=>"value"===C.name.toLowerCase()));if(!$)return{success:!1,error:"Unsupported data; the data's raster attribute table does not have a value field."};z.features.forEach((L=>{var z,q;const X=null==(z=C.uniqueValueInfos)?void 0:z.find((C=>String(C.value)===String(L.attributes[K]))),Q=null==(q=null==X?void 0:X.symbol)?void 0:q.color;Q?Z.push([L.attributes[$.name]].concat(Q)):J&&Z.push([L.attributes[$.name]].concat(J.color))}))}else{if("value"!==K.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not available.'};null==($=C.uniqueValueInfos)||$.forEach((C=>{var $;const L=null==($=null==C?void 0:C.symbol)?void 0:$.color;L?Z.push([parseInt(""+C.value,10)].concat(L)):J&&Z.push([parseInt(""+C.value,10)].concat(null==J?void 0:J.color))}))}if(0===Z.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};const Q=a$7({colormap:Z});return this.lookup={rendererJSON:C,colormapLut:Q},this.canRenderInWebGL=_(null==Q?void 0:Q.indexedColormap),{success:!0}}_updateColormapRenderer(C){if(!u$1(this.rasterInfo))return{success:!1,error:"Unsupported data; the data source does not have a colormap."};const $=C.colormapInfos.map((C=>[C.value].concat(C.color))).sort(((C,$)=>C[0]-$[0]));if(!$||0===$.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};const L=a$7({colormap:$});return this.lookup={rendererJSON:C,colormapLut:L},this.canRenderInWebGL=_(null==L?void 0:L.indexedColormap),{success:!0}}_updateShadedReliefRenderer(C){if(!e(this.rasterInfo))return{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.`};if(C.colorRamp){const $=a$7({colormap:B(C.colorRamp,{interpolateAlpha:!0})}),L=[],z=$.indexedColormap;for(let C=0;C<z.length;C+=4){const $=ft({r:z[C],g:z[C+1],b:z[C+2]});L.push([$.h/60,$.s/100,255*$.v/100])}this.lookup={rendererJSON:C,colormapLut:$,hsvMap:L}}else this.lookup=null;return this.canRenderInWebGL=!0,{success:!0}}_analyzeClassBreaks(C){const{attributeTable:$,pixelType:L}=this.rasterInfo,z=null!=$?$.fields.find((C=>"value"===C.name.toLowerCase())):null,q=null!=$?$.fields.find(($=>$.name.toLowerCase()===C.field.toLowerCase())):null,K=null!=z&&null!==q;return{canUseIndexedLUT:["u8","u16","s8","s16"].includes(L)||K,tableValueField:z,tableBreakField:q}}_updateClassBreaksRenderer(C){const{attributeTable:$}=this.rasterInfo,{canUseIndexedLUT:L,tableValueField:z,tableBreakField:q}=this._analyzeClassBreaks(C),K=C.classBreakInfos;if(!(null==K?void 0:K.length))return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};const J=K.sort(((C,$)=>C.classMaxValue-$.classMaxValue)),X=J[J.length-1];let Z=C.minValue;if(!L){const $=[];for(let C=0;C<J.length;C++)$.push({value:J[C].classMinValue??Z,mappedColor:J[C].symbol.color}),Z=J[C].classMaxValue;return $.push({value:X.classMaxValue,mappedColor:X.symbol.color}),this.lookup={rendererJSON:C,remapLut:$},this.canRenderInWebGL=!1,{success:!0}}const Q=[];if(null!=$&&null!=z&&null!==q&&z!==q){const L=z.name,K=q.name,X=J[J.length-1],{classMaxValue:tt}=X;Z=C.minValue;for(const C of $.features){const $=C.attributes[L],z=C.attributes[K],q=z===tt?X:z<Z?null:J.find((({classMaxValue:C})=>C>z));q&&Q.push([$].concat(q.symbol.color))}}else{Z=Math.floor(C.minValue);for(let C=0;C<J.length;C++){const $=J[C];for(let C=Z;C<$.classMaxValue;C++)Q.push([C].concat($.symbol.color));Z=Math.ceil($.classMaxValue)}X.classMaxValue===Z&&Q.push([X.classMaxValue].concat(X.symbol.color))}const tt=a$7({colormap:Q,fillUnspecified:!1});return this.lookup={rendererJSON:C,colormapLut:tt},this.canRenderInWebGL=_(null==tt?void 0:tt.indexedColormap),{success:!0}}_updateStretchRenderer(C){var $,L;let{stretchType:z,dra:q}=C;if(!("none"===z||(null==($=C.statistics)?void 0:$.length)||function v(C){return null!=C&&C.length>0&&null!=C[0].min&&null!=C[0].max}(this.rasterInfo.statistics)||q))return{success:!1,error:"Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used."};const K=C.histograms||this.rasterInfo.histograms;!function V(C){return"percentClip"===C||"histogramEqualization"===C}(C.stretchType)||(null==K?void 0:K.length)||q||(z="minMax");const{computeGamma:J,useGamma:X,colorRamp:Z}=C;let{gamma:Q}=C;if(X&&J&&!(null==Q?void 0:Q.length)){const $=(null==(L=C.statistics)?void 0:L.length)?C.statistics:this.rasterInfo.statistics;Q=function f$2(C,$,L){const z=[];for(let q=0;q<$.length;q++){let L=0,K=0,J=0;"min"in $[q]?({min:L,max:K,avg:J}=$[q]):[L,K,J]=$[q];let X=J??0;"u8"!==C&&(X=255*(X-L)/(K-L)),z.push(u$3(X))}return z}(this.rasterInfo.pixelType,$)}const tt=this.rasterInfo.pixelType,et=!q&&["u8","u16","s8","s16"].includes(tt);if("histogramEqualization"===z){const $=K.map((C=>r$2(C)));this.lookup={rendererJSON:C,histogramLut:$}}else if(et){const $=a$2({pixelType:tt,...p$1(C,{rasterInfo:this.rasterInfo}),gamma:X?Q:null,rounding:"floor"});this.lookup={rendererJSON:C,stretchLut:$}}if(Z&&!function U(C){return"algorithmic"===C.type&&["0,0,0,255","0,0,0"].includes(C.fromColor.join(","))&&["255,255,255,255","255,255,255"].includes(C.toColor.join(","))}(Z)){const $=B(Z,{interpolateAlpha:!0});this.lookup||(this.lookup={rendererJSON:C}),this.lookup.colormapLut=a$7({colormap:$}),this.lookup.rendererJSON=C}return this.lookup.gamma=X&&(null==Q?void 0:Q.length)?Q:null,this.canRenderInWebGL=!0,{success:!0}}_generateStretchWebGLParams(C,$,L){var z;let q=null,K=null;const J=null==(z=this.lookup)?void 0:z.colormapLut;$.colorRamp&&J&&(q=J.indexedColormap,K=J.offset),"histogramEqualization"===$.stretchType&&($={...$,stretchType:"minMax"});const{gamma:X}=this.lookup,Z=!(!$.useGamma||!(null==X?void 0:X.some((C=>1!==C)))),{minCutOff:Q,maxCutOff:tt,outMin:et,outMax:rt}=p$1($,{rasterInfo:this.rasterInfo,pixelBlock:C,bandIds:L});let ot=0;null!=C&&(ot=C.getPlaneCount(),2===ot&&((C=C.clone()).statistics=[C.statistics[0]],C.pixels=[C.pixels[0]]));const{bandCount:nt}=this.rasterInfo,it=Math.min(3,(null==L?void 0:L.length)||ot||nt,nt),st=new Float32Array(it),at=q||Z?1:255;let lt;for(lt=0;lt<Q.length;lt++)st[lt]=tt[lt]===Q[lt]?0:(rt-et)/(tt[lt]-Q[lt])/at;const ut=new Float32Array(it);if(Z&&X)for(lt=0;lt<it;lt++)X[lt]>1?X[lt]>2?ut[lt]=6.5+(X[lt]-2)**2.5:ut[lt]=6.5+100*(2-X[lt])**4:ut[lt]=1;return{bandCount:it,outMin:et/at,outMax:rt/at,minCutOff:Q,maxCutOff:tt,factor:st,useGamma:Z,gamma:Z?X:[1,1,1],gammaCorrection:Z?ut:[1,1,1],colormap:q,colormapOffset:K,stretchType:$.stretchType,type:"stretch"}}_generateShadedReliefWebGLParams(C,$=!1,L={x:0,y:0}){var z,q;let K=null,J=null;const X=null==(z=this.lookup)?void 0:z.colormapLut;C.colorRamp&&X&&(K=X.indexedColormap,J=X.offset);const Z=o$2({...C,isGCS:$,resolution:L}),Q=null==(q=this.rasterInfo.statistics)?void 0:q[0];return{...Z,minValue:(null==Q?void 0:Q.min)??0,maxValue:(null==Q?void 0:Q.max)??8e3,hillshadeType:"traditional"===C.hillshadeType?0:1,type:"hillshade",colormap:K,colormapOffset:J}}_generateVectorFieldWebGLParams(C){var $,L,z;const{style:q,inputUnit:K,outputUnit:J,visualVariables:X,symbolTileSize:Z,flowRepresentation:Q}=C;let tt;const et=(null==($=this.rasterInfo.statistics)?void 0:$[0].min)??0,rt=(null==(L=this.rasterInfo.statistics)?void 0:L[0].max)??50,ot=(null==X?void 0:X.find((C=>"sizeInfo"===C.type)))??{type:"sizeInfo",field:"Magnitude",maxDataValue:rt,maxSize:.8*Z,minDataValue:et,minSize:.2*Z},nt=ot.minDataValue??et,it=ot.maxDataValue??rt,st=null!=ot.maxSize&&null!=ot.minSize?[ot.minSize/Z,ot.maxSize/Z]:[.2,.8];if("wind_speed"===q){const C=(st[0]+st[1])/2;st[0]=st[1]=C}const at=null!=nt&&null!=it?[nt,it]:null;if("classified_arrow"===q)if(null!=nt&&null!=it&&null!=ot){tt=[];const C=(ot.maxDataValue-ot.minDataValue)/5;for(let $=0;$<6;$++)tt.push(ot.minDataValue+C*$)}else tt=[0,1e-6,3.5,7,10.5,14];const lt="flow_to"===Q==("ocean_current_kn"===q||"ocean_current_m"===q)?0:Math.PI,ut=null==X?void 0:X.find((C=>"rotationInfo"===C.type));return{breakValues:tt,dataRange:at,inputUnit:K,outputUnit:J,symbolTileSize:Z,symbolPercentRange:st,style:q||"single_arrow",rotation:lt,rotationType:(null==(z=this.rasterInfo.storageInfo)?void 0:z.tileInfo)&&"vector-uv"===this.rasterInfo.dataType?"geographic":(null==ut?void 0:ut.rotationType)||C.rotationType,type:"vectorField"}}};C([$({json:{write:!0}})],Ie.prototype,"rendererJSON",void 0),C([$({type:me,json:{write:!0}})],Ie.prototype,"rasterInfo",void 0),C([$({json:{write:!0}})],Ie.prototype,"lookup",void 0),C([$()],Ie.prototype,"canRenderInWebGL",void 0),Ie=C([z("esri.renderers.support.RasterSymbolizer")],Ie);const $e=Ie;function _(C){return!!(null==C?void 0:C.length)&&C.length<=16384}function O(C){return o$4(C)&&0!==C.validPixelCount}const i2=()=>X.getLogger("esri.views.2d.engine.flow.dataUtils");async function s(C,$,L,z){const q=performance.now(),K=function c(C,$){const L=function h(C,$,L,z){if(0===z)return C;const q=Math.round(3*z),K=new Array(2*q+1);let J=0;for(let Q=-q;Q<=q;Q++){const C=Math.exp(-Q*Q/(z*z));K[Q+q]=C,J+=C}for(let Q=-q;Q<=q;Q++)K[Q+q]/=J;const X=new Float32Array(C.length);for(let Q=0;Q<L;Q++)for(let L=0;L<$;L++){let z=0,J=0;for(let X=-q;X<=q;X++){if(L+X<0||L+X>=$)continue;const Z=K[X+q];z+=Z*C[2*(Q*$+(L+X))],J+=Z*C[2*(Q*$+(L+X))+1]}X[2*(Q*$+L)]=z,X[2*(Q*$+L)+1]=J}const Z=new Float32Array(C.length);for(let Q=0;Q<$;Q++)for(let C=0;C<L;C++){let z=0,J=0;for(let Z=-q;Z<=q;Z++){if(C+Z<0||C+Z>=L)continue;const tt=K[Z+q];z+=tt*X[2*((C+Z)*$+Q)],J+=tt*X[2*((C+Z)*$+Q)+1]}Z[2*(C*$+Q)]=z,Z[2*(C*$+Q)+1]=J}return Z}($.data,$.width,$.height,C.smoothing);if(C.interpolate)return(C,z)=>{const q=Math.floor(C),K=Math.floor(z);if(q<0||q>=$.width)return[0,0];if(K<0||K>=$.height)return[0,0];const J=C-q,X=z-K,Z=q,Q=K,tt=q<$.width-1?q+1:q,et=K<$.height-1?K+1:K,rt=L[2*(Q*$.width+Z)],ot=L[2*(Q*$.width+tt)],nt=L[2*(et*$.width+Z)],it=L[2*(et*$.width+tt)],st=L[2*(Q*$.width+Z)+1],at=L[2*(Q*$.width+tt)+1];return[(rt*(1-X)+nt*X)*(1-J)+(ot*(1-X)+it*X)*J,(st*(1-X)+L[2*(et*$.width+Z)+1]*X)*(1-J)+(at*(1-X)+L[2*(et*$.width+tt)+1]*X)*J]};return(C,z)=>{const q=Math.round(C),K=Math.round(z);return q<0||q>=$.width||K<0||K>=$.height?[0,0]:[L[2*(K*$.width+q)],L[2*(K*$.width+q)+1]]}}($,L),J=performance.now(),X=function u(C,$,L,z){const q=[],K=new wt,J=1/Math.max(C.lineCollisionWidth,1),X=Math.round(L*J),Z=Math.round(z*J),Q=new Int32Array(X*Z);for(let et=0;et<Q.length;et++)Q[et]=-1;const tt=[];for(let et=0;et<z;et+=C.lineSpacing)for(let $=0;$<L;$+=C.lineSpacing)tt.push({x:$,y:et,sort:K.getFloat()});tt.sort(((C,$)=>C.sort-$.sort));for(const{x:et,y:rt}of tt)if(K.getFloat()<C.density){const L=f(C,$,et,rt,q.length,Q,X,Z,J);if(L.length<2)continue;q.push(L)}return q}($,K,L.width,L.height),Z=performance.now(),Q=function m(C,$){const L=new wt,z=C.reduce(((C,$)=>C+$.length),0),q=new Float32Array(4*z),K=new Array(C.length);let J=0,X=0;for(const Z of C){const C=J;for(const $ of Z)q[4*J]=$.x,q[4*J+1]=$.y,q[4*J+2]=$.t,q[4*J+3]=$.speed,J++;K[X++]={startVertex:C,numberOfVertices:Z.length,totalTime:Z[Z.length-1].t,timeSeed:L.getFloat()}}return{lineVertices:q,lineDescriptors:K}}(X),tt=performance.now(),et="Streamlines"===C?function d(C,$){const L=9,{lineVertices:z,lineDescriptors:q}=C;let K=0,J=0;for(const et of q)K+=2*et.numberOfVertices,J+=6*(et.numberOfVertices-1);const X=new Float32Array(K*L),Z=new Uint32Array(J);let Q=0,tt=0;function u2(){Z[tt++]=Q-2,Z[tt++]=Q,Z[tt++]=Q-1,Z[tt++]=Q,Z[tt++]=Q+1,Z[tt++]=Q-1}function h2(C,$,z,q,K,J,Z,tt){const et=Q*L;let rt=0;X[et+rt++]=C,X[et+rt++]=$,X[et+rt++]=1,X[et+rt++]=z,X[et+rt++]=J,X[et+rt++]=Z,X[et+rt++]=q/2,X[et+rt++]=K/2,X[et+rt++]=tt,Q++,X[et+rt++]=C,X[et+rt++]=$,X[et+rt++]=-1,X[et+rt++]=z,X[et+rt++]=J,X[et+rt++]=Z,X[et+rt++]=-q/2,X[et+rt++]=-K/2,X[et+rt++]=tt,Q++}for(const et of q){const{totalTime:C,timeSeed:L}=et;let q=null,K=null,J=null,X=null,Z=null,Q=null;for(let tt=0;tt<et.numberOfVertices;tt++){const rt=z[4*(et.startVertex+tt)],ot=z[4*(et.startVertex+tt)+1],nt=z[4*(et.startVertex+tt)+2],it=z[4*(et.startVertex+tt)+3];let st=null,at=null,lt=null,ut=null;if(tt>0){st=rt-q,at=ot-K;const z=Math.sqrt(st*st+at*at);if(st/=z,at/=z,tt>1){let C=st+Z,L=at+Q;const z=Math.sqrt(C*C+L*L);C/=z,L/=z;const q=Math.min(1/(C*st+L*at),$);C*=q,L*=q,lt=-L,ut=C}else lt=-at,ut=st;null!==lt&&null!==ut&&(h2(q,K,J,lt,ut,C,L,it),u2())}q=rt,K=ot,J=nt,Z=st,Q=at,X=it}h2(q,K,J,-Q,Z,C,L,X)}return{vertexData:X,indexData:Z}}(Q,10):function w(C){const $=16,L=1,z=2,{lineVertices:q,lineDescriptors:K}=C;let J=0,X=0;for(const gt of K){const C=gt.numberOfVertices-1;J+=4*C*2,X+=6*C*2}const Z=new Float32Array(J*$),Q=new Uint32Array(X);let tt,et,rt,ot,nt,it,st,at,lt,ut,ct,ht,ft,dt,pt=0,mt=0;function D2(){Q[mt++]=pt-8,Q[mt++]=pt-7,Q[mt++]=pt-6,Q[mt++]=pt-7,Q[mt++]=pt-5,Q[mt++]=pt-6,Q[mt++]=pt-4,Q[mt++]=pt-3,Q[mt++]=pt-2,Q[mt++]=pt-3,Q[mt++]=pt-1,Q[mt++]=pt-2}function b2(C,q,K,J,X,Q,tt,et,rt,ot,nt,it,st,at){const lt=pt*$;let ut=0;for(const $ of[L,z])for(const L of[1,2,3,4])Z[lt+ut++]=C,Z[lt+ut++]=q,Z[lt+ut++]=K,Z[lt+ut++]=J,Z[lt+ut++]=tt,Z[lt+ut++]=et,Z[lt+ut++]=rt,Z[lt+ut++]=ot,Z[lt+ut++]=$,Z[lt+ut++]=L,Z[lt+ut++]=st,Z[lt+ut++]=at,Z[lt+ut++]=X/2,Z[lt+ut++]=Q/2,Z[lt+ut++]=nt/2,Z[lt+ut++]=it/2,pt++}function S2(C,$){let L=lt+ct,z=ut+ht;const q=Math.sqrt(L*L+z*z);L/=q,z/=q;const K=lt*L+ut*z;L/=K,z/=K;let J=ct+ft,X=ht+dt;const Z=Math.sqrt(J*J+X*X);J/=Z,X/=Z;const Q=ct*J+ht*X;J/=Q,X/=Q,b2(tt,et,rt,ot,-z,L,nt,it,st,at,-X,J,C,$),D2()}function k2(C,$,L,z,q,K){if(lt=ct,ut=ht,ct=ft,ht=dt,null==lt&&null==ut&&(lt=ct,ut=ht),null!=nt&&null!=it){ft=C-nt,dt=$-it;const L=Math.sqrt(ft*ft+dt*dt);ft/=L,dt/=L}null!=lt&&null!=ut&&S2(q,K),tt=nt,et=it,rt=st,ot=at,nt=C,it=$,st=L,at=z}function L2(C,$){lt=ct,ut=ht,ct=ft,ht=dt,null==lt&&null==ut&&(lt=ct,ut=ht),null!=lt&&null!=ut&&S2(C,$)}for(const gt of K){tt=null,et=null,rt=null,ot=null,nt=null,it=null,st=null,at=null,lt=null,ut=null,ct=null,ht=null,ft=null,dt=null;const{totalTime:C,timeSeed:$}=gt;for(let L=0;L<gt.numberOfVertices;L++)k2(q[4*(gt.startVertex+L)],q[4*(gt.startVertex+L)+1],q[4*(gt.startVertex+L)+2],q[4*(gt.startVertex+L)+3],C,$);L2(C,$)}return{vertexData:Z,indexData:Q}}(Q),rt=performance.now();return gt("esri-2d-profiler")&&(i2().info("I.1","_createFlowFieldFromData (ms)",Math.round(J-q)),i2().info("I.2","_getStreamlines (ms)",Math.round(Z-J)),i2().info("I.3","createAnimatedLinesData (ms)",Math.round(tt-Z)),i2().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(rt-tt)),i2().info("I.5","createFlowMesh (ms)",Math.round(rt-q)),i2().info("I.6","Mesh size (bytes)",et.vertexData.buffer.byteLength+et.indexData.buffer.byteLength)),await Promise.resolve(),yt(z),et}function f(C,$,L,z,q,K,J,X,Z){const Q=[];let tt=L,et=z,rt=0,[ot,nt]=$(tt,et);ot*=C.velocityScale,nt*=C.velocityScale;const it=Math.sqrt(ot*ot+nt*nt);let st,at;Q.push({x:tt,y:et,t:rt,speed:it});for(let lt=0;lt<C.verticesPerLine;lt++){let[L,z]=$(tt,et);L*=C.velocityScale,z*=C.velocityScale;const ot=Math.sqrt(L*L+z*z);if(ot<C.minSpeedThreshold)return Q;const nt=L/ot,it=z/ot;if(tt+=nt*C.segmentLength,et+=it*C.segmentLength,rt+=C.segmentLength/ot,Math.acos(nt*st+it*at)>C.maxTurnAngle)return Q;if(C.collisions){const C=Math.round(tt*Z),$=Math.round(et*Z);if(C<0||C>J-1||$<0||$>X-1)return Q;const L=K[$*J+C];if(-1!==L&&L!==q)return Q;K[$*J+C]=q}Q.push({x:tt,y:et,t:rt,speed:ot}),st=nt,at=it}return Q}export{w$1 as $,ve as A,B$2 as B,o as C,D$1 as D,E,F,u$1 as G,t as H,r2 as I,e as J,i$1 as K,$e as L,G as M,N,d$2 as O,P$1 as P,s$7 as Q,R$1 as R,A as S,T,U$1 as U,i$9 as V,W,u$5 as X,o$4 as Y,Ce as Z,we as _,l$6 as a,c$3 as a0,r$4 as a1,l$1 as a2,f$5 as a3,ye as a4,f$4 as a5,ee as a6,te as a7,w$2 as a8,oe as a9,g$2 as aa,y$1 as ab,c$6 as ac,p$4 as ad,h$4 as ae,p$1 as af,a$2 as ag,M as ah,x as ai,u$c as b,me as c,g as d,r$6 as e,f$1 as f,St as g,h$2 as h,U$3 as i,j,qt as k,l2 as l,m$1 as m,fe as n,L$1 as o,D$3 as p,R$2 as q,Kt as r,s,B as t,u$2 as u,be as v,xe as w,Te as x,a$1 as y,p as z};
