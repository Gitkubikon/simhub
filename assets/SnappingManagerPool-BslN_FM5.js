const __vite__fileDeps=["assets/FeatureServiceSnappingSource-DrsRYU1g.js","assets/index-DSIPxOWi.js","assets/index-B_7YxLDX.css","assets/memoize-Dzy0sPL8.js","assets/queryEngineUtils-Dj40YZwO.js","assets/VertexSnappingCandidate-D8VJ-XhT.js","assets/PointSnappingHint-Ct-FTQTL.js","assets/TileTreeDebugger-CDFY3SV7.js","assets/WorkerHandle-Bq2affGI.js","assets/geodesicLengthMeasurementUtils-Pq-FipkN.js","assets/geometryEngine-Bp1TD6MM.js","assets/geometryEngineBase-9EI9fooq.js","assets/hydrated-DE1HcVsK.js","assets/geometry2dUtils-4c9qUvJ6.js","assets/floorFilterUtils-2NbRkqHK.js","assets/keybindings-DkkJsHdp.js","assets/FeatureCollectionSnappingSource-BPsWv6gO.js","assets/symbologySnappingCandidates-Cl8kN1ha.js","assets/GraphicsSnappingSource-ALtnRoRA.js","assets/normalizeUtilsSync-B5F66Zka.js","assets/normalizeUtilsCommon-BU8xfl77.js","assets/FeatureStore-Dpo5Syxq.js","assets/BoundsStore-BQ0MOdb7.js","assets/PooledRBush-DOZnXWx2.js","assets/quickselect-D9ta8ndX.js","assets/QueryEngine-DAD9skS_.js","assets/normalizeUtils-BrH-PrZy.js","assets/WhereClause-DYd7Xwn9.js","assets/TimeOnly-C5lZbbIX.js","assets/json-omtrO2vq.js","assets/QueryEngineCapabilities-CTDe3LlQ.js","assets/utils-B-uQJqPz.js","assets/utils-DEUXBrCj.js","assets/utils-1_4Re7um.js","assets/ClassBreaksDefinition-Dt1HCCB7.js","assets/optimizedFeatureQueryEngineAdapter--U1rvwBV.js","assets/SceneLayerSnappingSource-DKOJ9l2u.js","assets/EdgeWorkerHandle-BFdu_J0U.js","assets/workerHelper-CgQLvwGd.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
import{e as y,y as x,a as b,S as T,V as M,ak as A,bk as C,n as I,eH as z,g as k,P as D,pj as q,l_ as j,bM as G,oh as Y,tq as B,ec as K,tr as ee,dx as ne,Q as re,cW as se,d0 as oe,c$ as le,cZ as ce,c_ as ue,cH as he,ts as Se,sq as Ee,O as be,gi as $e,dB as Re,hM as Ne,tt as Fe,bO as Ae,nZ as Ce,cY as Ve,dz as Ie,tu as Oe,tv as He,du as De,sr as je,e6 as Ge,cx as Ue,L as Ze,tw as We,nY as Ye,hD as Xe,m6 as Be,mW as Je,p_ as Qe,dy as Ke,cD as et,dL as it,bY as rt,p3 as st,hP as at,rb as ot,tx as lt,N as ct,p1 as ut,ty as dt,ql as ht,tz as pt,tA as ft,tB as vt,hN as St,q7 as bt,tC as $t,tD as At,iq as Vt,tE as Ot,lW as zt,a2 as Dt,cJ as qt,tF as jt,nt as Gt,A as Jt,cV as en,nU as tn,nS as nn,ab as rn,tG as sn,h as an,tH as on,lc as ln,i as cn,gR as un,b3 as dn,d9 as hn,k8 as pn,_ as fn,sg as gn,G as yn,H as vn,aI as Sn,tI as En,tJ as _n,tK as wn,aN as mn,aO as xn,pY as Ln,tL as bn,tM as $n,tN as Tn,dD as Pn,kj as Rn,bc as Nn,d8 as Mn,fO as Fn,c as An,a0 as Cn,tO as Vn}from"./index-DSIPxOWi.js";import{b as In,j as On,z as zn,d as kn,A as Hn,u as Dn}from"./geodesicLengthMeasurementUtils-Pq-FipkN.js";import{j as qn,d as jn,I as Gn,N as Un}from"./geometry2dUtils-4c9qUvJ6.js";import{o as Zn}from"./floorFilterUtils-2NbRkqHK.js";import{c as Wn}from"./keybindings-DkkJsHdp.js";let Yn=class i extends T{constructor(y){super(y),this.layer=null,this.enabled=!0,this.updating=!1,this.availability=1,this.sublayerSources=new M}};y([x({constructOnly:!0})],Yn.prototype,"layer",void 0),y([x()],Yn.prototype,"enabled",void 0),y([x()],Yn.prototype,"updating",void 0),y([x()],Yn.prototype,"availability",void 0),y([x()],Yn.prototype,"sublayerSources",void 0),Yn=y([b("esri.views.interactive.snapping.FeatureSnappingLayerSource")],Yn);const Xn=Yn;let Bn=class o extends C{constructor(){super(...arguments),this.enabled=!0}};y([x({type:Boolean})],Bn.prototype,"enabled",void 0),Bn=y([b("esri.views.interactive.snapping.Settings.DefaultSnappingAlgorithm")],Bn);let Jn=class l extends C{constructor(y){super(y),this.lineSnapper=new Bn,this.parallelLineSnapper=new Bn,this.rightAngleSnapper=new Bn,this.rightAngleTriangleSnapper=new Bn,this.shortLineThreshold=15,this.distance=5,this.pointThreshold=1e-6,this.intersectionParallelLineThreshold=1e-6,this.parallelLineThreshold=1e-6,this.verticalLineThresholdMeters=.3,this.touchSensitivityMultiplier=1.5,this.pointOnLineThreshold=1e-6,this.orange=new A([255,127,0]),this.orangeTransparent=new A([255,127,0,.5]),this.lineHintWidthReference=3,this.lineHintWidthTarget=3,this.lineHintFadedExtensions=.3,this.parallelLineHintWidth=2,this.parallelLineHintLength=24,this.parallelLineHintOffset=1.5,this.rightAngleHintSize=24,this.rightAngleHintOutlineSize=1.5,this.satisfiesConstraintScreenThreshold=1}};y([x({type:Bn,constructOnly:!0,nonNullable:!0,json:{write:!0}})],Jn.prototype,"lineSnapper",void 0),y([x({type:Bn,constructOnly:!0,nonNullable:!0,json:{write:!0}})],Jn.prototype,"parallelLineSnapper",void 0),y([x({type:Bn,constructOnly:!0,nonNullable:!0,json:{write:!0}})],Jn.prototype,"rightAngleSnapper",void 0),y([x({type:Bn,constructOnly:!0,nonNullable:!0,json:{write:!0}})],Jn.prototype,"rightAngleTriangleSnapper",void 0),y([x({type:Number,nonNullable:!0,range:{min:-1,max:50,step:1},json:{write:!0}})],Jn.prototype,"shortLineThreshold",void 0),y([x({type:Number,nonNullable:!0,range:{min:-1,max:50,step:1},json:{write:!0}})],Jn.prototype,"distance",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:1e-5},json:{write:!0}})],Jn.prototype,"pointThreshold",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:1e-5},json:{write:!0}})],Jn.prototype,"intersectionParallelLineThreshold",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:1e-5},json:{write:!0}})],Jn.prototype,"parallelLineThreshold",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],Jn.prototype,"verticalLineThresholdMeters",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:10},json:{write:!0}})],Jn.prototype,"touchSensitivityMultiplier",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:1e-5},json:{write:!0}})],Jn.prototype,"pointOnLineThreshold",void 0),y([x({type:A,nonNullable:!0})],Jn.prototype,"orange",void 0),y([x({type:A,nonNullable:!0})],Jn.prototype,"orangeTransparent",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:10},json:{write:!0}})],Jn.prototype,"lineHintWidthReference",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:10},json:{write:!0}})],Jn.prototype,"lineHintWidthTarget",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],Jn.prototype,"lineHintFadedExtensions",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:10},json:{write:!0}})],Jn.prototype,"parallelLineHintWidth",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:50},json:{write:!0}})],Jn.prototype,"parallelLineHintLength",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:5},json:{write:!0}})],Jn.prototype,"parallelLineHintOffset",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:46},json:{write:!0}})],Jn.prototype,"rightAngleHintSize",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:6},json:{write:!0}})],Jn.prototype,"rightAngleHintOutlineSize",void 0),y([x({type:Number,nonNullable:!0,range:{min:0,max:5},json:{write:!0}})],Jn.prototype,"satisfiesConstraintScreenThreshold",void 0),Jn=y([b("esri.views.interactive.snapping.Settings.Defaults")],Jn);const Qn=new Jn;let Kn=class u extends T{constructor(y){super(y),this.enabled=!1,this.enabledToggled=!1,this.forceDisabled=!1,this.selfEnabled=!0,this.featureEnabled=!0,this.attributeRulesEnabled=!1,this.featureSources=new M,this.distance=Qn.distance,this.touchSensitivityMultiplier=Qn.touchSensitivityMultiplier}get effectiveEnabled(){return!this.forceDisabled&&(this.enabledToggled?!this.enabled:this.enabled)}get effectiveSelfEnabled(){return this.effectiveEnabled&&this.selfEnabled}get effectiveFeatureEnabled(){return this.effectiveEnabled&&this.featureEnabled}get _effectiveFeatureSources(){var y;const x=this.featureSources;x.some(p$3)&&I.getLogger(this).warnOnce("Do not configure SubtypeGroupLayer sources in SnappingOptions.featureSources directly. Create a FeatureSnappingLayerSource for each SubtypeSublayer.");const b=x.filter(d$2),T=(null==(y=this._get("_effectiveFeatureSources"))?void 0:y.filter(p$3))??new M;for(const M of b){const y=T.find((y=>y.layer===M.layer.parent));if(y)y.sublayerSources.includes(M)||y.sublayerSources.add(M);else if(M.layer.parent){const y=new Xn({layer:M.layer.parent});y.sublayerSources.add(M),T.add(y)}}for(const M of T){const y=M.sublayerSources.filter((y=>!b.includes(y)));M.sublayerSources.removeMany(y)}T.removeMany(T.filter((y=>0===y.sublayerSources.length)));const A=x.filter(f$5),C=this._get("_effectiveFeatureSources")??new M,{added:k,removed:D}=z(C.toArray(),[...A,...T]);return C.removeMany(D),C.addMany(k),C}};y([x()],Kn.prototype,"enabled",void 0),y([x()],Kn.prototype,"enabledToggled",void 0),y([x()],Kn.prototype,"forceDisabled",void 0),y([x()],Kn.prototype,"selfEnabled",void 0),y([x()],Kn.prototype,"featureEnabled",void 0),y([x()],Kn.prototype,"attributeRulesEnabled",void 0),y([x({type:M.ofType(Xn)})],Kn.prototype,"featureSources",void 0),y([x()],Kn.prototype,"distance",void 0),y([x()],Kn.prototype,"touchSensitivityMultiplier",void 0),y([x({readOnly:!0})],Kn.prototype,"effectiveEnabled",null),y([x({readOnly:!0})],Kn.prototype,"effectiveSelfEnabled",null),y([x({readOnly:!0})],Kn.prototype,"effectiveFeatureEnabled",null),y([x({readOnly:!0})],Kn.prototype,"_effectiveFeatureSources",null),Kn=y([b("esri.views.interactive.snapping.SnappingOptions")],Kn);const ei=Kn;function p$3(y){return"subtype-group"===y.layer.type}function f$5(y){return"subtype-group"!==y.layer.type}function d$2(y){return"subtype-sublayer"===y.layer.type}var ti,ni;function f$4(y,x,b){return c(y,x,b)}function c(y=0,x=0,b=0){return G(y,x,b)}function a$1(y){return y}function d$1(y,x,b){return G(y,x,b)}function v$2(y){const[x,b,T]=y;return y.length>3?[x,b,T,y[3]]:[x,b,T]}function p$2(y){return y[3]=((y.length>3?y[3]:void 0)??ti.NONE)|ti.TARGET,y}function m$2(y){return Boolean(((y.length>3?y[3]:void 0)??ti.NONE)&ti.TARGET)}function N$2(y,x,{coordinateHelper:b,elevationInfo:T},M){return y?E$3(b.vectorToDehydratedPoint(y,ii),x,T,M):null}function E$3(y,x,b,T=c()){return T[0]=y.x,T[1]=y.y,T[2]=y.z??0,null==x||("2d"===x.type?T[2]=0:T[2]=q(x,y,b,Y)??0),T}function T$4(y,x,b){return b?(B(b,y[0],y[1],y[2],x),b):K(y[0],y[1],y[2],x)}function h$4(y,x,{z:b,m:T},M,A){const{spatialReference:C,elevationInfo:I}=M;let z;z=null==b&&null==T?void 0:null==x||"2d"===x.type?b??void 0:j(x,y,C,Y,I)??0;const[k,D]=y;return A?B(A,k,D,z,C):A=K(k,D,z,C),null!=T&&(A.m=T,A.hasM=!0),A}function y$2(y,x,b,T,M=c()){const[A,C]=y;return M[0]=A,M[1]=C,y.length>3&&(M[3]=y[3]??ti.NONE),"3d"!==(null==b?void 0:b.type)?(M[2]=x.value,M):(M[2]=ee(b,A,C,x.value,T,x.elevationInfo,Y)??0,M)}(ni=ti||(ti={}))[ni.NONE=0]="NONE",ni[ni.TARGET=1]="TARGET";const ii=K(0,0,0,null);function U$3({start:y,end:x,type:b},T,M){const A=[],C=se(li,x,y),I=se(ci,y,T),z=oe(C),k=2*le(C,I),D=k*k-4*z*(oe(I)-M*M);if(0===D){const x=-k/(2*z);(b===si.PLANE||x>=0)&&A.push(ce(ue(),y,C,x))}else if(D>0){const x=Math.sqrt(D),T=(-k+x)/(2*z);(b===si.PLANE||T>=0)&&A.push(ce(ue(),y,C,T));const M=(-k-x)/(2*z);(b===si.PLANE||M>=0)&&A.push(ce(ue(),y,C,M))}return A}function k$1(y,x){const b=y.start,T=y.end,M=se(li,T,b),A=be(di,-M[1],M[0],0),C=x.start,I=x.end,z=$e(hi,I,C),k=Re(z,A),D=be(pi,b[0],b[1],0),q=$e(fi,D,C),j=Re(q,A),G=Se();if(Math.abs(k)<G)return[];const Y=Ne(gi,C,z,j/k);if(x.type===qn.RAY){const y=$e(yi,Y,C);if(Re(y,z)<-G)return[]}if(y.type===si.HALF_PLANE){const y=Fe(ci,Y,b);if(le(y,M)<-G)return[]}return[Ae(Y)]}function w$3(y,x){return function T$3({start:y,end:x,type:b},T){const M=$e(ui,T,y),A=$e(di,x,y),C=Ze(hi,A,M),I=We(C)/We(A),z=Se();if(I<z)switch(b){case qn.LINE:return[Ae(T)];case qn.RAY:return Re(A,M)<-z?[]:[Ae(T)]}return[]}(X(Si,x[2],y),x)}function z$3(y,x){return S(X(Si,0,y),X(Ei,0,x)).map((([y,x])=>Ce(y,x)))}function C$1(y,x,b){return J(y,X(Si,y[2],x),b)}function D$1(y,x,b,T=re()){const M=se(li,y,x),A=Ve(M);return ce(T,x,M,0===A?1:b/A),T[2]=y[2],T}function J(y,{start:x,end:b,type:T},M=re()){const A=$e(ui,y,x),C=$e(di,b,x),I=Re(A,C)/Re(C,C);return Ne(M,x,C,T===qn.RAY?Math.max(I,0):I)}const ri=(()=>{const y=re(),x=re(),b=re();return({start:T,end:M},{center:A,radius:C,normal:I,slicePlane:z})=>{const k=Ie(A,I,vi);if($(Oe(k,T),0)&&$(Oe(k,M),0)){He(I,y,x);const a3=(T,M)=>(Ue(b,M,A),Xe(T,Re(b,y),Re(b,x)),T),k=jn({start:a3(li,T),end:a3(ci,M),type:qn.LINE},Be,C),D=[];for(const[b,T]of k){const M=De(re(),A);Ne(M,M,y,b),Ne(M,M,x,T),z&&!nt(z,M)||D.push(M)}return D}const D=re();return je(k,T,M,D)?!$(Ge(D,A),C)||z&&!nt(z,D)?[]:[D]:[]}})();function Q({start:y,end:x,type:b},T,M){const A=[],C=Ue(ui,x,y),I=se(ci,y,T),z=oe(C),k=2*le(C,I),D=k*k-4*z*(oe(I)-M*M);if(0===D){const x=-k/(2*z);(b===qn.LINE||x>=0)&&A.push(Ne(re(),y,C,x))}else if(D>0){const x=Math.sqrt(D),T=(-k+x)/(2*z);(b===qn.LINE||T>=0)&&A.push(Ne(re(),y,C,T));const M=(-k-x)/(2*z);(b===qn.LINE||M>=0)&&A.push(Ne(re(),y,C,M))}return A}function S(y,x){const b=y.start,T=y.end,M=x.start,A=x.end,C=$e(ui,T,b),I=$e(di,A,M),z=$e(hi,M,b),k=Ze(pi,C,I);if(!$(Re(z,k),0))return[];const D=We(k);if($(D,0))return[];const q=Ze(fi,z,I),j=Re(q,k)/D,G=Ne(gi,b,C,j);if(y.type===qn.RAY){const y=$e(yi,G,b);if(Re(C,y)<-Se())return[]}if(x.type===qn.RAY){const y=$e(yi,G,M);if(Re(I,y)<-Se())return[]}return[Ae(G)]}function W(y,x,b,T){const[M,A]=y,[C,I]=b,z=C-M,k=I-A,D=z*z+k*k,q=Math.sqrt(D);if(q>x+T)return[];if(q<Math.abs(x-T))return[];if($(q,0)&&$(x,T))return[];const j=(x*x-T*T+D)/(2*q),G=Math.sqrt(x*x-j*j),Y=G*k/q,B=G*z/q,[K,ee]=Ye(li,y,b,j/q);return $(Y,B)?[Ce(K,ee)]:[Ce(K+Y,ee-B),Ce(K-Y,ee+B)]}function X(y,x,{start:b,end:T,type:M}){return be(y.start,b[0],b[1],x),be(y.end,T[0],T[1],x),y.type=oi[M],y}function Z(y,x){return $(y[2],x[2])}function $(y,x){return he(Math.abs(y-x),0,Se())}function nt(y,x){return Ee(y,x)}var si,ai;(ai=si||(si={}))[ai.PLANE=0]="PLANE",ai[ai.HALF_PLANE=1]="HALF_PLANE";const oi={[si.PLANE]:qn.LINE,[si.HALF_PLANE]:qn.RAY},li=ue(),ci=ue(),ui=re(),di=re(),hi=re(),pi=re(),fi=re(),gi=re(),yi=re(),vi=ne(),Si={start:re(),end:re(),type:qn.LINE},Ei={start:re(),end:re(),type:qn.LINE};class mt{intersect(y){return Ht(this,y)}closestPoints(y){return[this.closestTo(y)]}}class gt extends mt{constructor(y){super(),this.point=y}equals(y){return this===y||Le(y)&&it(this.point,y.point)}closestTo(){return v$2(this.point)}}class _t extends mt{constructor(y,x,b){super(),this.start=y,this.end=x,this.lineLike={start:y,end:x,type:b}}equals(y){return this===y||ke(y)&&this.lineLike.type===y.lineLike.type&&it(this.start,y.start)&&it(this.end,y.end)}closestTo(y){const x=c();return J(y,this.lineLike,x),x}}class Lt extends _t{constructor(y,x){super(y,x,qn.LINE)}}class kt extends _t{constructor(y,x){super(y,x,qn.RAY)}}class Mt extends mt{constructor(y){super(),this.constraints=y}equals(y){return this===y||_e(y)&&rt(this.constraints,y.constraints,((y,x)=>y.equals(x)))}closestTo(y){let x,b=1/0;for(const T of this.constraints){const M=T.closestTo(y),A=st(y,M);A<b&&(b=A,x=M)}return v$2(x??y)}closestPoints(y){return this.constraints.flatMap((x=>x===this?[]:x.closestPoints(y)))}}class xt extends mt{constructor(y,x){super(),this.center=y,this.radius=x}equals(y){return this===y||ye(y)&&this.center[0]===y.center[0]&&this.center[1]===y.center[1]&&this.radius===y.radius}closestTo(y){const x=c();return D$1(y,this.center,this.radius,x),x}}class yt extends mt{constructor(y,x){super(),this.center=y,this.radius=x}equals(y){return this===y||Pe(y)&&it(this.center,y.center)&&this.radius===y.radius}closestTo(y){const x=c();return D$1(y,this.center,this.radius,x),x[2]=this.center[2],x}asCircle(){return new Pt(v$2(this.center),this.radius,d$1(0,0,1))}}class Pt extends mt{constructor(y,x,b,T=void 0){super(),this.center=y,this.radius=x,this.normal=b,this.slicePlane=T}equals(y){return this===y||ze(y)&&it(this.center,y.center)&&it(this.normal,y.normal)&&this.radius===y.radius}closestTo(y){const{center:x,radius:b}=this;Qe(this.getPlane(wi),y,_i);const T=$e(_i,_i,x),M=at(T);if($(M,0))return v$2(y);const A=b/Math.sqrt(M),C=c();Ne(C,x,T,A);const{slicePlane:I}=this;if(I&&!nt(I,C)){const x=Mi(I,this);return(null==x?void 0:x.closestTo(y))??v$2(y)}return C}getPlane(y=ne()){return Ie(this.center,this.normal,y)}}const _i=re(),wi=ne();class Tt extends mt{constructor(y){super(),this.z=y}equals(y){return this===y||Me(y)&&this.z===y.z}closestTo(y){return d$1(y[0],y[1],this.z)}getPlane(y=ne()){return be(mi,0,0,this.z),Ie(mi,vt,y)}}const mi=re();class wt extends mt{constructor(y,x,b){super(),this.start=y,this.end=x,this.planeLike={start:y,end:x,type:b}}equals(y){return this===y||xe(y)&&this.planeLike.type===y.planeLike.type&&it(this.start,y.start)&&it(this.end,y.end)}closestTo(y){const x=c();return C$1(y,this.planeLike,x),x}closestEndTo(y){const{start:x,end:b}=this.planeLike;return Math.sign(le(se(xi,b,x),se(Li,y,x)))>0?this.end:this.start}getPlane(y=ne()){const x=De(bi,this.end);return x[2]+=1,St(this.start,this.end,x,y)}getSlicePlane(y=ne()){const{start:x,end:b,type:T}=this.planeLike;if(T===si.PLANE)return;const M=be(bi,x[0],x[1],0),A=be($i,b[0],b[1],0),C=Ue($i,A,M);return Ie(M,C,y),y}}const xi=ue(),Li=ue(),bi=re(),$i=re();class Et extends wt{constructor(y,x){super(y,x,si.HALF_PLANE)}}class Rt extends wt{constructor(y,x){super(y,x,si.PLANE)}}class Nt extends mt{constructor(y,x){super(),this.sphere=bt(y,x)}equals(y){return this===y||ve(y)&&$t(this.sphere,y.sphere)}closestTo(y){const x=c();return At(this.sphere,y,x),x}get center(){return Vt(this.sphere)}get radius(){return this.sphere[3]}}class Ut extends mt{constructor(y,x,b){super(),this.start=y,this.end=x,this.getZ=b,this.planeLike={start:y,end:x,type:si.PLANE}}equals(y){return this===y||Te(y)&&it(this.start,y.start)&&it(this.end,y.end)&&this.getZ===y.getZ}closestTo(y){return function Ft(y,x){const b=c();return C$1(x,y.planeLike,b),b[2]=y.getZ(b[0],b[1])??Ii,b}(this,y)}addIfOnTheGround(y,x){for(const b of x){const x=this.getZ(b[0],b[1])??0;$(b[2],x)&&(b[2]=x,y.push(b))}}}class Zt extends mt{constructor(y,x,b){super(),this._x=y,this._y=x,this._z=b}equals(y){return this===y||function we(y){return y instanceof Zt}(y)&&this._x===y._x&&this._y===y._y&&this._z===y._z}closestTo([y,x,b]){return f$4(this._x??y,this._y??x,this._z??b)}}class It extends mt{constructor(y,x,b,T,M){super(),this._origin=y,this._spatialReference=x,this._distanceMeters=b,this._elevationMeters=T,this._directionDegrees=M}equals(y){return this===y||function qe(y){return y instanceof It}(y)&&Ot(this._origin,y._origin)&&this._spatialReference===y._spatialReference&&this._distanceMeters===y._distanceMeters&&this._elevationMeters===y._elevationMeters&&this._directionDegrees===y._directionDegrees}closestTo([y,x,b]){return Xe(Ti,y,x),Ot(Ti,this._origin)||this._applyDirectionAndDistance(Ti),f$4(Ti[0],Ti[1],this._elevationMeters??b)}_applyDirectionAndDistance(y){if(null!=this._directionDegrees&&null!=this._distanceMeters)In(y,this._origin,this._directionDegrees,this._distanceMeters,this._spatialReference);else if(null!=this._directionDegrees)!function Ct(y,x,b,T,M){let{azimuth:A,distance:C}=On(Ri,x,T,M);A??(A=0);let I=C*Math.cos((A-b)*zt);I=Math.max(0,I),In(y,x,b,I,M)}(y,this._origin,this._directionDegrees,y,this._spatialReference);else if(null!=this._distanceMeters){const{azimuth:x}=On(Pi,this._origin,y,this._spatialReference);In(y,this._origin,x??0,this._distanceMeters,this._spatialReference)}}}const Ti=[0,0],Pi=new zn;const Ri=new zn;function Ht(y,x){if(_e(y)){const b=[];for(const T of y.constraints){const y=T.intersect(x);y&&b.push(y)}return ge(b)}if(_e(x))return Ht(x,y);if(Te(y))return fe(y,x);if(Te(x))return fe(x,y);if(Le(y)){const{point:b}=y;if(Le(x))return it(b,x.point)?y:void 0;const T=x.closestTo(b);return ut(T,b)?y:void 0}if(ke(y)){if(Le(x))return Ht(x,y);if(ke(x))return pe(S(y.lineLike,x.lineLike));if(Me(x))return Ni(y,x);if(xe(x))return pe(k$1(x.planeLike,y.lineLike));if(ye(x))return pe(Q(y.lineLike,x.center,x.radius));if(ze(x))return pe(ri(y.lineLike,x));if(Pe(x))return function Yt({lineLike:y},{center:x,radius:b}){const T=x[2];return pe(Q(y,x,b).filter((y=>$(y[2],T))))}(y,x);if(ve(x))return function Bt({lineLike:y},{sphere:x}){return pe(dt(x,y.start,y.end))}(y,x)}else if(Me(y)){if(Le(x)||ke(x))return Ht(x,y);if(Me(x))return function Kt(y,x){return $(y.z,x.z)?y:void 0}(y,x);if(xe(x))return function Qt({z:y},{planeLike:x}){const[b,T]=x.start,[M,A]=x.end,C=d$1(b,T,y),I=d$1(M,A,y);return x.type===si.PLANE?new Lt(C,I):new kt(C,I)}(y,x);if(ye(x))return function Wt(y,x){const[b,T]=x.center;return new yt(d$1(b,T,y.z),x.radius)}(y,x);if(ze(x))return Fi(y,x);if(Pe(x))return function Xt(y,x){return $(x.center[2],y.z)?x:void 0}(y,x);if(ve(x))return function te(y,{center:x,radius:b}){const T=Math.abs(x[2]-y.z);if(T>b&&!$(T,b))return;const M=d$1(x[0],x[1],y.z),A=Math.sqrt(b**2-T**2);return $(A,0)?void 0:new yt(M,A)}(y,x)}else if(xe(y)){if(Le(x)||ke(x)||Me(x))return Ht(x,y);if(xe(x))return de(z$3(y.planeLike,x.planeLike));if(ye(x))return de(U$3(y.planeLike,x.center,x.radius));if(ze(x))return Ci(y,x);if(Pe(x))return Ai(y,x);if(ve(x))return Vi(y,x)}else if(ye(y)){if(Le(x)||ke(x)||Me(x)||xe(x))return Ht(x,y);if(ye(x))return de(W(y.center,y.radius,x.center,x.radius));if(ze(x))return;if(Pe(x))return function ie(y,x){const b=ft(y.center,x.center);return $(b,0)&&$(y.radius,x.radius)?x:me(W(y.center,y.radius,x.center,x.radius),x.center[2])}(y,x);if(ve(x))return}else if(ze(y)){if(Le(x)||ke(x)||Me(x)||xe(x)||ye(x))return Ht(x,y);if(ze(x))return;if(Pe(x))return void x.asCircle();if(ve(x))return}else if(Pe(y)){if(Le(x)||ke(x)||Me(x)||xe(x)||ye(x)||ze(x))return Ht(x,y);if(Pe(x))return function ae(y,x){if(!Z(y.center,x.center))return;const b=ft(y.center,x.center);return $(b,0)&&$(y.radius,x.radius)?y:me(W(y.center,y.radius,x.center,x.radius),y.center[2])}(x,y);if(ve(x))return}else if(ve(y)){if(Le(x)||ke(x)||Me(x)||xe(x)||ye(x)||Pe(x))return Ht(x,y);if(ve(x))return}}const Ni=(()=>{const y=ne();return(x,b)=>{const{start:T,end:M}=x;if(Z(T,M)&&$(T[2],b.z))return x;const A=c();return je(b.getPlane(y),T,M,A)?new gt(A):void 0}})();const Mi=(()=>{const y=ht(),x=re(),b=re();return(T,M,A)=>{const{normal:C,center:I,radius:z}=M;He(C,x,b);const k=Ke(T),D=z*Re(k,x),q=z*Re(k,b);ot(y,I[0],I[1],I[2],1);const j=lt(T,y),G=Math.hypot(D,q),Y=$(G,0);if($(Oe(T,I),0)){if(Y)return M;if($(z,0))return!A||nt(A,I)?new gt(v$2(I)):void 0;Ze(x,k,C),ct(x,x);const y=new Array,b=Ae(I);Ne(b,b,x,z),A&&!nt(A,b)||y.push(b);const T=Ae(I);return Ne(T,T,x,-z),A&&!nt(A,T)||y.push(T),pe(y)}if(Y)return;const B=-j/G;if(Math.abs(B)>1||$(B,1))return;const K=Math.atan(D/q),ee=pt(B)-K,ne=Math.PI-ee,se=new Array,oe=re();Ne(oe,I,x,z*Math.cos(ee)),Ne(oe,oe,b,z*Math.sin(ee)),se.push(oe);const le=re();return Ne(le,I,x,z*Math.cos(ne)),Ne(le,le,b,z*Math.sin(ne)),se.push(le),pe(A?function tt(y,x){return x.filter((x=>nt(y,x)))}(A,se):se)}})();const Fi=(()=>{const y=ne();return(x,b)=>Mi(x.getPlane(y),b,b.slicePlane)})();const Ai=(()=>{const y=ne();return(x,{center:b,radius:T})=>{const M=U$3(x.planeLike,b,T),A=b[2];x.getSlicePlane(y);const C=new Array;for(const[I,z]of M){const x=[I,z,A];nt(y,x)&&C.push(x)}return pe(C)}})(),Ci=(()=>{const y=ne(),x=ne();return(b,T)=>Mi(b.getPlane(y),T,b.getSlicePlane(x))})(),Vi=(()=>{const y=ne();return(x,{center:b,radius:T})=>{const M=x.getPlane(y),A=Je(M,b),C=Math.abs(A);if(C>T&&!$(C,T))return;const I=Math.sqrt(T**2-A**2);if($(I,0)){const y=c();return Qe(M,b,y),new gt(y)}const z=c(),k=Ae(Ke(M));return Ne(z,b,k,A),new Pt(z,I,k,x.getSlicePlane())}})();function fe(y,x){const{planeLike:b,getZ:T}=y,M=new Array;if(Le(x))y.addIfOnTheGround(M,w$3(b,x.point));else if(ke(x))y.addIfOnTheGround(M,k$1(b,x.lineLike));else if(ye(x))for(const[A,C]of U$3(b,x.center,x.radius)){const y=T(A,C);null!=y&&M.push(G(A,C,y))}else if(xe(x)||Te(x))for(const[A,C]of z$3(b,x.planeLike)){const y=T(A,C)??Ii;M.push(G(A,C,y))}return pe(M)}function de(y){return ge(y.map((([y,x])=>{const b=d$1(y,x,0),T=d$1(y,x,1);return new Lt(b,T)})))}function pe(y){return ge(y.map((y=>y?new gt(y):void 0)))}function me(y,x){return pe(y.map((([y,b])=>[y,b,x])))}function ge(y){if(0!==y.length)return 1===y.length?y[0]??void 0:new Mt(y.filter(et))}function _e(y){return y instanceof Mt}function Le(y){return y instanceof gt}function ke(y){return y instanceof _t}function Me(y){return y instanceof Tt}function xe(y){return y instanceof wt}function ye(y){return y instanceof xt}function Pe(y){return y instanceof yt}function ze(y){return y instanceof Pt}function ve(y){return y instanceof Nt}function Te(y){return y instanceof Ut}const Ii=0;function d(y,x){const b=y.x-x.x,T=y.y-x.y;return b*b+T*T}function f$3(y,x){x.sort(((x,b)=>st(x.targetPoint,y)-st(b.targetPoint,y)))}var Oi,zi;function y$1({point:y,distance:x,returnEdge:b,vertexMode:T,coordinateHelper:{spatialReference:M},filter:A},C,I){return I=null!=I?I.clone():new Dt({where:"1=1"}),A&&(I.geometry=A.geometry,I.distance=A.distance,I.spatialRelationship=A.spatialRelationship,I.where=qt(I.where,A.where),I.timeExtent=jt(I.timeExtent,A.timeExtent),I.objectIds=function h$3(y,x){return y||x?x?y?Array.from(Gt(new Set(y),new Set(x))):x:y:null}(I.objectIds,A.objectIds)),{point:K(y[0],y[1],y[2],M.toJSON()),mode:C,distance:x,returnEdge:b,vertexMode:T,query:I.toJSON()}}function w$2(y,x,b){return{left:N$2(y.leftVertex.pos,x,b),right:N$2(y.rightVertex.pos,x,b)}}function j$1(y){return y.createQuery()}(zi=Oi||(Oi={}))[zi.TARGET=0]="TARGET",zi[zi.REFERENCE=1]="REFERENCE",zi[zi.REFERENCE_EXTENSION=2]="REFERENCE_EXTENSION";const ki=Symbol("snapping-toggle");function N$1(y,x=()=>{}){const b=k((()=>({view:y.view,snappingOptions:y.snappingOptions})),(({view:b,snappingOptions:T})=>{if(y.removeHandles(ki),!b||!T)return;const M=en.TOOL,A=[b.on("key-down",(y=>{y.key!==Wn.toggle||y.repeat||(T.enabledToggled=!0,x())}),M),b.on("key-up",(y=>{y.key===Wn.toggle&&(T.enabledToggled=!1,x())}),M),b.on("pointer-move",(y=>{const b=y.native.ctrlKey;T.enabledToggled!==b&&(T.enabledToggled=b,x())}),M)];y.addHandles(A,ki)}),Jt);y.addHandles(b)}function v$1(y){var x;return function e(y){return null!=y&&"object"==typeof y&&"declaredClass"in y&&"esri.WebMap"===y.declaredClass}(y)&&"utilityNetworks"in y&&!!(null==(x=y.utilityNetworks)?void 0:x.length)}let Hi=class f extends T{set attributeRulesEnabled(y){this._set("attributeRulesEnabled",y),y&&this.loadRules()}get layerView(){var y,x;return null==(x=null==(y=this.view)?void 0:y.allLayerViews)?void 0:x.find((y=>y.layer===this.layer))}get valid(){const{_valid:y,snappingSource:x,layer:b}=this;return!(!x||!b)&&y}get subtypeFilter(){var y,x;const{layer:b,snappingSource:T}=this;if(!tn(b)||!(null==(y=b.subtypes)?void 0:y.length)||!T)return{mode:"not-in-use",filter:null};const M=T.layerSource.sublayerSources.filter((y=>{var x;return y.enabled&&y.layer.visible&&nn(null==(x=this.view)?void 0:x.scale,y.layer.effectiveScaleRange.minScale,y.layer.effectiveScaleRange.maxScale)})).map((y=>y.layer.subtypeCode));if(!M.length)return{mode:"none-visible",filter:null};if(M.length===b.subtypes.length)return{mode:"all-visible",filter:null};const A=(null==(x=b.fieldsIndex.get(b.subtypeField))?void 0:x.name)??b.subtypeField;return 1===M.length?{mode:"in-use",filter:`${A} = ${M.getItemAt(0)}`}:{mode:"in-use",filter:`${A} IN (${M.join(", ")})`}}get floorFilter(){const{view:y,layer:x}=this;return y&&x?Zn({view:y,layer:x}):null}constructor(y){super(y),this.layer=null,this.snappingSource=null,this.rulesTable=null,this._valid=null}initialize(){if(!this.snappingSource||!this.layer)return void(this._valid=!1);const{layer:y,snappingSource:x}=this;if("refresh"in y){const b=y;this.addHandles(b.on("refresh",(()=>x.refresh())))}this.loadRules(),this.addHandles([k((()=>x.updating),(y=>x.layerSource.updating=y),Jt),k((()=>x.availability),(y=>x.layerSource.availability=y),Jt)])}getFetchCandidatesParameters(y,x,b){var T,M,A,C,I;if(!this.valid)return[];const{layer:z,layerView:k,floorFilter:D,rulesTable:q,subtypeFilter:j}=this,G={distance:b,mode:(null==(T=this.view)?void 0:T.type)??"2d",point:y,coordinateHelper:x.coordinateHelper,returnEdge:!0,vertexMode:"all",filter:k&&"filter"in k?k.filter:null};if(D&&(G.filter=m$1(G.filter,D)),"not-in-use"!==j.mode&&"all-visible"!==j.mode){if("none-visible"===j.mode)return[];G.filter?G.filter.where=qt(G.filter.where,j.mode):G.filter=new rn({where:j.filter})}if(!this.attributeRulesEnabled)return[G];const Y=x.feature,B="subtype-sublayer"===(null==(M=null==Y?void 0:Y.sourceLayer)?void 0:M.type)?Y.sourceLayer.parent:null==Y?void 0:Y.sourceLayer;if(q&&Y&&v$1(null==(A=this.view)?void 0:A.map)&&(sn(z)||tn(z))&&z.layerId&&(sn(B)||tn(B))&&(null==(C=this.view.map.utilityNetworks)?void 0:C.find((y=>y.isUtilityLayer(B))))){if("loaded"!==q.loadStatus)return[];const y=[],x=z.layerId,b=null==(I=q.getFeatureSQL(B,Y))?void 0:I[x];if(!b)return[];const T=b.anyVertex;let M=b.endVertex;return M&&T&&M===T&&(M=""),M&&y.push({...G,returnEdge:!1,vertexMode:"ends",filter:m$1(G.filter,M)}),T&&y.push({...G,returnEdge:!1,vertexMode:"all",filter:m$1(G.filter,T)}),y}return[G]}async loadRules(){var y,x,b;this._valid=null;const{layer:T,view:M,attributeRulesEnabled:A}=this;if(A&&T&&M&&v$1(null==M?void 0:M.map)&&(sn(T)||tn(T)))try{await Promise.allSettled((null==(y=M.map.utilityNetworks)?void 0:y.map((y=>y.load())))??[]);const A=null==(x=M.map.utilityNetworks)?void 0:x.find((y=>y.isUtilityLayer(T)));A&&(this.rulesTable=await A.getRulesTable(),await(null==(b=this.rulesTable)?void 0:b.load()))}catch(C){return this._valid=!1,void I.getLogger("esri.views.interactive.snapping.FeatureSnappingSourceInfo").error("Failed to load rules table for snapping source",T.title)}this._valid=!0}remove(){this.destroy()}destroy(){var y;null==(y=this.snappingSource)||y.destroy()}};function m$1(y,x){return null==y?new rn({where:x}):y.where?new rn({where:qt(y.where,x)}):new rn({where:x})}var Di,qi;y([x({constructOnly:!0})],Hi.prototype,"layer",void 0),y([x({constructOnly:!0})],Hi.prototype,"snappingSource",void 0),y([x({constructOnly:!0})],Hi.prototype,"view",void 0),y([x({value:!1})],Hi.prototype,"attributeRulesEnabled",null),y([x()],Hi.prototype,"layerView",null),y([x()],Hi.prototype,"rulesTable",void 0),y([x()],Hi.prototype,"valid",null),y([x()],Hi.prototype,"subtypeFilter",null),y([x()],Hi.prototype,"floorFilter",null),y([x()],Hi.prototype,"_valid",void 0),Hi=y([b("esri.views.interactive.snapping.FeatureSnappingSourceInfo")],Hi),(qi=Di||(Di={}))[qi.FEATURE=1]="FEATURE",qi[qi.SELF=2]="SELF",qi[qi.ALL=3]="ALL";class t{constructor(y,x,b,T){this.targetPoint=y,this.constraint=x,this.isDraped=b,this.domain=T}}let ji=class n extends t{constructor({targetPoint:y,objectId:x,constraint:b,isDraped:T}){super(y,b,T,Di.FEATURE),this.objectId=x}},Gi=class s{constructor(y,x){this.isDraped=y,this.domain=x}},Ui=class n2 extends Gi{constructor(y,x,b,T,M=Di.ALL,A=!0,C=!0){super(T,M),this.type=y,this.lineStart=x,this.lineEnd=b,this.fadeLeft=A,this.fadeRight=C}equals(y){return y instanceof n2&&this.type===y.type&&it(this.lineStart,y.lineStart)&&it(this.lineEnd,y.lineEnd)&&this.fadeLeft===y.fadeLeft&&this.fadeRight===y.fadeRight}get length(){return Ge(this.lineStart,this.lineEnd)}},Zi=class r extends ji{constructor(y){super({...y,isDraped:!0,constraint:new Ut(y.edgeStart,y.edgeEnd,y.getGroundElevation)})}get hints(){return[new Ui(Oi.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}},Wi=class r2 extends ji{constructor(y){super({...y,constraint:new Lt(y.edgeStart,y.edgeEnd)})}get hints(){return[new Ui(Oi.REFERENCE,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}},Yi=class s2 extends Gi{constructor(y,x,b,T,M=Di.ALL){super(T,M),this.previousVertex=y,this.centerVertex=x,this.nextVertex=b}equals(y){return y instanceof s2&&it(this.previousVertex,y.previousVertex)&&it(this.centerVertex,y.centerVertex)&&it(this.nextVertex,y.nextVertex)}};class n3 extends t{constructor({targetPoint:y,constraint:x,previousVertex:b,otherVertex:T,otherVertexType:M,isDraped:A,selfSnappingType:C,objectId:I,domain:z}){super(y,x,A,z??Di.SELF),this.previousVertex=b,this.otherVertex=T,this.otherVertexType=M,this.selfSnappingType=C??Bi.None,this.objectId=I??null}get hints(){const y=this.previousVertex,x=this.otherVertexType===Xi.CENTER?this.otherVertex:this.targetPoint,b=this.otherVertexType===Xi.CENTER?this.targetPoint:this.otherVertex;return[new Ui(Oi.TARGET,x,b,this.isDraped,this.domain),new Ui(Oi.REFERENCE,y,x,this.isDraped,this.domain),new Yi(this.previousVertex,x,b,this.isDraped,this.domain)]}}var Xi,Bi;!function(y){y[y.NEXT=0]="NEXT",y[y.CENTER=1]="CENTER"}(Xi||(Xi={})),function(y){y[y.None=0]="None",y[y.LastVertex=1]="LastVertex",y[y.FirstVertex=2]="FirstVertex",y[y.ExistingEdge=3]="ExistingEdge"}(Bi||(Bi={}));let Ji=class P extends T{get updating(){return this._snappingSources.some((y=>{var x;return null==(null==y?void 0:y.valid)||!0===y.valid&&!0===(null==(x=y.snappingSource)?void 0:x.updating)}))||this._updatingHandles.updating}constructor(y){super(y),this.options=null,this._domain=Di.FEATURE,this._updatingHandles=new an,this._sourceModules={featureService:{module:null,loader:null},featureCollection:{module:null,loader:null},graphics:{module:null,loader:null},notes:{module:null,loader:null},scene:{module:null,loader:null}}}initialize(){const y=on((()=>{var y;return null==(y=this.options)?void 0:y._effectiveFeatureSources}),((y,x)=>this._createSourceInfo(y,x)));this._snappingSources=y,this.addHandles([ln(y),k((()=>{var y;return{rulesEnabled:!!(null==(y=this.options)?void 0:y.attributeRulesEnabled),sources:this._snappingSources.filter(et)}}),(({rulesEnabled:y,sources:x})=>{for(const b of x)b.attributeRulesEnabled=y}),cn)])}destroy(){this._set("options",null),this._updatingHandles.destroy()}async fetchCandidates(y,x,b,T){var M,A,C;if(!(x&this._domain&&null!=this.options&&this.options.effectiveFeatureEnabled))return[];const I=[],z=this._computeScreenSizeDistanceParameters(y,b);for(const D of this._snappingSources){if(!(null==D?void 0:D.valid)||!(null==(A=null==(M=D.snappingSource)?void 0:M.layerSource)?void 0:A.enabled)||(null==(C=D.layerView)?void 0:C.suspended))continue;const x=D.getFetchCandidatesParameters(y,b,z);for(const y of x)I.push(D.snappingSource.fetchCandidates(y,T).then((y=>y.filter((y=>!this._candidateIsExcluded(D.snappingSource,y,b.excludeFeature))))))}const k=(await un(I)).flat();return this._addRightAngleCandidates(k,y,z,b),dn(T),f$3(y,k),k}_addRightAngleCandidates(y,x,b,T){var M,A,C,I,z,k,D,q;const j=null!=T.vertexHandle?null==(A=null==(M=T.vertexHandle.rightEdge)?void 0:M.rightVertex)?void 0:A.pos:null!=T.editGeometryOperations&&"polygon"===T.editGeometryOperations.data.type?null==(I=null==(C=T.editGeometryOperations.data.components[0])?void 0:C.getFirstVertex())?void 0:I.pos:null,G=null!=T.vertexHandle?null==(k=null==(z=T.vertexHandle.leftEdge)?void 0:z.leftVertex)?void 0:k.pos:null!=T.editGeometryOperations?null==(q=null==(D=T.editGeometryOperations.data.components[0])?void 0:D.getLastVertex())?void 0:q.pos:null,{view:Y}=this,B=N$2(j,Y,T),K=N$2(G,Y,T),ee=y.length;for(let ne=0;ne<ee;ne++)this._addRightAngleCandidate(y[ne],K,x,b,y),this._addRightAngleCandidate(y[ne],B,x,b,y)}_addRightAngleCandidate(y,x,b,T,M){if(null==x||!function A$2(y){return(y instanceof Wi||y instanceof Zi)&&!function U$2({constraint:{start:y,end:x}}){const b=st(y,x),T=ft(y,x);return b<Se()||T/b<er}(y)}(y))return;const A=y.constraint.closestTo(x),C=(A[0]-b[0])/T.x,I=(A[1]-b[1])/T.y,{start:z,end:k}=y.constraint;if(C*C+I*I<=1){const b=ft(A,z)>ft(A,k)?z:k,T=new n3({targetPoint:p$2(A),otherVertex:x,otherVertexType:Xi.NEXT,previousVertex:b,constraint:new Et(x,A),objectId:y.objectId,isDraped:y.isDraped,domain:Di.FEATURE});M.push(T)}}_computeScreenSizeDistanceParameters(y,x){let b=null!=this.options?this.options.distance*("touch"===x.pointer?this.options.touchSensitivityMultiplier:1):0;return null==this.view?{x:b,y:b,z:b,distance:b}:"2d"===this.view.type?(b*=this.view.resolution,{x:b,y:b,z:b,distance:b}):this._computeScreenSizeDistanceParameters3D(y,b,this.view,x)}_computeScreenSizeDistanceParameters3D(y,x,b,T){const{spatialReference:M}=T;b.renderCoordsHelper.toRenderCoords(y,M,Qi);const A=b.state.camera.computeScreenPixelSizeAt(Qi),C=A*b.renderCoordsHelper.unitInMeters,I=C/hn(M),z=C/pn(M),k=x*I,D=x*z,q=kn(y,M,Y,b),j=q?z$2(q,y,I,0,0,b,T):0,G=q?z$2(q,y,0,I,0,b,T):0,B=q?z$2(q,y,0,0,z,b,T):0;return{x:0===j?0:k/j,y:0===G?0:k/G,z:0===B?0:D/B,distance:A*x}}_candidateIsExcluded(y,x,b){if(null==b)return!1;const T=this._getCandidateObjectId(x);if(null==T)return!1;const M=y.layerSource.layer;return"graphics"===M.type?b.uid===T:b.sourceLayer===M&&!(!b.attributes||!("objectIdField"in M))&&b.attributes[M.objectIdField]===T}_getCandidateObjectId(y){return y instanceof ji?y.objectId:null}async _createSourceInfo(y,x){const b=y.layer;b.loaded||(await b.load(),dn(x));const{view:T}=this,M=await this._createFeatureSnappingSourceType(y);return dn(x),new Hi(null==M?{}:{snappingSource:M,view:T,layer:b})}async _createFeatureSnappingSourceType(y){switch(y.layer.type){case"feature":case"geojson":case"csv":case"oriented-imagery":case"subtype-group":case"wfs":return this._createFeatureSnappingSourceFeatureLayer(y);case"graphics":return this._createFeatureSnappingSourceGraphicsLayer(y);case"map-notes":return this._createFeatureSnappingSourceMapNotesLayer(y);case"scene":case"building-scene":return this._createFeatureSnappingSourceSceneLayer(y)}return null}async _createFeatureSnappingSourceSceneLayer(y){const{view:x}=this;return null==x||"3d"!==x.type?null:new((await this._getSourceModule("scene")).SceneLayerSnappingSource)({layerSource:y,view:x})}async _createFeatureSnappingSourceFeatureLayer(y){var x;switch(null==(x=y.layer.source)?void 0:x.type){case"feature-layer":case"oriented-imagery":return new((await this._getSourceModule("featureService")).FeatureServiceSnappingSource)({spatialReference:this.spatialReference,view:this.view,layerSource:y});case"memory":case"csv":case"geojson":case"wfs":return"mesh"===y.layer.geometryType?null:new((await this._getSourceModule("featureCollection")).FeatureCollectionSnappingSource)({layerSource:y,view:this.view})}return null}async _createFeatureSnappingSourceGraphicsLayer(y){return new((await this._getSourceModule("graphics")).GraphicsSnappingSource)({getGraphicsLayers:()=>[y.layer],spatialReference:this.spatialReference,view:this.view,layerSource:y})}async _createFeatureSnappingSourceMapNotesLayer(y){return new((await this._getSourceModule("notes")).GraphicsSnappingSource)({getGraphicsLayers:()=>{var x;return(null==(x=y.layer.sublayers)?void 0:x.toArray())??[]},spatialReference:this.spatialReference,view:this.view,layerSource:y})}async _getSourceModule(y){const x=this._sourceModules[y];if(null==x.loader){const x=this._loadSourceModule(y),b={module:null,loader:x};this._sourceModules[y]=b;const T=await x,M={module:T,loader:x};return this._sourceModules[y]=M,T}return null==x.module?x.loader:x.module}_loadSourceModule(y){const x=this._updatingHandles;switch(y){case"featureService":return x.addPromise(fn((()=>import("./FeatureServiceSnappingSource-DrsRYU1g.js")),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])));case"featureCollection":return x.addPromise(fn((()=>import("./FeatureCollectionSnappingSource-BPsWv6gO.js")),__vite__mapDeps([16,1,2,3,4,5,6,17,9,10,11,12,13,14,15])));case"graphics":case"notes":return x.addPromise(fn((()=>import("./GraphicsSnappingSource-ALtnRoRA.js")),__vite__mapDeps([18,1,2,3,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,4,5,6,17,9,10,11,12,13,14,15])));case"scene":return x.addPromise(fn((()=>import("./SceneLayerSnappingSource-DKOJ9l2u.js")),__vite__mapDeps([36,1,2,37,8,38,5,6,9,10,11,12,13,14,15])))}}get test(){}};function z$2(y,x,b,T,M,A,{spatialReference:C}){const I=De(Ki,x);I[0]+=b,I[1]+=T,I[2]+=M;const z=kn(I,C,Y,A);return z?function g$2(y,x){return Math.sqrt(d(y,x))}(z,y):1/0}y([x({constructOnly:!0})],Ji.prototype,"spatialReference",void 0),y([x({constructOnly:!0})],Ji.prototype,"view",void 0),y([x()],Ji.prototype,"options",void 0),y([x({readOnly:!0})],Ji.prototype,"updating",null),y([x()],Ji.prototype,"_snappingSources",void 0),Ji=y([b("esri.views.interactive.snapping.FeatureSnappingEngine")],Ji);const Qi=re(),Ki=re(),er=1e-4;class l2{constructor(y,x){this.view=y,this.options=x,this.squaredShortLineThreshold=Qn.shortLineThreshold*Qn.shortLineThreshold}snap(y,x){return null!=x.vertexHandle?"vertex"!==x.vertexHandle.type?[]:this.snapExistingVertex(y,x):this.snapNewVertex(y,x)}edgeExceedsShortLineThreshold(y,x){return this.exceedsShortLineThreshold(N$2(y.leftVertex.pos,this.view,x),N$2(y.rightVertex.pos,this.view,x),x)}exceedsShortLineThreshold(y,x,{spatialReference:b}){return 0===this.squaredShortLineThreshold||d(kn(x,b,Y,this.view),kn(y,b,Y,this.view))>this.squaredShortLineThreshold}isVertical(y,x,{spatialReference:b}){const T=hn(b);return gn(y,x)*T<Qn.verticalLineThresholdMeters}squaredProximityThreshold(y){return"touch"===y?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:y,touchSensitivityMultiplier:x}=this.options,b=y*x;return b*b}}let tr=class r3 extends t{constructor({lineStart:y,lineEnd:x,targetPoint:b,isDraped:T}){super(b,new Rt(y,x),T,Di.SELF),this._referenceLineHint=new Ui(Oi.REFERENCE_EXTENSION,y,x,T,this.domain)}get hints(){return[this._referenceLineHint,new Ui(Oi.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}};var nr;function R$1(y,x){if(null==y||null==x)return;const b=ir(y,x);return null!=b?wn(b,"radians","geographic"):void 0}!function(y){y.Absolute="absolute",y.Relative="relative",y.RelativeBilateral="relative-bilateral"}(nr||(nr={}));const ir=(()=>{const y=re(),x=re();return(b,T)=>(be(y,b.x,b.y,b.z??0),be(x,T.x,T.y,T.z??0),rr(y,x,b.spatialReference,T.spatialReference))})(),rr=(()=>{const y=ue(),x=re(),b=re();return(T,M,A,C)=>{if(it(T,M))return;const I=Hn(A),z=Hn(C);if(I&&z&&yn(I,z)&&vn(T,A,x,I)&&vn(M,C,b,z)){const{azimuth:y}=On(ar,x,b,I);return null!=y?Sn(y,"degrees","radians"):void 0}y[0]=M[0]-T[0],y[1]=M[1]-T[1];let k=En(_n,y);return y[0]<0&&(k=or-k),k}})();function x$1(y,x,b,T=nr.Absolute){if(x&&b)switch(T){case nr.Absolute:return R$1(x,b);case nr.Relative:return w$1(z$1(y,x,b),nr.Relative);case nr.RelativeBilateral:return w$1(z$1(y,x,b),nr.RelativeBilateral)}}function z$1(y,x,b){if(!y||!x||!b)return;const T=ir(y,x),M=ir(x,b);return null!=T&&null!=M?wn(M-T,"radians","geographic"):void 0}function w$1(y,x){if(null!=y)switch(x){case nr.Absolute:return A$1(y);case nr.Relative:{const x=T$1(y);let b=cr.normalize(x,0,!0);return-180===b&&(b=180),wn(b,"degrees","geographic")}case nr.RelativeBilateral:{const x=T$1(y),b=Math.abs(cr.normalize(x,0,!0));return wn(b,"degrees","geographic")}}}function A$1(y){const x=T$1(y),b=lr.normalize(x,0,!0);return wn(b,"degrees","geographic")}const sr=(()=>{const y=re();return(x,b,T,M,A,C="geodesic")=>{De(y,b);const I=T$1(A);if("geodesic"===C){const A=Hn(T);if(A&&vn(y,T,y,A))return In(x,y,I,M,A),x[2]=b[2],!!vn(x,A,x,T)}const z=mn(I,"geographic","arithmetic"),k=Sn(z,"degrees","radians"),D=b[0]+M*Math.cos(k),q=b[1]+M*Math.sin(k),j=b[2];return be(x,D,q,j),!0}})();function T$1(y){if(null!=y)return mn(V(y),y.rotationType,"geographic")}function U$1(y){if(null!=y)return mn(V(y),y.rotationType,"arithmetic")}function V(y){return Sn(y.value,y.unit,"degrees")}const ar=new zn,or=2*Math.PI,lr=xn,cr=new Ln(-180,180);class E extends l2{snapNewVertex(y,x){const b=x.editGeometryOperations.data.components[0],T=b.edges.length,M=[];if(T<1)return M;const{spatialReference:A}=x,C=kn(y,A,Y,this.view),{view:I}=this,z=b.edges[T-1];let k=z;do{if(this.edgeExceedsShortLineThreshold(k,x)){const b=w$2(k,I,x);this._processCandidateProposal(b.left,b.right,y,C,x,M)}k=k.leftVertex.leftEdge}while(k&&k!==z);return M}snapExistingVertex(y,x){const b=[],T=x.vertexHandle,M=T.component;if(M.edges.length<2)return b;const{view:A}=this,{spatialReference:C}=x,I=kn(y,C,Y,A),z=T.leftEdge,k=T.rightEdge;z&&k&&this.edgeExceedsShortLineThreshold(z,x)&&this.edgeExceedsShortLineThreshold(k,x)&&this._processCandidateProposal(N$2(z.leftVertex.pos,A,x),N$2(k.rightVertex.pos,A,x),y,I,x,b);const D=M.edges[0];let q=D;do{if(q!==T.leftEdge&&q!==T.rightEdge&&this.edgeExceedsShortLineThreshold(q,x)){const T=w$2(q,A,x);this._processCandidateProposal(T.left,T.right,y,I,x,b)}q=q.rightVertex.rightEdge}while(q&&q!==D);return b}_processCandidateProposal(y,x,b,T,M,A){var C;const{spatialReference:I,pointer:z}=M,k=re();!function v(y,x,b,T,M){(function w(y,x,b,T,{spatialReference:M}){const A=rr(x,b,M,M);if(null==A)return!1;const C=rr(b,T,M,M);if(null==C)return!1;const I=Dn(b,T,M);if(null==I)return!1;const z=Math.abs(bn.shortestSignedDiff(A,C))>Math.PI/2?$n.normalize(A+Math.PI):A;return sr(y,b,M,Tn(I,"meters"),wn(z,"radians","geographic"),"geodesic"),y[2]=T[2],!0})(y,x,b,T,M)||function P$1(y,x,b,T){J(x,{start:b,end:T,type:qn.LINE},y),y[2]=x[2]}(y,T,x,b)}(k,y,x,b,M);const D=p$2(k);d(T,kn(D,I,Y,this.view))<this.squaredProximityThreshold(z)&&A.push(new tr({lineStart:y,lineEnd:x,targetPoint:D,isDraped:"on-the-ground"===(null==(C=M.elevationInfo)?void 0:C.mode)}))}}let ur=class r4 extends Gi{constructor(y,x,b,T=Di.ALL){super(b,T),this.lineStart=y,this.lineEnd=x}equals(y){return y instanceof r4&&it(this.lineStart,y.lineStart)&&it(this.lineEnd,y.lineEnd)}},dr=class g extends t{constructor({referenceLine:y,lineStart:x,targetPoint:b,isDraped:T}){const M=Ae(x),{left:A,right:C}=y;Ue(M,Pn(M,M,C),A),super(b,new Rt(x,M),T,Di.SELF),this._referenceLines=[{edge:y,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new Ui(Oi.TARGET,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new ur(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map((y=>new Ui(Oi.REFERENCE,y.edge.left,y.edge.right,this.isDraped,this.domain,y.fadeLeft,y.fadeRight)))]}addReferenceLine(y){const x={edge:y,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach((b=>{it(y.right,b.edge.left)&&(b.fadeLeft=!1,x.fadeRight=!1),it(y.right,b.edge.right)&&(b.fadeRight=!1,x.fadeRight=!1),it(y.left,b.edge.right)&&(b.fadeRight=!1,x.fadeLeft=!1),it(y.left,b.edge.left)&&(b.fadeLeft=!1,x.fadeLeft=!1)})),this._referenceLines.push(x)}},hr=class f2 extends l2{snapNewVertex(y,x){const b=x.editGeometryOperations.data.components[0],T=b.edges.length,M=b.vertices.length,A=[];if(T<2)return A;const{view:C}=this,I=kn(y,x.spatialReference,Y,C),z=N$2(b.vertices[M-1].pos,C,x),k=N$2(b.vertices[0].pos,C,x),D=b.edges[T-1];let q=D;do{if(this.edgeExceedsShortLineThreshold(q,x)){const b=w$2(q,C,x);this._checkEdgeForParallelLines(b,z,y,I,x,A),this._checkEdgeForParallelLines(b,k,y,I,x,A)}q=q.leftVertex.leftEdge}while(q&&q!==D);return A}snapExistingVertex(y,x){const b=[],T=x.vertexHandle,M=T.component;if(M.edges.length<3)return b;const{view:A}=this,C=kn(y,x.spatialReference,Y,A),I=T.leftEdge,z=T.rightEdge,k=M.vertices[0],D=N$2(k.pos,A,x),q=M.vertices.length,j=M.vertices[q-1],G=N$2(j.pos,A,x),B=M.edges[0];let K=B;do{if(K!==I&&K!==z&&this.edgeExceedsShortLineThreshold(K,x)){const M=w$2(K,A,x);I&&this._checkEdgeForParallelLines(M,N$2(I.leftVertex.pos,A,x),y,C,x,b),z&&this._checkEdgeForParallelLines(M,N$2(z.rightVertex.pos,A,x),y,C,x,b),T===k?this._checkEdgeForParallelLines(M,G,y,C,x,b):T===j&&this._checkEdgeForParallelLines(M,D,y,C,x,b)}K=K.rightVertex.rightEdge}while(K&&K!==B);return b}_checkEdgeForParallelLines(y,x,b,T,M,A){var C;const I=y.left,z=y.right;if(Gn(pr,x,I,z),ft(pr,x)<Qn.parallelLineThreshold)return;Gn(pr,b,I,z,x);const{spatialReference:k,pointer:D}=M,q=p$2(d$1(pr[0],pr[1],b[2]));if(d(T,kn(q,k,Y,this.view))<this.squaredProximityThreshold(D)){if(this.isVertical(q,x,M)||this.isVertical(I,z,M))return;if(function m(y,x){const b=y.left,T=y.right;for(const M of x)if(Gn(pr,T,M.constraint.start,M.constraint.end,b),ft(pr,T)<Qn.parallelLineThreshold)return M.addReferenceLine(y),!0;return!1}(y,A))return;A.push(new dr({referenceLine:y,lineStart:x,targetPoint:q,isDraped:"on-the-ground"===(null==(C=M.elevationInfo)?void 0:C.mode)}))}}};const pr=ue();class R extends l2{snapNewVertex(y,x){const b=x.editGeometryOperations.data.components[0],T=[];if(b.vertices.length<2)return T;const{view:M}=this,A=kn(y,x.spatialReference,Y,M),C=b.vertices.at(-1);this._checkForSnappingCandidate(Bi.LastVertex,T,C.leftEdge,C,C.leftEdge.leftVertex,y,A,x);const I=b.vertices[0];return this._checkForSnappingCandidate(Bi.FirstVertex,T,I.rightEdge,I,I.rightEdge.rightVertex,y,A,x),T}snapExistingVertex(y,x){const b=[],T=x.vertexHandle;if(T.component.vertices.length<3)return b;const{view:M}=this,A=kn(y,x.spatialReference,Y,M),C=T.leftEdge,I=T.rightEdge;if(null==C?void 0:C.leftVertex.leftEdge){const T=C.leftVertex.leftEdge;this._checkForSnappingCandidate(Bi.ExistingEdge,b,T,T.rightVertex,T.leftVertex,y,A,x)}if(null==I?void 0:I.rightVertex.rightEdge){const T=I.rightVertex.rightEdge;this._checkForSnappingCandidate(Bi.ExistingEdge,b,T,T.leftVertex,T.rightVertex,y,A,x)}return b}_checkForSnappingCandidate(y,x,b,T,M,A,C,I){if(!this.edgeExceedsShortLineThreshold(b,I))return;const z=this.view,k=N$2(T.pos,z,I),D=N$2(M.pos,z,I);(function _(y,x,b,T,M){(function P2(y,x,b,T,{spatialReference:M}){const A=rr(x,b,M,M);if(null==A)return!1;const C=rr(b,T,M,M);if(null==C)return!1;const I=Math.sign($n.shortestSignedDiff(A,C))*Math.PI*.5,z=wn(A+I,"radians","geographic"),k=re(),D=Dn(b,T,M);return null!=D&&(sr(k,b,M,Tn(D,"meters"),z,"geodesic"),Ue(y,k,b),!0)})(y,x,b,T,M)||function U(y,x,b){const T=se(fr,b,x);be(y,T[1],-T[0],0)}(y,x,b)})(gr,D,k,A,I),this._checkForSnappingCandidateAlongProjectedRay(y,x,D,k,gr,A,C,I)}_checkForSnappingCandidateAlongProjectedRay(y,x,b,T,M,A,C,I){var z;const{spatialReference:k,pointer:D}=I,q=se(fr,A,T),j=le(M,q)/oe(M),G=ce(fr,T,M,j),B=p$2(d$1(G[0],G[1],A[2]));if(d(C,kn(B,k,Y,this.view))>this.squaredProximityThreshold(D)||this.isVertical(B,T,I)||this.isVertical(T,b,I))return;const K=Ne(re(),T,M,Math.sign(j));x.push(new n3({targetPoint:B,constraint:new Et(T,K),previousVertex:b,otherVertex:T,otherVertexType:Xi.CENTER,selfSnappingType:y,isDraped:"on-the-ground"===(null==(z=I.elevationInfo)?void 0:z.mode)}))}}const fr=ue(),gr=re();class g2 extends t{constructor({targetPoint:y,point1:x,point2:b,isDraped:T}){super(y,new xt(Rn(re(),x,b,.5),.5*gn(x,b)),T,Di.SELF),this._p1=x,this._p2=b}get hints(){return[new Ui(Oi.REFERENCE,this.targetPoint,this._p1,this.isDraped,this.domain),new Ui(Oi.REFERENCE,this.targetPoint,this._p2,this.isDraped,this.domain),new Yi(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}}let yr=class h extends l2{snapNewVertex(y,x){const b=x.editGeometryOperations.data.components[0],T=[],M=b.vertices.length;if("polygon"!==x.editGeometryOperations.data.type||M<2)return T;const{view:A}=this,C=b.vertices[0],I=b.vertices[M-1],z=N$2(C.pos,A,x),k=N$2(I.pos,A,x);return this._processCandidateProposal(z,k,y,x,T),T}snapExistingVertex(y,x){const b=[],T=x.vertexHandle,M=T.component;if(M.edges.length<2)return b;if("polyline"===x.editGeometryOperations.data.type&&(0===T.index||T.index===M.vertices.length-1))return b;const{view:A}=this,C=N$2(T.leftEdge.leftVertex.pos,A,x),I=N$2(T.rightEdge.rightVertex.pos,A,x);return this._processCandidateProposal(C,I,y,x,b),b}_processCandidateProposal(y,x,b,T,M){var A;if(!this.exceedsShortLineThreshold(y,x,T))return;const C=Ye(vr,y,x,.5),I=.5*gn(y,x),z=Un(vr,b,C,I),k=p$2(d$1(z[0],z[1],b[2])),{spatialReference:D,pointer:q}=T;if(d(kn(b,D,Y,this.view),kn(k,D,Y,this.view))<this.squaredProximityThreshold(q)){if(this.isVertical(y,k,T)||this.isVertical(k,x,T))return;M.push(new g2({targetPoint:k,point1:y,point2:x,isDraped:"on-the-ground"===(null==(A=T.elevationInfo)?void 0:A.mode)}))}}};const vr=ue();let Sr=class extends T{constructor(y){super(y),this.updating=!1,this._snappers=new M,this._domain=Di.SELF}initialize(){this._snappers.push(new hr(this.view,this.options),new E(this.view,this.options),new R(this.view,this.options),new yr(this.view,this.options))}set options(y){this._set("options",y);for(const x of this._snappers)x.options=y}async fetchCandidates(y,x,b){if(!(x&this._domain&&this.options.effectiveSelfEnabled))return[];const T=[];for(const M of this._snappers.items)for(const x of M.snap(y,b))T.push(x);return f$3(y,T),T}};function i$1(y,x){return[new Sr({view:y,options:x}),new Ji({view:y,options:x,spatialReference:y.spatialReference})]}y([x({readOnly:!0})],Sr.prototype,"updating",void 0),y([x({constructOnly:!0})],Sr.prototype,"view",void 0),y([x()],Sr.prototype,"options",null),Sr=y([b("esri.views.interactive.snapping.SelfSnappingEngine")],Sr);class o2 extends Gi{constructor(y,x,b=Di.ALL){super(x,b),this.intersectionPoint=y}equals(y){return y instanceof o2&&it(this.intersectionPoint,y.intersectionPoint)}}class r5 extends t{constructor(y,x,b,T){super(y,new gt(y),T,Di.ALL),this.first=x,this.second=b}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new o2(this.targetPoint,this.isDraped,this.domain)]}}let Er=class extends(Nn.EventedMixin(T)){constructor(y){super(y),this.options=new ei,this.snappingEnginesFactory=i$1,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=_r.MAIN}initialize(){this.addHandles([k((()=>{const{effectiveFeatureEnabled:y,effectiveSelfEnabled:x,touchSensitivityMultiplier:b,distance:T}=this.options;return{effectiveFeatureEnabled:y,effectiveSelfEnabled:x,touchSensitivityMultiplier:b,distance:T}}),(()=>{this.doneSnapping(),this.emit("changed")}),cn),k((()=>this.options),(y=>{for(const x of this._engines)x.options=y}),cn),k((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:y,snappingEnginesFactory:x})=>this._recreateEngines(y,x)),Jt)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((y=>y.updating))}_recreateEngines(y,x){if(this._destroyEngines(),!y)return;const{view:b,options:T}=this;this._engines=x(b,T)}_destroyEngines(){for(const y of this._engines)y.destroy();this._engines=[]}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:y,touchSensitivityMultiplier:x}=this.options,b=y*x;return b*b}snap(y){return function H(y){return null!=y.scenePoint}(y)?this._snapMultiPoint(y):this._snapSinglePoint(y)}update(y){const{point:x,context:b}=y;this._removeVisualization();const T=this._currentMainCandidate;if(null==T)return x;const M=this._selectUpdateInput(y);if(null==M)return x;const{spatialReference:A}=b,C=Mn(M,A);if(null==C)return x;const{view:I}=this,{elevationInfo:z,visualizer:k}=b,D=[],q=E$3(C,I,z),j=T.constraint.closestTo(q);if(!this._arePointsWithinScreenThreshold(q,j,b)||!F(T,b.drawConstraints))return this._resetSnappingState(),x;T.targetPoint=p$2(j),D.push(...T.hints);for(const G of this._currentOtherActiveCandidates)F(G,b.drawConstraints)&&(G.targetPoint=p$2(j),D.push(...G.hints));return null!=k&&this.addHandles(k.draw(D,{spatialReference:A,elevationInfo:L(b),view:I,selfSnappingZ:b.selfSnappingZ}),wr),h$4(j,I,x,b)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:y,scenePoint:x}){switch(this._currentSnappedType){case _r.MAIN:return y;case _r.SCENE:return x}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=_r.MAIN}_removeVisualization(){this.removeHandles(wr)}async _snapSinglePoint({point:y,context:x,signal:b}){const{view:T}=this,{elevationInfo:M}=x,A=E$3(y,T,M),C=await this._fetchCandidates(A,Di.ALL,x,b);return this._createSnapResult(A,_r.MAIN,C,T,y,x,b)}async _snapMultiPoint({point:y,scenePoint:x,context:b,signal:T}){const{view:M}=this,{coordinateHelper:A,elevationInfo:C,spatialReference:I}=b;await Fn(x.spatialReference,I);const z=Mn(x,I),k=E$3(z,M,C),D=await this._fetchCandidates(k,Di.FEATURE,b,T);if(D.length>0){const y=await this._fetchCandidates(k,Di.SELF,b,T);return this._createSnapResult(k,_r.SCENE,[...D,...y],M,z,b,T)}const q=E$3(y,M,C),j=await this._fetchCandidates(q,Di.SELF,b,T);return this._createSnapResult(q,_r.MAIN,j,M,{z:A.hasZ()&&y.hasZ?y.z??0:void 0,m:A.hasM()&&y.hasM?y.m??0:void 0},b,T)}async _fetchCandidates(y,x,b,T){return(await Promise.all(this._engines.map((M=>M.fetchCandidates(y,x,b,T))))).flat()}_createSnapResult(y,x,b,T,M,A,C){return{get valid(){return!An(C)},apply:()=>{const{spatialReference:C}=A,{snappedPoint:I,hints:z}=this._processCandidates(y,x,b,A);return this._removeVisualization(),null!=A.visualizer&&this.addHandles(A.visualizer.draw(z,{spatialReference:C,elevationInfo:Y,view:T,selfSnappingZ:A.selfSnappingZ}),wr),h$4(I,T,M,A)}}}_processCandidates(y,x,b,T){if(b.length<1)return this.doneSnapping(),{snappedPoint:y,hints:[]};this._currentSnappedType!==x&&this._resetSnappingState(),f$3(y,b);const M=this._currentMainCandidate;if(null!=M){const A=function N(y,x){return y instanceof r5?O(x,y.first)>=0&&O(x,y.second)>=0?0:-1:O(x,y)}(M,b);if(A>=0){if(!(b[A]instanceof r5))return this._intersectWithOtherCandidates(A,b,y,x,T);if(this._arePointsWithinScreenThreshold(y,M.targetPoint,T))return this._updateSnappingCandidate(M,x,b,T)}}return this._intersectWithOtherCandidates(0,b,y,x,T)}_intersectWithOtherCandidates(y,x,b,T,M){const{coordinateHelper:A}=M,C=x[y],I=[];for(let z=0;z<x.length;++z){if(z===y)continue;const T=x[z],M=C.constraint.intersect(T.constraint);if(M)for(const y of M.closestPoints(C.targetPoint))I.push([new r5(p$2(y),C,T,T.isDraped),this._squaredScreenDistance(b,y,A)])}return I.length>0&&(I.sort(((y,x)=>y[1]-x[1])),I[0][1]<this._squaredPointProximityThreshold(M.pointer))?this._updateSnappingCandidate(I[0][0],T,x,M):F(C,M.drawConstraints)?this._updateSnappingCandidate(C,T,x,M):{snappedPoint:b,hints:[]}}_updateSnappingCandidate(y,x,b,T){this.doneSnapping(),this._currentMainCandidate=y,this._currentSnappedType=x;const M=this._currentMainCandidate.targetPoint,A=[];A.push(...y.hints);for(const C of b){if(y instanceof r5){if(C.constraint.equals(y.first.constraint)||C.constraint.equals(y.second.constraint))continue}else if(C.constraint.equals(y.constraint))continue;const x=C.constraint.closestTo(M);this._squaredScreenDistance(x,M,T.coordinateHelper)<Qn.satisfiesConstraintScreenThreshold*Qn.satisfiesConstraintScreenThreshold&&(C.targetPoint=M,this._currentOtherActiveCandidates.push(C),A.push(...C.hints))}return{snappedPoint:M,hints:A}}_squaredPointProximityThreshold(y){return"touch"===y?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(y,x,b){return this._squaredScreenDistance(y,x,b.coordinateHelper)<this._squaredPointProximityThreshold(b.pointer)}_squaredScreenDistance(y,x,b){return d(this._toScreen(y,b),this._toScreen(x,b))}_toScreen(y,x){return kn(y,x.spatialReference,Y,this.view)}get test(){}};var _r;y([x({constructOnly:!0})],Er.prototype,"view",void 0),y([x()],Er.prototype,"options",void 0),y([x({readOnly:!0})],Er.prototype,"updating",null),y([x()],Er.prototype,"snappingEnginesFactory",void 0),y([x()],Er.prototype,"_engines",void 0),y([x()],Er.prototype,"_squaredMouseProximityThreshold",null),y([x()],Er.prototype,"_squaredTouchProximityThreshold",null),Er=y([b("esri.views.interactive.snapping.SnappingManager")],Er),function(y){y[y.MAIN=0]="MAIN",y[y.SCENE=1]="SCENE"}(_r||(_r={}));const wr="visualization-handle";function F(y,x){return!x||null==x.direction&&null==x.distance||!(y instanceof Zi||y instanceof Wi||y instanceof tr||y instanceof dr||y instanceof g2)&&(!(y instanceof n3)||null==x.direction&&y.selfSnappingType===Bi.LastVertex)}function O(y,x){let b=-1;for(let T=0;T<y.length;++T)if(x.constraint.equals(y[T].constraint)){b=T;break}return b}function L({coordinateHelper:y,elevationInfo:x}){return y.hasZ()?Y:x}const mr=new Map;function a(y){if(!mr.has(y)){const x=function a$2(y,x){const b=new ei({enabled:!0,selfEnabled:!1,featureEnabled:!0,distance:(null==x?void 0:x.distance)??Qn.distance,touchSensitivityMultiplier:(null==x?void 0:x.touchSensitivityMultiplier)??Qn.touchSensitivityMultiplier});return{...k((()=>{var x,b;return(null==(b=null==(x=y.map)?void 0:x.allLayers)?void 0:b.toArray())??[]}),(y=>{b.featureSources=new M(y.map((y=>new Xn({layer:y}))))}),D),options:b}}(y,{distance:10}),b=function s3(y,x){return new Er({view:y,options:x,snappingEnginesFactory:(x,b)=>[new Ji({view:y,spatialReference:y.spatialReference,options:b})]})}(y,x.options);mr.set(y,{referenceCount:0,snappingManager:b,remove:()=>{x.remove(),b.destroy()}})}const x=mr.get(y);x.referenceCount++;const b=Cn((()=>function p(y,x){x.referenceCount--,x.referenceCount>0||Vn((()=>{0===x.referenceCount&&(x.remove(),mr.delete(y))}))}(y,x)));return{snappingManager:x.snappingManager,...b}}export{nr as A,ge as B,Tt as C,Et as D,Di as E,A$1 as F,w$1 as G,x$1 as H,It as I,Le as L,sr as M,N$1 as N,R$1 as R,T$4 as T,U$1 as U,Zt as Z,Wi as a,a$1 as b,a as c,d$1 as d,Ui as e,f$3 as f,gt as g,ur as h,Yi as i,j$1 as j,Qn as k,y$2 as l,m$2 as m,ji as n,o2 as o,p$2 as p,Oi as q,Zi as r,Gi as s,E$3 as t,c as u,v$1 as v,h$4 as w,xt as x,y$1 as y,T$1 as z};
