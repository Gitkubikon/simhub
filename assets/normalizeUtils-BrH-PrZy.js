import{a$ as e,gr as t,fk as n,bZ as s,gM as o,ej as r,k6 as f,k7 as l,g5 as c,b$ as a,ax as u,h3 as p,j as h,n as d,h2 as N,b as q}from"./index-DSIPxOWi.js";import{r as k,o as z,i as A,s as I}from"./normalizeUtilsCommon-BU8xfl77.js";const m=()=>d.getLogger("esri.geometry.support.normalizeUtils");function y(e){return"polygon"===e[0].type}function x(e){return"polyline"===e[0].type}function w(e,t,n){if(t){const t=function M(e,t){if(!(e instanceof u||e instanceof h)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw m().error(e),new q(e)}const n=z(e),s=[];for(const o of n){const e=[];s.push(e),e.push([o[0][0],o[0][1]]);for(let n=0;n<o.length-1;n++){const s=o[n][0],r=o[n][1],f=o[n+1][0],l=o[n+1][1],c=Math.sqrt((f-s)*(f-s)+(l-r)*(l-r)),a=(l-r)/c,u=(f-s)/c,p=c/t;if(p>1){for(let l=1;l<=p-1;l++){const n=l*t,o=u*n+s,f=a*n+r;e.push([o,f])}const n=(c+Math.floor(p-1)*t)/2,o=u*n+s,f=a*n+r;e.push([o,f])}e.push([f,l])}}return function g(e){return"polygon"===e.type}(e)?new h({rings:s,spatialReference:e.spatialReference}):new u({paths:s,spatialReference:e.spatialReference})}(e,1e6);e=N(t,!0)}return n&&(e=I(e,n)),e}function b(e,t,n){if(Array.isArray(e)){const s=e[0];if(s>t){const n=A(s,t);e[0]=s+n*(-2*t)}else if(s<n){const t=A(s,n);e[0]=s+t*(-2*n)}}else{const s=e.x;if(s>t){const n=A(s,t);e=e.clone().offset(n*(-2*t),0)}else if(s<n){const t=A(s,n);e=e.clone().offset(t*(-2*n),0)}}return e}async function R(d,N,q){if(!Array.isArray(d))return R([d],N);N&&"string"!=typeof N&&m().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const L="string"==typeof N?N:(null==N?void 0:N.url)??c.geometryServiceUrl;let P,S,F,J,O,T,U,$,v=0;const C=[],X=[];for(const e of d)if(null!=e)if(P||(P=e.spatialReference,S=a(P),F=P.isWebMercator,T=F?102100:4326,J=k[T].maxX,O=k[T].minX,U=k[T].plus180Line,$=k[T].minus180Line),S)if("mesh"===e.type)X.push(e);else if("point"===e.type)X.push(b(e.clone(),J,O));else if("multipoint"===e.type){const t=e.clone();t.points=t.points.map((e=>b(e,J,O))),X.push(t)}else if("extent"===e.type){const t=e.clone()._normalize(!1,!1,S);X.push(t.rings?new h(t):t)}else if(e.extent){const t=e.extent,n=A(t.xmin,O)*(2*J);let s=0===n?e.clone():I(e.clone(),n);t.offset(n,0);let{xmin:o,xmax:r}=t;o=Number(o.toFixed(9)),r=Number(r.toFixed(9)),t.intersects(U)&&r!==J?(v=r>v?r:v,s=w(s,F),C.push(s),X.push("cut")):t.intersects($)&&o!==O?(v=r*(2*J)>v?r*(2*J):v,s=w(s,F,360),C.push(s),X.push("cut")):X.push(s)}else X.push(e.clone());else X.push(e);else X.push(e);let D=A(v,J),W=-90;const Z=D,_=new u;for(;D>0;){const e=360*D-180;_.addPath([[e,W],[e,-1*W]]),W*=-1,D--}if(C.length>0&&Z>0){const c=function j(e,t){let n=-1;for(let s=0;s<t.cutIndexes.length;s++){const o=t.cutIndexes[s],r=t.geometries[s],f=z(r);for(let e=0;e<f.length;e++){const t=f[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const s=t[e][0];n=s>n?s:n}n=Number(n.toFixed(9));const s=-360*A(n,180);for(let o=0;o<t.length;o++){const t=r.getPoint(e,o);r.setPoint(e,o,t.clone().offset(s,0))}return!0}}))}if(o===n){if(y(e))for(const t of z(r))e[o]=e[o].addRing(t);else if(x(e))for(const t of z(r))e[o]=e[o].addPath(t)}else n=o,e[o]=r}return e}(C,await async function i(r,f,l,c){const a=e(r),u=f[0].spatialReference,p={...c,responseType:"json",query:{...a.query,f:"json",sr:t(u),target:JSON.stringify({geometryType:n(f[0]),geometries:f}),cutter:JSON.stringify(l)}},h=await s(a.path+"/cut",p),{cutIndexes:d,geometries:N=[]}=h.data;return{cutIndexes:d,geometries:N.map((e=>{const t=o(e);return t.spatialReference=u,t}))}}(L,C,_,q)),a=[],u=[];for(let e=0;e<X.length;e++){const t=X[e];if("cut"!==t)u.push(t);else{const t=c.shift(),n=d[e];null!=n&&"polygon"===n.type&&n.rings&&n.rings.length>1&&t.rings.length>=n.rings.length?(a.push(t),u.push("simplify")):u.push(F?p(t):t)}}if(!a.length)return u;const h=await async function m$1(e,o,c){const a="string"==typeof e?r(e):e,u=o[0].spatialReference,p=n(o[0]),h={...c,query:{...a.query,f:"json",sr:t(u),geometries:JSON.stringify(f(o))}},{data:d}=await s(a.path+"/simplify",h);return l(d.geometries,p,u)}(L,a,q),N=[];for(let e=0;e<u.length;e++){const t=u[e];"simplify"!==t?N.push(t):N.push(F?p(h.shift()):h.shift())}return N}const B=[];for(let e=0;e<X.length;e++){const t=X[e];if("cut"!==t)B.push(t);else{const e=C.shift();B.push(!0===F?p(e):e)}}return B}export{R};
